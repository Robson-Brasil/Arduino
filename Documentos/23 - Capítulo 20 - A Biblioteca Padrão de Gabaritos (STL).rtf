{\rtf1\ansi\ansicpg1252\deff0\deflang1033{\fonttbl{\f0\fswiss\fprq2\fcharset0 Arial;}{\f1\froman\fcharset0 Times New Roman;}}
\viewkind4\uc1\pard\sb100\sa240\lang2070\f0\fs24\par
\par
\ul 20 \ulnone\line A biblioteca padr\'e3o de gabaritos (STL) \line\line Objetivos \line\bullet  Ser capaz de usar cont\'eaineres padronizados da STL, cont\'eaineres adaptadores e \ldblquote quase cont\'eaineres\rdblquote . \line\bullet  Ser capaz de programar com as dezenas de algoritmos da \line STL. \line\bullet  Compreender como algoritmos usam iteradores para acessar os elementos dos cont\'eaineres da STL. \line\bullet  Familiarizar-se com os recursos da STL dispon\'edveis na Tnternet e na World Wide Web. \line As formas que um cont\'eainer brilhante pode conter Theodore Roethke \line Viaje por todo o universo em um mapa. Miguel de Cervantes \line Oh! tendes perseveran\'e7a conden\'f3vel, e arte suficiente para poder corromper um santo. \line William Shakespeare \line Aquele enorme monte de p\'f3 chamado \ldblquote hist\'f3ria Augustine Birreil \line O historiador \'e9 um profeta em reverso. Friedrich von Schlegel \line Attempt the end, and never stand to doubt; \line Nothing \lquote s so hard but search willflnd it out. \line Robert Herrick \par
Prossiga - continue andando. Thomas Morton \par
CAP\'cdTULO 20 - A BIBLIOTECA PADR\'c3O DE GABARITOS (STL) 917 \line Vis\'e3o Geral \line 20.1 Introdu\'e7\'e3o \'e0 biblioteca padr\'e3o de gabaritos (STL) \line 20.1.1 Introdu\'e7\'e3o a cont\'eaineres \line 20.1.2 Introdu\'e7\'e3o a iteradores \line 20.1.3 Introdu\'e7\'e3o a algoritmos \line 20.2 Cont\'eaineres seq\'fcenciais \line 20.2.1 O cont\'eainer seq\'fcencial vector \line 20.2.2 O cont\'eainer seq\'fcencial list \line 20.2.3 O cont\'eainer seq\'fcencial deque \line 20.3 Cont\'eaineres associativos \line 20.3.1 O cont\'eainer associativo multiset \line 20.3.2 O cont\'eainer associativo set \line 20.3.3 O cont\'eainer associativo multimap \line 20.3.4 O cont\'eainer associativo map \line 20.4 Adaptadores de cont\'eaineres \line 20.4.1 O adaptador stack \line 20.4.2 O adaptador queue \line 20.4.3 O adaptador priority_queue \line 20.5 Algoritmos \line 20.5.1 f iii, fill_n, generate e generate_n \line 20.5.2 equal, mismatch e lexicographical compare \line 20.5.3 remove, remove if, remove copy e remove copyif \line 20.5.4 replace, replace if replace copy e replacecopyif \line 20.5.5 Algoritmos matem\'e1ticos \line 20.5.6 Algoritmos b\'e1sicos de pesquisa e classifica\'e7\'e3o \line 20.5.7 swap, iter_swap e swap_ranges \line 20.5.8 copybackward, merge, unique e reverse \line 20.5.9 inplacemerge, unique_copy e reversecopy \line 20.5.10 Opera\'e7\'f5es sobre conjuntos \line 20.5.11 lowerbound, upper_bound e equal_range \line 20.5.12 Heapsort \line 20.5.13 minemax \line 20.5.14 Algoritmos n\'e3o-cobertos neste cap\'edtulo \line 20.6 A classe bitset \line 20.7 Objetos fun\'e7\'e3o \line Resumo\bullet  Terminologia. Erros comuns de programa\'e7\'e3o . Boas pr\'e1ticas de programa\'e7\'e3o. Observa\'e7\'f5es de \line engenharia de software \bullet  Dicas de desempenho \bullet  Dicas de teste e depura \'e7\'e3o Exerc\'edcios de auto-revis\'e3o \line Respostas aos exerc\'edcios de auto-revis\'e3o \bullet  Exerc\'edcios \bullet  Recursos para a STL na Internet e na World Wide \line Web . Bibliografia da STL \par
CAP\'cdTULO 20 - A BIBLIOTECA PADR\'c3O DE GABARITOS (STL) 919 \par
\ldblquote inteligente\rdblquote , corno veremos. Classes de iteradores s\'e3o projetadas para serem usadas genericamente com qualquer cont\'eainer. \par
Os cont\'eaineies encapsulam algumas opera\'e7\'f5es primitivas, mas os algoritmos da STL s\'e3o implementados independentemente dos cont\'eaineres. \line A STL evita new e delete em favor de alocadores para a aloca\'e7\'e3o e desaloca\'e7\'e3o de mem\'f3ria. O programador pode fornecer alocadores para customizar a maneira como um cont\'eainer trata a administra\'e7\'e3o de mem\'f3ria, mas os alocadores default fornecidos pela STL s\'e3o sufucientes para a maioria das aplica\'e7\'f5es. Alocadores customizados s\'e3o um t\'f3pico avan\'e7ado, fora do escopo deste texto. \line Este texto pretende ser uma introdu\'e7\'e3o \'e0 STL. Ele n\'e3o \'e9 de forma alguma completo ou abrangente. Entretanto, \'e9 um cap\'edtulo amig\'e1vel e acess\'edvel que deveria lhe convencer do valor da STL e incentiv\'e1-lo a estudar mais a mesma. Usamos a mesma abordagem de \ldblquote c\'f3digo que funciona\rdblquote  que usamos ao longo de todo o livro. Em termos da sua percep\'e7\'e3o do valor de \ldblquote reutilizar, reutilizar, reutilizar\rdblquote , este pode ser um dos cap\'edtulos mais importantes do livro. Os cont\'eaineres da STL cont\'eam as estruturas de dados mais comuns e de maior valor. Elas s\'e3o todas definidas como gabaritos, de forma que voc\'ea possa adapt\'e1-las para conter o tipo de dados relevante para suas aplica\'e7\'f5es particulares. \line No Cap\'edtulo 15, estudamos estruturas de dados. Constru\'edmos listas encadeadas, filas, pilhas e \'e1rvores. Ligamos cuidadosamente objetos com ponteiros. O c\'f3digo baseado em ponteiros \'e9 complexo e a menor omiss\'e3o ou desaten\'e7\'e3o pode conduzir a s\'e9rias viola\'e7\'f5es de acesso \'e0 mem\'f3ria e erros de \ldblquote perda de mem\'f3ria\rdblquote  sem reclama\'e7\'f5es do compilador. Implementar estruturas de dados adicionais, tais como deques, filas com prioridade, conjuntos, mapas, etc. iria requerer um trabalho adicional substancial. \par
Observa\'e7\'e3o de engenharia de software 20.2 \par
Evite reinventar a roda; programe com componentes reutiliz\'e1veis da biblioteca padr\'e3o de C++. A STL cont\'e9m muitas das estruturas de dados mais populares, como cont\'eaineres, e fornece v\'e1rios algoritmos populares que os programas usam para processar dados nestes cont\'eaineres. \par
Dica de (este e depura \'e7\'e3o 20.1 \par
Quando programamos com estruturas de dados e algoritmos baseados em ponteiros, devemos fazer nossa pr\'f3pria depura\'e3o e teste para garantir que nossas estruturas de dados, classes e algoritmos funcionam corretamente. Ef\'e1cil cometer erros ao manipular ponteiros neste n\'edvel t\'e3o baixo. \ldblquote Perdas de mem\'f3ria\rdblquote  e viola\'e7\'f5es de acesso \'e0 memo ria s\'e3o comuns em tal c\'f3digo customizado. Para a maioria dos pro gramadores, e para maioria das aplica\'e7\'f5es que necessitar\'e3o escrever as estruturas de dados definidas como gaba- ritos, pr\'e9-empacotadas, da STL s\'e3o suficientes. Usar o c\'f3digo da STL pode evitar muito tempo de teste e depura \'e7\'e3o. Uma precau\'e7\'e3o a ser tomada com rela\'e7\'e3o a grandes projetos \'e9 que o tempo de compila\'e7\'e3o pode ser significativo. \par
Cada cont\'eainer da STL tem fun\'e7\'f5es membro associadas. Algumas funcionalidades se aplicam a todos os cont\'eaineres da STL. Outras funcionalidades s\'e3o espec\'edficas para determinados cont\'eaineres. Ilustramos a maioria das funcionalidades comuns com os gabaritos de classe vector, list e deque. Apresentamos funcionalidades espec\'edficas para um cont\'eainer nos exemplos de cada um dos outros cont\'eaineres da STL. \line Fizemos uma pesquisa extensa de recursos dispon\'edveis na InternetlWorld Wide Web e os inclu\'edmos para voc\'ea \line no final deste cap\'edtulo. Tamb\'e9m fornecemos uma extensa bibliografia de artigos relacionados com a STL. \par
20.1.1 Introdu\'e7\'e3o a cont\'eaineres \par
Os tipos de cont\'eaineres da STL s\'e3o mostrados na Fig. 20.1. Os cont\'eaineres est\'e3o divididos em tr\'eas categorias principais - cont\'eaineres de seq\'fc\'eancias, cont\'eaineres associativos e adaptadores de cont\'eaineres. Os cont\'eaineres de seq\'fc\'eancias s\'e3o \'e0s vezes chamados de cont\'eaineres seq\'fcenciais; nonnalmente usaremos o termo cont\'eaineres seq\'fcenciais. Os cont\'eaineres seq\'fcenciais e os cont\'eaineres associativos s\'e3o chamados coletivamente de cont\'eaineres de primeira classe. Existem quatro outros tipos de cont\'eaineres que s\'e3o considerados \ldblquote quase cont\'eaineres\rdblquote  - arrays no estilo de C (discutidos no Cap\'edtulo 4), strings (discutidos no Cap\'edtulo 19), bitsets para manter conjuntos de indicadores 1/O e valarray para executar opera\'e7\'f5es matem\'e1ticas sobre vetores em alta velocidade (esta classe \'e9 otimizada \par
920 C\'f7+ COMO PROGRAMAR \par
*1 \line 1 \par
para desempenho e n\'e3o \'e9 t\'e3o flex\'edvel quanto os cont\'eaineres de primeira classe). Estes quatro tipos s\'e3o considerados \ldblquote quase cont\'eaineres\rdblquote  porque apresentam recursos similares aos cont\'eaineres de primeira classe, mas n\'e3o suportam todos os recursos dos cont\'eaineres de primeira classe. \par
Fig. 20.1 Classes cont\'eainer da biblioteca padr\'e3o. \par
A STL foi cuidadosamente projetada de maneira que os cont\'eaineres forne\'e7am funcionalidades similares. H\'e1 muitas opera\'e7\'f5es gen\'e9ricas, como a fun\'e7\'e3o size. que se aplicam a todos os cont\'eaineres e outras opera\'e7\'f5es que se aplicam a subconjuntos de cont\'eaineres similares. Isto estimula a extensibilidade da STL com novas classes. As fun\'e7\'f5es comuns a todos os cont\'eaineres da STL s\'e3o ilustradas na Fig. 20.2. [Nota: as fun\'e7\'f5es operador sobrecarregadas operator<, operator<=, operator>, operator>=. operator == eoperator!=n\'e3o s\'e3o fornecidas para priorityqueue. \par
Fig. 20.2 Fun\'e7\'f5es comuns a todos os cont\'eaineres da STL (parte 1 de 2). \par
\pard\par
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2938\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx8946\pard\intbl Classes cont\'eainer da Biblioteca Padr\'e3o \cell Descri\'e7\'e3o \cell\row
\intbl Cont\'eaineres seq\'fcenciais \cell\cell\row
\intbl vector \cell inser\'e7\'f5es e retiradas r\'e1pidas no fim acesso direto a qualquer elemento \cell\row
\intbl deque \cell inser\'e7\'f5es e retiradas r\'e1pidas no in\'edcio e no fim acesso direto a qualquer elemento \cell\row
\intbl i.ist \cell lista duplamente encadeada, inser\'e7\'e3o e retirada r\'e1pidas em qualquer lugar \cell\row
\intbl Cont\'eaineres associativos \cell\cell\row
\intbl set \cell pesquisa r\'e1pida, duplicatas n\'e3o-permitidas \cell\row
\intbl multiset \cell pesquisa r\'e1pida, duplicatas permitidas \cell\row
\intbl map \cell mapeamento um para um, duplicatas n\'e3o-permitidas, pesquisa r\'e1pida usando chaves \cell\row
\intbl muJ.timap \cell mapeamento um para muitos, duplicatas n\'e3o-permitidas, pesquisa r\'e1pida usando chaves \cell\row
\intbl Adaptadores de cont\'eaineres \cell\cell\row
\intbl stack \cell\'faltimo a entrar, primeiro a sair (LIFO) \cell\row
\intbl queue \cell primeiro a entrar, primeiro a sair (FIFO) \cell\row
\intbl priorityqueue \cell o elemento de mais alta prioridade \'e9 sempre o primeiro a sair \cell\row
\pard\sa240\par
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2423\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx8946\pard\intbl Fun\'e7\'f5es membro comuns a todos os cont\'eaineres da STL \cell Descri\'e7\'e3o \cell\row
\intbl construtor default \cell Um construtor para fazer uma inicializa\'e7\'e3o default do cont\'eainer. Normalmente, cada cont\'eainer tem diversos construtores que fornecem uma variedade de m\'e9todos de inicializa\'e7\'e3o para o cont\'eainer. \cell\row
\intbl construtor de c\'f3pia \cell Um construtor que inicializa o cont\'eainer como sendo uma c\'f3pia de um cont\'eainer existente do mesmo tipo. \cell\row
\pard\par
\pard\sb100\sa240 CAP\'cdTULO 20 - A BIBLIOTECA PADR\'c3O DE GABARITOS (STL) 921 \par
Fun\'e7\'f5es membro \line comuns a todos os \line cont\'eaineres da STL Descri\'e7\'e3o \line destruidor Fun\'e7\'e3o destruidor para limpeza depois que um cont\'eainer n\'e3o \'e9 mais necess\'e1rio. \line empty Retorna true se n\'e3o h\'e1 nenhum elemento no cont\'eainer; caso contr\'e1rio, retorna false. niaxsize Retorna o n\'famero m\'e1ximo de elementos de um cont\'eainer. \line size Retorna o n\'famero de elementos presentemente no cont\'eainer. \line operator= Atribui um cont\'eainer a outro. \line operator< Retorna true se o primeiro cont\'eainer \'e9 menor do que o segundo cont\'eainer; caso contrario, retorna false. \line operator<= Retorna true se o primeiro cont\'eainer \'e9 menor ou igual ao segundo cont\'eainer; caso contr\'e1rio, retorna false. \line operator> Retorna true se o primeiro cont\'eainer \'e9 maior do que o segundo cont\'eainer; caso contr\'e1rio, retorna false. \line operator>= Retorna true se o primeiro cont\'eainer \'e9 maior ou igual ao segundo cont\'eainer; caso contr\'e1rio, retorna false. \line operator== Retorna true se o primeiro cont\'eainer \'e9 igual ao segundo cont\'eainer; caso contr\'e1rio, retorna false. \line operator ! = Retorna true se o primeiro cont\'eainer n\'e3o \'e9 igual ao segundo cont\'eainer, caso contr\'e1rio, retorna false. \line swap Permuta os elementos de dois cont\'eaineres. \line Fun\'e7\'f5es que s\'e3o encontradas somente em cont\'eaineres de primeira classe \line begin As duas vers\'f5es desta fun\'e7\'e3o retornam ou um iterator ou um const_iterator que se refere ao primeiro elemento do cont\'eainer. \line end As duas vers\'f5es desta fun\'e7\'e3o retornam ou um iterator ou um constiterator que se refere \'e0 pr\'f3xima posi\'e7\'e3o ap\'f3s o fim do cont\'eainer. \line rbegin As duas vers\'f5es desta fun\'e7\'e3o retornam ou um reverse_iterator ou um constreverseiterator que se refere ao \'faltimo elemento do cont\'eainer. \line rend As duas vers\'f5es desta fun\'e7\'e3o retornam ou um reverse iterator ou um constreverseiterator que se refere \'e0 posi\'e7\'e3o antes do primeiro elemento do \line cont\'eainer. \line erase Apaga um ou mais elementos do cont\'eainer. \line clear Apaga todos os elementos do cont\'eainer. \line Fig. 20.2 Fun\'e7\'f5es comuns a todos os cont\'eaineres da STL (parte 2 de 2). \line Os arquivos de cabe\'e7alho para cada um dos cont\'eaineres da biblioteca padr\'e3o s\'e3o mostrados na Fig. 20.3. Os conte\'fados destes arquivos de cabe\'e7alho est\'e3o todos em naxnespace std. [Nota: alguns compiladores C++ ainda n\'e3o suportam os novos arquivos de cabe\'e7alho. Muitos destes compiladores fornecem sua pr\'f3pria vers\'e3o dos nomes dos arquivos de cabe\'e7alho. Veja a documenta\'e7\'e3o do seu compilador para mais informa\'e7\'f5es sobre o suporte \'e0 STL que seu compilador fornece.] \line A Fig. 20.4 mostra os typedefs comuns (para criar sin\'f4nimos ou apelidos para nomes de tipos muito longos) encontrados em cont\'eaineres de primeira classe. Estes typedefs s\'e3o usados em declara\'e7\'f5es gen\'e9ricas de \line vari\'e1veis, par\'e2metros para fun\'e7\'f5es e valores de retorno de fun\'e7\'f5es. Por exemplo, value type em cada cont\'eainer 4. \'e9 sempre um typedef que representa o tipo de valor armazenado no cont\'eainer. \par
922 C++ COMO PROGRAMAR \line Arquivos de cabe\'e7alho de cont\'eaineres da biblioteca padr\'e3o \line <vector> \line <li st> \line <deque> \line <queue> cont\'e9m queue e priorityqueue \line <stack> \line <map> cont\'e9m map e inultimap \line <set> cont\'e9m set e znultiset \line <bitset> \line Fig. 20.3 Arquivos de cabe\'e7alho dos cont\'eaineres da biblioteca padr\'e3o. \line typedef Descri\'e7\'e3o \line valuetype O tipo do elemento armazenado no cont\'eainer. \line reference Uma refer\'eancia ao tipo do elemento armazenado no cont\'eainer. \line constreference Uma refer\'eancia constante ao tipo do elemento armazenado no cont\'eainer. \line Tal tipo de refer\'eancia pode ser usado somente para ler elementos no \line cont\'eainer e para executar opera\'e7\'f5es const. \line pointer Um ponteiro para o tipo do elemento armazenado no cont\'eainer. \line i terator Um iterador que aponta para o tipo do elemento armazenado no cont\'eainer. \line constiterator Um iterador constante que aponta para o tipo de elemento armazenado \line no cont\'eainer e que pode ser usado somente para ler elementos. \line reverseiterator Um iterador reverso que aponta para o tipo de elemento armazenado no \line cont\'eainer. Este tipo de iterator \'e9 para percorrer um cont\'eainer do fim para \line o in\'edcio. \line constreverseiterator Um iterador reverso constante para o tipo de elemento armazenado no \line cont\'eainer e que pode ser usado somente para ler elementos. Este tipo de \line iterador \'e9 para percorrer o cont\'eainer do fim para o in\'edcio. \line differencetype O tipo do resultado da subtra\'e7\'e3o de dois iteradores que se referem ao \line mesmo cont\'eainer (operator- n\'e3o est\'e1 definido para iteradores de \line lists e cont\'eaineres associativos). \line sizetype O tipo usado para contar itens em um cont\'eainer e indexar ao longo de \line um cont\'eainer seq\'fcencial (n\'e3o pode indexar ao longo de uma list). \line Fig. 20.4 typedefs comuns encontrados em cont\'eaineres de primeira classe. \line Dica de desempenho 20.3 \line ______ A STL geralmente evita heran\'e7a efun\'e7\'f5es virtual em favor da programa\'e7\'e3o gen\'e9rica com gabaritos, para obter um desempenho melhor durante a execu\'e7\'e3o. \line Dica de portabilidade 20.1 \line A STL certamente vai se tornar o meio favorito de programa\'e7\'e3o com cont\'eaineres. Programar com a STL \line vai aumentar a portabilidade de seu c\'f3digo. \par
CAP\'cdTULO 20- A BIBLIOTECA PADR\'c3O DE GABARITOS (STL) 923 \line I)ica de desempenho 20.4 \line Conhe\'e7a seus componentes da STL. Escolher o cont\'eainer mais apropriado para um determinado problema pode maximizar o desempenho e minimizar os requisitos de mem\'f3ria. \line Ao se preparar para usar um cont\'eainer da STL, \'e9 importante assegurar-se de que o tipo de elemento sendo armazenado no cont\'eainer suporta um conjunto m\'ednimo de funcionalidades. Quando um elemento \'e9 inserido em um cont\'eainer, \'e9 feita uma c\'f3pia daquele elemento. Por esta raz\'e3o, o tipo do elemento deve fornecer seu pr\'f3prio construtor de c\'f3pia e operador de atribui\'e7\'e3o. [Nota: isto \'e9 necess\'e1rio somente se uma c\'f3pia membro a membro default n\'e3o executa uma opera\'e7\'e3o de c\'f3pia adequada para o tipo do elementoj. Al\'e9m disso, os cont\'eaineres associativos e diversos algoritmos requerem que os elementos sejam comparados. Por esta raz\'e3o, o tipo do elemento deve fornecer um operador de igualdade (==) e um operador menor do que (<). \line Observa\'e7\'e3o de engenharia de software 20.3 \line _______ Os operadores de igualdade e menor do que s\'e3o tecnicamente desnecess\'e1rios para os elementos armazenodos em um cont\'eainer a menos que os elementos necessitem ser comparados. Entretanto, quando se cria c\'f3digo a partir de um gabarito, alguns compiladores requerem que todas as partes do gabarito sejam definidas, enquanto outros compiladores requerem somente as partes do gabarito que s\'e3o realmente usadas no programa. \line 20.1.2 Introdu\'e7\'e3o a iteradores \line Os iteradores t\'eam muitas caracter\'edsticas em comum com os ponteiros e s\'e3o usados para apontar para os elementos dos cont\'eaineres de primeira classe (e para uns poucos outros prop\'f3sitos, como veremos). Iteradores armazenam informa\'e7\'e3o sens\'edvel aos tipos espec\'edficos de cont\'eaineres com os quais eles operam, portanto iteradores s\'e3o implementados apropriadamente para cada tipo de cont\'eainer. N\'e3o obstante, certas opera\'e7\'f5es de iteradores s\'e3o uniformes para todos os cont\'eaineres. Por exemplo, o operador derreferenciador (*) derreferencia um iterador de modo que voc\'ea possa usar o elemento para o qual ele aponta. A opera\'e7\'e3o ++ em um iterador retorna um iterador para o pr\'f3ximo elemento do cont\'eainer (assim como incrementar um ponteiro para um array aponta o ponteiro para o pr\'f3ximo elemento do array). \line Os cont\'eaineres de primeira classe da STL fornecem fun\'e7\'f5es membro begin () e end () . A fun\'e7\'e3o begin O retorna um iterador apontando para o primeiro elemento do cont\'eainer. A fun\'e7\'e3o end O retorna um iterador apontando para o primeiro elemento ap\'f3s o final do cont\'eainer (um elemento que n\'e3o existe). Se um iterador i aponta para um elemento em particular, ent\'e3o ++ i aponta para o pr\'f3ximo elemento e * i refere-se ao elemento apontado por i. O iterador resultante de end () pode ser usado somente em uma compara\'e7\'e3o quanto \'e0 igualdade ou desigualdade, para determinar se o iterador m\'f3vel\rdblquote  (i, neste caso) atingiu o fim do cont\'eainer. \line Usamos um objeto do tipo iterador para fazer refer\'eancia a um elemento de cont\'eainer que pode ser modificado. Usamos um objeto do tipo const iterator para fazer refer\'eancia a um elemento de cont\'eainer que n\'e3o pode ser modificado. \line Usamos iteradores com seq\'fc\'eancias (tamb\'e9m chamadas de intervalos). Estas seq\'fc\'eancias podem estar em cont\'eaineres ou podem ser seq\'fc\'eancias de entrada ou seq\'fc\'eancias de sa\'edda. O programa da Fig. 20.5 demonstra a leitura a partir da entrada padr\'e3o (uma seq\'fc\'eancia de dados de entrada para um programa) usando um istreamiterator e sa\'edda para a sa\'edda padr\'e3o (uma seq\'fc\'eancia de dados para sa\'edda de um programa) usando um ostream iterator. O programa l\'ea dois inteiros digitados pelo usu\'e1rio no teclado e mostra a soma dos inteiros. [Nota: nos exemplos neste cap\'edtulo, cada uso de uma fun\'e7\'e3o da STL e cada defini\'e7\'e3o de um objeto cont\'eainer da STL \'e9 precedido pelo prefixo std: : em vez de colocar os comandos using no come\'e7o do programa, como mostrado na maioria dos exemplos anteriores. Devido a diferen\'e7as nos compiladores e \'e0 complexidade do c\'f3digo gerado quando a STL \'e9 usada, \'e9 dif\'edcil se construir um conjunto adequado de comandos using que permita que os programas sejam compilados sem erros. Para permitir que estes programas sejam compilados na maior variedade de plataformas, optamos pela abordagem com prefixo \ldblquote std: :\ldblquote .j \par
924 C\'f7+ COMO PROGRAMAR \line 1 II Fig. 20.5: fig2005.cpp \line 2 II Demonstrando entrada e sa\'edda com iteradores. \line 3 #include <iostreain> \line 4 \line 5 using std::cout; \line 6 using std::cin; \line 7 using std::endl; \line 8 \line 9 #include <iterator> \line 10 \line 11 int main() \line 12 \line 13 cout \'ab \ldblquote Digite dois inteiros: \ldblquote ; \line 14 \line 15 std: :istream_iterator< int > inputlnt( cm ), \line 16 int numberl, nun\rquote iber2; \line 17 \line 18 nuniberl = *inputlnt; II l\'ea primeiro int da entrada padr\'e3o \line 19 ++inputlnt; II move iterador para pr\'f3ximo valor de entrada \line 20 nuniber2 = *inputlnt; // l\'ea pr\'f3ximo int da entrada padr\'e3o \line 21 \line 22 cout \'ab \ldblquote A soma \'e9: \ldblquote ; \line 23 \line 24 std: :ostreaxniterator< int > outputlnt( cout ); \line 25 \line 26 *outputlnt = numberi + number2; // envia resultado para cout \line 27 cout \'ab endl; \line 28 return 0; \line 29 \line Digite dois inteiros: 12 25 \line A soma \'e9: 37 \line Fig. 20.5 Demonstrando iteradores de entrada e sa\'edda com streams. \line A linha 15 \line std::istreamiterator< int > inputlnt( cm ); \line cria um istream iterator que \'e9 capaz de extrair (ler) valores int de um modo seguro quanto ao tipo dc objeto de entrada padr\'e3o cm. A linha 18 \line numberi = *inputlnt; // l\'ea primeiro int da entrada padr\'e3o \line desreferencia o iterador inputlnt para ler o primeiro inteiro de cm e atribui aquele inteiro a numberl. Observe o uso do operador derreferenciador * para obter o valor do stream associado com inputlnt; isto \'e9 semelhante derreferenciar um ponteiro. A linha 19 \line ++inputlnt; // nove iterador para pr\'f3ximo valor de entrada \line posiciona o iterador inputlnt no pr\'f3ximo valor no stream de entrada. A linha 20 \line number2 = *inputlnt; II l\'ea pr\'f3ximo int da entrada padr\'e3o \par
l\'ea o pr\'f3ximo inteiro de inputlnt e o atribui a number2. \line A linha 24 \par
std::ostreamiterator< int > outputlnt( cout ); \par
cria um ostream iterator que \'e9 capaz de inserir (enviar) valores int no objeto de sa\'edda padr\'e3o cout. A linha 26 \par
*outputlnt = numberi + number2; // envia resultado para cout \par
envia um inteiro para cout ao atribuir ao *outputlnt a soma de numberl e nuniber2. Note o uso do operador derreferenciador * para usar *outputlnt como um Ivalue na instru\'e7\'e3o de atribui\'e7\'e3o. Se voc\'ea quizer produzir outro valor usando outputlnt, o iterador deve ser incrementado com ++ (podem ser usados tanto pr\'e9-incremento como p\'f3s-incremento). \par
\'ae Dica de teste e depura\'e7\'e3o 20.2 \line O operador * (desreferenciador) de qualquer iterador const retorna uma refer\'eancia const ao elemento do cont\'eainer n\'e3o permitindo, portanto, o uso de fun\'e7\'f5es membro n\'e3o-const. \par
Erro comum de programa\'e7\'e3o 20.1 \line Tentar desreferenciar um iteradorposicionadofora de seu cont\'eainer \'e9 um erro l\'f3gico durante a execu\'e7\'e3o. \line Especialmente, o iterador retornado por end () n\'e3o pode ser derreferenciado ou incrementado. \par
Erro comum de programa\'e7\'e3o 20.2 \line Tentar criar um iterador n\'e3o-const para um cont\'eainer const \'e9 um erro de sintaxe. \par
A Fig. 20.6 mostra as categorias de iteradores usados pela STL. Cada categoria fornece um conjunto espec\'edfico de funcionalidades. \par
Categoria Descri\'e7\'e3o \par
Usado para ler um elemento de um cont\'eainer. Um iterador de entrada pode mover-se somente na dire\'e7\'e3o para a frente (isto \'e9, do in\'edcio do cont\'eainer para o fim do cont\'eainer), um elemento a cada vez. Interadores de entrada suportam somente algoritmos de um \'fanico passo - o mesmo iterador de entrada n\'e3o pode ser usado para percorrer uma seq\'fc\'eancia duas vezes. \par
Usado para escrever um elemento em um cont\'eainer. Um iterador de sa\'edda pode mover-se somente na dire\'e7\'e3o para a frente, um elemento a cada vez. Iteradores de sa\'edda suportam somente algoritmos de um \'fanico passo - o mesmo iterador de sa\'edda n\'e3o pode ser usado para percorrer uma seq\'fc\'eancia duas vezes. \par
Combina as recursos de iteradores de entrada e de sa\'edda e ret\'e9m sua posi\'e7\'e3o no cont\'eainer (como informa\'e7\'e3o de estado). \par
Combina os recursos de um iterador para a frente com a habilidade de mover-se na dire\'e7\'e3o para tr\'e1s (isto \'e9, do final do cont\'eainer em dire\'e7\'e3o ao in\'edcio do cont\'eainer). Tteradores para a frente suportam algoritmos de m\'faltiplas passagens. \par
Combina os recursos de um iterador bidirecional com a habilidade de acessar diretamente qualquer elemento do cont\'eainer, isto \'e9, saltar para frente ou para tr\'e1s um n\'famero arbitr\'e1rio de elementos. \par
CAP\'cdTULO 20 - A BIBLIOTECA PADR\'c3O DE GABARITOS (STL) 925 \par
entrada \par
sa\'edda \par
para a frente \par
bidirecional \par
acesso aleat\'f3rio \par
Fig. 20.6 Categorias de iteradores. \par
926 C++ COMO PROGRAMAR \line entrada sa\'edda \line para a frente \line bidirecional \line acesso aleat\'f3rio \line Fig. 20.7 Hierarquia das categorias de iteradores. \line A Fig. 20.7 ilustra a hierarquia das categorias de iteradores. \'c0 medida que voc\'ea segue a hierarquia de cima parabaixo, cada categoria de iterador suporta toda a funcionalidade das categorias acima dela na figura. Portanto, os tipos mais fracos de iteradores est\'e3o no topo e o tipo mais poderoso de iterador est\'e1 na parte inferior. Note que isto n\'e3o \'e9 uma hierarquia de heran\'e7a. \line A categoria de iterador suportada por cada cont\'eainer determina se aquele cont\'eainer pode ser usado com algoritmos espec\'edficos na STL. Cont\'eaineres que suportam iteradores de acesso aleat\'f3rio podem ser usados com todos os algoritmos na STL. Como veremos, ponteiros para arrays podem ser usados em lugar de iteradores na maioria dos algoritmos STL, incluindo aqueles que necessitam de iteradores de acesso aleat\'f3rio. A Fig. 20.8 mostra a categoria de iterador suportada por cada um dos cont\'eaineres da STL. Observe que somente vectors. deques, lists, sets, multisets, maps e multimaps (isto \'e9, os cont\'eaineres de primeira classe) podem ser percorridos com iteradores. \line Observa\'e7\'e3o de engenharia de software 20.4 \line ______ Usar o \ldblquote iterador mais fraco\rdblquote  que produz um desempenho aceit\'e1vel ajuda a produzir componentes reutiliz\'e1veis ao m\'e1ximo. \par
Cont\'eainer Tipo de iterador suportado \par
Cont\'eaineres seq\'fcenciais \line vector acesso aleat\'f3rio \line deque acesso aleat\'f3rio \line list bidirecional \line Cont\'eaineres associativos \line set bidirecional \line multiset bidirecional \line map bidirecional \line multimap bidirecional \line Adaptadores de cont\'eaineres \line stack n\'e3o tem suporte a iteradores \line queue n\'e3o tem suporte a iteradores \line priorityqueue n\'e3o tem suporte a iteradores \line Fig. 20.8 Tipos de iteradores suportados em cada cont\'eainer da biblioteca padrao. \line A Fig. 20.9 mostra os typedefs de iteradores predefinidos que s\'e3o encontrados nas defini\'e7\'f5es de classes dos cont\'eaineres da STL. Nem todo typedef est\'e1 definido para cada cont\'eainer. Usamos vers\'f5es const dos iteradores \par
CAP\'cdTULO 20- A BiBLIoTEcA PADR\'c3O DE GABARITOS (STL) 927 \par
para percorrer cont\'eaineres apenas de leitura. Usamos iteradores reversos para percorrer cont\'eaineres do fim para o in\'edcio. \par
Fig. 20.9 typedefS de iteradores predefinidos. \par
Dica de teste e depura \'e7\'e3o 20.3 \par
Opera\'e7\'f5es executadas em um cons t iterator retornam refrr\'eancias cons t para evitar modifica\'e7\'e3o a elementos do cont\'eainer que est\'e1 sendo manipulado. D\'ea prefer\'eancia ao uso de const iterators em vez de iterators, onde apropriado. Este \'e9 um outro exemplo do princ\'edpio do menor privil\'e9gio. \par
A Fig. 20.10 mostra as opera\'e7\'f5es que podem ser executadas sobre cada tipo de iterador. Note que as opera\'e7\'f5es para cada tipo de iterador incluem todas as opera\'e7\'f5es precedentes \'e0quele tipo na figura. Note, tamb\'e9m, que para os iteradores de entrada e de sa\'edda n\'e3o \'e9 poss\'edvel salvar o iterador e, ent\'e3o, usar o valor salvo mais tarde. \par
Fig. 20.10 Algumas opera\'e7\'f5es de iteradores para cada tipo de iterador (parte 1 de 2). \par
\pard\par
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx3623\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4748\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx5804\pard\intbl typedefS predefinidos para tipos de iteradores \cell Dire\'e7\'e3o de ++ \cell Recurso  ler/escrever \cell\row
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx3623\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx5804\pard\intbl i te rator \cell para frente \cell\row
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx3623\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4748\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx5804\pard\intbl constiterator \cell para frente \cell ler \cell\row
\intbl reverseiterator \cell para tr\'e1s \cell ler/escrever \cell\row
\intbl const_reverse_iterator \cell para tr\'e1s \cell ler \cell\row
\pard\sa240\par
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1854\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx8946\pard\intbl Opera\'e7\'e3o de iterador \cell Descri\'e7\'e3o \cell\row
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx8946\pard\intbl Todos os iteradores \cell\row
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1854\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx8946\pard\intbl ++p p++ \cell pr\'e9-incrementa um iterador p\'f3s-incrementa um iterador \cell\row
\intbl iteradores de entrada \cell\cell\row
\intbl *p  p = p1  p == p1  p ! = pi \cell derreferencia um iterador para uso como um rvalue atribui um iterador a outro  compara iteradores quanto \'e0 igualdade  compara iteradores quanto \'e0 desigualdade \cell\row
\intbl iteradores de sa\'edda \cell\cell\row
\intbl *p  p = p1 \cell derrefer\'eancia um iterador (para uso como um Ivalue) atribui um iterador a outro \cell\row
\intbl Iteradores para a frente \cell iteradores para a frente fornecem todas as funcionalidades tanto dos iteradores de entrada como de sa\'edda \cell\row
\intbl Iterudures bidirecionais \cell\cell\row
\intbl - -p p-- \cell pr\'e9-decrementa um iterador p\'f3s-decrementa um iterador \cell\row
\pard\par
\pard\sb100\sa240 928 C++ COMO PROGRAMAR \par
Iteradores de acesso aleat\'f3rio \line p += i \line p -= i \line p+i \par
p- i \par
p[ i 1 p < pi \par
p <= pi \par
p > pi \par
p >= pi \par
incrementa o iterador p em i posi\'e7\'f5es \line decrementa o iterador p em i posi\'e7\'f5es \line fornece como resultado um iterador posicionado em p incrementado em i posi\'e7\'f5es. \line fornece como resultado um iterador posicionado em p decrementado em i posi\'e7\'f5es. \line retorna uma refer\'eancia ao elemento distante i posi\'e7\'f5es de p. retorna true se o iterador p for menor do que o iterador p1 (isto \'e9, o iterador p est\'e1 antes do iterador p1 no cont\'eainer); caso contr\'e1rio, retorna false. retorna true se o iterador p for menor do que ou igual ao iterador p1 (isto \'e9, o iterador est\'e1 antes do iterador p1 ou est\'e1 no mesmo lugar que o iterador p1 no cont\'eainer); caso contr\'e1rio, retorna false. \line retorna true se o iterador p for maior do que o iterador p1 (isto \'e9, o iterador p est\'e1 ap\'f3s o iterador p1 no cont\'eainer); caso contr\'e1rio, retorna false. retorna true se o iterador p for maior ou igual ao iterador p1 (isto \'e9, o iterador p est\'e1 ap\'f3s o iterador p1, ou est\'e1 no mesmo lugar que o iterador p1 no cont\'eainer); caso contr\'e1rio, retorna false. \par
Fig. 20.10 Algumas opera\'e7\'f5es de iteradores para cada tipo de iterador (parte 2 de 2). \par
20.1.3 Introdu\'e7\'e3o a algoritmos \par
Um aspecto crucial da STL \'e9 que ela fornece algoritmos que podem ser usados genericamente para v\'e1rios tipos de cont\'eaineres. A STL fornece muitos algoritmos que voc\'ea usar\'e1 freq\'fcentemente para manipular cont\'eaineres. Inserir, deletar, procurar, classificar e outras mais s\'e3o a\'e7\'f5es apropriadas para alguns ou todos os cont\'eaineres da \par
STL. \par
A STL inclui aproximadamente 70 algoritmos padr\'e3o. Fornecemos exemplos de c\'f3digo real da maioria destes e resumimos os outros em tabelas. Os algoritmos operam sobre os elementos de cont\'eaineres somente indiretamente, atrav\'e9s de iteradores. Muitos algoritmos operam em seq\'fc\'eancias de elementos definidas por pares de iteradores - um primeiro iterador apontando para o primeiro elemento da seq\'fc\'eancia e um segundo apontando para um elemento imediatamente ap\'f3s o \'faltimo elemento da seq\'fc\'eancia. Al\'e9m disso, \'e9 poss\'edvel criar seus pr\'f3prios algoritmos novos, que operem de maneira similar, de modo que possam ser usados com os cont\'eaineres e iteradores da STL. \par
A fun\'e7\'e3o membro de cont\'eainer begin () retorna um iterador para o primeiro elemento de um cont\'eainer; end () retorna um iterador para a primeira posi\'e7\'e3o al\'e9m do \'faltimo elemento de um cont\'eainer. Algoritmos freq\'fcentemente retornam iteradores. \line Um algoritmo como f ind () , por exemplo, localiza um elemento e retorna um iterador para aquele elemento. Se o elemento n\'e3o for encontrado, f ind () retorna o iterador end , que pode ser testado para determinar se um elemento n\'e3o foi encontrado (o retorno de end O sup\'f5e uma pesquisa em todo o cont\'eainer). O algoritmo f ind O pode ser usado com qualquer cont\'eainer da STL. \par
Observa\'e7\'e3o de engenharia de software 20.5 \par
A STL \'e9 implementada concisamente. At\'e9 agora, projetistas de classes teriam associado os algoritmos aos cont\'eaineres tornando os algoritmos fun\'e7\'f5es membro dos cont\'eaineres. A STL adota uma abordagem diferente. Os algoritmos est\'e3o separados dos cont\'eaineres e operam sobre os elementos dos cont\'eaineres s\'f3 indiretamente, atrav\'e9s de iteradores. Esta separa\'e7\'e3o torna mais f\'e1cil escrever algoritmos gen\'e9ricos aplic\'e1veis a muitas outras classes de cont\'eaineres. \par
CAP\'cdTULO 20 - A BIBLIOTECA PADR\'c3O DE GABARITOS (STL) 929 \line Os algoritmos da STL criam mais uma oportunidade para reutiliza\'e7\'e3o. Usando a rica cole\'e7\'e3o de algoritmos populares, os programadores podem economizar muito tempo e esfor\'e7o. \line Se um algoritmo usa iteradores menos poderosos, ele tamb\'e9m pode ser usado com cont\'eaineres que suportam \line iteradores mais poderosos. Alguns algoritmos exigem iteradores poderosos; por exemplo, sort exige iteradores de acesso aleat\'f3rio. \line Observa\'e7\'e3o de engenharia de software 20.6 \line ______ A STL \'e9 extens\'edvel. \'c9 simples adicionar a ela novos algoritmos e fazer isso sem mudan\'e7as nos cont\'eaineres da STL. \line Observa\'e7\'e3o de engenharia de software 20.7 \line _______ Os algoritmos podem operar sobre cont\'eaineres da STL e sobre arrays baseados em ponteiros, no estilo usado em C. \line Dica de portabilidade 20.2 \line ______ Devido aos algoritmos da STL processarem os cont\'eaineres s\'f3 indiretamente, atrav\'e9s dos iteradores, um algoritmo pode freq\'fcentemente ser usado com muitos cont\'eaineres diferentes. \line A Fig. 20.11 mostra muitos dos algoritmos seqtienciais mutantes - isto \'e9, os algoritmos que resultam em modifica\'e7\'f5es dos cont\'eaineres sobre os quais os algoritmos s\'e3o aplicados. \par
Fig. 20.11 Algoritmos seq\'fcenciais mutantes \line A Fig. 20.12 mostra muitos dos algoritmos seq\'fcenciais n\'e3o-mutantes - isto \'e9, os algoritmos que n\'e3o resultam em modifica\'e7\'f5es dos cont\'eaineres sobre os quais os algoritmos s\'e3o aplicados. \par
Fig. 20.12 Algoritmos seq\'fcenciais n\'e3o-mutantes. \line A Fig. 20.13 mostra os algoritmos num\'e9ricos do arquivo de cabe\'e7alho <numeric>. \par
\pard\par
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2324\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4101\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx5984\pard\intbl 1 Algoritmos seq\'fcenciai \cell s mutantes \cell 1 \cell\row
\intbl copy() \cell remove O \cell reversecopy() \cell\row
\intbl copybackward O \cell remove copy O \cell rotate O \cell\row
\intbl filiO \cell remove copyif (1 \cell rotate_copy() \cell\row
\intbl fiii_n () \cell removeif O \cell stabieyartition O \cell\row
\intbl generate() \cell repiace() \cell swap() \cell\row
\intbl generate_n () \cell replacecopy () \cell swap ranges O \cell\row
\intbl iterswap () \cell repiace_copyif () \cell transform O \cell\row
\intbl partition() \cell repiace_if() \cell unique() \cell\row
\intbl randomshuffie O \cell reverse O \cell uniquecopy () \cell\row
\pard\sa240\par
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2402\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4059\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx5236\pard\intbl 1 Algoritmos seq\'fcenciais \cell n\'e3o-mutantes \cell 1  find_if O  mismatch()  search() \cell\row
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2402\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx5236\pard\intbl adjacentfind()  count()  countif () \cell findQ  findeach()  findend() \cell\row
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2402\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4059\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx5236\pard\intbl equal() \cell find_first_of() \cell search_n() \cell\row
\pard\par
\pard\sb100\sa240 930 C\'f7+ COMO PROGRAMAR \line Algoritmos num\'e9ricos do arquivo de cabe\'e7alho <numeric> \line accumulate O \line inner_product () \line partialsum() \line adjacentdifference O \line Fig. 20.13 Algoritmos num\'e9ricos do arquivo de cabe\'e7alho <numeric> \line 20.2 Cont\'eaineres seq\'fcenciais \line A biblioteca padr\'e3o de gabaritos de C++ fornece tr\'eas cont\'eaineres seq\'fcenciais - vector, list e deque. A classe vector e a classe deque s\'e3o ambas baseadas em arrays. A classe list implementa uma estrutura de dados de lista encadeada similar \'e0 nossa classe List apresentada no Cap\'edtulo 15, mas mais robusta. \line Um dos cont\'eaineres mais populares na STL \'e9 vector. A classe vector \'e9 um refinamento da classe Array \ldblquote meio inteligente\rdblquote  que criamos no Cap\'edtulo 8. Um vector pode mudar de tamanho dinamicamente. Diferentemente dos arrays \ldblquote crus\rdblquote  de C e C++ (ver Cap\'edtulo 4), os vectors podem ser atribu\'eddos um ao outro. Isto n\'e3o \'e9 poss\'edvel com os arrays no estilo usado em C, baseados em ponteiros, porque os nomes daqueles arrays s\'e3o ponteiros constantes e n\'e3o podem ser o destino em atribui\'e7\'f5es. Assim como com os arrays C, a indexa\'e7\'e3o de vector n\'e3o executa a verifica\'e7\'e3o autom\'e1tica de limites, mas a classe vector fornece este recurso (como veremos adiante) atrav\'e9s da fun\'e7\'e3o membro at. \line Dica de desempenho 20.5 \line A inser\'e7\'e3o no fim de um vector \'e9 eficiente. O vector simplesmente cresce, se necess\'e1rio, para acomodar o novo item. E dispendioso inserir (ou retirar) um elemento no meio de um vector - a por\'e7\'e3o inteira do vector ap\'f3s o ponto de inser\'e7\'e3o (ou retirada) deve ser movida, porque elementos vector ocupam posi\'e7\'f5es cont\'edguas na mem\'f3ria, assim como um array \ldblquote cru\rdblquote  em C ou C++. \line A Fig. 20.2 apresenta as opera\'e7\'f5es comuns a todos os cont\'eaineres da STL. Al\'e9m destas opera\'e7\'f5es, cada cont\'eainer fornece tipicamente diversos outros recursos. Muitos destes recursos s\'e3o comuns a diversos cont\'eaineres. Entretanto, estas opera\'e7\'f5es nem sempre s\'e3o igualmente eficientes para cada cont\'eainer. Os programadores precisam ent\'e3o, freq\'fcentemente, escolher o cont\'eainer mais apropriado \'e0s suas aplica\'e7\'f5es. \line Dica de desempenho 20.6 \line Aplica\'e7\'f5es que requeiram freq\'fcentes inser\'e7\'f5es e dele \'e7\'f5es em ambas as extremidades de um cont\'eainer normalmente usam uma deque de prefer\'eancia a um vector. Embora possamos inserir e deletar elementos na frente e atr\'e1s tanto de um vector como de uma deque, a classe deque \'e9 mais eficiente do que vector para fazer inser\'e7\'f5es e dele\'e7\'f5es no in\'edcio. \line Dica de desempenho 20.7 \line\lquote _ Aplica\'e7\'f5es com freq\'fcentes inser\'e7\'f5es e dele \'e7\'f5es no meio e/ou nos extremos de um cont\'eainer normalmente usam uma list, devido \'e0 sua eficiente implementa\'e7\'e3o de inser\'e7\'e3o e dele\'e7\'e3o em qualquer lugar na \line estrutura de dados. \line Al\'e9m das opera\'e7\'f5es em comum descritas na Fig. 20.2, os cont\'eaineres seq\'fcenciais t\'eam diversas outras opera\'e7\'f5es em comum - front para retornar uma refer\'eancia ao primeiro elemento no cont\'eainer, back para retornar uma refer\'eancia ao \'faltimo elemento no cont\'eainer, push_back para inserir um novo elemento no final do cont\'eainer e pop_back para remover o \'faltimo elemento do cont\'eainer. \par
CAP\'cdTULO 20- A BIBLIOTECA PADR\'c3O DE GABARITOS (STL) 931 \line 20.2.1 O corit\'eainer seq\'fcencial vector \line A classe vector fornece uma estrutura de dados com posi\'e7\'f5es de mem\'f3ria cont\'edguas. Isto viabiliza o acesso direto \line e eficiente a qualquer elemento de um vector via o operador subscrito [],exatamente como um array \ldblquote bruto\rdblquote  em \line C ou C++. A classe vector \'e9 mais comumente usada quando os dados no cont\'eainer devem ser ordenados e facilmente acess\'edveis via um subscrito. Quando a mem\'f3ria de um vector est\'e1 esgotada, o vector aloca uma \'e1rea de \line mem\'f3ria maior em uma \'e1rea cont\'edgua, copia os elementos originais para a nova mem\'f3ria e libera a mem\'f3ria antiga. \line Dica de desempenho 20.8 \line ______ Escolha o cont\'eainer vector para obter o melhor desempenho com acesso aleat\'f3rio. \line Dica de desempenho 20.9 \line f Objetos da classe vector fornecem acesso indexado r\'e1pido com o operador subscrito sobrecarregado [J porque eles est\'e3o armazenados em uma \'e1rea cont\'edgua, como um array \ldblquote bruto\rdblquote  em C ou C+ +. \line Dica de desempenho 20.10 \line t \'c9 muito mais r\'e1pido inserir muitos elementos de uma s\'f3 vez do que um elemento de cada vez. \line Uma parte importante de todo cont\'eainer \'e9 o tipo de iterador que ele suporta. Isto determina quais algoritmos podem ser aplicados ao cont\'eainer. Um vector suporta iteradores de acesso aleat\'f3rio - isto \'e9, todas as opera\'e7\'f5es sobre cont\'eaineres mostradas na Fig. 20.10 podem ser aplicadas a um iterador de vector. Todos os algoritmos podem operar sobre um vector. Os iteradores para um vector s\'e3o normalmente implementados como ponteiros para os elementos do vector. Cada um dos algoritmos da STL que aceitam iteradores como argumentos requerem que estes iteradores forne\'e7am um n\'edvel m\'ednimo de funcionalidade. Se um algoritmo requer um iterador para a frente, por exemplo, tal algoritmo pode operar em qualquer cont\'eainer que forne\'e7a iteradores para a frente, iteradores bidirecionais ou iteradores de acesso aleat\'f3rio. Desde que o cont\'eainer suporte a funcionalidade m\'ednima do iterador do algoritmo, o algoritmo pode operar sobre o cont\'eainer. \line A Fig. 20.14 ilustra diversas fun\'e7\'f5es do gabarito de classe vector. Muitas destas fun\'e7\'f5es est\'e3o dispon\'edveis \line em todos os cont\'eaineres de primeira classe da biblioteca padr\'e3o. Voc\'ea deve incluir o arquivo de cabe\'e7alho <vector> para usar a classe vector. \line 1 // Fig. 20.14: fig2Ol4.cpp \line 2 // Testando o gabarito de classe vector da Biblioteca Padr\'e3o \line 3 #include <iostream> \line 4 \line 5 using std: :cout; \line 6 using std: :cin; \line 7 using std::endl; \line 8 \line 9 #include <vector> \line 10 \line 11 template < class T > \line 12 void printVector( const std: :vector< i vec \line 13 \line 14 int main() \line 15 \{ \line 16 const int SIZE = 6; \line 17 inta[SIZE]=\{1,2,3,4,5,6\}; \line 18 std: :vector< int > v; \line 19 \line 20 cout \'ab \lquote O tamanho inicial de v \'e9: \'ab v.size() \line Fig. 20.14 Demonstrando o gabarito de classe vector da biblioteca padr\'e3o (parte 1 de 2). \par
932 C++ COMO PROGRAMAR \par
21 \'ab \ldblquote\\nA capacidade inicial de v \'e9: \'ab v.capacity \line 22 v.push_back( 2 ); II o m\'e9todo push_back() existe em \line 23 v.push_back( 3 ); II todas as cole\'e7\'f5es seq\'fcenciais \line 24 v.push_back( 4 ); \line 25 cout \'ab \ldblquote\\nO tamanho de v \'e9: \'ab v.size() \line 26 \'ab \ldblquote\\nA capacidade de v \'e9: \'ab v.capacity \line 27 cout \'ab \ldblquote\\n\\nConte\'fado do array a usando nota\'e7\'e3o de ponteiro: \line 28 \line 29 for ( int *ptr = a; ptr != a + SIZE; ++ptr \line 30 cout \'ab *ptr \'ab \lquote  \line 31 \line 32 cout \'ab \ldblquote\\nConte\'fado do vector v usando nota\'e7\'e3o de iterador: \ldblquote ; \line 33 printVector( v \line 34 \line 35 cout \'ab \ldblquote\\nConte\'fado do vector v invertido: \ldblquote ; \line 36 \line 37 std: :vector< int >: :reverse_iterator p2; \line 38 \line 39 for ( p2 = v.rbeginO; p2 != v.rend(); ++p2 \line 40 cout \'ab *p2 \'ab \line 41 \line 42 cout \'ab endl; \line 43 return 0; \line 44 \line 45 \line 46 template < class T > \line 47 void printVector( const std: :vector< T > &vec \line 48 \line 49 std: :vector< T >: :const_iterator p1; \line 50 \line 51 for ( p1 = vec.beginO; p1 != vec.endO; pl++ \line 52 cout \'ab *p1 \'ab \line 53 \line O tamanho inicial de v \'e9: O \line A capacidade inicial de v \'e9: O \line O tamanho de v \'e9: 3 \line A capacidade de v \'e9: 4 \line Conte\'fado do array a usando nota\'e7\'e3o de ponteiro: 1 2 3 4 5 6 \line Conte\'fado do vector v usando nota\'e7\'e3o de iterador: 2 3 4 \line Conte\'fado do vector v invertido: 4 3 2 \line Fig. 20.14 Demonstrando o gabarito de classe vector da biblioteca padr\'e3o (parte 2 de 2). \line A linha 18 \line std: :vector< int > v; \line declara uma inst\'e2ncia da classe vector chamada v, que armazena valores int. Quando este objeto \'e9 instanciad \'e9 criado um vector vazio com tamanho (isto \'e9, o n\'famero de elementos armazenados no vector) igual a O capacidade (isto \'e9, o n\'famero de elementos que podem ser armazenados sem alocar mais mem\'f3ria para o vectoz tamb\'e9m igual a O. \line As linhas 20 e 21 \par
cout \'ab \ldblquote O tamanho inicial de v \'e9: \ldblquote  \'ab v.size() \line\'ab \ldblquote\\nA capacidade inicial de v \'e9: \ldblquote  \'ab v.capacity \par
CAP\'cdTULO 20 - A BIBLIOTECA PADR\'c3O DE GABARITOS (STL) 933 \par
demonstram as fun\'e7\'f5es size e capacity, as quais inicialmente retornam O para o vector v, neste exemplo. A fun\'e7\'e3o size dispon\'edvel em todos os cont\'eaineres - retorna o n\'famero de elementos atualmente armazenados no cont\'eainer. A fun\'e7\'e3o capacity retorna o n\'famero de elementos que podem ser armazenados no vector antes que o vector se redimensione dinamicamente para acomodar mais elementos. \line As linhas 22 at\'e9 24 \line v.pushback( 2 ); II o m\'e9todo push_back() existe em \line v.pushback( 3 ); II todas as cole\'e7\'f5es seq\'fcenciais \line v.pushback( 4 ); \line usam a fun\'e7\'e3o push_back - dispon\'edvel em todos os cont\'eaineres seq\'fcenciais - para adicionar um elemento ao final do vector. Se um elemento \'e9 adicionado a um vector cheio, o vector aumenta seu tamanho - algumas implementa\'e7\'f5es da STL fazem o vector dobrar seu tamanho. \line\ul 1 \ulnone Dica de desempenho 20.11 \line _____ Pode ser um desperd\'edcio dobrar o tamanho de um vector quando \'e9 necess\'e1rio mais espa\'e7o. Por exemplo, um vector com um total de 1.000.000 elementos se redimensiona para acomodar 2.000.000 elementos quando \'e9 adicionado um novo elemento. Isto deixa 999.999 elementos sem uso. Os programadores podem usar resize () para controlar melhoro uso do espa\'e7o. \line As linhas 25 e 26 usam size e capacity para ilustrar o novo tamanho e capacidade do vector ap\'f3s as opera\'e7\'f5es de push back. A fun\'e7\'e3o size retorna 3 - o n\'famero de elementos acrescentados ao vector. A fun\'e7\'e3o capacity retorna 4 indicando que podemos acrescentar mais um elemento sem alocar mais mem\'f3ria para o vector. Quando adicionamos o primeiro elemento, o tamanho de v tornou-se 1 e a capacidade de v tornou-se 1. Quando adicionamos o segundo elemento, o tamanho de v tornou-se 2 e a capacidade de v tornou-se 2. Quando adicionamos o terceiro elemento, o tamanho de v tornou-se 3 e a capacidade de v tornou-se 4. Se adicionarmos mais dois elementos, o tamanho de v ser\'e1 5 e a capacidade ser\'e1 8. A capacidade dobra toda vez que o total do espa\'e7o alocado para o vector est\'e1 cheio e outro elemento \'e9 adicionado. \line As linhas 29 e 30 demonstram como enviar para a sa\'edda o conte\'fado de um array usando ponteiros e aritm\'e9tica de ponteiros. A linha 33 busca a fun\'e7\'e3o printVector para produzir os conte\'fados de um vector usando iteradores. A defini\'e7\'e3o do gabarito de fun\'e7\'e3o printVector come\'e7a na linha 46. A fun\'e7\'e3o recebe uma refer\'eancia const para um vector como seu argumento. A linha 49 \line std: :vector< T >: :const iterator p1; \line declara um const_iterator chamado p1 que itera atrav\'e9s do vector e envia seu conte\'fado para a sa\'edda. Um const vector habilita o programa a ler os elementos do vector, mas n\'e3o permite ao programa modificar os elementos. A estrutura for nas linhas 51 e 52 \line for ( p1 = vec.beginO; p1 != vec.end(); pl++ \line cout \'ab *p1 \'ab \line inicializa p1 usando a fun\'e7\'e3o membro begin de vector que retorna um const_iterator para o primeiro elemento no vector (h\'e1 uma outra vers\'e3o de begin que retorna um iterator que pode ser usado para cont\'eaineres n\'e3o-const). O la\'e7o continua enquanto p1 n\'e3o tenha ultrapassado o final de vector. Isto \'e9 determinado ao comparar p1 com o resultado de vec . end () que retorna um const_iterator (como com begin. h\'e1 uma outra vers\'e3o de end que retorna um iterator) indicando a localiza\'e7\'e3o ap\'f3s o \'faltimo elemento do vector. Se p1 \'e9 igual a este valor, o fim do vector foi atingido. As fun\'e7\'f5es begin e end est\'e3o dispon\'edveis a todos os cont\'eaineres de primeira classe. O corpo do la\'e7o derreferencia o iterador p1 para conseguir o valor que est\'e1 armazenado no elemento corrente (apontado pelo iterador) do vector. A express\'e3o pl++ posiciona o iterador no pr\'f3ximo elemento do vector. \line\'ae Dica de teste e depura \'e7\'f5o 20.4 \line Somente iteradores de acesso aleat\'f3rio suportam <. \'c9 melhor usar ! = e end O para testar o fim do cont\'eainer \par
934 C++ COMO PROGRAMAR \par
A linha 37 \line declara um reverse_iterator que pode ser usado para percorrer um vector do fim para o in\'edcio. Todos os cont\'eaineres de primeira classe suportam este tipo de iterador. \line As linhas 39 e 40 \line for ( p2 = v.rbeginO; p2 != v.rendO; ++p2 \line cout \'ab *p2 \'ab \line usam uma estrutura for similar \'e0quela na fun\'e7\'e3o printVector para percorrer o vector. Neste la\'e7o, as fun\'e7\'f5es rbegin (isto \'e9, o iterador para o ponto inicial para percorrer o cont\'eainer do fim para o in\'edcio) e rend (isto \'e9, o iterador para o ponto final para percorrer o cont\'eainer do fim para o in\'edcio) delimitam o intervalo de elementos para sa\'edda do fim para o in\'edcio. Como as fun\'e7\'f5es begin e end, rbegin e rend podem retornar um const_reverse_iterator ou um reverse iterator baseadas em se o cont\'eainer \'e9 ou n\'e3o constante. \line A Fig. 20.15 ilustra fun\'e7\'f5es que permitem a recupera\'e7\'e3o e manipula\'e7\'e3o dos elementos de um vector. A linha 16 \line std::vector< int > v( a, a + SIZE ); \line usa um construdctor vector sobrecarregado que aceita dois iteradores como argumentos. Lembre-se de que p011- teiros para um array podem ser usados como iteradores. Esta declara\'e7\'e3o cria integer vector v e o inicializa com o conte\'fado do array integer a da posi\'e7\'e3o a at\'e9 - mas n\'e3o incluindo - a posi\'e7\'e3o a + SIZE. \line 1 II Fig. 20.15: fig2Ol5.cpp \line 2 // Testando as fun\'e7\'f5es de manipula\'e7\'e3o de elementos \line 3 // do gabarito de classe vector da Biblioteca Padr\'e3o \line 4 #include <iostream> \line 5 \line 6 using std::cout; \line 7 using std::endl; \line 8 \line 9 #include <vector> \line 10 #include <algorithm> \line li \line 12 int main() \line 13 \{ \line 14 const int SIZE = 6; \line 15 inta[SIZE]=\{l,2,3,4,5,6\}; \line 16 std: :vector< int > v( a, a + SIZE ); \line 17 std: :ostreamiterator< int > output( cout, \line 18 cout \'ab \ldblquote O vector v cont\'e9m: \line 19 std: :copy( v.beginO), v.endO), output ); \line 20 \line 21 cout \'ab \ldblquote\\nPrimeiro elemento de v: \ldblquote  \'ab v.frontO \line 22 \'ab \ldblquote\\\'daltimo elemento de v: \ldblquote  \'ab v.backO; \line 23 \line 24 v[ O ] = 7; II atribui 7 ao primeiro elemento \line 25 v.at( 2 ) = 10; II atribui 10 ao elemento na posi\'e7\'e3o 2 \line 26 v.insert( v.begin() + 1, 22 ); // insere 22 como segundo elemento \line 27 cout \'ab \ldblquote\\nConte\'fado do vector v ap\'f3s mudan\'e7as: \ldblquote ; \line 28 std::copy( v.beginO, v.endO, output ); \line 29 \line 30 try\{ \par
std: :vector< int >: :reverse_iterator p2; \par
Fig. 20.15 Demonstrando as fun\'e7\'f5es de manipula\'e7\'e3o de elementos do gabarito de classe vector da \line biblioteca padr\'e3o (parte 1 de 2). \par
CAP\'cdTULO 20 - A BIBLIOTECA PADR\'c3O DE GABARITOS (STL) 935 \par
31 v.at( 100 ) = 777; /1 acessa elemento fora do intervalo v\'e1lido \line 32 \line 33 catch ( std: :out_of_range e \line 34 cout \'ab \ldblquote\\nExce\'e7\'e3o: \ldblquote  \'ab e.what(); \line 35 \line 36 \line 37 v.erase( v.begin() ); \line 38 cout \'ab \ldblquote\\nConte\'fado do vector v ap\'f3s erase: \ldblquote ; \line 39 std: :copy( v.beginQ, v.endO, output ); \line 40 v.erase( v.beginO, v.end() ); \line 41 cout \'ab \ldblquote\\nAp\'f3s erase, o vector v \line 42 \'ab ( v.empty() ? \ldblquote est\'e1\rdblquote  : \ldblquote n\'e3o est\'e1\rdblquote  ) \'ab \ldblquote  vazio\rdblquote ; \line 43 \line 44 v.insert( v.beginQ, a, a + SIZE ); \line 45 cout \'ab \ldblquote\\nConte\'fado do vector v antes de clear: \ldblquote ; \line 46 std: :copy( v.beginO, v.endO, output ); \line 47 v.clearO; 1/ clear chama erase para esvaziar uma cole\'e7\'e3o \line 48 cout \'ab \ldblquote\\nAp\'f3s clear, o vector v \line 49 \'ab ( v.empty() ? \ldblquote est\'e1\rdblquote  : \ldblquote n\'e3o est\'e1\rdblquote  ) \'ab \ldblquote  vazio\rdblquote ; \line 48 \line 51 cout \'ab endl; \line 52 return 0; \line 53 \par
Fig. 20.15 Demonstrando as fun\'e7\'f5es de manipula\'e7\'e3o de elementos do gabarito de classe vector da biblioteca padr\'e3o (parte 2 de 2). \line A linha 17 \line std: :ostreamiterator< int > output( cout, \ldblquote  \ldblquote  \line declara um ostream iterator chamado output que pode ser usado para enviar para a sa\'edda via cout valores inteiros separados por espa\'e7os simples. Um ostream iterator \'e9 um mecanismo de sa\'edda seguro quanto ao tipo - que vai produzir somente valores do tipo int ou de um tipo compat\'edvel. O primeiro argumento para o construtor especifica o stream de sa\'edda e o segundo argumento \'e9 um string especificando caracteres separadores para os valores de sa\'edda - neste caso um caractere espa\'e7o. Usaremos o ostream iterator para enviar o conte\'fado do vector para a sa\'edda neste exemplo. \line A linha 19 \line std: :copy( v.beginO, v.endO, output ); \line usa o algoritmo copy da biblioteca padr\'e3o para enviar o conte\'fado de vector v para a sa\'edda padr\'e3o. O algoritmo copy copia cada elemento do cont\'eainer come\'e7ando com a posi\'e7\'e3o especificada pelo iterador em seu primeiro argumento e at\'e9 - mas n\'e3o incluindo - a posi\'e7\'e3o especificada pelo iterador em seu segundo argumento. O primeiro e segundo argumentos precisam satisfazer aos requisitos de iteradores de entrada - isto \'e9, eles devem ser iteradores atrav\'e9s dos quais valores podem ser lidos de um cont\'eainer. Al\'e9m disso, a aplica\'e7\'e3o de ++ ao primeiro iterador deve, em algum momento, fazer com que o primeiro iterador alcance o segundo argumento iterador no cont\'eainer. Os elementos s\'e3o copiados para a posi\'e7\'e3o especificada pelo iterador de sa\'edda (isto \'e9, um iterador atrav\'e9s do qual um \par
fr \par
\pard\par
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx6030\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx7790\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx8103\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx8608\pard\intbl O vector v cont\'e9m: 1 2 3 4 5 6 \cell\cell\cell\cell\row
\intbl Primeiro elemento de v: 1 \cell\cell\cell\cell\row
\intbl Ultimo elemento de v: 6 \cell\cell\cell\cell\row
\intbl Conte\'fado do vector v ap\'f3s mudan\'e7as: 7 \cell 22 2 10 4 \cell 5 \cell 6 \cell\row
\intbl Exce\'e7\'e3o: invalid vector<T> subscript \cell\cell\cell\cell\row
\intbl Conte\'fado do vector v ap\'f3s erase: 22 2 \cell 10 4 5 6 \cell\cell\cell\row
\intbl Ap\'f3s erase, o vector v est\'e1 vazio \cell\cell\cell\cell\row
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx7790\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx8103\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx8608\pard\intbl Conte\'fado do vector v antes de clear: 1 2 3 4 5 Ap\'f3s clear, o vector v est\'e1 vazio \cell 6 \cell 1 \cell\row
\pard\par
\pard\sb100\sa240 936 C++ COMO PROGRAMAR \line valor pode ser armazenado ou enviado para a sa\'edda) especificado como o \'faltimo argumento. Neste caso, o iterad( de sa\'edda \'e9 o ostream iterator output que est\'e1 vinvulado a cout, de modo que os elementos s\'e3o copiadc para a sa\'edda padr\'e3o. Para usar os algoritmos da biblioteca padr\'e3o, voc\'ea precisa incluir o arquivo de cabe\'e7alh <algorithm>. \line As linhas 21 e 22 usam as fun\'e7\'f5es front e back (dispon\'edveis para todos os cont\'eaineres seq\'fcenciais) par \line determinar o primeiro e o \'faltimo elementos do vector, respectivamente. \line Erro comum de programa\'e7\'e3o 20.3 \line O vector n\'e3o deve estar vazio; caso contr\'e1rio, os resultados das fim \'e7\'f5es front e back s\'e3o indefinido \line As linhas 24 e 25 \line v[ O 1 = 7; II atribui 7 ao primeiro elemento \line v.at( 2 ) = 10; // atribui 10 ao elemento na posi\'e7\'e3o 2 \line ilustram dois modos de usar subscritos para percorrer um vector (estes modos tamb\'e9m podem ser usados com o cont\'eaineres deque). A linha 24 usa o operador subscrito que \'e9 sobrecarregado para retornar ou uma refer\'eancia a valor na posi\'e7\'e3o especificada ou uma refer\'eancia constante \'e0quele valor, dependendo de se o cont\'eainer \'e9 constante oi n\'e3o. A fun\'e7\'e3o at executa a mesma opera\'e7\'e3o com um recurso adicional - verificar os limites. A fun\'e7\'e3o at primem verifica o valor fornecido como um argumento e determina se ele est\'e1 dentro dos limites do vector. Se n\'e3o estiver a fun\'e7\'e3o at dispara uma exce\'e7\'e3o out_of_bounds (como demostrado nas linhas 30 a 35). Alguns dos tipos d exce\'e7\'e3o da STL s\'e3o mostrados na Fig. 20.16 (os tipos de exce\'e7\'e3o s\'e3o comentados no cap\'edtulo 13, \ldblquote Tratamento d exce\'e7\'f5es\rdblquote ). \par
Fig. 20.16 Tipos de exce\'e7\'f5es da STL. \line A linha 26 \line v.insert( v.begin() + 1, 22 ); II insere 22 como segundo elemento \line usa uma das tr\'eas fun\'e7\'f5es insert que est\'e3o dispon\'edveis para todo cont\'eainer seq\'fcencia!. A declara\'e7\'e3o anterio insere o valor 22 antes do elemento na posi\'e7\'e3o especificada pelo iterador no primeiro argumento. No exemplo, iterador est\'e1 apontando para o segundo elemento do vector, ent\'e3o 22 \'e9 inserido como o segundo elemento e segundo elemento original torna-se o terceiro elemento do vector. As outras vers\'f5es de insert permitem inseri m\'faltiplas c\'f3pias do mesmo valor come\'e7ando por uma posi\'e7\'e3o particular no cont\'eainer ou inserir uma faixa de valore de um outro cont\'eainer (ou array come\'e7ando em uma posi\'e7\'e3o espec\'edfica no cont\'eainer original. \line As linhas 37 e 40 \line v.erase( v. begin() ); \line v.erase( v. begin, v.end() ); \par
\pard\par
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2069\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx8946\pard\intbl [Tipos de exce\'e7\'f5es da STL \cell Descri\'e7\'e3o \cell\row
\intbl out_of_range \cell Indica quando o subscrito est\'e1 tora do intervalo-por exemplo, quan do um subscrito inv\'e1lido \'e9 especificado para a fun\'e7\'e3o membro ai de vector. \cell\row
\intbl invalidargument \cell Indica que um argumento inv\'e1lido foi passado para uma fun\'e7\'e3o \cell\row
\intbl lengtherror \cell Indica uma tentativa de criar um cont\'eainer muito longo. string etc. \cell\row
\intbl badalloc \cell Indica que uma tentativa de alocar mem\'f3ria com new (ou com un alocador) falhou porque n\'e3o havia mem\'f3ria suficiente dispon\'edvel. \cell\row
\pard\par
\pard\sb100\sa240 CAP\'cdTULO 20 A BIBLIOTECA PADR\'c3O DE GABARITOS (STL) 937 \par
usam as duas fun\'e7\'f5es erase que est\'e3o dispon\'edveis em todos os cont\'eaineres de primeira classe. A linha 37 indica que o elemento na posi\'e7\'e3o especificada pelo argumento iterador deveria ser removida do cont\'ealner (neste exemplo o elemento no in\'edcio do vector). A linha 40 especifica que todos os elementos no intervalo come\'e7ando com a posi\'e7\'e3o do primeiro argumento at\'e9 - mas n\'e3o incluindo - a posi\'e7\'e3o do segundo argumento devem ser apagados do cont\'eainer. Neste exemplo, todos os elementos s\'e3o apagados do vector. A linha 42 usa a fun\'e7\'e3o empty (dispon\'edvel para todos os cont\'eaineres, incluindo os adaptadores) para confirmar que o vector est\'e1 vazio. \line Erro comum de programa\'e7\'e3o 20.4 \line Apagar um elemento que cont\'e9m um ponteiro para um objeto alocado dinamicamente n\'e3o deleta o objeto. \par
A linha 44 \par
v.insert( v. beginO, a, a + SIZE); \par
usa a vers\'e3o da fun\'e7\'e3o insert que usa o segundo e terceiro argumentos para especificar a posi\'e7\'e3o inicial e a posi\'e7\'e3o final de uma seq\'fc\'eancia de valores (possivelmente de outro cont\'eainer, mas neste caso do array integer a) que deve ser inserida no vector. Lembre-se de que a posi\'e7\'e3o final especifica a posi\'e7\'e3o na seq\'fc\'eancia ap\'f3s o \'faltimo elemento ter sido inserido; a c\'f3pia \'e9 executada at\'e9 - mas n\'e3o incluindo - esta posi\'e7\'e3o. \line Finalmente, a linha 47 \line v.clearo; II clear chama erase para esvaziar um cont\'eainer \par
usa a fun\'e7\'e3o clear (dispon\'edvel em todos os cont\'eaineres de primeira classe) para esvaziar o vector. Esta fun\'e7\'e3o chama a vers\'e3o de erase usada na linha 40, que \'e9 quem realmente executa a opera\'e7\'e3o. \line INota: h\'e1 outras fun\'e7\'f5es que s\'e3o comuns a todos os cont\'eaineres e comuns a todos os cont\'eaineres seq\'fcenciais que ainda n\'e3o ftram cobertas. Abordaremos a maior parte destas fun\'e7\'f5es nas pr\'f3ximas se\'e7\'f5es. Tamb\'e9m abordaremos muitas fun\'e7\'f5es que s\'e3o espec\'edficas para cada cont\'eainer.j \line 20.2.2 O cont\'eainer seq\'fcencial list \line O cont\'eainer seq\'fcencial list fornece uma implementa\'e7\'e3o eficiente para opera\'e7\'f5es de inser\'e7\'e3o e dele\'e7\'e3o em qualquer posi\'e7\'e3o no cont\'eainer. Se a maioria das inser\'e7\'f5es e dele\'e7\'f5es ocorrem nas extremidades do cont\'eainer, a estrutura de dados deque (Se\'e7\'e3o 20.2.3) fornece uma implementa\'e7\'e3o mais eficiente. A classe list \'e9 implementada como uma lista duplamente encadeada - isto \'e9, cada nodo em list cont\'e9m um ponteiro para o nodo anterior em list e um para o nodo seguinte em list. Isto habilita a classe list a suportar iteradores bidirecionais que permitem que o cont\'eainer seja percorrido de ambos os modos, para frente e para tr\'e1s. Qualquer algoritmo que requeira iteradores de entrada, sa\'edda, para frente e bidirecionais pode operar sobre uma list. Muitas das fun\'e7\'f5es membro manipulam os elementos do cont\'eainer como um conjunto ordenado de elementos. \line Al\'e9m das fun\'e7\'f5es membro de todos os cont\'eaineres da STL na fig. 20.2 e as fun\'e7\'f5es membro comuns de todos os cont\'eaineres seq\'fcenciais discutidas na Se\'e7\'e3o 20.5, a classe list fornece outras oito fun\'e7\'f5es membro - splice. pushfront, pop front, remove. unique, merge, reverse e sort. A Fig. 20.17 demonstra diversos recursos da classe list. Lembre-se de que muitas das fun\'e7\'f5es apresentadas nas Figs. 20.14 e 20.15 podem ser usadas com a classe list. O arquivo de cabe\'e7alho <list> deve ser inclu\'eddo para usar a classe list. \par
Fig. 20.17 Demonstrando o gabarito de classe list da biblioteca padr\'e3o (parte 1 de 3). \par
\pard\par
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx217\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx5512\pard\intbl 1 \cell // Fig. 20.17: fig2Ol7.cpp \cell\row
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx217\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2486\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx3135\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx5512\pard\intbl 2 \cell // Testando a classe \cell list \cell da Biblioteca Padr\'e3o \cell\row
\intbl 3 \cell #include <iostream> \cell\cell\cell\row
\intbl 4 \cell\cell\cell\cell\row
\intbl 5 \cell using std: :cout; \cell\cell\cell\row
\intbl 6 \cell using std::endl; \cell\cell\cell\row
\pard\par
\par
\pard\sb100\sa240 938 C++ COMO PROGRAMAR \line 7 \line 8 #include <list> \line 9 #include <algorithm> \line 10 \line 11 template < class T > \line 12 void printList( const std::list< T > &J.istRef ); \line 13 \line 14 int main() \line 15 \line 16 const jnt SIZE = 4; \line 17 int a[ SIZE ) = \{ 2, 6, 4, 8 \}; \line 18 std::list< int > values, otherValues; \line 19 \line 20 values.pushfront( 1 ); \line 21 values.pushfront( 2 ); \line 22 values.pushback( 4 ); \line 23 values.pushback( 3 ); \line 24 \line 25 cout \'ab \lquote values cont\'e9m: \ldblquote ; \line 26 printList( values ); \line 27 values.sortQ; \line 28 cout \'ab \ldblquote\\nvalues ap\'f3s sort cont\'e9m: \ldblquote ; \line 29 printList( values ); \line 30 \line 31 otherValues.insert( otherValues.beginO), a, a + SIZE ); \line 32 cout \'ab \ldblquote\\notherValues cont\'e9m: \ldblquote ; \line 33 printList( otherValues ); \line 34 values.splice( values.endO, otherValues ); \line 35 cout \'ab \ldblquote\\nAp\'f3s splice values cont\'e9m: \line 36 printList( values ); \line 37 \line 38 values.sortQ; \line 39 cout \'ab \ldblquote\\nvalues cont\'e9m: \line 40 printList( values ); \line 41 otherValues.insert( otherValues.beginO, a, a + SIZE ); \line 42 otherValues.sortO; \line 43 cout \'ab \ldblquote\\notherValues cont\'e9m: \ldblquote ; \line 44 printList( otherValues ); \line 45 values.merge( otherValues \line 46 cout \'ab \ldblquote\\nAp\'f3s merge:\\n values cont\'e9m: \line 47 printList( values ); \line 48 cout \'ab \ldblquote\\n otherValues cont\'e9m: \ldblquote ; \line 49 printList( otherValues ); \line 50 \line 51 va1ues.popfront \line 52 va1ues.popback II todos os cont\'eaineres seq\'fcenciais \line 53 cout \'ab \ldblquote\\nAp\'f3s pop_front e pop back values cont\'e9m:\\n\rdblquote ; \line 54 printList( values ); \line 55 \line 56 values.uniqueQ; \line 57 cout \'ab \ldblquote\\nAp\'f3s unique values cont\'e9m: \ldblquote ; \line 58 printList( values ); \line 59 \line 60 // o m\'e9todo swap est\'e1 dispon\'edvel em todos os cont\'eaineres \line 61 values.swap( otherValues ); \line 62 cout \'ab \ldblquote\\nAfter swap:\\n values cont\'e9m: \line 63 printList( values ); \line 64 cout \'ab \ldblquote\\n otherValues cont\'e9m: \line Fig. 20.17 Demonstrando o gabarito de classe list da biblioteca padr\'e3o (parte 2 de 3). \par
CAP\'cdTULO 20 - A BIBLIOTECA PADR\'c3O DE GABARITOS (STL) 939 \line 65 printList( otherValues ); \line 66 \line 67 values. assign( otherValues.beginO, otherValues. end() ); \line 68 cout \'ab \ldblquote\\nAp\'f3s assign values cont\'e9m: \ldblquote ; \line 69 printList( values ); \line 70 \line 71 values.merge( otherValues ); \line 72 cout \'ab \ldblquote\\nvalues cont\'e9m: \ldblquote ; \line 73 printList( values ); \line 74 values.remove( 4 ); \line 75 cout \'ab \ldblquote\\nAp\'f3s remove( 4 ) values cont\'e9m: \ldblquote ; \line 76 printList( values ); \line 77 cout \'ab endi; \line 78 return O; \line 79 \} \line 80 \line 81 template < class T > \line 82 void printList( const std: :list< T > &listRef \line 83 \line 84 if ( listRef.empty() \line 85 cout \'ab \ldblquote lista est\'e1 vazia\rquote ; \line 86 else \{ \line 87 std: :ostream_iterator< T > output( cout, \ldblquote  \ldblquote  \line 88 std::copy( 1istRef.begin, listRef.endQ, output ); \line 89 \} \line 90 \} \line values cont\'e9m: 2 1 4 3 \line values ap\'f3s sort cont\'e9m: 1 2 3 4 \line otherValues cont\'e9m: 2 6 4 8 \line Ap\'f3s splice values cont\'e9m: 1 2 3 4 2 6 4 8 \line values cont\'e9m: 1 2 2 3 4 4 6 8 \line otherValues cont\'e9m: 2 4 6 8 \line Ap\'f3s merge: \line valuescont\'e9m: 122234446688 \line otherValues cont\'e9m: lista est\'e1 vazia \line Ap\'f3s pop_front e pop_back values cont\'e9m: \line 2223444668 \line Ap\'f3s unique values cont\'e9m: 2 3 4 6 8 \line Ap\'f3s swap: \line values cont\'e9m: lista est\'e1 vazia \line otherValues cont\'e9m: 2 3 4 6 8 \line Ap\'f3s atribui\'e7\'e3o values cont\'e9m: 2 3 4 6 8 \line values cont\'e9m: 2 2 3 3 4 4 6 6 8 8 \line Ap\'f3s remove( 4 ) values cont\'e9m: 2 2 3 3 6 6 8 8 \line Fig. 20.17 Demonstrando o gabarito de classe list da biblioteca padr\'e3o (parte 3 de 3). \line A linha 18 \line std::list< int > values, otherValues; \line instancia dois objetos list capazes de armazenar inteiros. As linhas 20 e 21 usam a fun\'e7\'e3o push_front paa inserir inteiros no in\'edcio de values. A fun\'e7\'e3o push front \'e9 espec\'edfica para classes list e deque (n\'e3o para vector). As linhas 22 e 23 usam fun\'e7\'e3o push_back para inserir inteiros no final de values. Lembre-se de que a fun\'e7\'e3o push_back \'e9 comum a todos os cont\'eaineres seq\'fcenciais. \par
940 C++ COMO PROGRAMAR \line A linha 27 \line values.sortO; \line usa a fun\'e7\'e3o membro sort de list para organizar os elementos na list em ordem ascendente. [Nota: isto \'e9 diferente do sort nos algoritmos da STL.] H\'e1 uma segunda vers\'e3o da fun\'e7\'e3o sort que permite ao programador fornecer uma fun\'e7\'e3o predicado bin\'e1rio que recebe dois argumentos (valores na lista), executa uma compara\'e7\'e3o e retorna um valor bool indicando o resultado. Esta fun\'e7\'e3o determina a ordem na qual os elementos da list s\'e3o classificados. Esta vers\'e3o poderia ser particularmente \'fatil para uma list que armazena ponteiros em vez de valores. [Nota: demonstramos uma fun\'e7\'e3o predicado un\'e1ria na Fig. 20.28. Uma fun\'e7\'e3o predicado un\'e1ria recebe um \'fanico argumento, executa uma compara\'e7\'e3o usando aquele argumento e retorna um valor bool indicando o resultado. 1 \line A linha 34 \line values.splice( values.end() , otherValues ); \line usa a fun\'e7\'e3o splice de list para remover os elementos de otherValues e inseri-los em values antes da posi\'e7\'e3o do iterador especificado como o primeiro argumento. H\'e1 outras duas vers\'f5es desta fun\'e7\'e3o. A fun\'e7\'e3o splice com tr\'eas argumentos permite que um elemento seja removido do cont\'eainer especificado como segundo argumento a partir da posi\'e7\'e3o especificada pelo iterador no terceiro elemento. A fun\'e7\'e3o splice com quatro argumentos usa os dois \'faltimos argumentos para especificar uma faixa de posi\'e7\'f5es que deveriam ser removidas do cont\'eainer no segundo argumento e colocadas na posi\'e7\'e3o especificada no primeiro argumento. \line Ap\'f3s inserir mais elementos na list otherValues e classificar tanto values como otherValues, a \line linha 45 \line values.merge( otherValues ); \line usa a fun\'e7\'e3o membro merge de list para remover todos os elementos de otherValues e inseri-los em ordem classificada em values. Ambas as lists devem estar classificadas na mesma ordem antes que esta opera\'e7\'e3o seja executada. Uma segunda vers\'e3o de merge permite que o programador forne\'e7a uma fun\'e7\'e3o predicado que recebe dois argumentos (valores na lista) e retoma um valor bool. A fun\'e7\'e3o predicado especifica a ordem de classifica\'e7\'e3o usada por merge. \line A linha 51 usa a fun\'e7\'e3o pop front de list para remover o primeiro elemento da list. A linha 52 usa \line a fun\'e7\'e3o pop back (dispon\'edvel a todos os cont\'eaineres seq\'fcenciais) para remover o \'faltimo elemento da list. A linha 56 \line values.unique() \line usa a fun\'e7\'e3o unique de list para remover elementos duplicados da list. A list deve estar em ordem classificada (de modo que todos os duplicados estejam lado a lado) antes que esta opera\'e7\'e3o seja executada, para garantir que todos os duplicados sejam eliminados. Uma segunda vers\'e3o de unique permite que o programador forne\'e7a uma fun\'e7\'e3o predicado que recebe dois argumentos (valores no list) e retorna um valor bool. A fun\'e7\'e3o predicado especifica se dois elementos s\'e3o iguais. \line A linha 61 \line values. swap ( otherValues ); \line usa a fun\'e7\'e3o swap (dispon\'edvel para todos os cont\'eaineres) para trocar os conte\'fados de values com os conte\'fados de o therValue s. \line A linha 67 \line values.assign( otherVa1ues.begin, otherValues.end() ); \par
\pard\par
\pard\sb100\sa240 942 C++ COMO PROGRAMAR \line 10 \line 11 int main() \line 12 \line 13 std: :deque< double > values; \line 14 std::ostreamiterator< double > output( cout, \line 15 \line 16 values.pushfront( 2.2 ); \line 17 values.pushfront( 3.5 ); \line 18 values.pushback( 1.1 ); \line 19 \line 20 cout \'ab values cont\'e9m: \line 21 \line 22 for ( int i o; i < values.sjzeO; ++i \line 23 cout \'ab values[ i ) \'ab \line 24 \line 25 va1ues.pop_front \line 26 cout \'ab \\riAp\'f3s pop_front values cont\'e9m: \line 27 std::copy ( values.begmnO, values.endO, output ); \line 28 \line 29 values[ 1 ] = 5.4; \line 30 cout \'ab \lquote\\nAp\'f3s values[ 1 ) = 5.4 values cont\'e9m: \ldblquote ; \line 31 std::copy ( values.beginO), values.endO, output ); \line 32 cout \'ab endi; \line 33 return 0; \line 34 \} \line vaJ.ues cont\'e9m: 3.5 2.2 1.1 \line Ap\'f3s pop_front values cont\'e9m: 2.2 1.1 \line Ap\'f3s values[ 1 3 = 5.4 values cont\'e9m: 2.2 5.4 \line Fig. 20.18 Demonstrando o gabarito de classe deque da biblioteca padr\'e3o (parte 2 de 2). \line Alinha 13 \line std: :deque< double > values; \line instancia uma deque que pode armazenar valores double. As linhas 16 a 18 usam as fun\'e7\'f5es push_front e push back para inserir elementos no in\'edcio e no final da deque. respectivamente. Lembre-se de que push_back est\'e1 dRpon\'edvel a todos os cont\'eaineres seqilenciais, mas push_front est\'e1 dispon\'edvel somente para a classe list e a classe deque. \line A estrutura for na linha 22 \line for ( int i = 0; i < values.sizeQ; ++i \line cout \'ab values[ i 3 \'ab \line usa o operador subscrito para recuperar o valor em cada elemento do deque para saida. Note ouso da fun\'e7\'e3o size na condi\'e7\'e3o para assegurar que n\'e3o tentaremos acessar um elemento fora dos limites do deque. \line A linha 25 usa fun\'e7\'e3o pop_front para demonstrar a retirada do primeiro elemento do deque. Lembre-se \line de que pop front est\'e1 dispon\'edvel somente para classe list e a classe deque (n\'e3o para classe vector). \line A linha 29 \line values[ 1 3 = 5.4; \line usa o operador subscrito para criar um Ivalue. Isso permite que sejam atribu\'eddos valores diretamente a qualquer elemento do deque. \par
CAP\'cdTULO 20 - A BIBLIOTECA PADR\'c3O DE GABARITOS (STL) 943 \line 20.3 Cont\'eaineres associativos \line Os cont\'eaineres associativos da STL destinam-se a fornecer acesso direto para armazenar e recuperar elementos via chaves (freq\'fcentemente chamadas de chaves de pesquisa). Os quatro cont\'eaineres associativos s\'e3o multiset, set. multimap e xnap. Em cada cont\'eainer, as chaves s\'e3o mantidas em ordem classificada. herar atrav\'e9s de um cont\'eainer associativo percorre o mesmo em uma ordem classificada para aquele cont\'eainer. As classes multiset e set fornecem opera\'e7\'f5es para manipular conjuntos de valores nos quais os pr\'f3prios valores s\'e3o as chaves - isto \'e9. n\'e3o h\'e1 um valor separado associado a cada chave. A principal diferen\'e7a entre um multiset e um set \'e9 que um multiset permite chaves duplicadas e um set n\'e3o permite. As classes multimap e inap fornecem opera\'e7\'f5es para manipular valores associados com chaves (estes valores \'e0s vezes s\'e3o referidos como valores mapeados). A principal diferen\'e7a entre um multimap e um map \'e9 que um multimap permite chaves duplicadas com valores associados a serem armazenados e um map permite somente chaves \'fanicas com valores associados. Em adi\'e7\'e3o \'e0s fun\'e7\'f5es membro comuns a todos os cont\'eaineres apresentados na Fig. 20.2, todos os cont\'eaineres associativos tamb\'e9m suportam diversas outras fun\'e7\'f5es membro, incluindo find, lower bound, upper bound e count. Exemplos de cada cont\'eainer associativo e das fun\'e7\'f5es membro comuns aos cont\'eaineres associativos s\'e3o apresentados nas pr\'f3ximas subse\'e7\'f5es. \line 20.3.1 O cont\'eainer associativo multiset \line O cont\'eainer associativo muitiset oferece armazenagem e recupera\'e7\'e3o r\'e1pidas de chaves. Um multiset permite chaves duplicadas. A ordena\'e7\'e3o dos elementos \'e9 determinada por um objeto fun\'e7\'e3o de compara\'e7\'e3o. Por exemplo, em um mui tiset de inteiros, os elementos podem ser ordenados em ordem crescente ordenando-se as chaves com o objeto fun\'e7\'e3o de compara\'e7\'e3o iess< int>. O tipo de dado das chaves em todos os cont\'eaineres associativos deve suportar adequadamente a compara\'e7\'e3o, com base no objeto fun\'e7\'e3o de compara\'e7\'e3o especificado - as chaves ordenadas com less< int > devem suportar a compara\'e7\'e3o com operator<. Se as chaves usadas em cont\'eaineres associativos s\'e3o de tipos definidos pelo programador, estes tipos devem prover os operadores de compara\'e7\'e3o apropriados. Um multiset suporta iteradores bidirecionais (mas n\'e3o iteradores de acesso rand\'f4mico). \line Dica de desempenho 20.14 \line\bullet  Por raz\'f5es de desempenho, muitisets e sets s\'e3o tipicamente implementados como estruturas denominadas \'e1rvores de pesquisa bin\'e1ria vermelho-preto. Com esta representa\'e7\'e3o interna, a \'e1rvore de pesquisa \line bin\'e1ria tende a ser balanceada, minimizando desta forma os tempos m\'e9dios de pesquisa. \line A Fig. 20.19 demonstra o cont\'eainer associativo multiset para um multiset de inteiros ordenados em ordem \line crescente. O arquivo de cabe\'e7alho <set> deve ser inclu\'eddo para usar a classe multi set. Cont\'eaineres multiset \line e set oferecem as mesmas fun\'e7\'f5es membro. \line 1 1/ Fig. 20.19: fig2o_19.cpp \line 2 // Testando a classe zuultiset da Biblioteca Padr\'e3o \line 3 #include <iostreani> \line 4 \line 5 using std::cout; \line 6 using std::endl; \line 7 \line 8 #include <set> \line 9 #include <algorithm> \line 10 \line 11 int main() \line 12 \{ \line 13 const int SIZE 10; \line 14 int a[ SIZE ) = \{ 7, 22, 9, 1, 18, 30, 100, 22, 85, 13 \}; \line 15 typedef std::multiset< int, std::less< int > > ims; \line 16 ims intNultiset; II ims significa \ldblquote integer multiset\rdblquote  \line Fig. 20.19 Demonstrando o gabarito de classe multiset da biblioteca padr\'e3o (parte 1 de 2). \par
944 C++ COMO PROGRAMAR \line 17 std: :ostreamiterator< int > output( cout, \ldblquote  \ldblquote  \line 18 \line 19 cout \'ab \ldblquote Atualmente existem \ldblquote  \'ab intNultiset.count( 15 \line 20 \'ab \ldblquote  valores iguais a 15 no multiset\\n\rdblquote ; \line 21 intMultiset.insert( 15 ); \line 22 intNultiset.insert( 15 ); \line 23 cout \'ab Ap\'f3s inserts, existem \line 24 \'ab intMultiset.count( 15 \line 25 \'ab \ldblquote  valores iguais a 15 no multiset\\n\rdblquote ; \line 26 \line 27 ims: :const iterator result; \line 28 \line 29 result = intMultiset.find( 15 ); /1 find retorna iterador \line 30 \line 31 if ( result != intMultiset.end() ) II se iterador n\'e3o est\'e1 no fim \line 32 cout \'ab \ldblquote Encontrou o valor 15\\n\rdblquote ; II encontrou o valor 15 procurado \line 34 result = intMultiset.find( 20 ); \line 35 \line 36 if ( result == intMultiset.end() ) II ser\'e1 verdadeiro portanto \line 37 cout \'ab \ldblquote N\'e3o encontrou o valor 20\\n\rdblquote ; II n\'e3o encontrou 20 \line 38 \line 39 intMultiset.insert( a, a + SIZE ); II soma array a ao multiset \line 40 cout \'ab \ldblquote Ap\'f3s insert intMultiset cont\'e9m:\\n\rdblquote ; \line 41 std: :copy( intldultiset.beginQ, intMultiset.endO, output ); \line 42 \line 43 cout \'ab \ldblquote\\nLimite inferior de 22: \line 44 \'ab *( intMultiset.lowerbound( 22 ) ); \line 45 cout \'ab \ldblquote\\nLimite superior de 22: \line 46 \'ab ( intNultiset.upper_bound( 22 ) ); \line 47 \line 48 std::pair< ims::constiterator, ims::constiterator > p; \line 49 \line 50 p = intMultiset.equal range( 22 ); \line 51 cout \'ab \ldblquote\\nUsando equal_range de 22\rdblquote  \line 52 \'ab \ldblquote\\n Limite inferior: \'ab ( p.first \line 53 \'ab \ldblquote\\n Limite superior: \ldblquote  \'ab ( p.second ); \line 54 cout \'ab endl; \line 55 return 0; \line 56 \} \line Atualmente existem O valores iguais a 15 no multiset \line Ap\'f3s inserts, existem 2 valores iguais a 15 no multiset \line Encontrou o valor 15 \line N\'e3o encontrou o valor 20 \line Ap\'f3s insert intMultiset cont\'e9m: \line 1 7 9 13 15 15 18 22 22 30 85 100 \line Limite inferior de 22: 22 \line Limite superior de 22: 30 \line Usando equal_range de 22 \line Limite inferior: 22 \line Limite superior: 30 \line Fig. 20.19 Demonstrando o gabarito de classe multiset da biblioteca padr\'e3o (parte 2 de 2). \line As linhas 15 e 16 \line typedef std::multiset< int, std::less< int > > ims; \line ims intMultiset; II ims significa \ldblquote integer multiset\rdblquote  \par
CAP\'cdTULO 20 - A BIBLIOTECA PADR\'c3O DE GABARITOS (STL) 945 \line usam um typedef para criar um novo nome de tipo (alias) para um multiset de inteiros ordenados em ordem ascendente usando o objeto fun\'e7\'e3o less< int>. Este novo tipo \'e9 ent\'e3o usado para instanciar um objeto integer multiset, denominado intNultiset. \line Boa pr\'e1tica de programa\'e7\'e3o 20.1 \line ______ Usar typedefs para conseguir ler mais facilmente c\'f3digo de programas com tipos com nomes longos (tais como multisets). \line O comando de sa\'edda na linha 19 \line cout \'ab \ldblquote Atualmente existem \ldblquote  \'ab intMultiset.count( 15 \line\'ab \ldblquote  valores iguais a 15 no multiset\\n\rquote ; \line usa a fun\'e7\'e3o count (dispon\'edvel a todos os cont\'eaineres associativos) para contar o n\'famero de ocorr\'eancias do valor 15 presentemente no multiset. \line As linhas 21 e 22 \line intMultiset.insert( 15 ); \line intMultiset.insert( 15 ); \line usam uma das tr\'eas vers\'f5es da fun\'e7\'e3o insert para adicionar o valor 15 ao multiset duas vezes. Uma segunda vers\'e3o de insert recebe um iterador e um valor como argumentos e inicia a busca do ponto de inser\'e7\'e3o a partir da posi\'e7\'e3o especificada pelo iterador. Uma terceira vers\'e3o de insert recebe dois iteradores como argumentos que especificam um intervalo de valores de um outro cont\'eainer para adicionar ao multiset. \line A linha 29 \line result = intMultiset.find( 15 ); II f ind retorna iterador \line usa a fun\'e7\'e3o f ind dispon\'edvel a todos os cont\'eaineres associativos) para localizar o valor 15 no multiset. A fun\'e7\'e3o f ind retorna um iterator ou um const iterator apontando para a primeira posi\'e7\'e3o em que o valor \'e9 encontrado. Se o valor n\'e3o \'e9 encontrado, f ind retorna um iterator ou um const iterator igual ao valor retornado por uma chamada a end. \line A linha 39 \line intMultiset.insert( a, a + SIZE ); II soma array a ao xnultiset \line usa a fun\'e7\'e3o insert para inserir os elementos do array a no multiset. Na linha 41,o algoritmo copy copia os elementos do multiset para a sa\'edda padr\'e3o. Note que os elementos est\'e3o dispostos em ordem ascendente. \line As linhas 43 a 46 \line cout \'ab \ldblquote\\nLimite inferior de 22: \line\'ab ( intMultiset.lowerbound( 22 ) ); \line cout \'ab \ldblquote\\nLimite superior de 22: \line\'ab *( intMultiset.upper_bound( 22 ) ); \line usam as fun\'e7\'f5es lower bound e upper bound (dispon\'edveis a todos os cont\'eaineres associativos) para determinar a posi\'e7\'e3o da primeira ocorr\'eancia do valor 22 no multiset e a posi\'e7\'e3o do elemento ap\'f3s a \'faltima ocorr\'eancia do valor 22 no multiset. Ambas as fun\'e7\'f5es retornam iterators ou const_iterators apontando para posi\'e7\'e3o apropriada ou o iterator retornado por end. se o valor procurado n\'e3o est\'e1 no multiset. \line A linha 48 \line std: :pair< ims: :constiterator, ims: :const_iterator > p; \line instancia uma inst\'e2ncia da classe pair chamada p. Objetos da classe pair s\'e3o usados para associar pares de valores. Neste exemplo, os conte\'fados de um pair s\'e3o dois const iterators para nosso multiset baseado em inteiros. A finalidade de p \'e9 armazenar o valor retornado pela fun\'e7\'e3o equal range de multiset que \par
946 C++ COMO PROGRAMAR \line retorna um pair contendo os resultados das opera\'e7\'f5es lower bound e upper bound. O tipo pair cont\'e9m dois membros de dados public chamados first e second. \line A linha 50 \line p = intMultiset.equal_range( 22 ); \line usa a fun\'e7\'e3o equal range para determinar o lower bound e o upper bound de 22 no multiset. As linhas 52 e 53 usam p. first e p. second, respectivamente, para acessar o lower bound e o upper_bound. Derreferenciamos os iteradores para enviar para a sa\'edda os valores retornados por equal range. \line 20.3.2 O cont\'eainer associativo set \line O cont\'eainer associativo set \'e9 usado para armazenagem e recupera\'e7\'e3o r\'e1pidas com chaves \'fanicas. A implementa\'e7\'e3o de um set \'e9 id\'eantica \'e0quela de um multiset, exceto pelo fato de que um set precisa ter chaves \'fanicas. Portanto, se \'e9 feita uma tentativa de inserir uma chave duplicada em um set, a duplicata \'e9 ignorada como este \'e9 o comportamento matem\'e1tico objetivado por um set, n\'e3o o identificamos como um erro comum de programa\'e7\'e3o. Um set suporta iteradores bidirecionais (mas n\'e3o iteradores de acesso aleat\'f3rio). A Fig. 20.20 demonstra um set de doubles. O arquivo de cabe\'e7alho <set> deve ser inclu\'eddo para usar a classe set. \line 1 II Fig. 20.20: fig2O2O.cpp \line 2 // Testando a classe set da biblioteca padr\'e3o \line 3 #include <iostream> \line 4 \line 5 using std: :cout; \line 6 using std: :endl; \line 7 \line 8 #include <set> \line 9 #include <algorithm> \line 10 \line 11 int main() \line 12 \line 13 typedef std::set< double, std::less< double > > double_set; \line 14 const int SIZE = 5; \line 15 doublea[SIZE]=\{2.1, 4.2, 9.5,2.1, 3.7\}; \line 16 doubleset doubleSet( a, a + SIZE ); \line 17 std: :ostream iterator< double > output( cout, \lquote  \line 18 \line 19 cout \'ab \ldblquote doubleSet cont\'e9m: ; \line 20 std: :copy( doubleSet.begmnO, doubleSet.endO, output ); \line 21 \line 22 std: :pair< double set: :const_iterator, bool > p; \line 23 \line 24 p = doubleSet.insert( 13.8 ); II valor n\'e3o est\'e1 no conjunto \line 25 cout \'ab \lquote\\n\rquote  \'ab *( p.first \line 26 \'ab ( p.second ? \ldblquote  foi\rdblquote  : \ldblquote  n\'e3o foi\rquote  ) \'ab \ldblquote  inserido\rdblquote ; \line 27 cout \'ab \ldblquote\\ndoubleSet contem: \line 28 std: :copy( doubleSet.begmnO), doubleSet.endO, output ); \line 29 \line 30 p = doubleSet.insert( 9.5 ); II valor j\'e1 est\'e1 no conjunto \line 31 cout \'ab \lquote\\n\rquote  \'ab *( p.first \line 32 \'ab ( p.second ? \ldblquote  foi\rdblquote  : \ldblquote  n\'e3o foi\rdblquote  ) \'ab \ldblquote  inserido\rdblquote ; \line 33 cout \'ab \\ndoubleSet cont\'e9m: \ldblquote ; \line 34 std: :copy( doubleSet.beginO, doubleSet.endQ, output ); \line 35 \line Fig. 20.20 Demonstrando o gabarito de classe set da biblioteca padr\'e3o (parte 1 de 2). \par
CAP\'cdTULO 20 - A BIBLIOTECA PADR\'c3O DE GABARITOS (STL) 947 \par
36 \line 37 \line 38 \par
cout \'ab endi; return O; \par
Fig. 20.20 Demonstrando o gabarito de classe set da biblioteca padr\'e3o (parte 2 de 2). \line A linha 13 \line typedef std: :set< double, std: :less< double > > double_set; \line usa typedef para criar um novo nome de tipo (alias) para um conjunto de valores double ordenados em ordem ascendente, usando a fun\'e7\'e3o objeto less< double >. \line A linha 16 \line doubleset doubleSet( a, a + SIZE ); \line usa o novo tipo double set para instanciar o objeto doubleSet. A chamada para o construtor recebe os elementos no array a entre a e a + SIZE (isto \'e9, o array inteiro) e os insere dentro do set. A linha 20 usa o algoritmo copy para enviar o conte\'fado do set para a sa\'edda. Observe que o valor 2.1 - que aparece duas vezes no array a somente aparece uma vez em doubleSet. Isto porque o cont\'eainer set n\'e3o permite duplicatas. \line A linha 22 \line std: :pair< double_set: :const_iterator, bool > p; \line define um pair consistindo em um const iterator para um double set e um valor bool. Este objeto armazena o resultado de uma chamada para a fun\'e7\'e3o insert de set. \line A linha 24 \line p = doubleSet.insert( 13.8 ); // valor n\'e3o est\'e1 no conjunto \line usa a fun\'e7\'e3o insert para inserir o valor 13 . 8 no set. O pair retornado, p, cont\'e9m um iterador p. first apontando para o valor 13. 8 no set e um valor bool que \'e9 true se o valor foi inserido e false se o valor n\'e3o foi inserido (porque j\'e1 estava no set). \line 20.3.3 O cont\'eainer associativo multimap \line O cont\'eainer associativo multimap \'e9 usado para armazenagem e recupera\'e7\'e3o r\'e1pidas de chaves e valores associados (freq\'fcentemente chamados de pares chave/valor). Muitos dos m\'e9todos usados com multisets e sets s\'e3o usados tamb\'e9m com multimaps e maps. Os elementos de multimaps e maps s\'e3o pairs de chaves e valores em vez de valores individuais. Quando se insere em um multimap ou map. um objeto pair, que cont\'e9m a chave e o valor, \'e9 usado. A ordena\'e7\'e3o das chaves \'e9 determinada por um objeto fun\'e7\'e3o comparadora. Por exemplo, em um multimap que usa inteiros como o tipo de chave, as chaves podem ser classificadas em ordem ascendente ordenando as chaves com o objeto fun\'e7\'e3o comparadora less< int >. Chaves duplicadas s\'e3o permitidas em um multimap. de modo que valores m\'faltiplos podem ser associados com uma chave \'fanica. Isto \'e9 chamado freq\'fcentemente de um relacionamento um para muitos. Por exemplo, em um sistema de processamento de transa\'e7\'f5es por cart\'e3o de cr\'e9dito, uma conta de cart\'e3o de cr\'e9dito pode ter muitas transa\'e7\'f5es associadas; em uma universidade, um estudante pode fazer v\'e1rios cursos e um professor pode ensinar muitos estudantes; no ex\'e9rcito, um posto \par
\pard\par
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1081\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2162\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2703\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx3244\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx3785\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4326\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4975\pard\intbl doubleSet \cell cont\'e9m: \cell 2.1 \cell 3.7 \cell 4.2 \cell 9.5 \cell\cell\row
\intbl 13.8 foi \cell inserido \cell\cell\cell\cell\cell\cell\row
\intbl doubleSet \cell cont\'e9m: \cell 2.1 \cell 3.7 \cell 4.2 \cell 9.5 \cell 13.8 \cell\row
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1081\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2703\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx3244\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx3785\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4326\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4975\pard\intbl 9.5 n\'e3o f \cell oi inserido \cell\cell\cell\cell\cell\row
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1081\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2162\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2703\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx3244\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx3785\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4326\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4975\pard\intbl doubleSet \cell cont\'e9m: \cell 2.1 \cell 3.7 \cell 4.2 \cell 9.5 \cell 13.8 \cell\row
\pard\par
\pard\sb100\sa240 948 C++ COMO PROGRAMAR \line (como \ldblquote soldado raso\rdblquote ) tem muitas pessoas. Um multimap suporta iteradores bidirecionais (mas n\'e3o iteradores de acesso aleat\'f3rio). Tal como com multisets e sets, multimaps s\'e3o implementados t\'edpicamente como uma \'e1rvore de busca bin\'e1ria vermelho-preta na qual os nodos da \'e1rvore s\'e3o pairs chave/valor. A Fig. 20.21 demonstra o cont\'eainer associativo multimap. O arquivo de cabe\'e7alho map> deve ser inclu\'eddo para usar a classe multimap. \line Dica de desempenho 20.15 \line _____ Um multimap \'e9 implementado de modo a localizar eficientemente todos os pares de valores com uma determinada chave. \line A linha 12 \line typedef std::multimap< int, double, std::less< int > > mmid; \line usa typedef para definir um alias para um tipo multimap onde o tipo de chave \'e9 int. o tipo de um valor associado \'e9 double e os elementos s\'e3o ordenados em ordem ascendente. A linha 13 usa o novo tipo para instanciar um multimap denominado pairs. \line 1 II Fig. 20.21: fig20_21.cpp \line 2 II Testando a classe multimap da Biblioteca Padr\'e3o \line 3 #include <iostreaxn> \line 4 \line 5 using std::cout; \line 6 using std::endl; \line 7 \line 8 #include <map> \line 9 \line 10 int main() \line 11 \{ \line 12 typedef std::multimap< int, double, std::less< int > > mmid; \line 13 mmid pairs; \line 14 \line 15 cout \'ab \lquote Atualmente existem \ldblquote  \'ab pairs.count( 15 \line 16 \'ab \lquote  pares com a chave 15 no multimap\\n\rquote ; \line 17 pairs.insert( mmmd: :value type( 15, 2.7 ) ); \line 18 pairs.insert( mmid::valuetype( 15, 99.3 ) ); \line 19 cout \'ab \ldblquote Ap\'f3s inserts, existem \line 20 \'ab pairs.count( 15 \line 21 \'ab \ldblquote  pares com a chave 15\\n\rquote ;p \line 22 pairs.insert( mmid: :value type( 30, 111.11 ) ); \line 23 pairs.insert( mmid: :valuetype( 10, 22.22 \line 24 pairs.insert( mmid: :value type( 25, 33.333 ) ); \line 25 pairs.insert( mmid: :valuetype( 20, 9.345 ) ); \line 26 pairs.insert( mmid::valuetype( 5, 77.54 ) ); \line 27 cout \'ab O multimap pairs cont\'e9m:\\nChave\\tValor\\n\rdblquote ; \line 28 \line 29 for ( mmid::const_iterator iter = pairs.begmn \line 30 iter != pairs.end ++iter \line 31 cout \'ab iter->first \'ab \lquote\\t\rquote  \line 32 \'ab iter->second \'ab \lquote\\n\rquote ; \line 31 \line 34 cout \'ab endl; \line 35 return 0; \line 36 \line Fig. 20.21 Demonstrando o gabarito de classe multimap da biblioteca padr\'e3o (parte 1 de 2). \par
CAP\'cdTULO 20 - A BIBLIOTECA PADR\'c3O DE GABARITOS (STL) 949 \par
Fig. 20.21 Demonstrando o gabarito de classe multimap da biblioteca padr\'e3o (parte 2 de 2). \line As linhas 15 e 16 \line cout \'ab \ldblquote Atualmente existem \ldblquote  \'ab pairs.count( 15 \line\'ab \ldblquote  pares com a chave 15 no multimap\\n\rdblquote ; \line usam a fun\'e7\'e3o count para determinar o n\'famero de pares chave/valor com uma chave igual a 15. \line A linha 17 \line pairs.insert( mmid::valuetype( 15, 2.7 ) ); \line usa a fun\'e7\'e3o insert para adicionar um novo par chave/valor ao multimap. A express\'e3o mid: : value type 15, 2.7 ) cria um objeto pair no qual first \'e9 a chave (15 ) do tipo int e second \'e9 o valor (2.7) do tipo double. O tipo mmid: : value type \'e9 definido na linha 12 como parte do typedef para o multimap. \line A estrutura for na linha 29 envia para a sa\'edda o conte\'fado do multimap, incluindo tanto as chaves como os \line valores. As linhas 31 e 32 \line cout \'ab iter->first \'ab \lquote\\t\rquote  \line\'ab iter->second \'ab \lquote\\n; \line usam o const_iterator denominado iter para acessar os membros do par em cada elemento do multimap. Note na sa\'edda que as chaves est\'e3o em ordem ascendente. \line 20.3.4 O cont\'eainer associativo map \line O cont\'eainer associativo map \'e9 usado para armazenagem e recupera\'e7\'e3o r\'e1pidas de chaves \'e1nicas e valores associados. Chaves duplicadas n\'e3o s\'e3o permitidas em um map. de modo que somente um \'fanico valor pode ser associado a cada chave. Isto \'e9 chamado de mapeamento um a um. Por exemplo, uma empresa que usa n\'fameros \'fanicos para identificar seus empregados tais como 100, 200 e 300 poderiam ter um map que associa o n\'famero dos empregados com seus ramais 4321, 4115 e 5217, respectivamente. Com um map voc\'ea especifica a chave e obt\'e9m de volta os dados associados rapidamente. Um map \'e9 normalmente chamado de array associativo. Fornecer a chave em um operador de subscrito de map [ ], permite localizar o valor associado com aquela chave no map. Inser\'e7\'f5es e retiradas podem ser feitas em qualquer lugar em um map. \line A Fig. 20.22 demonstra o cont\'eainer associativo map. A Fig. 20.22 usa as mesmas caracter\'edsticas que a Fig. \line 20.21, exceto pelo operador subscrito, O arquivo de cabe\'e7alho <map> precisa ser inclu\'eddo para usar a classe map. As linhas 31 e 32 \line pairs[ 25 ) = 9999.99; II muda valor existente para 25 \line pairs[ 40 3 = 8765.43; II insere novo valor para 40 \par
\pard\par
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4537\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx5942\pard\intbl Atualmente existem O pares com a chave 15  Ap\'f3s inserts, existem 2 pares com a chave  O multimap pairs cont\'e9m:  Chave Valor \cell no multimap  15 \cell\row
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx3683\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4537\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx5942\pard\intbl 5 77.54 \cell\cell\cell\row
\intbl 10 22.22 \cell\cell\cell\row
\intbl 15 2.7 \cell\cell\cell\row
\intbl 15 99.3 \cell\cell\cell\row
\intbl 20 9.345 \cell\cell\cell\row
\intbl 25 33.333 \cell\cell\cell\row
\intbl 30 111.11 \cell\cell\cell\row
\pard\par
\pard\sb100\sa240 950 C++ COMO PROGRAMAR \par
usam o operador de subscrito da classe map. Quando o subscrito \'e9 uma chave que j\'e1 est\'e1 no map. o operador retor uma refer\'eancia ao valor associado. Quando o subscrito \'e9 uma chave que n\'e3o est\'e1 no map. o operador insere a cha no map e retorna uma refer\'eancia que pode ser usada para associar um valor \'e0quela chave. A linha 31 substitui o vai correspondente \'e0 chave 25 (anteriormente 33 . 333, como especificado na linha 19) por um novo valor de 9999. 9 A linha 32 insere um novo par chave/valor (denominado criar u,na associa\'e7\'e3o) no map. \par
1 II Fig. 20.22: fig2022.cpp \line 2 // Testando a classe map da biblioteca padr\'e3o \line 3 #include <iostreaxn> \line 4 \line 5 using std::cout; \line 6 using std::endl; \line 7 \line 8 #include <map> \line 9 \line int main() \line typedef std: :map< int, double, std: :less< int > > mid; mid pairs; \line 15, 2.7) ); \line 30, 111.11 ) ); \line 5, 1010.1 ) ); \line 10, 22.22 ) ); \line 25, 33.333 ) ); \line 5, 77.54 ) ); /20, 9.345 ) ); \line - 15, 99.3 ) ); // \line cout \'ab \ldblquote pairs cont\'e9m:\\nChave\\tValor\\n\rdblquote ; \par
pairs . insert pairs . insert pairs . insert pairs . insert pairs . insert pairs . insert pairs . insert \par
mid: :valuetype( mid: :valuetype( mid: :valuetype( mid: :valuetype( mid: : value type mid: :valuetype( mid: :valuetype( mid: :value type( \par
pairs . insert \par
10 \line 11 \line 12 \line 13 \line 14 \line 15 \line 16 \line 17 \line 18 \line 19 \line 20 \line 21 \line 22 \line 23 \line 24 \line 25 \line 26 \line 27 \line 28 \line 29 \line 30 \line 31 \line 32 \line 33 \line 34 \line 35 \line 36 \line 37 \line 38 \line 39 \line 40 \line 41 \line 42 \par
duplicata ignorada duplicata ignorada \par
mid: :const_iterator iter; \line for ( iter = pairs.begin iter != pairs.endQ; ++iter cout \'ab iter->first \'ab \lquote\\t\rquote  \line\'ab iter->second \'ab \lquote\\n\rquote ; \line pairs[ 25 ) = 9999.99; II muda valor existente para 25 \line pairs[ 40 ] = 8765.43; II insere novo valor para 40 \line cout \'ab \ldblquote\\nAp\'f3s opera\'e7\'f5es com subscritos, pairs cont\'e9m:\rdblquote  \line\'ab \ldblquote\\nChave\\tValor\\n\rdblquote ; \line for ( iter pairs.begin iter != pairs.end ++iter cout \'ab iter->first \'ab \lquote\\t\rquote  \line\'ab iter->second \'ab \lquote\\n\rquote ; \line cout \'ab endl; \line return 0; \par
pairs \line Chave \line 5 \line 10 \line 15 \line 20 \line 25 \line 30 \par
cont\'e9m: \line Valor \line 1010.1 \line 22.22 \line 2.7 \line 9.345 \line 33.333 \line 111.11 \par
Fig. 20.22 Demonstrando o gabarito de classe map da biblioteca padr\'e3o (parte 1 de 2). \par
A STL fornece tr\'eas dos chamados adaptadores de cont\'eaineres - stack. queue e priority queue. Adaptadores n\'e3o s\'e3o cont\'eaineres de primeira classe porque n\'e3o implementam verdadeiramente a estrutura de dados na qual elementos podem ser armazenados e tamb\'e9m porque n\'e3o suportam iteradores. O beneficio de uma classe de adaptador \'e9 que o programador pode escolher uma estrutura de dados subjacente apropriada. Todas as tr\'eas classes de adaptadores fornecem fun\'e7\'f5es membro push e pop que implementam o m\'e9todo adequado para inserir um elemento em cada estrutura de dados do adaptador e o m\'e9todo adequado para retirar um elemento de cada estrutura de dados. As conhecida subse\'e7\'f5es seguintes fornecem exemplos das classes de adaptadores. \line 20.4.1 O adaptador stack \line A classe stack fornece funcionalidade que permite inser\'e7\'f5es e retiradas em uma mesma extremidade da estrutura de dados subjacente (comumente conhecida como uma estrutura de dados \'faltimo a entrar, primeiro a sair - LIFO). Um stack pode ser implementado com qualquer um dos cont\'eaineres seq\'fcenciais: vector. list e deque. Este exemplo cria tr\'eas stacks de inteiros usando cada um dos cont\'eaineres seq\'fcenciais da Biblioteca Padr\'e3o como a estrutura de dados subjacente para representar o stack. Por default, um stack \'e9 implementado com um deque. As opera\'e7\'f5es do stack s\'e3o: push, para inserir um elemento no topo do stack (implementado pela chamada \'e0 fun\'e7\'e3o push back do cont\'eainer subjacente); pop. para remover o elemento do topo do stack (implementado pela chamada \'e0 fun\'e7\'e3o pop back do cont\'eainer subjacente); top. para obter uma refer\'eancia ao elemento do topo do stack (implementada pela chamada \'e0 fun\'e7\'e3o back do cont\'eainer subjacente); empty. para determinar se o stack est\'e1 vazio (implementado pela chamada \'e0 fun\'e7\'e3o empty do cont\'eainer subjacente); e size para obter o n\'famero de elementos no stack (implementado pela chamada \'e0 fun\'e7\'e3o size do cont\'eainer subjacente). \line\ul II)ica \ulnone de desempenho 20.16 \line Cada uma das opera\'e7\'f5es comuns de um stack \'e9 implementada como uma fun\'e7\'e3o mime que chama a f\'e0n\'e7\'e3o apropriada do cont\'eainer subjacente. Isto evita o overhead de uma segunda chamada de fun\'e7\'e3o. \line Dica de desempenho 20.17 \line Para melhor desempenho, use as classes deque ou vector como o cont\'eainer subjacente para um stack. \line A Fig. 20.23 demonstra o adaptador de classe stack. O arquivo de cabe\'e7alho <stack> deve ser inclu\'eddo para usar a classe stack. \line 1 II Fig. 20.23: fig2023.cpp \line 2 // Testando a classe stack da biblioteca padr\'e3o \line 3 #include <iostream> \par
lor \par
CAP\'cdTULO 20- A BIBLIOTECA PADR\'c3O DE GABARITOS (STL) 951 \par
Ap\'f3s opera\'e7\'f5es com subscritos, pairs cont\'e9m: \line Chave Valor \line 5 1010.1 \line 10 22.22 \line 15 2.7 \par
20 \line 25 \line 30 \line 40 \par
9.345 \line 9999. 99 \line 111.11 \line 8765.43 \par
Fig. 20.22 Demonstrando o gabarito de classe map da biblioteca padr\'e3o (parte 2 de 2). \par
20.4 Adaptadores de cont\'eaineres \par
Fig. 20.23 Demonstrando a classe adaptadora stack da biblioteca padr\'e3o (parte 1 de 2). \par
952 C++ COMO PROGRAMAR \line 4 \line 5 using std::cout; \line 6 using std::endl; \line 7 \line 8 #include <stack> \line 9 #include <vector> \line 10 #include <list> \line 11 \line 12 template< class T > \line 13 void popElements ( T &s ); \line 14 \line 15 int main() \line 16 \line 17 std::stack< int > intDequeStack; // pilha baseada em deque \line 18 std::stack< int, std::vector< int > > intVectorStack; \line 19 std::stack< int, std::list< int > > intListStack; \line 20 \line 21 for ( int i 0; i < 10; ++i \line 22 intDequeStack.push( i ); \line 23 intVectorStack.push( i ); \line 24 intListStack.push( i ); \line 25 \} \line 26 \line 27 cout \'ab \lquote Retirando de intDequeStack: \line 28 popElements( mntDequeStack ); \line 29 cout \'ab \ldblquote\\nRetirando de intVectorStack: \ldblquote ; \line 30 popElements ( intVectorStack ); \line 31 cout \'ab \ldblquote\\nRetirando de intListStack: \ldblquote ; \line 32 popElements ( intListStack ); \line 33 \line 34 cout \'ab endi; \line 35 return 0; \line 36 \line 37 \line 38 template< class T > \line 39 void popElements( T &s \line 40 \{ \line 41 while ( !s.empty() ) \{ \line 42 cout \'ab s.top() \'ab \lquote  \line 43 s.popO); \line 44 \} \line 45 \} \line Retirando de intDequeStack: 9 8 7 6 5 4 3 2 1 O \line Retirando de intVectorStack: 9 8 7 6 5 4 3 2 1 O \line Retirando de intListStack: 9 8 7 6 5 4 3 2 1 O \line Fig. 20.23 Demonstrando a classe adaptadora stack da biblioteca padr\'e3o (parte 2 de 2). \line As linhas 17 a 19 \line std::stack< int > intDequeStack; // pilha baseada em deque std::stack< int, std::vector< int > > mntVectorStack; \line std::stack< int, std::list< int > > intListStack; \line instanciam tr\'eas s tacks de inteiros. A linha 17 especifica um stack de inteiros que usa o cont\'eainer default deque como sua estrutura de dados subjacente. A linha 18 especifica um stack de inteiros que usa um vector de \par
1 \line CAP\'cdTULO 20 - A BIBLIOTECA PADR\'c3O DE GABARITOS (STL) 953 \line inteiros como sua estrutura subjacente de dados. A linha 19 especifica um stack de inteiros que usa uma list de inteiros como sua estrutura subjacente de dados. \line As linhas 22 a 24 usam cada uma a fun\'e7\'e3o push (dispon\'edvel em toda classe de adaptador) para colocar um inteiro no topo de cada stack. \line A fun\'e7\'e3o popElements na linha 38 retira os elementos de cada stack. A linha 42 usa a fun\'e7\'e3o top de stack para recuperar o elemento no topo do stack como resultado. A fun\'e7\'e3o top n\'e3o remove o elemento do topo. A linha 43 usa a fun\'e7\'e3o pop (dispon\'edvel em cada adaptador de classe) para remover o elemento no topo do stack. A fun\'e7\'e3o pop n\'e3o retorna nenhum valor. \line 20.4.2 O adaptador queue \line deque A classe queue possibilita inser\'e7\'f5es no fim da estrutura de dados subjacente e retiradas no in\'edcio da estrutura de dados subjacente (comumente conhecida como uma estrutura de dados primeiro a entrar primeiro a sair - FIFO). Uma queue pode ser implementada com as estruturas de dados list e deque da STL. Por default, uma queue \'e9 implementada com um deque. As opera\'e7\'f5es comuns de queue s\'e3o: push para inserir um elemento no fim da queue (implementada pela chamada \'e0 fun\'e7\'e3o push back do cont\'eainer subjacente); pop para remover o elemento do in\'edcio da queue (implementada pela chamada \'e0 fun\'e7\'e3o pop_front do cont\'eainer subjacente); front para obter uma refer\'eancia ao primero elemento na queue (implementada pela chamada \'e0 fun\'e7\'e3o front do cont\'eainer subjacente): back para obter uma refer\'eancia ao \'faltimo elemento na queue (implementada pela chamada \'e0 fun\'e7\'e3o back do cont\'eainer subjacente); empty para determinar se a queue est\'e1 vazia (implementada pela chamada \'e0 fun\'e7\'e3o empty do cont\'eainer subjacente); e size para obter o n\'famero de elementos na queue (implementada pela chamada \'e0 fun\'e7\'e3o size do cont\'eainer subjacente). \line\ul IDica de desempenho 20.18 \ulnone\line _____ Cada uma das opera\'e7\'f5es comuns de uma queue \'e9 implementada como uma fun\'e7\'e3o mime que chama a fun\'e7\'e3o apropriada do cont\'eainer subjacente. Isto evita o overhead de uma chamada de uma segunda fun\'e7\'e3o. \line\ul Dica de desempenho 20.19 \ulnone\line t Para melhor desempenho, use a classe deque como o cont\'eainer subjacente para uma queue. \line A Fig. 20.24 demonstra a classe adaptador ql.leue. O arquivo de cabe\'e7alho <queue> deve ser inclu\'eddo para usar uma queue. \line 1 II Fig. 20.24: fig20_24.cpp \line ______________ 2 // Testando o gabarito de classe adaptadora queue da Biblioteca Padr\'e3o \line 3 #include <iostream> \line 4 \line 5 using std::cout; \line 6 using std: :endl; \line ___________________ 7 \line de 2). 8 #include <queue> \line 9 \line 10 int main() \line 11 \{ \line 12 std::queue< double > values; \line deque 13 \line 14 vaiues.push( 3.2 ); \line 15 vaiues.push( 9.8 ); \line 16 values.push( 5.4 ); \line t\'eainer default deque 17 \line usa um vector de \par
Fig. 20.24 Demonstrando os gabaritos de classe adaptadora queue da biblioteca padr\'e3o (parte 1 de 2). \par
954 C++ COMO PROGRAMAR \line 18 cout \'ab \ldblquote Retirando de values: \ldblquote ; \line 19 \line 20 while ( !values.empty() \line 21 cout \'ab values.front() \'ab \lquote ; // n\'e3o remove \line 22 values.popO; // remove o elemento \line 23 \line 24 \line 25 cout \'ab endl; \line 26 return 0; \line 27 \line Retirando de values: 3.2 9.8 5.4 \line Fig. 20.24 Demonstrando os gabaritos de classe adaptadora queue da biblioteca padr\'e3o (parte 2 de 2). \line A linha 12 \line std: :pieue< double > values; \line instancia uma queue que armazena valores double. As linhas 14 a 16 usam fun\'e7\'e3o push para adicionar elementos \'e0 queue. A estrutura while na linha 20 usa a fun\'e7\'e3o empty (dispon\'edvel em todos os cont\'eaineres) para determinar se a queue est\'e1 vazia. \line Enquanto h\'e1 mais elementos na queue, a linha 21 usa a fun\'e7\'e3o front de queue para ler (mas n\'e3o remover) o primeiro elemento da queue para enviar para a sa\'edda. A linha 22 remove o primeiro elemento da queue com a fun\'e7\'e3o pop (dispon\'edvel em todas as classes de adaptadores). \line 20.4.3 O adaptador priority_queue \line A classe priority queue fornece funcionalidade que permite inser\'e7\'f5es em ordem classificada na estrutura de dados subjacente, bem como retiradas do in\'edcio da estrutura de dados subjacente. Uma priority_queue pode ser implementada com estruturas de dados vector e deque. Por default, uma priority ql.leue \'e9 implementada com um vector como a estrutura de dados. Ao se adicionar elementos a uma priority queue. os elementos s\'e3o inseridos em ordem de prioridade, de tal modo que o elemento de mais alta prioridade (isto \'e9, o valor maior) ser\'e1 o primeiro elemento retirado da priority queue. Isto normalmente \'e9 realizado usando-se uma t\'e9cnica de classifica\'e7\'e3o denominada heapsort, que sempre mant\'e9m o maior valor (isto \'e9, a mais alta prioridade) na frente da estrutura de dados - tal estrutura de dados \'e9 chamada de heap. A compara\'e7\'e3o de elementos \'e9 executada com o objeto fun\'e7\'e3o de compara\'e7\'e3o less< T > por default, mas o programador pode fornecer um comparador diferente. \line As opera\'e7\'f5es comuns de priority queue s\'e3o: push para inserir um elemento na posi\'e7\'e3o apropriada com base na ordem de prioridade da priority_queue (implementada pela chamada \'e0 fun\'e7\'e3o push_back do cont\'eainer subjacente e ent\'e3o pela reordena\'e7\'e3o dos elementos usando heapsort): pop para remover o elemento de mais alta prioridade da priority queue (implementada pela chamada \'e0 fun\'e7\'e3o pop back do cont\'eainer subjacente ap\'f3s remover o elemento do topo do heap): top, para obter uma refer\'eancia ao elemento no topo da priorityqueue (implementada pela chamada \'e0 fun\'e7\'e3o front do cont\'eainer subjacente); empty para determinar se a priorityqueue est\'e1 vazia (implementada pela chamada \'e0 fun\'e7\'e3o empty do cont\'eainer subjacente); e size para obter o n\'famero de elementos na priori ty queue (implementada pela chamada \'e0 fun\'e7\'e3o si ze do cont\'eainer subjacente). \line\ul 1 \ulnone Dica de desempenho 20.20 \line _____ Cada uma das opera\'e7\'f5es comuns de uma priority queue \'e9 implementada como uma fun\'e7\'e3o inline \line que chama afun\'e7\'e3o apropriada do cont\'eainer subjacente. Isto evita o overhead de uma segunda fun\'e7\'e3o. \line Dica de desempenho 20.21 \line f Para melhor desempenho, use a classe vector como cont\'eainer subjacente para uma priorityqueue. \par
CAP\'cdTULO 20- A BIBLIOTECA PADR\'c3O DE GABARITOS (STL) 955 \line A Fig 20.25 demonstra a classe de adaptador priority queue. O arquivo de cabe\'e7alho <queue> deve \line ser inclu\'eddo para usar a classe priorityqueue. \line 1 // Fig. 20.25: fig2025.cpp \line 2 // Testando a classe priority_queue da biblioteca padr\'e3o \line 3 #include <iostream> \line 4 \line 5 using std: :cout; \line 6 using std: :endl; \line 7 \line 8 #include <queue> \line 9 \line 10 int main() \line 11 \{ \line 12 std: :priority_queue< double > priorities; \line 13 \line 14 priorities.push( 3.2 ); \line 15 priorities.push( 9.8 ); \line 16 priorities.push( 5.4 ); \line 17 \line 18 cout \'ab \ldblquote Retirando de priorities: \ldblquote ; \line 19 \line 20 while ( !priorities.emptyO) ) \{ \line 21 cout \'ab priorities.top() \'ab \line 22 priorities.popO); \line 23 \line 24 \line 25 cout \'ab endl; \line 26 return 0; \line 27 \} \line [Retirando de priorities: 9.8 5.4 3.2 \line Fig. 20.25 Demonstrando a classe adaptadora priori ty queue da biblioteca padr\'e3o. \line A linha 12 \line std: :priority_queue< double > priorities; \line instancia uma priority queue que armazena valores double e usa um vector como a estrutura de dados subjacente. As linhas 14 a 16 usam a fun\'e7\'e3o push para adicionar elementos \'e0 priority queue. A estrutura while na linha 20 usa a fun\'e7\'e3o exnpty (dispon\'edvel em todos os cont\'eaineres) para determinar se a priorityqueue est\'e1 vazia. Enquanto houver mais elementos na priority queue, a linha 21 usa a fun\'e7\'e3o top de priorityqueue para recuperar o elemento de mais alta prioridade na priority queue como resultado. A linha 22 remove f\'edsicamente o elemento de maior prioridade na priority queue com a fun\'e7\'e3o pop (dispon\'edvel em todas as classes de adaptadores). \line 20.5 Algoritmos \line Antes da STL, as bibliotecas de classes de cont\'eaineres e algoritmos de diferentes fornecedores eram essencialmente incompat\'edveis. As bibliotecas de cont\'eaineres antigas geralmente usavam heran\'e7a e polimorfismo, com os overheads associados a chamadas de fun\'e7\'f5es virtual. As bibliotecas antigas tinham os algoritmos constru\'eddos nas classes de cont\'eaineres, como comportamentos das classes. A STL separa os algoritmos dos cont\'eaineres. A STL \'e9 implementada para efici\'eancia. Ela evita o overhead das chamadas de fun\'e7\'f5es virtual. Com a STL, os elementos de cont\'eaineres s\'e3o acessados atrav\'e9s de iteradores. \par
956 C++ COMO PROGRAMAR \line Observa\'e7\'e3o de engenharia de software 20.8 \line Os algoritmos n\'e3o dependem dos detalhes de implementa\'e7\'e3o dos cont\'eaineres sobre os quais eles operam. Enquanto os iteradores de cont\'eaineres (ou de arrays) satisfizerem os requisitos do algoritmo, os algoritmos da STL podem trabalhar com quaisquer arrays no estilo de C, baseados em ponteiros, assim como trabalhar com os cont\'eaineres da STL (e estruturas de dados definidas pelo usu\'e1rio). \line Observa\'e7\'e3o de engenharia de software 20.9 \line Algoritmos podem ser facilmente adicionados \'e0 STL sem modificar as classes cont\'eaineres. \line 20.5.1 fui, fili_n, generate e generate_n \line A Fig. 20.26 demonstra as fun\'e7\'f5es f iii. filin, generate e generate n da biblioteca padr\'e3o. As fun\'e7\'f5es \line f iii e fui n atribuem a cada elemento de uma s\'e9rie de elementos do cont\'eainer um valor espec\'edfico. As fun\'e7\'f5es \line generate e generate_n usam uma fun\'e7\'e3o geradora para criar valores para cada elemento de uma s\'e9rie de \line elementos do cont\'eainer. A fun\'e7\'e3o geradora n\'e3o recebe nenhum argumento, retornando um valor que pode ser colocado em um elemento do cont\'eainer. \line 1 II Fig. 20.26: fig2026.cpp \line 2 /1 Demonstrando os m\'e9todos da Biblioteca Padr\'e3o \line 3 II fui, fiiln, generate e generate_n. \line 4 #include <iostream> \line 5 \line 6 using std: :cout; \line 7 using std::endl; \line 8 \line 9 #include <algorithm> \line 10 #inciude <vector> \line 11 \line 12 char nextLetterQ; \line 13 \line 14 int main() \line 15 \line 16 std::vector< char > chars( 10 ); \line 17 std: :ostream_iterator< char > output( cout, \ldblquote  \line 18 \line 19 std: :fill( chars.begmn() , chars.end() , \lquote 5\rquote  ); \line 20 cout \'ab \ldblquote Vector chars depois de preenchido com 5s:\\n\rdblquote ; \line 21 std: :copy( chars.beginO), chars.endO, output ); \line 22 \line 23 std: :fill_n( chars.begmnO), 5, \lquote A\rquote  \line 24 cout \'ab \ldblquote nVector chars depois de preenchidos cinco elementos\rdblquote  \line 25 \'ab \ldblquote com As:\\n\rdblquote ; \line 26 std: :copy( chars.beginQ, chars.end() , output \line 27 \line 28 std: :generate( chars.beginQ, chars.end() , nextLetter ); \line 29 cout \'ab \ldblquote nVector chars depois da gera\'e7\'e3o das letras A a \line 30 std::copy( chars.beginQ, chars.endQ, output ); \line 31 \line 32 std::generate_n( chars.beginQ, 5, nextLetter ); \line 33 cout \'ab \ldblquote\\nVector chars depois da gera\'e7\'e3o de K a O para os\rdblquote  \line 34 \'ab \ldblquote  primeiros cinco elementos:\\n\rdblquote ; \line 35 std: :copy( chars.begin() , chars.end() , output \line 36 \line Fig. 20.26 Demonstrando as fun\'e7\'f5es fill, filin, generate e generate_n da biblioteca padr\'e3o (parte 1 de 2). \par
CAP\'cdTULO 20- A BIBLIOTECA PADR\'c3O DE GABARITOS (STL) 957 \line 37 cout \'ab endi; \line 38 return 0; \line\lquote am. 39 \} \line mos 40 \line iba- 41 char nextLetter() \line 42 \{ \line 43 static char letter = \lquote A\rquote ; \line 44 return letter++; \line 45 \} \line Vector chars depois de preenchido com 5s: \line 5555555555 \line Vector chars depois de preenchidos cinco elementos com As: \line AAAAA5 5555 \line :\'f5es \line Vector chars depois da gera\'e7ao das letras A a J: \line ABCDEFGHIJ \line de \line aio- Vector chars depois da gera\'e7\'e3o de K a O para os primeiros cinco elementos: \line KLMNOFGHIJ \line Fig. 20.26 Demonstrando as fun\'e7\'f5es fill, filin, generate e generate n da biblioteca padr\'e3o (parte 2 de 2). \line A linha 19 \line std: :fill( chars.begin() , chars.end() , \lquote 5\rquote  ); \line usa a fun\'e7\'e3o fill para colocar o caracter 5 em cada elemento do vector chars desde chars begin O at\'e9, mas n\'e3o incluindo, chars end . Observe que os iteradores fornecidos como o primeiro e o segundo argumentos devem ser no m\'ednimo iteradores para a frente (isto \'e9, podem ser usados tanto para leitura de um cont\'eainer quanto para sa\'edda para um cont\'eainer na dire\'e7\'e3o para a frente). \line A linha 23 \line std: :filln( chars.begin, 5, \lquote A\rquote  \line usa a fun\'e7\'e3o fill_n para colocar o caractere \lquote A\rquote  nos primeiros cinco elementos do vector chars. O iterador fornecido como o primeiro argumento deve ser no m\'ednimo um iterador de sa\'edda (isto \'e9, pode ser usado para sa\'edda de um cont\'eainer na dire\'e7\'e3o para a frente). O segundo argumento especifica o n\'famero de elementos para preencher. O terceiro argumento especifica o valor para colocar em cada elemento. \line A linha 28 \line std: :generate( chars.begin() , chars.end() , nextLetter ) \line usa a fun\'e7\'e3o generate para colocar o resultado de uma chamada \'e0 fun\'e7\'e3o geradora nextLetter em cada elemento do vector chars. desde chars begin () at\'e9, mas n\'e3o incluindo, chars . end o. Os iteradores fornecidos como o primeiro e segundo argumentos devem ser no m\'ednimo iteradores para a frente. A fun\'e7\'e3o nextLetter (definida na linha 41) come\'e7a com o caractere \lquote A\rquote  mantido em uma vari\'e1vel local static. O comando na linha 44 \line return letter++; \line incrementa o valor de letter e retorna o valor anterior de letter cada vez que nextLetter \'e9 chamada. A linha 32 \line rao \par
std: :generate_n( chars.begin() , 5, nextLetter ) \par
958 C++ COMO PROGRAMAR \line usa a fun\'e7\'e3o generate_n para colocar o resultado de uma chamada do gerador de fun\'e7\'e3o nextLetter em cinco elementos do vector chars come\'e7ando em chars . begin . O iterador fornecido como o primeiro argumento deve ser no m\'ednimo um iterador de sa\'edda. \line 20.5.2 equal. mismatch e lexicographical compare \line A Fig . 20.27 demonstra a compara\'e7\'e3o de seq\'fc\'eancias de valores quanto \'e0 igualdade com as fun\'e7\'f5es equal, mismatch e lexicographical compare da biblioteca padr\'e3o. \line 1 // Fig. 20.27: fig2027.cpp \line 2 // Demonstra as fun\'e7\'f5es da biblioteca padr\'e3o \line 3 // equal, mismatch e lexicographical compare. \line 4 #include <iostream> \line 5 \line 6 using std: :cout; \line 7 using std: :endl; \line 8 \line 9 #inciude <algorithm> \line 10 #include <vector> \line ii \line 12 int main() \line 13 \line 14 const int SIZE = 10; \line 15 intai[SIZE)=\{i, 2,3,4,5,6,7,8,9, i0\}; \line 16 inta2[SIZE)=\{i, 2,3,4,1000,6,7,8,9, 10\}; \line 17 std::vector< int > vl( ai, ai + SIZE ), \line 18 v2( ai, ai + SIZE ), \line 19 v3( a2, a2 + SIZE ); \line 20 std: :ostreamiterator< int > output( cout, \ldblquote  \line 21 \line 22 cout \'ab \ldblquote Vector vi cont\'e9m: \line 23 std::copy( v1.begmn, vi.end, output ); \line 24 cout \'ab \ldblquote\\nVector v2 cont\'e9m: \ldblquote ; \line 25 std::copy( v2.beginQ, v2.end(), output ); \line 26 cout \'ab \ldblquote\\nVector v3 cont\'e9m: \ldblquote ; \line 27 std: :copy( v3.beginQ, v3.endQ, output ); \line 28 \line 29 bool result = \line 30 std: :equal ( vi .begmnO, vi .endO, v2 .begin() ); \line 31 cout \'ab \ldblquote\\n\\nVector vi \ldblquote  \'ab ( result ? \ldblquote\'e9\rdblquote  : \ldblquote n\'e3o \'e9\rdblquote  \line 32 \'ab \ldblquote  igual a v2.\\n\rdblquote ; \line 33 \line 34 result = std::equal( vl.beginO, vl.end(), v3.begin() ); \line 35 cout \'ab \ldblquote Vector vi \ldblquote  \'ab ( result ? \ldblquote\'e9\rdblquote  : \ldblquote n\'e3o \'e9\rdblquote  \line 36 \'ab \ldblquote  igual a vector v3.\\n\rdblquote ; \line 1 \line 38 std::pair< std::vector< int >::iterator, \line 39 std::vector< int >::iterator > location; \line 40 location = \line 41 std: :mismatch( vi.begin(), vl.endO, v3.begin() ); \line 42 cout \'ab \ldblquote\\nExiste uma diferen\'e7a entre vi e v3 na \line 43 \'ab \ldblquote posi\'e7\'e3o \'ab ( location.first - vl.beginO) \line 44 \'ab \ldblquote\\nonde vi cont\'e9m \ldblquote  \'ab *locationfirst \line 45 \'ab \ldblquote  e v3 cont\'e9m \ldblquote  \'ab *locationsecond \line Fig. 20.27 Demonstrando as fun\'e7\'f5es equal, mismatch e lexicographical compare da biblioteca padr\'e3o (parte 1 de 2). \par
CAP\'cdTULO 20- A BIBLIOTECA PADR\'c3O DE GABARITOS (STL) 959 \line m 46 \'ab \ldblquote\\n\\n\rdblquote ; \line ro 47 \line 48 char cl[ SIZE ] = \ldblquote 01\rdblquote , c2[ SIZE 1 = \ldblquote AT\'c9 LOGO\rdblquote ; \line 49 \line 50 result = std: :lexicographicalcompare( \line 51 cl, cl + SIZE, c2, c2 + SIZE \line 52 cout \'ab cl \line 53 \'ab ( result ? \ldblquote  \'e9 menor do que \line 54 \ldblquote  \'e9 maior do que ou igual a \line 55 \'ab c2 \'ab endi; \line 56 \line 57 return 0; \line 58 \} \line Vector vi cont\'e9m: 1 2 3 4 5 6 7 8 9 10 \line Vector v2 cont\'e9m: 1 2 3 4 5 6 7 8 9 lO \line Vector v3 cont\'e9m: 1 2 3 4 1000 6 7 8 9 10 \line Vector vi \'e9 igual a vector v2. \line Vector vi n\'e3o \'e9 igual a vector v3. \line Existe uma diferen\'e7a entre vl e v3 na posi\'e7\'e3o 4 \line onde vi cont\'e9m 5 e v3 cont\'e9m 1000 \line 01 \'e9 maior do que ou igual a AT\'c9 LOGO \line Fig. 20.27 Demonstrando as fun\'e7\'f5es equal, mismatch e lexicographical compare da biblioteca padr\'e3o (parte 2 de 2). \line As linhas 29 e 30 \line bool result = \line std: :equal( vi .beginO, vi .endO, v2 .begin() ); \line usam a fun\'e7\'e3o equal para comparar duas seq\'fc\'eancias de valores quanto \'e0 igualdade. Cada seq\'fc\'eancia n\'e3o precisa conter, necessariamente, o mesmo n\'famero de elementos - equal retorna false se as seq\'fc\'eancias n\'e3o t\'eam o mesmo comprimento. A fun\'e7\'e3o operator== faz a compara\'e7\'e3o dos elementos. Neste exemplo, os elementos no vector vi, de vi . begin () at\'e9, mas n\'e3o incluindo, vi . end , s\'e3o comparados aos elementos no vector v2 come\'e7ando em v2 . begin () (neste exemplo, vi e v2 s\'e3o iguais). Os tr\'eas argumentos iteradores devem ser no m\'ednimo iteradores de entrada (isto \'e9, podem ser usados para leitura de uma seq\'fc\'eancia na dire\'e7\'e3o para a frente). A linha 34 usa a fun\'e7\'e3o equal para comparar vectors vi e v3 que n\'e3o s\'e3o iguais. \line H\'e1 uma outra vers\'e3o da fun\'e7\'e3o equal que aceita uma fun\'e7\'e3o predicado bin\'e1ria como um quarto par\'e2metro. A fun\'e7\'e3o predicado bin\'e1ria recebe os dois elementos que est\'e3o sendo comparados e retorna um valor booi indicando se os elementos s\'e3o iguais ou n\'e3o. Isto pode ser \'fatil em seq\'fc\'eancias que armazenam ponteiros para valores em vez de valores reais, porque voc\'ea pode definir uma ou mais compara\'e7\'f5es. Por exemplo, voc\'ea pode comparar objetos Employee quanto \'e0 idade, c\'f3digo ou localiza\'e7\'e3o em vez de comparar objetos inteiros. Pode comparar aquilo a que os ponteiros se referem, em vez de comparar os conte\'fados dos ponteiros (isto \'e9, os endere\'e7os armazenados nos ponteiros). \line As linhas 38 a41 \line std: :pair< std: :vector< int >: :iterator, \line std: :vector< int >: :iterator > location; \line location = \line std: :mismatch( vi .beginQ, vi. endO, v3 .begin() ); \par
960 C++ COMO PROGRAMAR \line come\'e7am por instanciar um pair de iteradores chamado location com um vector de inteiros. Este objeto armazena o resultado da chamada para mismatch. A fun\'e7\'e3o mismatch compara duas seq\'fc\'eancias de valores e retorna um pair de iteradores indicando a posi\'e7\'e3o, em cada seq\'fc\'eancia, dos elementos diferentes. Se todos os elementos forem iguais, os dois iteradores no pair s\'e3o iguais ao \'faltimo iterador para cada seq\'fc\'eancia. Os tr\'eas argumentos iteradores devem ser pelo menos iteradores de entrada. Para determinar a verdadeira posi\'e7\'e3o da n\'e3o- concord\'e2ncia dos vectors, neste exemplo \'e9 usada a express\'e3o location. first - vi . begin () na linha 43. O resultado desse c\'e1lculo \'e9 o n\'famero de elementos entre os iteradores (isto \'e9 an\'e1logo \'e0 aritm\'e9tica de ponteiros que estudamos no Cap\'edtulo 5). Corresponde ao n\'famero do elemento neste exemplo, porque a compara\'e7\'e3o \'e9 executada a partir do come\'e7o de cada vector. \line Assim como com a fun\'e7\'e3o equal, h\'e1 outra vers\'e3o da fun\'e7\'e3o mismatch que aceita uma fun\'e7\'e3o predicado \line bin\'e1ria como um quarto par\'e2metro. \line As linhas 50 e 51 \line result std: :lexicographical_compare( \line ci, cl + SIZE, c2, c2 + SIZE ); \line usam a fun\'e7\'e3o lexicographical compare para comparar os conte\'fados de dois arrays de caracteres. Os quatro argumentos iteradores desta fun\'e7\'e3o devem ser pelo menos iteradores de entrada. Como voc\'ea sabe, ponteiros em arrays s\'e3o iteradores de acesso aleat\'f3rio. Os dois primeiros argumentos de iteradores especificam o intervalo das posi\'e7\'f5es na primeira seq\'fc\'eancia. Os dois \'faltimos argumentos de iteradores especificam o intervalo das posi\'e7\'f5es na segunda seq\'fc\'eancia. Ao se percorrer as seq\'fc\'eancias, se o elemento na primeira seq\'fc\'eancia \'e9 menor do que o elemento correspondente na segunda seq\'fc\'eancia, a fun\'e7\'e3o retorna true. Se o elemento na primeira seq\'fc\'eancia \'e9 maior que ou igual ao elemento na segunda seq\'fc\'eancia, a fun\'e7\'e3o retorna false. Esta fun\'e7\'e3o pode ser usada para colocar seq\'fc\'eancias em ordem lexicogr\'e1fica*. Tipicamente, tais seq\'fc\'eancias cont\'eam strings. \line 20.5.3 remove. remove if, remove_copy e remove_copy_if \line A Fig. 20.28 demonstra a remo\'e7\'e3o de valores de uma seq\'fc\'eancia usando as fun\'e7\'f5es remove. remove_if, remove_copy e remove_copy_if da biblioteca padr\'e3o. \line 1 II Fig. 20.28: fig2028.cpp \line 2 II Demonstra as fun\'e7\'f5es remove, removeif, \line 3 II remove_copy e remove_copyif da biblioteca padr\'e3o. \line 4 #include <iostream> \line 5 \line 6 using std::cout; \line 7 using std: :endl; \line 8 \line 9 #include <algorithm> \line iO #include <vector> \line ii \line 12 bool greater9 ( int ); \line 13 \line i4 int main() \line Fig. 20.28 Demonstrando as fun\'e7\'f5es remove, remove_if, remove copy e remove_copy_if da biblioteca padr\'e3o (parte 1 de 3). \line * N. de R.T.: Na ordem em que apareceriam em um dicion\'e1rio, ou seja, em ordem crescente dos c\'f3digos num\'e9ricos utilizados para representar os caracteres na mem\'f3ria do computador. \par
CAPITULO 20 - A BIBLIOTECA PADR\'c3O DE GABARITOS (STL) 961 \line jeto 15 \{ \line se 16 const int SIZE = 10; \line 17 int a[ SIZE ] = \{ 10, 2, 10, 4, 16, 6, 14, 8, 12, 10 \}; \line tr\'eas 18 std: :ostreamiterator< int > output( cout, \ldblquote  \lquote  \line 19 \line ao 2 \line // Remove lOs de v \line nha 21 std: :vector< int > v( a, a + SIZE ); \line [fOS 22 std::vector< int >::iterator newLastElement; \line CU- 23 cout \'ab \ldblquote Vector v antes da remo\'e7\'e3o de todos os lOs:\\n; \line 24 std: :copy( v.beginQ, v.endO, output ); \line 25 newLastElement = std: :remove( v.beginO, v.endO, 10 ); \line 26 cout \'ab \ldblquote\\nVector v depois da remo\'e7\'e3o de todos os lOs:\\n\rquote ; \line 27 std: :copy( v.begin, newLastElement, output ); \line 28 \line 29 // Copia de v2 para c, removendo os lOs \line 30 std::vector< int > v2( a, a + SIZE ); \line 31 std: :vector< int > c( SIZE, O ); \line 32 cout \'ab \ldblquote\\n\\nVector v2 antes da remo\'e7\'e3o de todos os lOs \line 33 \'ab \ldblquote e copia:\\n\rdblquote ; \line be, 34 std::copy( v2.beginO, v2.endQ, output ); \line 35 std: :remove copy( v2.beginQ, v2.endO, c.beginO, 10 ); \line ao 36 cout \'ab \lquote\\nVector c depois da remo\'e7\'e3o de todos os lOs de v2:\\n\rdblquote ; \line se- 37 std: :copy( c.begin, c.endQ, output ); \line 38 \line na 1 // Remove elementos maiores do que 9 de v3 \line ais 40 std::vector< int > v3( a, a + SIZE ); \line 41 cout \'ab \ldblquote\\n\\nVector v3 antes da remo\'e7\'e3o de todos os elementos\rdblquote  \line 42 \'ab \ldblquote\\nmaiores do que 9:\\n\rquote ; \line 43 std::copy( v3.begin, v3.endO, output ); \line 44 newLastElement = \line 45 std: :remove_if( v3.beginQ, v3.endO, greater9 ); \line 46 cout \'ab \ldblquote\\nVector v3 depois da remo\'e7\'e3o de todos os elementos\rdblquote  \line 47 \'ab \ldblquote\\nmaiores do que 9:\\n\rquote ; \line 48 std: :copy( v3.begin, newLastElement, output ); \line 49 \line 50 II Copia elementos de v4 para c2, \line 51 // removendo elementos maiores do que 9 \line 52 std::vector< int > v4( a, a + SIZE ); \line 53 std::vector< int > c2( SIZE, O ); \line 54 cout \'ab \ldblquote\\n\\nVector v4 antes da remo\'e7\'e3o de todos os elementos\rdblquote  \line 55 \'ab \\nmaiores do que 9 e copia:\\n\rdblquote ; \line 56 std::copy( v4.beginQ, v4.endO, output ); \line 57 std: : remove copy if( v4 .begin, v4 . endQ, \line 58 c2.begin, greater9 ); \line 59 cout \'ab \ldblquote\\nVector c2 depois da remo\'e7\'e3o de todos os elementos\rdblquote  \line 60 \'ab \lquote\\nmaiores do que 9 de v4:\\n\rdblquote ; \line 61 std::copy( c2.beginO, c2.endO, output ); \line 62 \line 63 cout \'ab endl; \line 64 return 0; \line 65 \line 66 \line 67 bool greater9( int x \line 68 \line 69 return x > 9; \line 70 \line Fig. 20.28 Demonstrando as fun\'e7\'f5es remove, remove if, remove copy e remove copy if da biblioteca padr\'e3o (parte 2 de 3). \par
962 C++ COMO PROGRAMAR \par
Vector v antes da remo\'e7\'e3o de todos os lOs: \line 10 2 10 4 16 6 14 8 12 10 \line Vector v depois da remo\'e7\'e3o de todos os lOs: \line 2 4 16 6 14 8 12 \line Vector v2 antes da remo\'e7\'e3o de todos os lOs e copia: \line 1021041661481210 \line Vector c depois da remo\'e7\'e3o de todos os lOs de v2: \line 2416614812000 \line Vector v3 antes da remo\'e7\'e3o de todos os elementos \line maiores do que 9: \line 10 2 10 4 16 6 14 8 12 10 \line Vector v3 depois da remo\'e7\'e3o de todos os elementos \line maiores do que 9: \line 2468 \line Vector v4 antes da remo\'e7\'e3o de todos os elementos \line maiores do que 9 e copia: \line 1021041661481210 \line Vector c2 depois da remo\'e7\'e3o de todos os elementos \line naiores do que 9 de v4: \line 2468000000 \line Fig. 20.28 Demonstrando as fun\'e7\'f5es remove, remove if, remove copy e remove_copy_if da b\'edblioteca padr\'e3o (parte 3 de 3). \line A linha 25 \line newLastElement = std: :remove( v.begin, v.endO, 10 \line usa a fun\'e7\'e3o remove para eliminar todos os elementos com o valor 10 no intervalo que vai de v.begin O at\'e9, mas n\'e3o incluindo, v. end () do vector v. Os dois primeiros argumentos iteradores devem ser iteradores para a frente, de modo que o algoritmo possa modificar os elementos na seq\'fc\'eancia. Esta fun\'e7\'e3o n\'e3o modifica o n\'famero de elementos no vector nem destr\'f3i os elementos eliminados, mas move todos os elementos que n\'e3o s\'e3o eliminados em dire\'e7\'e3o ao come\'e7o do vector. A fun\'e7\'e3o retorna um iterador posicionado ap\'f3s o \'faltimo elemento do vector que n\'e3o foi exclu\'eddo. Os elementos da posi\'e7\'e3o do iterador at\'e9 o final do vector t\'eam valores indefinidos (neste exemplo, cada posi\'e7\'e3o \ldblquote indefinida\rdblquote  tem valor O). \line A linha 35 \line std: :remove_copy( v2.beginQ, v2.endO, c.begin, 10 ); \line usa a fun\'e7\'e3o remove copy para copiar todos os elementos que n\'e3o t\'eam o valor 10 na fila v2 . begin () at\'e9, mas n\'e3o incluindo, v2 . end () do vector v2. Os elementos s\'e3o colocados no vector c come\'e7ando na posi\'e7\'e3o c . begin . Os iteradores fornecidos como os dois primeiros argumentos devem ser iteradores de entrada. O iterador fornecido como terceiro argumento deve ser um iterador de sa\'edda, de modo que o elemento que est\'e1 sendo copiado possa ser inserido na posi\'e7\'e3o da c\'f3pia. Esta fun\'e7\'e3o retorna um iterador posicionado ap\'f3s o \'faltimo elemento copiado no vector c. Note na linha 31 o uso do construtor de vector que recebe o n\'famero de elementos no vector e o valor inicial daqueles elementos. \line As linhas 44 and 45 \line newLastElement = \line std: : remove if( v3 .beginO, v3 .endO, greater9 ); \line usam a fun\'e7\'e3o remove if para deletar todos os elementos no intervalo v3 . begin () at\'e9, mas n\'e3o incluindo, v3 . end () do vector v3 para o qual nossa fun\'e7\'e3o predicado un\'e1ria definida pelo usu\'e1rio greater9 retorna \par
\pard\par
\pard\sb100\sa240 using std::cout; using std::endl; \par
9 #include <algorithm> \line 10 #include <vector> \par
11 \line 12 \line 13 \par
14 \line 15 \line 16 \line 17 \line 18 \line 19 \line 20 \line 21 \line 22 \line 23 \line 24 \line 25 \line 26 \line 27 \par
b, .i., .LU \par
CAP\'cdTULO 20- A BIBLIOTECA PADR\'c3O DE GABARITOS (STL) 963 \par
true. A fun\'e7\'e3o greater9 \'e9 definida na linha 67 de modo a retornar true se o valor passado for maior do que 9, e, caso contr\'e1rio, retornar false. Os iteradores fornecidos como os dois primeiros argumentos devem ser iteradores para a frente; deste modo, o algoritmo pode modificar os elementos na seq\'fc\'eancia. Esta fun\'e7\'e3o n\'e3o modifica o n\'famero de elementos no vector, mas ela move de fato para o in\'edcio do vector todos os elementos que n\'e3o s\'e3o eliminados. Esta fun\'e7\'e3o retorna um iterador posicionado ap\'f3s o \'faltimo elemento no vector que n\'e3o foi exclu\'eddo. Todos os elementos da posi\'e7\'e3o do iterador at\'e9 o final do vector t\'eam valores indefinidos. \line As linhas 57 e 58 \line std: :remove copyif( v4.begin, v4.endQ, \line c2.begin, greater9 ); \line usam a fun\'e7\'e3o remove copy_if para copiar todos os elementos no intervalo v4 . begin () at\'e9, mas n\'e3o incluindo, v4 . end O do vector v4 para os quais a fun\'e7\'e3o predicado un\'e1ria greater9 retorna true. Os elementos s\'e3o colocados no vector c2 a partir da posi\'e7\'e3o c2 . begin O . Os iteradores fornecidos como os primeiros dois argumentos devem ser iteradores de entrada. O iterador fornecido como terceiro argumento deve ser um iterador de sa\'edda, de modo que o elemento que est\'e1 sendo copiado possa ser inserido na posi\'e7\'e3o da c\'f3pia. Esta fun\'e7\'e3o retorna um iterador posicionado ap\'f3s o \'faltimo elemento copiado para o vector c2. \par
20.5.4 replace. replace_if, replace_copy e replace_copy_if \line A Fig. 20.29 demonstra a substitui\'e7\'e3o de valores de uma seq\'fc\'eancia usando as fun\'e7\'f5es replace, replaceif, replacecopy e replacecopyif da biblioteca padr\'e3o. \par
6 \line 7 \line 8 \par
1 II Fig. 20.29: fig2029.cpp \line 2 II Demonstra as fun\'e7\'f5es replace, replace_if, replace_copy \line 3 II e replace_copy_if da biblioteca padr\'e3o \line 4 #include <iostream> \line 5 \par
bool greater9 ( int ); \line int main() \line const int SIZE = 10; \line inta[ SIZE) = \{ 10,2,10,4,16,6,14, \line std: :ostreamiterator< int > output( cout, \line // Substitui lOs em vi por iOOs \line std::vector< int > vl( a, a + SIZE ); \line cout \'ab Vector vi antes da substitui\'e7\'e3o de todos os lOs:\\n\rdblquote ; std: :copy( v1.begin, vl.endO, output ); \line std::replace( vi.beginO, vl.endO, 10, 100 ); \line cout \'ab \ldblquote\\nVector vi ap\'f3s a substitui\'e7\'e3o de todos os std: : copy( vi .beginO, vi. endO, output ); \line 28 // copia de v2 para ci, substituindo i0s por iOOs \line 29 std::vector< int > v2( a, a + SIZE ); \line 30 std::vector< int > ci( SIZE ); \line 31 cout \'ab \ldblquote\\n\\nVector v2 antes da substitui\'e7\'e3o de todos os i0s \line 32 \'ab \ldblquote e copia:\\n\rdblquote ; \par
i0s por iOOs:\\n\rdblquote ; \par
Fig. 20.29 Demonstrando as fun\'e7\'f5es replace, replace if, replace_copy e replace_copy_if \line da biblioteca padr\'e3o (parte 1 de 2). \par
964 C++ COMO PROGRAMAR \line 33 std::copy( v2.beginO, v2.end(), output ); \line 34 std: : replace_copy( v2 .beginO, v2 .endO, \line 35 cl.begin() , 10, 100 \line 36 cout \'ab \ldblquote\\nVector cl depois da substitui\'e7\'e3o de todos os lOs em \line 37 std::copy( c1.begin, cl.endQ, output ); \line 38 \line 39 II Substitui valores maiores do que 9 em v3 por 100 \line 40 std::vector< int > v3( a, a + SIZE ); \line 41 cout \'ab \lquote\\n\\nVector v3 antes da substitui\'e7\'e3o de valores maiores\rdblquote  \line 42 \'ab \ldblquote  do que 9:\\n\rdblquote ; \line 43 std: :copy( v3.begin, v3.end(), output ); \line 44 std: :replace if( v3.beginQ, v3.endQ, greater9, 100 ); \line 45 cout \'ab \ldblquote\\nVector v3 ap\'f3s a substitui\'e7\'e3o de todos os valores\rdblquote  \line 46 \'ab \ldblquote\\nmaiores do que 9 por iOOs:\\n\rdblquote ; \line 47 std::copy( v3.beginO, v3.endO, output ); \line 48 \line 49 II Copia v4 para c2, substituindo elementos maiores do que 9 por 100 \line 50 std::vector< int > v4( a, a + SIZE ); \line 51 std::vector< int > c2( SIZE ); \line 52 cout \'ab \ldblquote\\n\\nVector v4 antes da substitui\'e7\'e3o de todos os valores \line 53 \'ab \ldblquote\\nmaiores do que 9 e copia:\\n\rdblquote ; \line 54 std::copy( v4.beginQ, v4.endO, output ); \line 55 std: :replace copy if( v4.beginQ, v4.endO, c2.begin, \line 56 greater9, 100 ); \line 57 cout \'ab \ldblquote\\nVector c2 ap\'f3s a substitui\'e7\'e3o de todos os valores\rdblquote  \line 58 \'ab \ldblquote\\nmaiores do que 9 em v4:\\n\rdblquote ; \line 59 std: :copy( c2.beginQ, c2.end(), output ); \line 60 \line 61 cout \'ab endl; \line 62 return 0; \line 63 \line 64 \line 65 bool greater9( int x \line 66 \line 67 return x > 9; \line 68 \line Vector vi antes da substitui\'e7\'e3o de todos os lOs: \line 1021041661481210 \line Vector vi ap\'f3s a substitui\'e7\'e3o de todos os lOs por lOOs: \line 100 2 100 4 16 6 14 8 12 100 \line Vector v2 antes da substitui\'e7\'e3o de todos os lOs e copia: \line 1021041661481210 \line Vector ci ap\'f3s a substitui\'e7\'e3o de todos os lOs em v2: \line 100 2 100 4 16 6 14 8 12 100 \line Vector v3 antes da substitui\'e7\'e3o de valores maiores do que 9: \line 1021041661481210 \line Vector v3 ap\'f3s a substitui\'e7\'e3o de todos os valores \line maiores do que 9 por lOOs: \line 100 2 100 4 100 6 100 8 100 100 \line Vector v4 antes da substitui\'e7\'e3o de todos os valores \line maiores do que 9 e copia: \line 1021041661481210 \line Vector c2 ap\'f3s a substitui\'e7\'e3o de todos os valores \line maiores do que 9 em v4: \line 100 2 100 4 100 6 100 8 100 100 \line Fig. 20.29 Demonstrando as fun\'e7\'f5es replace, replace if, replace_copy e replace_copy_if da biblioteca padr\'e3o (parte 2 de 2). \par
CAP\'cdTULO 20- A BIBLIOTECA PADR\'c3O DE GABARITOS (STL) 965 \par
A linha 24 \line std::replace( vl.beginQ, vl.endO, 10, 100 ); \line usa a fun\'e7\'e3o replace para substituir todos os elementos com o valor 10 no intervalo devi begin () at\'e9, mas n\'e3o incluindo, vi end O do vector vi pelo novo valor 100. Os iteradores fornecidos como os dois primeiros argumentos devem ser iteradores para a frente; deste modo, o algoritmo pode modificar os elementos na seq\'fc\'eancia. \line As linhas 34 e 35 \line std: :repiace copy( v2 .beginQ, v2 .endO, \line cl.beginQ, 10, 100 ); \line usam a fun\'e7\'e3o replace copy para copiar todos os elementos no intervalo v2 . begin () at\'e9, mas n\'e3o incluindo, v2 .endO do vector v2, substituindo todos os elementos com o valor 10 pelo novo valor 100. Os elementos s\'e3o copiados para o vector ci a partir da posi\'e7\'e3o ci begin o. Os iteradores fornecidos como os primeiros dois argumentos devem ser iteradores de entrada. O iterador fornecido como terceiro argumento deve ser um iterador de sa\'edda, de modo que o elemento que est\'e1 sendo copiado possa ser inserido na posi\'e7\'e3o da c\'f3pia. Esta fun\'e7\'e3o retorna um iterador posicionado ap\'f3s o \'faltimo elemento copiado para o vector c2. \line A linha 44 \line std::replace_if( v3.beginO, v3.endO, greater9, 100 ); \line usa a fun\'e7\'e3o replace if para substituir todos os elementos no intervalo v3 . begin O at\'e9, mas n\'e3o incluindo, \line v3 end O do vector v3 para os quais a fun\'e7\'e3o predicado un\'e1ria greater9 retorna true. A fun\'e7\'e3o greater9 \line\'e9 definida na linha 65 para retornar true se o valor passado for maior do que 9 e faise caso contr\'e1rio. O valor \line 100 substitui cada valor maior do que 9. Os iteradores fornecidos como os primeiros dois argumentos devem ser \line iteradores para a frente; deste modo, o algoritmo pode modificar os elementos na seq\'fc\'eancia. \line As linhas 55 e 56 \line std: :replace copyif( v4 .beginQ, v4 .end(), c2 .beginO, \line greater9, 100 ); \line usam a fun\'e7\'e3o repiace copy if para copiar todos os elementos no intervalo v4 .begin O) at\'e9, mas n\'e3o incluindo. v4 . end O) do vector v4. Elementos para os quais a fun\'e7\'e3o predicado un\'e1ria greater9 retorna true s\'e3o substitu\'eddos pelo valor 100. Os elementos s\'e3o colocados no vector c2 come\'e7ando na posi\'e7\'e3o c2 begin O. Os iteradores fornecidos como os primeiros dois argumentos devem ser iteradores de entrada. O iterador fornecido como terceiro argumento precisa ser um iterador de sa\'edda, de modo que o elemento que est\'e1 sendo copiado possa ser inserido na posi\'e7\'e3o da c\'f3pia. Esta fun\'e7\'e3o retorna um iterador posicionado ap\'f3s o \'faltimo elemento copiado para o vector c2. \line 20.5.5 Algoritmos matem\'e1ticos \line A Fig. 20.30 demonstra alguns algoritmos matem\'e1ticos comuns da STL. incluindo random shuffie. count. countif, mm element. max element, accumulate. for_each e transform. \par
Fig. 20.30 Demonstrando alguns algoritmos matem\'e1ticos da biblioteca padr\'e3o (parte 1 de 3). \par
\pard\par
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx205\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx6039\pard\intbl 1 \cell II Fig. 20.30: fig2O3O.cpp \cell\row
\intbl 2 \cell // Exemplos dos aigoritmos matem\'e1ticos da Biblioteca Padr\'e3o. \cell\row
\intbl 3 \cell #include <iostream> \cell\row
\intbl 4 \cell\cell\row
\intbl 5 \cell using std::cout; \cell\row
\intbl 6 \cell using std::endl; \cell\row
\intbl 7 \cell\cell\row
\pard\par
\pard\sb100\sa240 966 C++ COMO PROGRAMAR \line 8 #inciude <aigorithm> \line 9 #inciude <nuineric> II accumulate est\'e1 definido aqui \line 10 #inciude <vector> \line 11 \line 12 bool greater9( int ); \line 13 void outputSquare( int ); \line 14 int calculateCube( int ); \line 15 \line 16 int main() \line 17 \line 18 const int SIZE = 10; \line 19 int ai[] = \{ 1, 2, 3, 4, 5, 6, 7, 8, , iv \line 20 std: :vector< int > v( ai, ai \'f7 SIZE ); \line 21 std: :ostreamiterator< int > output( cout, \ldblquote  \line 22 \line 23 cout \'ab Vector v antes de randomshuf fie: \line 24 std: :copy( v.begin, v.endQ, output ); \line 25 std: :randomshuffie( v.begmnO, v.end() ); \line 26 cout \'ab \lquote\\nVector v ap\'f3s random_shuffie: \line 27 std: :copy( v.begmnO, v.endQ, output ); \line 28 \line 29 int a2[] = \{ 100, 2, 8, 1, 50, 3, 8, 8, 9, 10 \}; \line 30 std::vector< int > v2( a2, a2 + SIZE ); A \line 31 cout \'ab \ldblquote\\n\\nVector v2 cont\'e9m: \line 32 std::copy( v2.beginO), v2.endO, output ); \line 33 int resuit = std::count( v2.beginO, v2.endO, 8 ); \line 34 std: :cout \'ab \ldblquote\\nQuantidade de elementos iguais a 8: \'ab result; \line 35 US \line 36 result = std::count_if( v2.beginO), v2.endO, greater9 ); \line 37 cout \'ab \\nQuantidade de elementos maiores do que 9: \'ab result; \line 38 \line 39 cout \'ab \ldblquote\\n\\nEiemento m\'ednimo em Vector v2 \'e9: \line 40 \'ab *( std::minelement( v2.beginO, v2.end() ) ); \line 41 us \line 42 cout \'ab \ldblquote\\nElemento m\'e1ximo em Vector v2 \'e9: \line 43 \'ab *( std::max_eiement( v2.beginO), v2.end() ) ); \line 44 \line 45 cout \'ab \ldblquote\\n\\nO total dos elementos em Vector v \'e9: \line 46 \'ab std: :accuinulate( v.beginO, v.end, O ); \line 47 \line 48 cout \'ab \ldblquote\\n\\nO quadrado do todos os inteiros em Vector v \'e9:\\n\rdblquote ; \line 49 std::for_each( v.beginO), v.end, outputSquare ); VE \line 50 \line 51 std::vector< int > cubes( SIZE ); \line 52 std::transform( v.beginO), v.endO), cubes.begino, \line 53 caicuiateCube ); \line 54 cout \'ab \ldblquote\\n\\nO cubo de todos os inteiros em Vector v \line 55 std::copy( cubes.beginO, cubes.endO, output ); \line 56 \line 57 cout \'ab endl; \line 58 return 0; \line 59 \line 60 \line 61 bool greater9( int value ) \{ return value > 9; \line 62 \line 63 void outputSquare ( int value ) \{ cout \'ab value * value \'ab \line 64 \line 65 int calculateCube( int value ) \{ return value * value * value; \line Fig. 20.30 Demonstrando alguns algoritmos matem\'e1ticos da biblioteca padr\'e3o (parte 2 de 3). \par
CAP\'cdTULO 20 - A BIBLIOTECA PADR\'c3O DE GABARITOS (STL) 967 \line Vector v antes de randomshuffle: 1 2 3 4 5 6 7 8 9 10 \line Vector v ap\'f3s random_shuf fie: 5 4 1 3 7 8 9 10 6 2 \line Vector v2 contem: 100 2 8 1 50 3 8 8 9 10 \line Quantidade de elementos iguais a 8: 3 \line Quantidade de elementos maiores do que 9: 3 \line Elemento m\'ednimo em Vector v2 \'e9: 1 \line Elemento m\'e1ximo em Vector v2 \'e9: 100 \line O total de todos os elementos em Vector v \'e9: 55 \line O quadrado de todos os inteiros em Vector v \'e9: \line 251619496481100364 \line O cubo de todos os inteiros em Vector v \'e9: \line 125 64 1 27 343 512 729 1000 216 8 \line Fig. 20.30 Demonstrando alguns algoritmos matem\'e1ticos da biblioteca padr\'e3o (parte 3 de 3). \line A linha 25 \line std: :randomshuffle( v.beginO, v.end() ); \line usa a fun\'e7\'e3o random shuffie para ordenar aleatoriamente os elementos no intervalo v . begin O at\'e9, mas n\'e3o incluindo, v. end () no vector v. Esta fun\'e7\'e3o recebe dois iteradores de acesso aleat\'f3rio como argumentos. \line A linha 33 \line int resuit = std::count( v2.beginO, v2.endO, 8 ); \line usa a fun\'e7\'e3o count para contar os elementos com o valor 8 no intervalo v2 . begin () at\'e9, mas n\'e3o incluindo, v2 . end () no vector v2. Esta fun\'e7\'e3o requer que seus dois argumentos sejam no m\'ednimo iteradores de entrada. \line A linha 36 \line result = std::count_if( v2.beginO, v2.endO, greater9 ); \line usa a fun\'e7\'e3o count if para contar os elementos no intervalo v2 . begin O at\'e9, mas n\'e3o incluindo, v2 . end O no vector v2 para os quais a fun\'e7\'e3o predicado greater9 retorna true. A fun\'e7\'e3o count if requer que seus dois argumentos iteradores sejam no m\'ednimo iteradores de entrada. \line As linhas 39 e 40 \line cout \'ab \ldblquote\\n\\nElemento m\'ednimo em Vector v2 \'e9: \line\'ab ( std::min_element( v2.beginO, v2.end() ) ); \line usam a fun\'e7\'e3o mm eiement para localizar o menor elemento no intervalo v2 . begin () at\'e9, mas n\'e3o incluindo, v2 .end() no vector v2. A fun\'e7\'e3o retorna um iterador de entrada apontando para o menor elemento ou, se o intervalo est\'e1 vazio, retorna o pr\'f3prio iterador. A fun\'e7\'e3o requer que seus dois argumentos iteradores sejam no m\'ednimo iteradores de entrada. Uma segunda vers\'e3o desta fun\'e7\'e3o aceita como seu terceiro argumento uma fun\'e7\'e3o bin\'e1ria que compara os elementos na seq\'fc\'eancia. A fun\'e7\'e3o aceita dois argumentos e retoma um valor bool. \line Boa pr\'e1tica de programa\'e7\'e3o 20.2 \line\'c9 uma boa pr\'e1tica verificar se o intervalo especWcado em uma chamada para mm element n\'e3o est\'e1 \line vazio e verificar se o valor de retorno n\'e3o \'e9 um iterador apontando para \ldblquote depois do final\rdblquote . \par
96 C++ COMO PROGRAMAR \line As linhas 42 e 43 \line cout \'ab \ldblquote\\nElemento m\'e1ximo em Vector v2 \'e9: \line\'ab ( std::max_element( v2.beginO, v2.end() ) ); \line usam a fun\'e7\'e3o max element para localizar o maior elemento no intervalo v2 begin () at\'e9, mas n\'e3o incluindo, v2 . end () no vector v2. A fun\'e7\'e3o retorna um iterador de entrada apontando para o maior elemento. A fun\'e7\'e3o requer que seus dois argumentos sejam no m\'ednimo iteradores de entrada. Uma segunda vers\'e3o desta fun\'e7\'e3o recebe como seu argumento uma fun\'e7\'e3o predicado bin\'e1ria que compara os elementos na seq\'fc\'eancia. A fun\'e7\'e3o bin\'e1ria aceita dois argumentos e retoma um valor bool. \line As linhas 45 e 46 \line cout \'ab \ldblquote\\n\\nO total dos elementos em Vector v \'e9: \line\'ab std: : accumulate ( v.begin, v. end, O ); \line usam a fun\'e7\'e3o accumulate (cujo prot\'f3tipo est\'e1 no arquivo de cabe\'e7alho <numeric>) para somar os valores no intervalo v begin () at\'e9, mas n\'e3o incluindo. v. end () no vector v. Os dois argumentos iteradores desta fun\'e7\'e3o devem ser no m\'ednimo iteradores de entrada. Uma segunda vers\'e3o desta fun\'e7\'e3o aceita como seu terceiro argumento uma fun\'e7\'e3o gen\'e9rica que determina como os elementos s\'e3o acumulados. A fun\'e7\'e3o gen\'e9rica precisa receber dois argumentos e retorna um resultado. O primeiro argumento para esta fun\'e7\'e3o \'e9 o valor acumulado corrente. O segundo argumento \'e9 o valor do elemento corrente na seq\'fc\'eancia sendo acumulada. Por exemplo, para acumular a soma dos quadrados de cada elemento, pode-se usar a fun\'e7\'e3o \line int sumOfSquares( int accumulator, int currentValue \line return accumulator + currentValue * currentValue; \line que recebe o total anterior como seu primeiro argumento (accumulator) e o novo valor para elesar ao quadrado e somar ao total como seu segundo argumento (currentValue). Quando \'e9 chamada a fun\'e7\'e3o, ela eleva ao quadrado currentValue. soma o quadrado de currentValue ao accumulator e retorna o novo total. \line A linha 49 \line std: :for_each( v.begin, v.endO, outputSquare ); \line usa a fun\'e7\'e3o for_each para aplicar uma fun\'e7\'e3o gen\'e9rica sobre cada elemento no intervalo v . begin at\'e9, mas n\'e3o incluindo, v. end () no vector v. A fun\'e7\'e3o deve receber o elemento corrente como um argumento e n\'e3o deve modificar tal elemento. A fun\'e7\'e3o for_each requer que seus dois argumentos iteradores sejam no m\'ednimo iteradores de entrada. \line As linhas 52 e 53 \line std: :transform( v.begin, v.endO, cubes.begin(), \line calculateCube ); \line usam a fun\'e7\'e3o transformpara aplicaruma fun\'e7\'e3o gen\'e9rica sobre todos os elementos no intervalo v.bgin O at\'e9, mas n\'e3o incluindo, v. end () no vector v. A fun\'e7\'e3o gen\'e9rica (o quarto argumento) deve receber o elemento corrente como um argumento, n\'e3o deve modificar o elemento e deve retornar o valor transformado. A fun\'e7\'e3o trans form requer que seus dois primeiros argumentos iteradores sejam no m\'ednimo iteradores de entrada e que seu terceiro argumento seja pelo menos um iterador de sa\'edda. O terceiro argumento especifica onde os valores transformados devem ser colocados. Note que o terceiro argumento pode ser igual ao primeiro. \line 20.5.6 Algoritmos b\'e1sicos de pesquisa e classifica\'e7\'e3o \line A Fig. 20.31 demonstra algumas recursos b\'e1sicos de pesquisa e classifica\'e7\'e3o da biblioteca padr\'e3o, incluindo f ind. findif, sort e binary_search. \par
CAP\'cdTULO 20 - A BIBLIOTECA PADR\'c3O DE GABARITOS (STL) 969 \line 1 II Fig. 20.31: fig2O3l.cpp \line 2 // Demonstra recursos de pesquisa e classifica\'e7\'e3o. \line 3 #include <iostream> \line 4 \line 5 using std::cout; \line 6 using std: :endl; \line 7 \line 8 #include <algorithxn> \line 9 #include <vector> \line 10 \line 11 bool greaterlO ( int value ); \line 12 \line 13 int main() \line 14 \line 15 const int SIZE = 10; \line 16 int a[ SIZE ] = \{ 10, 2, 17, 5, 16, 8, 13, 11, 20, 7 \}; \line 17 std: :vector< int > v( a, a + SIZE ); \line 18 std: :ostreamiterator< int > output( cout, \ldblquote  \ldblquote  \line 19 \line 20 cout \'ab Vector v cont\'e9m: \ldblquote ; \line 21 std: :copy( v.beginO, v.endO, output ); \line 22 \line 23 std::vector< int >::iterator location; \line 24 location = std::find( v.begin, v.end(), 16 ); \line 25 \line 26 if ( location != v.endO \line 27 cout \'ab \ldblquote\\n\\nEncontrou 16 na posi\'e7\'e3o \line 28 \'ab ( location - v.begin() ); \line 29 else \line 30 cout \'ab \ldblquote\\n\\n16 n\'e3o encontrado; \line 31 \line 32 location = std::find( v.begin, v.endO, 100 ); \line 33 \line 34 if ( location != v.endQ \line 35 cout \'ab \\nEncontrou 100 na posi\'e7\'e3o \line 36 \'ab ( location - v.begin() ); \line 37 else \line 38 cout \'ab \ldblquote\\nlOO n\'e3o encontrado\rdblquote ; \line 39 \line 40 location = std::find_if( v.beginO, v.endO, greaterlO ); \line 41 \line 42 if ( location \lquote = v.end() \line 43 cout \'ab \ldblquote\\n\\nO primeiro valor maior do que 10 \'e9 \line 44 \'ab *l,tjn \'ab \\nencontrado na posi\'e7\'e3o \line 45 \'ab ( location - v.begin() ); \line 46 else \line 47 cout \'ab \ldblquote\\n\\nNenhum valor maior do que 10 foi encontrado\rquote ; \line 48 \line 49 std::sort( v.beginO, v.end() ); \line 50 cout \'ab \ldblquote\\n\\nVector v ap\'f3s classifica\'e7\'e3o: \ldblquote ; \line 51 std::copy( v.begin(), v.endO, output ); \line 52 \line 53 if O std::binary_search( v.begin, v.endO, 13 \line 54 cout \'ab \ldblquote\\n\\n13 foi encontrado em v\rdblquote ; \line 55 else \line 56 cout \'ab \ldblquote\\n\\nl3 n\'e3o foi encontrado em v\rdblquote ; \line 57 \line Fig. 20.31 Algoritmos b\'e1sicos de pesquisa e classifica\'e7\'e3o da biblioteca padr\'e3o (parte 1 de 2). \par
970 C++ COMO PROGRAMAR \line 58 if ( std: :binary search( v.beginO, v.endQ, 100 \line 59 cout \'ab \ldblquote\\nlOO foi encontrado em v\rdblquote ; \line 60 else \line 61 cout \'ab \ldblquote\\nlOO n\'e3o foi encontrado em v\rdblquote ; \line 62 \line 63 cout \'ab endl; \line 64 return 0; \line 65 \line 66 \line 67 bool greaterl0( int value ) \{ return value > 10; \line Vector v contem: 10 2 17 5 16 8 13 11 20 7 \line Encontrado 16 na posi\'e7\'e3o 4 \line 100 n\'e3o encontrado \line O primeiro valor maior do que 10 \'e9 17 \line encontrado na posi\'e7\'e3o 2 \line Vector v ap\'f3s classifica\'e7\'e3o: 2 5 7 8 10 11 13 16 17 20 \line 13 foi encontrado em v \line 100 n\'e3o foi encontrado em v \line Fig. 20.31 Algoritmos b\'e1sicos de pesquisa e classifica\'e7\'e3o da biblioteca padr\'e3o (parte 2 de 2). \line A linha 24 \line location = std::find( v.begin, v.endO, 16 ); \line usa a fun\'e7\'e3o f ind para localizar o valor 16 no intervalo v . begin () at\'e9, mas n\'e3o incluindo, v. end () no vector v. A fun\'e7\'e3o requer que seus dois argumentos iteradores sejam, no m\'ednimo, iteradores de entrada. A fun\'e7\'e3o retorna um iterador de entrada que est\'e1 posicionado ou no primeiro elemento contendo o valor ou um iterador indica o fim da seq\'fc\'eancia. \line A linha 40 \line location std::find_if( v.begin, v.end, greaterlO ); \line usa a fun\'e7\'e3o find_if para localizar o primeiro valor no intervalo v begin O at\'e9, mas n\'e3o incluindo, v. end O no vector v para o qual a fun\'e7\'e3o predicado un\'e1ria greaterlO retoma true. A fun\'e7\'e3o greaterlO est\'e1 definida na linha 65 para receber um inteiro e retornar um valor bool indicando se o argumento inteiro \'e9 maior do que 10. A fun\'e7\'e3o find if requer que seus dois argumentos iteradores sejam no m\'ednimo iteradores de entrada. A fun\'e7\'e3o retorna um iterador de entrada que \'e9 posicionado ou no primeiro elemento contendo um valor para qual a fun\'e7\'e3o predicado retoma true ou um iterador indicando o fim da seq\'fc\'eancia. \line A linha 49 \line std::sort(v.beginO, v.end() ); \line usa a fun\'e7\'e3o sort para ordenar os elementos no intervalo v . begin O at\'e9, mas n\'e3o incluindo, v. end O no vector v, em ordem ascendente. A fun\'e7\'e3o requer que seus dois argumentos iteradores sejam iteradores de acesso aleat\'f3rio. Uma segunda vers\'e3o desta fun\'e7\'e3o aceita um terceiro argumento que \'e9 uma fun\'e7\'e3o predicado bin\'e1ria que recebe dois argumentos que s\'e3o valores na seq\'fc\'eancia e retorna um bool indicando a ordem de classifica\'e7\'e3o - se o valor retornado \'e9 true, os dois elementos comparados est\'e3o ordenados. \par
\ul Erro com um de programa\'e7\'e3o 20.5 \ulnone\line A linha 53 \line if ( std: :binary_search( v.beginQ, v.endO, 13 \line usa a fun\'e7\'e3o binary_search para determinar se o valor 13 est\'e1 no intervalo v . begin () at\'e9, mas n\'e3o incluindo, v . end () no vector v. A seq\'fc\'eancia de valores deve ser primeiro classificada em ordem ascendente. A fun\'e7\'e3o binary_search requer que seus dois argumentos iteradores sejam, no m\'ednimo, iteradores para a frente. A fun\'e7\'e3o retorna um bool indicando se o valor foi ou n\'e3o encontrado na seq\'fc\'eancia. Uma segunda vers\'e3o desta fun\'e7\'e3o aceita um quarto argumento que \'e9 uma fun\'e7\'e3o predicado bin\'e1ria que recebe dois argumentos que s\'e3o valores na seq\'fc\'eancia e retorna um bool. A fun\'e7\'e3o predicado retorna true se os dois elementos sendo comparados est\'e3o ordenados. \line 20.5.7 swap, iter_swap e swap_ranges \line A Fig. 20.32 demonstra as fun\'e7\'f5es swap. iter_swap e swap ranges para permutar elementos. \line 1 II Fig. 20.32: fig2032.cpp \line 2 II Demonstra iterswap, swap e swap_ranges. \line 3 #include <iostream> \line 4 \line 5 using std::cout; \line 6 using std::endl; \line 7 \line 8 #include <algorithm> \line 9 \line 10 int main() \line 11 \line 12 const int SIZE = 10; \line 13 inta[SIZE]=\{1, 2,3,4,5,6,7,8,9, i0\}; \line 14 std: :ostreamiterator< int > output( cout, \ldblquote  ); \line 15 \line 16 cout \'ab \ldblquote Array a cont\'e9m:\\n\rdblquote ; \line 17 std: :copy( a, a + SIZE, output ); \line 18 \line 19 std::swap( a[ O ), a[ 1 1 ); \line 20 cout \'ab \ldblquote\\nArray a ap\'f3s permuta\'e7\'e3o de aIO) e a[1] \line 21 \'ab \ldblquote usando swap:\\n\rdblquote ; \line 22 std: :copy( a, a + SIZE, output ); \line 24 std: :iterswap( &a[ O ] , &a[ 1 ] ) \line 25 cout \'ab \ldblquote\\nArray a ap\'f3s permuta\'e7\'e3o de a[0) e ali) \line 26 \'ab \ldblquote usando iterswap:\\n\rdblquote ; \line 27 std: :copy( a, a + SIZE, output ); \line 28 \line 29 std: : swap_ranges ( a, a + 5, a + 5 ); \line 30 cout \'ab \ldblquote\\nArray ap\'f3s a permuta\'e7\'e3o dos primeiros cinco elementos\\n\rdblquote  \line 31 \'ab \ldblquote pelos \'faltimos cinco elementos:\\n\rdblquote ; \line 32 std::copy( a, a + SIZE, output ); \line 33 \line 34 cout \'ab endi; \line 35 return 0; \line 36 \} \par
CAP\'cdTULO 20 - A BIBLIOTECA PADR\'c3O DE GABARITOS (STL) 971 \line Tentar ordenar um cont\'eainer usando um iterador que n\'e3o seja um iterador de acesso aleat\'f3rio \'e9 um erro de sintaxe. A fun\'e7\'e3o sort requer um iterador de acesso aleat\'f3rio. \par
Fig. 20.32 Demonstrando swap. iter swap e swap ranges (parte 1 de 2). \par
972 C++ COMO PROGRAMAR \line Array a cont\'e9m: \line 1 2 3 4 5 6 7 8 9 10 \line Array a ap\'f3s permuta\'e7\'e3o de a[0] e a[1] usando swap: \line 2 1 3 4 5 6 7 8 9 10 \line Array a ap\'f3s permuta\'e7\'e3o de a[0] e a[l] usando iter_swap: \line 1 2 3 4 5 6 7 8 9 10 \line Array a ap\'f3s permuta\'e7\'e3o dos primeiros cinco elementos \line pelos \'faltimos cinco elementos: \line 6 7 8 9 10 1 2 3 4 5 \line Fig. 20.32 Demonstrando swap, iter_swap e swap ranges parte 2 de . \line A linha 19 \line std::swap( a[ O ], a[ 1 ] ); \line usa a fun\'e7\'e3o swap para permutar dois valores. Neste exemplo, o primeiro e o segundo elementos do array a s\'e3o permutados. A fun\'e7\'e3o recebe como argumentos refer\'eancias para os dois valores que est\'e3o sendo permutados. \line A linha 24 \line std: :iter_swap( &a[ O ] , &a 1 \line usa a fun\'e7\'e3o iter_swap para permutar os dois elementos. A fun\'e7\'e3o aceita dois argumentos iteradores para a frente (neste caso, ponteiros para elementos de um array) e permuta os valores nos elementos aos quais os iteradores se refere. \line A linha 29 \line std: :swap_ranges( a, a + 5, a + 5 ); \line usa a fun\'e7\'e3o swap ranges para permutar os elementos no intervalo a at\'e9, mas n\'e3o incluindo, a \'f7 5 com os elementos come\'e7ando na posi\'e7\'e3o a + 5. A fun\'e7\'e3o requer tr\'eas argumentos iteradores para a frente. Os dois primeiros argumentos especificam o intervalo de elementos na primeira seq\'fc\'eancia que ser\'e1 trocado com os elementos na segunda seq\'fc\'eancia come\'e7ando a partir do iterador especificado como terceiro argumento. Neste exemplo, as duas seq\'fc\'eancias de valores est\'e3o no mesmo array, mas as seq\'fc\'eancias podem ser de arrays ou cont\'eaineres diferentes. \line 20.5.8 copy_backward, merge, unique e reverse \line A Fig. 20.33 demonstra as fun\'e7\'f5es copy backward, merge. unique e reverse da biblioteca padr\'e3o. \par
Fig. 20.33 Demonstrando copy backward, merge, unique e reverse (parte 1 de 2). \par
\pard\par
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx325\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4956\pard\intbl 1  2  3  4 \cell II Fig. 20.33: fig2033.cpp  II Demonstra diversas fun\'e7\'f5es:  II copy_backward, merge, unique e reverse.  #include <iostream> \cell\row
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx325\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4643\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4956\pard\intbl 5 \cell\cell\cell\row
\intbl 6  7 \cell using std: :cout; using std: :endl; \cell\cell\row
\intbl 8 \cell\cell\cell\row
\intbl 9  10 \cell #include <algorithm> #include <vector> \cell\cell\row
\intbl 11 \cell\cell\cell\row
\intbl 12 \cell int main() \cell\cell\row
\intbl 13 \cell\{ \cell\cell\row
\pard\par
\pard\sb100\sa240 CAP\'cdTULO 20 - A BIBLIOTECA PADR\'c3O DE GABARITOS (STL) 973 \line 14 const int SIZE = 5; \line 15 intai[SIZE]\{1,3,5,7,9\}; \line 16 inta2[SIZE]=\{2,4,5,7,9\}; \line 17 std::vector< int > vl( ai, ai + SIZE ); \line 18 std::vector< int > v2( a2, a2 + SIZE ); \line 19 \line 20 std: :ostreamiterator< int > output( cout, ); \line 21 \line 22 cout \'ab \ldblquote Vector vi cont\'e9m: \ldblquote ; \line 23 std: :copy( vl.beginQ, vl.endO, output ); \line 24 cout \'ab \\nVector v2 cont\'e9m: \line 25 std::copy( v2.beginO, v2.endO, output ); \line 26 \line 27 std::vector< int > results( vl.size() ); \line 28 std: : copy_backward( vi .beginO, vi .end, results .end() ); \line 29 cout \'ab \ldblquote\\n\\nAp\'f3s copybackward, resuits cont\'e9m: \ldblquote ; \line 30 std::copy( results.begin, results.endO, output ); \line 31 \line 32 std::vector< int > resuits2( vl.size() + v2.size() ); \line 33 std: :merge( vl.beginO, vl.endQ, v2.beginO, v2.endO, \line 34 results2.begin() ); \line 35 cout \'ab \ldblquote\\n\\nAp\'f3s intercala\'e7\'e3o de vi e v2, resuits2 cont\'e9m:\\n\rquote ; \line 36 std::copy( results2.begin, results2.endQ, output ); \line 37 \line 38 std: :vector< int >: :iterator endLocation; \line 39 endLocation = \line 40 std: :unique( resuits2 .beginO, resuits2.end() ); \line 41 cout \'ab \ldblquote\\n\\nAp\'f3s unique, results2 cont\'e9m:\\n\rdblquote ; \line 42 std::copy( resuits2.begin, endLocation, output ); \line 43 \line 44 cout \'ab \ldblquote\\n\\nVector vi ap\'f3s reverse: ; \line 45 std: :reverse( vi.beginQ, vi.end() ); \line 46 std: :copy( vi.begin(), vi.endO, output ); \line 47 \line 48 cout \'ab endi; \line 49 return 0; \line 50 \} \line Vector vi cont\'e9m: 1 3 5 7 9 \line Vector v2 cont\'e9m: 2 4 5 7 9 \line Ap\'f3s copybackward, resuits cont\'e9m: 1 3 5 7 9 \line Ap\'f3s intercala\'e7\'e3o de vi e v2, results2 cont\'e9m: \line 1234557799 \line Ap\'f3s unique, results2 cont\'e9m: \line 1234579 \line Vector vi ap\'f3s reverse: 9 7 5 3 1 \line Fig. 20.33 Demonstrando copy backward, merge, unique e reverse (parte 2 de 2). \line A linha 28 \line std: :copybackward( vi .beginO, vi .endO, results .end() ); \line usa a fun\'e7\'e3o copy_backward para copiar elementos no intervalo vi . begin () at\'e9, mas n\'e3o incluindo, vi . end O no vector vi e colocar os elementos no vector results come\'e7ando do elemento antes de results . end () \par
974 C++ COMO PROGRAMAR \line e trabalhando em dire\'e7\'e3o ao come\'e7o do vector. A fun\'e7\'e3o retorna um iterador posicionado no \'faltimo elemento copiado para o vector resuits (isto \'e9, o come\'e7o de resuits, porque estamos indo para tr\'e1s). Os elementos s\'e3o colocados em resuits na mesma ordem que cmvi. Esta fun\'e7\'e3o requer tr\'eas argumentos iteradores bidirecionais (iteradores que podem ser incrementados e decrementados para percorrer uma seq\'fc\'eancia para frente e para tr\'e1s, respectivamente). A principal diferen\'e7a entre copy e copy backward \'e9 que o iterador retornado de copy \'e9 posicionado ap\'f3s o \'faltimo elemento copiado e o iterador retornado de copy_backward \'e9 posicionado no \'faltimo elemento copiado (que \'e9, na verdade, o primeiro elemento na seq\'fc\'eancia). Al\'e9m disso, copy tamb\'e9m requer dois iteradores de entrada e um iterador de sa\'edda como argumentos. \line As linhas 33 e 34 \line std: :merge( vi .beginO, vi .endO, v2 .beginO, v2 .end, \line results2.begin() ); \line usam a fun\'e7\'e3o merge para intercalar duas seq\'fc\'eancias de valores classificados em ordem ascendente em uma terceira seq\'fc\'eancia classificada em ordem ascendente. A fun\'e7\'e3o requer cinco iteradores como argumentos. Os quatro primeiros argumentos devem ser no m\'ednimo iteradores de entrada e o \'faltimo argumento deve ser no m\'ednimo um iterador de sa\'edda. Os dois primeiros argumentos especificam o intervalo de elementos na primeira seq\'fc\'eancia ordenada (vi), os dois segundos argumentos especificam o intervalo de elementos na segunda seq\'fc\'eancia ordenada (v2) e o \'faltimo argumento especifica a posi\'e7\'e3o inicial na terceira seq\'fc\'eancia (resuits2) onde os elementos ser\'e3o intercalados. Uma segunda vers\'e3o dessa fun\'e7\'e3o aceita como seu quinto argumento uma fun\'e7\'e3o predicado bin\'e1ria que especifica a ordem de classifica\'e7\'e3o. \line Note que a linha 32 cria o vector resuits com o n\'famero de elementos vi. size () + v2 . size O. Usar a fun\'e7\'e3o merge como mostrado aqui requer que a seq\'fc\'eancia na qual os resultados ser\'e3o armazenados seja no m\'ednimo do tamanho das duas seq\'fc\'eancias que est\'e3o sendo intercaladas. Se n\'e3o se quiser alocar o n\'famero de elementos para a seq\'fc\'eancia resultante antes da opera\'e7\'e3o merge. pode-se usar as seguintes declara\'e7\'f5es: \line vector< int > resuits2O; \line merge ( v1.begin, vl.endO, v2.beginO, v2.endO, \line backinserter( resuits2 ) ); \line O argumento back inserter ( resuits2 ) usa a fun\'e7\'e3o gabarito back_inserter (arquivo de cabe\'e7alho <iterator>) para o cont\'eainer resuits2. Uma back_inserter chama a fun\'e7\'e3o push back default do cont\'eainer para inserir um elemento no final do cont\'eainer. Mais importante, se um elemento \'e9 inserido em um cont\'eainer que n\'e3o tem mais elementos dispon\'edveis, o cont\'eainer cresce em tamanho. Portanto, o n\'famero de elementos no cont\'eainer n\'e3o precisa ser conhecido antecipadamente. H\'e1 outras duas fun\'e7\'f5es de inser\'e7\'e3o - front_inserter (para inserir um elemento no come\'e7o de um cont\'eainer especificado como seu argumento) e inserter (para inserir um elemento antes de um iterador fornecido como seu segundo argumento no cont\'eainer fornecido como seu primeiro argumento). \line As linhas 39 e 40 \line endLocation = \line std: :unique( resuits2.begin, resuits2.end() ); \line usam a fun\'e7\'e3o unique sobre a seq\'fc\'eancia classificada de elementos no intervalo resuits2 . begin O at\'e9, mas n\'e3o incluindo, resuits2 . end O no vector resuits2. Ap\'f3s essa fun\'e7\'e3o haver sido aplicada a uma seqti\'eancia ordenada com valores duplicados, somente uma \'fanica c\'f3pia de cada valor permanece na seq\'fc\'eancia. A fun\'e7\'e3o recebe dois argumentos que precisam ser no m\'ednimo iteradores para a frente. A fun\'e7\'e3o retorna um iterador posicionado ap\'f3s o \'faltimo elemento na seq\'fc\'eancia de valores \'fanicos. Os valores de todos os elementos no cont\'eainer ap\'f3s o \'faltimo valor \'fanico s\'e3o indefinidos. Uma segunda vers\'e3o dessa fun\'e7\'e3o recebe como um terceiro argumento uma fun\'e7\'e3o predicado bin\'e1ria especificando como comparar dois elementos quanto \'e0 igualdade. \line A linha 45 \line std: :reverse( vi.beginO, vi.end() ); \par
CAP\'cdTULO 20 - A BIBLIOTECA PADR\'c3O DE GABARITOS (STL) 975 \line usa a fun\'e7\'e3o reverse para colocar em ordem inversa todos os elementos no intervalo vi . begin () at\'e9, mas n\'e3o incluindo, vi . end () no vector vi. A fun\'e7\'e3o recebe dois argumentos que devem ser no m\'ednimo iteradores bidirecionais. \line 20.5.9 inplace merge, unique_copy e reverse_copy \line O programa da Fig. 20.34 demonstra as fun\'e7\'f5es inpiace merge, unique copy e reverse copy da biblioteca padr\'e3o. [Nota: o programa a seguir n\'e3o compila no Borland C++j. \line 1 II Fig. 20.34: fig2034.cpp \line 2 II Demonstra diversas fun\'e7\'f5es: \line 3 // inpiacemerge, reverse_copy e unique_copy. \line 4 #include <iostream> \line 5 \line 6 using std::cout; \line 7 using std::endi; \line 8 \line 9 #include <aigorithni> \line 10 #inciude <vector> \line 11 #include <iterator> \line 12 \line 13 int main() \line 14 \{ \line 15 const int SIZE = 10; \line 16 intal[SIZE]=\{1, 3,5,7,9,1,3,5,7, 9\}; \line 17 std::vector< int > vi( ai, ai + SIZE ); \line 18 \line 19 std: :ostreamiterator< int > output( cout, \ldblquote  \ldblquote  \line 20 \line 21 cout \'ab \ldblquote Vector vi cont\'e9m: \line 22 std::copy( v1.begin, vl.endO, output ); \line 23 \line 24 std: :inpiace_merge( vl.begmnO), vl.begin() + 5, vi.end() ); \line 25 cout \'ab \ldblquote\\nApos inpiacemerge, vi cont\'e9m: \ldblquote ; \line 26 std::copy( vl.beginQ, vi.end(), output ); \line 27 \line 28 std::vector< int > resuitsl; \line 29 std: :unique_copy( vl.beginO), vl.endO), \line 30 std::back_inserter( resuitsi ) ); \line 31 cout \'ab \ldblquote\\nAp\'f3s uniquecopy, resuitsi cont\'e9m: \line 32 std::copy( resuitsl.beginQ, resuitsi.end, output ); \line 33 \line 34 std::vector< int > results2; \line 35 cout \'ab \ldblquote\\nAp\'f3s reversecopy, resuits2 cont\'e9m: \ldblquote ; \line 36 std: :reverse_copy( vi.beginO), vl.endO), \line 37 std::backinserter( resuits2 ) ); \line 38 std::copy( resuits2.beginO), resuits2.endO, output ); \line 39 \line 40 cout \'ab endi; \line 41 return 0; \line 42 \line Vector vi cont\'e9m: i 3 5 7 9 1 3 5 7 9 \line Ap\'f3s inpiacemerge, vi cont\'e9m: 1 1 3 3 5 5 7 7 9 9 \line Ap\'f3s uniquecopy, resuitsi cont\'e9m: 1 3 5 7 9 \line Ap\'f3s reverse_copy, resuits2 cont\'e9m: 9 9 7 7 5 5 3 3 1 1 \line Fig. 20.34 Demonstrando inpiace_merge, unique_copy e reverse_copy. \par
CAP\'cdTULO 20 A BIBLIOTECA PADR\'c3O DE GABARITOS (STL) 977 \line 1 II Fig. 20.35: fig2035.cpp \line 2 // Demonstra as fun\'e7\'f5es includes, set_difference, \line 3 II set_intersection, setsymmetricdifference e set_union. \line 4 #include <iostream> \line 5 \line 6 using std::cout; \line 7 using std::endl; \line 8 \line 9 #inciude <algorithm> \line 10 \line ii int main() \line 12 \{ \line 13 const int SIZE1 = 10, SIZE2 = 5, SIZE3 = 20; \line 14 intai[SIZE1] =\{i, 2,3,4,5,6,7,8,9, iO\}; \line 15 inta2[SIZE2]\{4,5,6,7,8\}; \line 16 int a3[ SIZE2 ] = \{ 4, 5, 6, li, 15 \}; \line 17 std: :ostreamiterator< int > output( cout, \ldblquote  ); \line 18 \line 19 cout \'ab \ldblquote ai cont\'e9m: \ldblquote ; \line 20 std::copy( ai, ai + SIZEi, output ); \line 21 cout \'ab \\na2 cont\'e9m: \lquote ; \line 22 std: :copy( a2, a2 + SIZE2, output ); \line 23 cout \'ab \ldblquote\\na3 cont\'e9m: ; \line 24 std::copy( a3, a3 + SIZE2, output ); \line 25 \line 26 if ( std::includes( ai, ai + SIZE1, a2, a2 + SIZE2 \line 27 cout \'ab \ldblquote\\nai inclui a2\rquote ; \line 28 else \line 29 cout \'ab \ldblquote\\nai n\'e3o inclui a2\rdblquote ; \line 30 \line 31 if ( std::includes( ai, ai + SIZEi, a3, a3 + SIZE2 \line 32 cout \'ab \ldblquote\\nal inclui a3\rquote ; \line 33 else \line 34 cout \'ab \ldblquote\\nai n\'e3o inclui a3\rdblquote ; \line 35 \line 36 int difference[ SIZE1 ]; \line 37 int *ptr = std::setdifference( ai, ai + SIZE1, \line 38 a2, a2 + SIZE2, difference ); \line 39 cout \'ab \ldblquote\\nsetdifference de ai e a2 \'e9: \line 40 std: :copy( difference, ptr, output ); \line 41 \line 42 int intersection[ SIZE1 ]; \line 43 ptr = std::setintersection( ai, ai + SIZE1, \line 44 a2, a2 + SIZE2, intersection ); \line 45 cout \'ab \ldblquote\\nsetintersection de ai e a2 \'e9: \line 46 std::copy( intersection, ptr, output ); \line 47 \line 48 int symmetricdifference[ SIZEi ]; \line 49 ptr = std::setsymmetricdifference( ai, ai + SIZE1, \line 50 a2, a2 + SIZE2, syinmetricdifference ); \line 51 cout \'ab \lquote\\nsetsymmetricdifference de ai e a2 \'e9: \line 52 std::copy( symmetricdifference, ptr, output ); \line 53 \line 54 int unionSet[ SIZE3 ); \line 55 ptr = std::set_union( ai, ai + SIZE1, \line 56 a3, a3 + SIZE2, unionSet ); \line 57 cout \'ab \lquote\\nsetunion de ai e a3 \'e9: \line Fig. 20.35 Demonstrando as opera\'e7\'f5es set da biblioteca padr\'e3o (parte 1 de 2). \par
978 C++ COMO PROGRAMAR \par
58 std::copy( unionSet, ptr, output ); \line 59 cout \'ab endi; \line 60 return 0; \line 61 \line ai cont\'e9m: 1 2 3 4 5 6 7 8 9 10 \line a2 cont\'e9m: 4 5 6 7 8 \line a3 cont\'e9m: 4 5 6 ii 15 \line ai inciui a2 \line ai n\'e3o inciui a3 \line setdifference de ai e a2 \'e9: 1 2 3 9 10 \line setintersection de ai e a2 \'e9: 4 5 6 7 8 \line setsymmetricdifference de ai e a2 \'e9: 1 2 3 9 10 \line set_uniondeai ea3 \'e9: 123456789 iO ii i5 \line Fig. 20.35 Demonstrando as opera\'e7\'f5es set da biblioteca padr\'e3o (parte 2 de 2). \line As linhas 37 e 38 \line int *ptr = std::setdifference( ai, ai + SIZE1, \line a2, a2 + SIZE2, difference ); \line usam a fun\'e7\'e3o set_difference para determinar os elementos do primeiro conjunto de valores ordenados que : n\'e3o est\'e3o no segundo conjunto de valores ordenados (os dois conjuntos de valores devem estar em ordem ascendente). Os elementos que s\'e3o diferentes s\'e3o copiados no quinto argumento (neste caso, o array difference). Os dois primeiros argumentos iteradores devem ser no m\'ednimo iteradores de entrada para o primeiro conjunto de valores. Os pr\'f3ximos dois argumentos iteradores devem ser no m\'ednimo iteradores de entrada para o segundo conjunto de valores. O quinto argumento deve ser no m\'ednimo um iterador indicando onde armazenar uma c\'f3pia dos valores que s\'e3o diferentes. A fun\'e7\'e3o retorna um iterador de entrada posicionado imediatamente ap\'f3s o \'faltimo valor copiado no conjunto para o qual o quinto argumento aponta. Uma segunda vers\'e3o da fun\'e7\'e3o set difference aceita um sexto argumento que \'e9 uma fun\'e7\'e3o predicado bin\'e1ria indicando a ordem na qual os elementos foram originalmente classificados. As duas seq\'fc\'eancias devem estar ordenadas usando-se a mesma fun\'e7\'e3o de compara\'e7\'e3o. \line A linha 43 e 44 \line ptr = std::setintersection( ai, ai + SIZEi, \line a2, a2 + SIZE2, intersection ); \line usam a fun\'e7\'e3o set intersection para determinar os elementos do primeiro conjunto de valores ordenados que est\'e3o no segundo conjunto de valores ordenados (os dois conjuntos de valores devem estarem ordem ascendente). Os elementos comuns a ambos os conjuntos s\'e3o copiados para dentro do quinto argumento (neste caso, o array intersection). Os dois primeiros argumentos iteradores devem ser no m\'ednimo iteradores de entrada para o primeiro conjunto de valores. Os dois argumentos iteradores seguintes devem ser no m\'ednimo iteradores de entrada para o segundo conjunto de valores. O quinto argumento deve ser no m\'ednimo um iterador de sa\'edda indicando onde armazenar a c\'f3pia dos valores que s\'e3o diferentes. A fun\'e7\'e3o retorna um iterador posicionado imediatamente ap\'f3s o \'faltimo valor copiado para o conjunto para o qual o quinto argumento aponta. Uma segunda vers\'e3o da fun\'e7\'e3o set_intersection recebe um sexto argumento que \'e9 uma fun\'e7\'e3o predicado bin\'e1ria indicando a ordem na qual os elementos estavam originalmente classificados. As duas seq\'fc\'eancias devem estar ordenadas usando a mesma fun\'e7\'e3o de compara\'e7\'e3o. \line As linhas 49 e 50 \line ptr = std::setsymmetricdifference( ai, ai + SIZE1, \line a2, a2 + SIZE2, symmetricdifference ); \line usam a fun\'e7\'e3o set symmetricdifference para determinar os elementos no primeiro conjunto que n\'e3o estejam no segundo conjunto e os elementos no segundo conjunto que n\'e3o est\'e3o no primeiro conjunto (os dois \par
CAP\'cdTULO 20 - A BIBLIOTECA PADR\'c3O DE GABARITOS (STL) 979 \par
conjuntos de valores devem estarem ordem ascendente). Os elementos que s\'e3o diferentes s\'e3o copiados de ambos os conjuntos para dentro do quinto argumento (neste caso, o arranjo symmetric_difference). Os dois primeiros argumentos iteradores devem ser no m\'ednimo iteradores de entrada para o primeiro conjunto de valores. Os dois argumentos iteradores seguintes devem ser no m\'ednimo iteradores de entrada para o segundo conjunto de valores. O quinto argumento deve ser no m\'ednimo um iterador indicando onde armazenar a c\'f3pia dos valores que s\'e3o diferentes. A fun\'e7\'e3o retorna um iterador posicionado imediatamente ap\'f3s o valor copiado para dentro do conjunto para o qual quinto argumento aponta. Uma segunda vers\'e3o da fun\'e7\'e3o set symmetric_difference recebe um sexto argumento que \'e9 uma fun\'e7\'e3o predicado bin\'e1ria indicando a ordem na qual os elementos estavam originalmente classificados. As duas seq\'fc\'eancias devem estar classificadas usando a mesma fun\'e7\'e3o de compara\'e7\'e3o. \line As linhas 55 e 56 \line ptr = std::set_union( ai, ai + SIZE1, \line a3, a3 + SIZE2, unionSet ); \line usam a fun\'e7\'e3o set_union para criar um conjunto de todos os elementos que est\'e3o em um, ou em outro ou nos dois conjuntos ordenados (os dois conjuntos de valores devem estar em ordem ascendente). Os elementos s\'e3o copiados de ambos os conjuntos para o quinto argumento (neste caso, o array unionSet). Elementos que aparecem em ambos os conjuntos s\'e3o somente copiados do primeiro conjunto. Os dois primeiros argumentos devem ser no m\'ednimo iteradores de entrada para o primeiro conjunto de valores. Os dois argumentos devem ser no m\'ednimo iteradores de entrada para o segundo conjunto de valores. O quinto argumento deve ser no m\'ednimo um iterador de sa\'edda indicando onde armazenar os elementos copiados. A fun\'e7\'e3o retoma um iterador de sa\'edda posicionado imediatamente ap\'f3s o \'faltimo valor copiado no conjunto para o qual o quinto argumento aponta. A segunda vers\'e3o da fun\'e7\'e3o set_union recebe um sexto argumento que \'e9 uma fun\'e7\'e3o predicado bin\'e1ria indicando a ordem em que os elementos estavam originalmente classificados. As duas seq\'fc\'eancias devem estar ordenadas usando-se a mesma fun\'e7\'e3o de compara\'e7\'e3o. \line 20.5.11 lower bound, upper_bound e equal_range \line A Fig. 20.36 demonstra as fun\'e7\'f5es lower bound, upper_bound e equal range da biblioteca padr\'e3o. \line 1 II Fig. 20.36: fig2036.cpp \line 2 // Demonstra iowerbound, upper_bound e equal range \line 3 II para uma seq\'fc\'eancia de valores ordenados. \line 4 #include <iostream> \line 5 \line 6 using std::cout; \line 7 using std::endi; \line 8 \line 9 #inciude <algorithin> \line 10 #include <vector> \line ii \line 12 int main() \line 13 \line 14 const int SIZE = 10; \line 15 intai[)\{2, 2,4,4,4,6,6,6,6,8); \line 16 std::vector< int > v( ai, ai + SIZE ); \line 17 std: :ostreamiterator< int > output( cout, \ldblquote  \lquote  ); \line 18 \line 19 cout \'ab \lquote Vector v cont\'e9m:\\n\rdblquote ; \line 20 std: :copy( v.begmnO, v.endQ, output ); \line 21 \line 22 std: :vector< int >: :iterator lower; \line 23 lower = std::iower_bound( v.begmnO), v.endO, 6 ); \line 24 cout \'ab \ldblquote\\n\\nLimite inferior de 6 \'e9 o elemento \line 25 \'ab ( iower - v.begmn() ) \'ab \ldblquote  do vector v\rdblquote ; \par
Fig. 20.36 Demonstrando iower bound, upper bound e equal range (parte 1 de 2). \par
980 C++ COMO PROGRAMAR \line 26 \line 27 std: :vector< int >: :iterator upper; \line 28 upper = std: :upper_bound( v.beginO, v.endQ, 6 ); \line 29 cout \'ab \ldblquote\\nLimite superior de 6 \'e9 o elemento \line 30 \'ab ( upper - v.begin() ) \'ab \ldblquote  do vector v\rdblquote ; \line 31 \line 32 std::pair< std::vector< int >::iterator, \line 33 std: :vector< int >: :iterator > eq; \line 34 eq = std::equal_range( v.begin, v.endO, 6 ); \line 35 cout \'ab \ldblquote\\ntjsando equal_range:\\n\rdblquote  \line 36 \'ab \ldblquote  Limite inferior de 6 \'e9 o elemento \line 37 \'ab ( eq.first - v.begin() ) \'ab \ldblquote  do vector v\rdblquote ; \line 38 cout \'ab \ldblquote\\n Limite superior de 6 \'e9 o elemento \line 39 \'ab ( eq.second - v.begin() ) \'ab \ldblquote  do vector v\rdblquote ; \line 40 \line 41 cout \'ab \ldblquote\\n\\nUsando lowerbound para localizar o primeiro ponto\\n\rdblquote  \line 42 \'ab \ldblquote no qual 5 pode ser inserido em ordem\rdblquote ; \line 43 lower = std::lowerbound( v.begin, v.endO, 5 ); \line 44 cout \'ab \ldblquote\\n Limite inferior de 5 \'e9 o elemento \line 45 \'ab ( lower - v.begin() ) \'ab \ldblquote  do vector v\rdblquote ; \line 46 \line 47 cout \'ab \ldblquote\\n\\nUsando upper bound para localizar o \'faltimo ponto\\n\rdblquote  \line 48 \'ab \ldblquote no qual 7 pode ser inserido em ordem\rdblquote ; \line 49 upper = std::upperbound( v.beginO, v.endO, 7 ); \line 50 cout \'ab \ldblquote\\n Limite superior de 7 \'e9 o elemento \line 51 \'ab ( upper - v.begin() ) \'ab \ldblquote  do vector v\rdblquote ; \line 52 \line 53 cout \'ab \ldblquote\\n\\nUsando equal_range para localizar o primeiro e o\\n\rdblquote  \line 54 \'ab \ldblquote\'faltimo ponto nos quais 5 pode ser inserido em ordem\rdblquote ; \line 55 eq = std::equal_range( v.begin, v.endO, 5 ); \line 56 cout \'ab \ldblquote\\n Limite inferior de 5 \'e9 o elemento \line 57 \'ab ( eq.first - v.begin() ) \'ab \ldblquote  do vector v\rdblquote ; \line 58 cout \'ab \ldblquote\\n Limite superior de 5 \'e9 o elemento \line 59 \'ab ( eq.second - v.begin() ) \'ab \ldblquote  do vector v\rdblquote  \line 60 \'ab endl; \line 61 return 0; \line 62 \line Vector v cont\'e9m: \line 2244466668 \line Limite inferior de 6 \'e9 o elemento 5 do vector v \line Limite superior de 6 \'e9 o elemento 9 do vector v \line Usando equal_range: \line Limite inferior de 6 \'e9 o elemento 5 do vector v \line Limite superior de 6 \'e9 o elemento 9 do vector v \line Usando lower_bound para localizar o primeiro ponto \line no qual 5 pode ser inserido em ordem \line Limite inferior de 5 \'e9 o elemento 5 do vector v \line Usando upper_bound para localizar o \'faltimo ponto \line no qual 7 pode ser inserido em ordem \line Limite superior de 7 \'e9 o elemento 9 do vector v \line Usando equal_range para localizar o primeiro e o \line ultimo ponto nos quais 5 pode ser inserido em ordem \line Limite inferior de 5 \'e9 o elemento 5 do vector v \line Limite superior de 5 \'e9 o elemento 5 do vector v \line Fig. 20.36 Demonstrando lower bound, upper bound e equal range (parte 2 de 2). \par
CAP\'cdTULO 20 - A BIBLIOTECA PADR\'c3O DE GABARITOS (STL) 981 \par
A linha 23 \line lower = std: :lower_bound( v.beginO, v.endO, 6 ); \line usa a fun\'e7\'e3o lower bound para determinar a primeira posi\'e7\'e3o em uma seq\'fc\'eancia de valores ordenados na qual o terceiro argumento poderia ser inserido na seq\'fc\'eancia. de modo que, ainda assim, a seq\'fc\'eancia estaria classificada em ordem ascendente. Os dois primeiros argumentos iteradores devem ser no m\'ednimo iteradores para a frente. O terceiro argumento \'e9 o valor para o qual se quer determinar o limite inferior. A fun\'e7\'e3o retorna um iterador para a frente apontando para a posi\'e7\'e3o onde a inser\'e7\'e3o pode ocorrer. Uma segunda vers\'e3o da fun\'e7\'e3o lower bound aceita como um quarto argumento uma fun\'e7\'e3o predicado bin\'e1ria indicando a ordem na qual os elementos estavam originalmente classificados. \line A linha 28 \line upper = std::upper_bound( v.beginO, v.endO, 6 ); \line usa a fun\'e7\'e3o upper_bound para determinar a \'faltima posi\'e7\'e3o em uma seq\'fc\'eancia ordenada de valores na qual o terceiro argumento poderia ser inserido na seq\'fc\'eancia, de modo que, ainda assim, a seq\'fc\'eancia estaria classificada em ordem ascendente. Os dois primeiros argumentos iteradores devem ser no m\'ednimo iteradores para a frente. O terceiro argumento \'e9 o valor para o qual se quer determinar o limite superior. A fun\'e7\'e3o retorna um iterador para a frente apontando para a posi\'e7\'e3o na qual a inser\'e7\'e3o pode ocorrer. Uma segunda vers\'e3o da fun\'e7\'e3o upper bound aceita como quarto argumento uma fun\'e7\'e3o predicado bin\'e1ria indicando a ordem na qual os elementos estavam original- mente classificados. \line A linha 34 \line eq = std::equal_range( v.begin, v.endO, 6 ); \line usa a fun\'e7\'e3o equal range para retornar um pair de iteradores para a frente contendo os resultados combinados de executar tanto uma opera\'e7\'e3o lower bound como uma upper_bound. Os dois primeiros argumentos iteradores devem ser iteradores para a frente. O terceiro argumento \'e9 o valor ao qual se quer aplicar equal range. A fun\'e7\'e3o retorna um pair de iteradores para o limite inferior (eq. first) e o limite superior (eq. second), respectiva- mente. \line As fun\'e7\'f5es lower bound, upper bound e equal range s\'e3o freq\'fcentemente usadas para determinar \line a posi\'e7\'e3o de inser\'e7\'e3o em seq\'fc\'eancias ordenadas. A linha 40 usa lower_bound para localizar o primeiro ponto no \line qual 5 pode ser inserido na ordem em v. A linha 46 usa upper bound para localizar o \'faltimo ponto no qual 7 \line pode ser inserido na ordem em v. A linha 52 usa equal range para localizar o primeiro e \'faltimo pontos no qual \line 5 pode ser inserido na ordem em v. \line 20.5.12 Heapsort \line A Fig. 20.37 demonstra as fun\'e7\'f5es da Biblioteca Padr\'e3o para executar o algoritmo de classifica\'e7\'e3o heapsort. Heapsort \'e9 um algoritmo de classifica\'e7\'e3o no qual um array de elementos \'e9 organizado em uma \'e1rvore bin\'e1ria especial chamada de heap. O fator-chave para o bom desempenho de um heap \'e9 que o maior elemento esteja sempre no topo do heap e os valores dos filhos de qualquer nodo na \'e1rvore bin\'e1ria sejam sempre menores que ou iguais ao valor daquele nodo. Um heap organizado desta maneira \'e9 freq\'fcentemente chamado de maxheap. O heapsort \'e9 geralmente estudado em disciplinas de Ci\'eancia da Computa\'e7\'e3o chamadas de \ldblquote Estruturas de dados\rdblquote  e \ldblquote Algoritmos.\rdblquote  \par
Fig. 20.37 Usando fun\'e7\'f5es da biblioteca padr\'e3o para executar um heapsort (parte 1 de 3). \par
\pard\par
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx205\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx5960\pard\intbl 1 \cell II Fig. 20.37: fig20_37.cpp \cell\row
\intbl 2 \cell // Demonstrando push_heap, pop_heap, make_heap e sort_heap. \cell\row
\intbl 3 \cell #include <iostream> \cell\row
\intbl 4 \cell\cell\row
\intbl 5 \cell using std: :cout; \cell\row
\pard\par
\pard\sb100\sa240 982 C++ COMO PROGRAMAR \line 6 using std::endl; \line 7 \line 8 #include <algorithm> \line 9 #include <vector> \line 10 \line 11 int main() \line 12 \line 13 const int SIZE = 10; \line 14 int a[ SIZE ) = \{ 3, 100, 52, 77, 22, 31, 1, 98, 13, 40 ); \line 15 int i; \line 16 std: :vector< int > v( a, a + SIZE ), v2; \line 17 std: :ostream jterator< int > output( cout, \ldblquote  \ldblquote  ); \line 18 \line 19 cout \'ab \ldblquote Vector v antes de make_heap:\\n\rdblquote ; \line 20 std: :copy( v.beginO, v.end(), output ); \line 21 std::make_heap( v.beginQ, v.endO ); \line 22 cout \'ab \ldblquote\\nVector v ap\'f3s make_heap:\\n\rdblquote ; \line 23 std: :copy( v.beginO), v.endO, output ); \line 24 std: :sort_heap( v.begmn() , v.end() ); \line 25 cout \'ab \ldblquote\\nVector v ap\'f3s sort_heap:\\n\rdblquote ; \line 26 std: :copy( v.begin, v.endO, output ); \line 27 \line 28 // executa o heapsort com push_heap e pop_heap \line 29 cout \'ab \ldblquote\\n\\nArray a cont\'e9m: \line 30 std: :copy( a, a \'f7 SIZE, output ); \line 31 \line 32 for ( i = 0; i < SIZE; ++i \line 33 v2.push_back( a[ i 1 ); \line 34 std: :push_heap( v2 .begmnO), v2 .end() ); \line 35 cout \'ab \ldblquote\\nv2 ap\'f3s push_heap(a[\rdblquote  \'ab i \'ab \ldblquote 1): \line 36 std::copy( v2.beginO), v2.end(), output ); \line 37 \line 38 \line 39 for ( i = 0; i < v2.sizeQ; ++i \line 40 cout \'ab \ldblquote\\nv2 ap\'f3s \ldblquote  \'ab v2[ O ] \'ab \ldblquote  ser retirado do heap\\n\rdblquote ; \line 41 std::pop_heap( v2.begmnQ, v2.endO - i ); \line 42 std::copy( v2.begmn, v2.end(), output ); \line 43 \} \line 44 \line 45 cout \'ab endi; \line 46 return 0; \line 47 \} \line Vector v antes de make_heap: \line 3 100 52 77 22 31 1 98 13 40 \line Vector v ap\'f3s make_heap: \line 100 98 52 77 40 31 1 3 13 22 \line Vector v ap\'f3s sort_heap: \line 1 3 13 22 31 40 52 77 98 100 \line Array a cont\'e9m: 3 100 52 77 22 31 1 98 13 40 \line v2 ap\'f3s push heap(a[0]) : 3 \line v2 ap\'f3s pushheap(a[1]): 100 3 \line v2 ap\'f3s pushheap(a[2fl: 100 3 52 \line v2 ap\'f3s push_heap(a[3)): 100 77 52 3 \line Fig. 20.37 Usando fun\'e7\'f5es da biblioteca padr\'e3o para executar um heapsort (parte 2 de 3). \par
CAP\'cdTULO 20- A BIBLIOTECA PADR\'c3O DE GABARITOS (STL) 983 \par
v2 ap\'f3s pushheap(a[4]): 100 77 52 \line v2 ap\'f3s push_heap(a[5]): 100 77 52 \line v2 ap\'f3s push_heap(a[6]): 100 77 52 \line v2 ap\'f3s push_heap(a[7]): 100 98 52 \line v2 ap\'f3s pushheap(a[8]): 100 98 52 \line v2 ap\'f3s push heap(a[9]) : 100 98 52 \line v2 ap\'f3s 100 ser retirado do heap \line 98 77 52 22 40 31 1 3 13 100 \line v2 ap\'f3s 98 ser retirado do heap \line 77 40 52 22 13 31 1 3 98 100 \line v2 ap\'f3s 77 ser retirado do heap \line 52 40 31 22 13 3 1 77 98 100 \line v2 ap\'f3s 52 ser retirado do heap \line 40 22 31 1 13 3 52 77 98 100 \line v2 ap\'f3s 40 ser retirado do heap \line 31 22 3 1 13 40 52 77 98 100 \line v2 ap\'f3s 31 ser retirado do heap \line 22 13 3 1 31 40 52 77 98 100 \line v2 ap\'f3s 22 ser retirado do heap \line 13 1 3 22 31 40 52 77 98 100 \line v2 ap\'f3s 13 ser retirado do heap \line 3 1 13 22 31 40 52 77 98 100 \line v2 ap\'f3s 3 ser retirado do heap \line 1 3 13 22 31 40 52 77 98 100 \line v2 ap\'f3s 1 ser retirado do heap \line 1 3 13 22 31 40 52 77 98 100 \par
3 22 \line 3 22 31 \line 3 22 31 1 \line 77 22 31 1 3 \line 77 22 31 1 3 13 \line 77 40 31 1 3 13 22 \par
Fig. 20.37 Usando fun\'e7\'f5es da biblioteca padr\'e3o para executar um heapsort (parte 3 de 3). \par
A linha 21 \par
std: :make_heap( v.beginO, v.end() ); \par
usa a fun\'e7\'e3o make heap para obter uma seq\'fc\'eancia de valores no intervalo v . begin () at\'e9, mas n\'e3o incluindo, v . end () e criar um heap que pode ser usado para produzir uma seq\'fc\'eancia ordenada. Os dois argumentos devem ser iteradores de acesso aleat\'f3rio, de modo que esta fun\'e7\'e3o trabalhar\'e1 somente com arrays, vectors e deques. Uma segunda vers\'e3o desta fun\'e7\'e3o aceita como terceiro argumento uma fun\'e7\'e3o predicado bin\'e1ria para comparar valores. \par
A linha 24 \par
std: :sort_heap( v.beginO, v.end() \par
usa a fun\'e7\'e3o sort_heap para ordenar uma seq\'fc\'eancia de valores no intervalo v . begin () at\'e9, mas n\'e3o incluindo, v. end O que s\'e3o organizados em um heap. Os dois argumentos iteradores devem ser iteradores de acesso aleat\'f3rio. Uma segunda vers\'e3o dessa fun\'e7\'e3o aceita como terceiro argumento uma fun\'e7\'e3o predicado para comparar valores. \par
A linha 34 \par
std: :push_heap( v2 .begin, v2 .end() ); \par
usa a fun\'e7\'e3o push_heap para adicionar um novo valor a um heap. Tomamos um elemento do array a de uma vez, acrescentamos aquele elemento ao final do vector v2 e executamos a opera\'e7\'e3o push_heap. Se o elemento acrescentado \'e9 o \'fanico elemento no vector, o vector j\'e1 \'e9 um heap. Caso contr\'e1rio, a fun\'e7\'e3o pushheap rearranja os elementos do vector em um heap. Cada vez que push heap \'e9 chamada, ela assume que o \'faltimo \par
984 C++ COMO PROGRAMAR \par
elemento corrente do vector (isto \'e9, aquele que \'e9 acrescentado antes da chamada \'e0 fun\'e7\'e3o push heap) \'e9 o elemento que est\'e1 sendo acrescentado ao heap e que todos os outros elementos no vector est\'e3o organizados realmente como um heap. Os dois argumentos iteradores para push heap devem ser iteradores de acesso aleat\'f3rio. Uma segunda vers\'e3o dessa fun\'e7\'e3o aceita como terceiro argumento uma fun\'e7\'e3o predicado bin\'e1ria para comparar os valores. \line A linha 41 \line std::pop_heap( v2.begin, v2.end() - i ); \line usa pop_heap para remover o elemento do topo do heap. Essa fun\'e7\'e3o assume que os elementos no intervalo especificado por seus dois argumentos iteradores de acesso aleat\'f3rio j\'e1 s\'e3o um heap. Remover repetidamente o elemento do topo de um heap resulta em uma seq\'fc\'eancia de valores ordenados. A fun\'e7\'e3o pop_heap permuta o primeiro elemento do heap (v2 . begin O neste exemplo) com o \'faltimo elemento do heap (o elemento antes de v2 end () - i neste exemplo) e, ent\'e3o, assegura que os elementos at\'e9, mas n\'e3o incluindo, o \'faltimo elemento ainda formam um heap. Note na sa\'edda do programa que, ap\'f3s as opera\'e7\'f5es pop heap. o vector est\'e1 classificado em ordem ascendente. Uma segunda vers\'e3o dessa fun\'e7\'e3o aceita como terceiro argumento uma fun\'e7\'e3o predicado bin\'e1ria para comparar valores. \line 2O5.13 mm e max \line Os algoritmos mm e max determinam o m\'ednimo de dois elementos e m\'e1ximo de dois elementos, respectivamente. \line O programa da Fig. 20.38 demonstra mm e max para valores int e char, [Nota: o compilador Microsoft Visual \line C++ n\'e3o suporta os algoritmos mm e max da STL, porque entram em conflito com fun\'e7\'f5es do mesmo nome das \line Microsoft Foundation Classes - as classes reutiliz\'e1veis da Microsoft para cria\'e7\'e3o de aplicativos para Windows. O \line programa da Fig. 20.38 foi compilado com o Borland C++.j \line 1 II Fig. 20.38: fig2038.cpp \line 2 // Demonstrando mm e max \line 3 #include <iostream> \line 4 \line 5 using std::cout; \line 6 using std::endi; \line 7 \line 8 #include <algorithin> \line 9 \line 10 int main() \line 11 \line 12 cout \'ab \lquote O m\'ednimo de 12 e 7 \'e9: \line 13 \'ab std::min( 12, 7 ); \line 14 cout \'ab \ldblquote\\nO m\'e1ximo de 12 e 7 \'e9: \line 15 \'ab std::max( 12, 7 ); \line 16 cout \'ab \ldblquote\\nO m\'ednimo de \lquote G\rquote  e \lquote Z \'e9: \line 17 \'ab std::min( \lquote G\rquote , \lquote Z\rquote  ); \line 18 cout \'ab \ldblquote\\nO m\'e1ximo de \lquote G\rquote  e \lquote Z\rquote  \'e9: \line 19 \'ab std: :max( \lquote G\rquote , \lquote Z\rquote  ) \'ab endi; \line 20 return O; \line 21 \} \line Om\'ednimodel2e7\'e9: 7 \line O m\'e1ximo de 12 e 7 \'e9: 12 \line O m\'ednimo de \lquote G\rquote  e \lquote Z\rquote  \'e9: G \line O m\'e1ximo de \lquote G\rquote  e \lquote Z\rquote  \'e9: Z \par
Fig. 20.38 Demonstrando os algoritmos mm e max. \par
CAP\'cdTULO 20 - A BIBLIoTEcA PADR\'c3O DE GABARITOS (STL) 985 \par
20.5.14 Algoritmos n\'e3o-cobertos neste cap\'edtulo \line A Fig. 20.39 comenta os algoritmos que n\'e3o s\'e3o cobertos neste cap\'edtulo. \par
Algoritmo Descri\'e7\'e3o \par
inneryroduct Calcula a soma dos produtos de duas seq\'fc\'eancias tomando elementos correspondentes em cada seq\'fc\'eancia, multiplicando aqueles elementos e acumulando os resultados em um total. \line Come\'e7ando com o segundo elemento em uma seq\'fc\'eancia, calcula a diferen\'e7a (usando o operador-) entre o elemento corrente e o anterior e armazena o resultado. Os dois primeiros argumentos iteradores de entrada indicam o intervalo de elementos no cont\'eainer e o terceiro argumento iterador de sa\'edda indica onde os resultados devem ser armazenados. Uma segunda vers\'e3o deste algoritmo aceita como quarto argumento uma fun\'e7\'e3o para executar um c\'e1lculo usando o elemento corrente e o elemento anterior. \line Calcula um total acumulado (usando o operador +) dos valores em uma seq\'fc\'eancia. Os dois primeiros argumentos iteradores de entrada indicam o intervalo dos elementos no cont\'eainer e o iterador de sa\'edda especificado como terceiro argumento indica onde os resultados devem ser armazenados. Uma segunda vers\'e3o deste algoritmo aceita como quarto argumento uma fun\'e7\'e3o bin\'e1ria que executa um c\'e1lculo usando o valor corrente na seq\'fc\'eancia e o total acumulado atual. \line Usa tr\'eas iteradores de acesso aleat\'f3rio para particionar uma seq\'fc\'eancia de elementos. O primeiro e o \'faltimo argumentos representam o intervalo de elementos. O segundo argumento \'e9 a posi\'e7\'e3o do elemento particionador. Ap\'f3s esse algoritmo ser executado, todos os elementos \'e0 esquerda do elemento particionador s\'e3o menores do que aquele elemento e todos os elementos \'e0 direita do elemento particionador s\'e3o maiores que ou iguais \'e0quele elemento. Uma segunda vers\'e3o deste algoritmo aceita como quarto argumento uma fun\'e7\'e3o bin\'e1ria de compara\'e7\'e3o. \line Esse algoritmo \'e9 similar ao nth element. mas requer iteradores bidirecionais menos potentes, o que o torna mais flex\'edvel do que nth_element. O algoritmo partition requer dois iteradores bidirecionais indicando o intervalo dos elementos para particionamento. O terceiro elemento \'e9 uma fun\'e7\'e3o predicado un\'e1ria que ajuda a particionar os elementos de tal modo que todos os elementos na seq\'fc\'eancia para os quais o predicado \'e9 true est\'e3o \'e0 esquerda (em dire\'e7\'e3o ao come\'e7o da seq\'fc\'eancia) de todos os elementos para os quais o predicado \'e9 false. E retornado um iterador bidirecional, indicando o primeiro elemento na seq\'fc\'eancia para o qual a fun\'e7\'e3o predicado retorna false. \line stable_partition Este algoritmo \'e9 similar a partition. exceto pelo fato de que os elementos para os quais a fun\'e7\'e3o predicado retorna true s\'e3o mantidos em sua ordem original e elementos para os quais a fun\'e7\'e3o predicate retorna false s\'e3o mantidos em sua ordem original. \line next_yermutation Pr\'f3xima permuta\'e7\'e3o lexicogr\'e1fica de uma seq\'fc\'eancia. \line prevyermutation Permuta\'e7\'e3o lexicogr\'e1fica anterior de uma seq\'fc\'eancia. \line rotate Usa tr\'eas argumentos iteradores para a frente para girar a seq\'fc\'eancia indicada pelo \line primeiro e \'faltimo argumentos pelo n\'famero de posi\'e7\'f5es calculado subtraindo-se \line o primeiro argumento do segundo argumento. Por exemplo, a seq\'fc\'eancia 1, 2, 3, \line 4, 5 girada por duas posi\'e7\'f5es seria 4, 5, 1, 2, 3. \line rotatecopy Este algoritmo \'e9 id\'eantico a rotate. exceto pelo fato de que os resultados s\'e3o armazenados em uma seq\'fc\'eancia separada indicada pelo quarto argumento - um \line iterador de sa\'edda. As duas seq\'fc\'eancias devem ter o mesmo n\'famero de elementos. \par
adj acent_difference \line partialsum \line nthelement \line partition \par
Fig. 20.39 Algoritmos n\'e3o-cobertos neste cap\'edtulo (parte 1 de 2). \par
986 C++ COMO PROGRAMAR \par
Fig. 20.39 Algoritmos n\'e3o-cobertos neste cap\'edtulo (parte 2 de 2). \line 206 A classe bitset \line A classe bitset toma mais f\'e1cil criar e manipular bit sets (conjuntos de bits). Bit sets s\'e3o \'fateis para representar um conjunto de bits usados como indicadores (flags). O tamanho de um bitset \'e9 fixado durante a compila\'e7\'e3o. A declara\'e7\'e3o \par
bitset< size > b; \par
cria o bitset b, no qual cada bit \'e9 inicialmente 0. O comando \par
b.set( bitNuniber ); \par
coloca o bit n\'famero bitNumber do bitset b em 1. A express\'e3o b. set () coloca todos os bits de b em 1. O comando \line b.reset( bitNuinber ); \line coloca o bit n\'famero bitNumber do bitset b em O. A express\'e3o b. reset () coloca todos os bits de bem O. O \par
comando \par
b.flip( bitNumber ); \par
complementa o bit n\'famero bitNuinber do bitset b (por exemplo, se o bit \'e9 1. flip o coloca em O). A express\'e3o b. flip () complementa todos os bits de b. O comando \line b[ bitt4uinber ]; \line retorna uma refer\'eancia ao bit n\'famero bitNuniber do bitset b. Similarmente, \par
faz v\'e1l do \line faz ret ou \line ret \line ft\rquote t \par
ret \par
cor \par
cxc \par
exe \line O\rquote - \par
A \par
de \par
des \par
b.at( bitNuxtiber ); \par
\pard\par
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1297\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx8946\pard\intbl Algoritmo \cell Descri\'e7\'e3o \cell\row
\intbl adj acent f ind \cell Este algoritmo retorna um iterador de entrada indicando o primeiro de dois elementos adjacentes id\'eanticos em uma seq\'fc\'eancia. Se n\'e3o h\'e1 elementos adjacentes id\'eanticos, o iterador \'e9 posicionado na posi\'e7\'e3o end da seq\'fc\'eancia. \cell\row
\intbl partialsort \cell Usa tr\'eas iteradores de acesso aleat\'f3rio para ordenar parte de uma seq\'fc\'eancia. O primeiro e o \'faltimo argumentos indicam a seq\'fc\'eancia de elementos. O segundo argumento indica a posi\'e7\'e3o final para a parte ordenada da seq\'fc\'eancia. Por default, os elementos s\'e3o ordenados usando-se o operator < (uma fun\'e7\'e3o predicado bin\'e1ria pode ser tamb\'e9m fornecida). Os elementos do segundo argumento iterador at\'e9 o final da seq\'fc\'eancia ficam em uma ordem indefinida. \cell\row
\intbl partialsortcopy \cell Usa dois iteradores de entrada e dois iteradores de acesso aleat\'f3rio para classificar parte da seq\'fc\'eancia indicada pelos dois argumentos iteradores de entrada. Os resultados s\'e3o armazenados na seq\'fc\'eancia indicada pelos dois argumentos iteradores de acesso aleat\'f3rio. Por default, os elementos s\'e3o ordenados usando- se o operador < (uma fun\'e7\'e3o predicado bin\'e1ria tamb\'e9m pode ser fornecida). O n\'famero de elementos ordenados \'e9 o menor entre o n\'famero de elementos no resultado e o n\'famero de elementos na seq\'fc\'eancia original. \cell\row
\intbl stablesort \cell O algoritmo \'e9 similar ao sort exceto pelo fato de que todos os elementos iguais s\'e3o mantidos em sua ordem original. \cell\row
\pard\par
\pard\sb100\sa240 CAP\'cdTULO 20 - A BIBLIOTECA PADR\'c3O DE GABARITOS (STL) 987 \line faz uma verifica\'e7\'e3o de validade do bit n\'famero bitNumber primeiro. Ent\'e3o, sebitNumber est\'e1 no intervalo v\'e1lido, at retorna uma refer\'eancia ao bit. Caso contr\'e1rio, at dispara uma exce\'e7\'e3o out_of_range. O comando \line b.test( bitNunber ); \line faz uma verifica\'e7\'e3o de validade do bitNuinber primeiro. Ent\'e3o, se bitNuniber est\'e1 no intervalo v\'e1lido, test retorna true se o bit \'e9 igual a 1 e false se o bit \'e9 igual a 0. Caso contr\'e1rio, test dispara uma exce\'e7\'e3o out_of_range. A express\'e3o \line b.size() \line retorna o n\'famero de bits do bitset b. A express\'e3o \line b.count() \line retorna o n\'famero de bits que est\'e3o ligados (iguais a 1) no bitset b. A express\'e3o \line b . any O \line retorna true se qualquer bit est\'e1 ligado no bitset b. A express\'e3o \line b.none() \line retorna true se nenhum dos bits de bitset b est\'e1 ligado. As express\'f5es \line b == bi \line b != bi \line comparam os dois bitsets quanto \'e0 igualdade e desigualidade, respectivamente. \line Cada um dos operadores de atribui\'e7\'e3o sobre bits &=. = e = podem ser usados para combinar bitsets. Por \line exemplo, \line b & bi; \line executa um E l\'f3gico bit a bit entre os bitsets b e bi. O resultado \'e9 armazenado em b. O OU l\'f3gico bit a bit e o OU l\'f3gico exclusivo bit a bit (XOR) s\'e3o executados por \line b bi; \line b A b2; \line A express\'e3o \line b \'bb= n; \line desloca os bits em bitset b para a direita por n posi\'e7\'f5es. A express\'e3o \line b \'ab= n; \line desloca os bits em bitset b para a esquerda por n posi\'e7\'f5es. As express\'f5es \line b.tostring() \line b.to_ulong() \line converte o bitset b para um string e um unsigned ).ong, respectivamente. \par
9S C++ COMO PROGRAMAR \line A Fig. 20.40 revisita o Crivo de Erat\'f3stenes para encontrar os n\'fameros primos que comentamos no Exerc\'edcio 4.29. Um bitset \'e9 usado em lugar de um array para implementar o algoritmo. O programa exibe todos os n\'fameros de 2 a 1023 e ent\'e3o permite ao usu\'e1rio digitar um n\'famero para determinar se aquele n\'famero \'e9 primo. \line 1 II Fig. 20.40: fig2O4O.cpp \line 2 // Usando um bitset para demonstrar o Crivo de Erat\'f3stenes. \line 3 #include <iostream> \line 4 \line 5 using std::cin; \line 6 using std::cout; \line 7 using std: :endl; \line 8 \line 9 #include <iomanip> \line 10 \line 11 using std::setw; \line 12 \line 13 #include <bitset> \line 14 #include <cmath> \line 15 \line 16 int main() \line 17 \{ \line 18 const int size = 1024; \line 19 int i, value, counter; \line 20 std::bitset< size > sieve; \line 21 \line 22 sieve.flipO); \line 23 \line 24 // executa o Crivo de Erat\'f3stenes \line 25 int finalBit = sqrt( sieve.size() ) + 1; \line 26 \line 27 for ( i = 2; i < finalBit; ++i \line 28 if ( sieve.test( i \line 29 for ( int j = 2 * i; j < size; j += i \line 30 sieve.reset( j ); \line 31 \line 32 cout \'ab \ldblquote Os n\'fameros primos no intervalo de 2 a 1023 s\'e3o:\\n\rquote ; \line 33 \line 34 for ( i = 2, counter = 0; i < size; ++i \line 35 if ( sieve.test( i ) ) \{ \line 36 cout \'ab setw( 5 ) \'ab i; \line 37 \line 38 if ( ++counter % 12 == O \line 39 cout\'ab \lquote\\n; \line 40 \} \line 41 \line 42 cout \'ab endi; \line 43 \line 44 II obt\'e9m um valor digitado pelo usu\'e1rio para determinar se \'e9 primo \line 45 cout \'ab \ldblquote\\nDigite um valor de 2 a 1023 (-1 para terminar) : \ldblquote ; \line 46 cm \'bb value; \line 47 \line 48 while ( value -1 ) \{ \line 49 if ( sieve[ value 1 \line 50 cout \'ab value \'ab \ldblquote  \'e9 um n\'famero primo\\n; \line 51 else \line 52 cout \'ab value \'ab n\'e3o \'e9 um n\'famero primo\\n; \line Fig. 20.40 Demonstrando a classe bitset e o Crivo de Erat\'f3stenes (parte 1 de 2). \par
CAP\'cdTULO 20 - A BIBLIOTECA PADR\'c3O DE GABARITOS (STL) 989 \par
53 \line 54 cout \'ab \ldblquote\\nDigite um valor de 2 a 1023 (-1 para terminar) \par
59 1 \par
\} \par
cm \'bb value; \par
return 0; \par
Digite um valor de 2 a 1023 (-1 para terminar) : 389 389 \'e9 um numero primo \line Digite um valor de 2 a 1023 (-1 para terminar): 88 \line 88 n\'e3o \'e9 um numero primo \line Digite um valor de 2 a 1023 (-1 para terminar): -1 \par
Fig. 20.40 Demonstrando a classe bitset e o Crivo de Erat\'f3stenes (parte 2 de 2). \par
A linha 20 \par
std: :bitset< size > sieve; \par
cria um bitset de bits size (size \'e9 1024 neste exemplo). Ignoramos os bits nas posi\'e7\'f5es O e 1 neste programa. Por default, todos os bits no bitset s\'e3o colocados em zero. O c\'f3digo \par
// executa o Crivo de Erat\'f3stenes \line int finalBit = sqrt( sieve.size() ) + 1; \line for ( i = 2; i < finalBit; ++i \line if ( sieve.test( i \line for ( int j =2 * i; j < size; j +=i \par
sieve.reset( j \par
determina todos os n\'fameros primos de 2 a 1023. O inteiro finalBit \'e9 usado para determinar quando o algoritmo foi completado. O algoritmo b\'e1sico \'e9 que um n\'famero \'e9 primo se ele n\'e3o tem outros divisores al\'e9m de 1 e ele mesmo. Come\'e7ando com o n\'famero 2, uma vez que sabemos que um n\'famero \'e9 primo, podemos eliminar todos os m\'faltiplos daquele n\'famero. O n\'famero 2 \'e9 divis\'edvel somente por 1 e por ele mesmo, ent\'e3o ele \'e9 primo. Portanto, pode-se eliminar 4, 6, 8 e assim por diante. O n\'famero 3 \'e9 divis\'edvel somente por 1 e ele mesmo. Portanto, pode-se eliminar todos os m\'faltiplos de 3 (lembre-se de que todos os n\'fameros pares j\'e1 foram eliminados). \par
55 \line 56 \line 57 \line 58 \par
\pard\par
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx301\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1407\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2489\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx3571\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4172\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4965\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx5566\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx6071\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx6576\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx7081\pard\intbl Os \cell n\'fameros \cell primos no \cell intervalo \cell de 2 \cell a 1023 \cell s\'e3o: \cell\cell\cell\cell\row
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx301\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx806\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1407\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1948\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2489\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx3030\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx3571\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4172\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4965\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx5566\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx6071\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx6576\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx7081\pard\intbl\cell 2 \cell 3 \cell 5 \cell 7 \cell 11 \cell 13 \cell 17 \cell 19 \cell 23 \cell 29 \cell 31 \cell 37 \cell\row
\intbl\cell 41 \cell 43 \cell 47 \cell 53 \cell 59 \cell 61 \cell 67 \cell 71 \cell 73 \cell 79 \cell 83 \cell 89 \cell\row
\intbl\cell 97 \cell 101 \cell 103 \cell 107 \cell 109 \cell 113 \cell 127 \cell 131 \cell 137 \cell 139 \cell 149 \cell 151 \cell\row
\intbl\cell 157 \cell 163 \cell 167 \cell 173 \cell 179 \cell 181 \cell 191 \cell 193 \cell 197 \cell 199 \cell 211 \cell 223 \cell\row
\intbl\cell 227 \cell 229 \cell 233 \cell 239 \cell 241 \cell 251 \cell 257 \cell 263 \cell 269 \cell 271 \cell 277 \cell 281 \cell\row
\intbl\cell 283 \cell 293 \cell 307 \cell 311 \cell 313 \cell 317 \cell 331 \cell 337 \cell 347 \cell 349 \cell 353 \cell 359 \cell\row
\intbl\cell 367 \cell 373 \cell 379 \cell 383 \cell 389 \cell 397 \cell 401 \cell 409 \cell 419 \cell 421 \cell 431 \cell 433 \cell\row
\intbl\cell 439 \cell 443 \cell 449 \cell 457 \cell 461 \cell 463 \cell 467 \cell 479 \cell 487 \cell 491 \cell 499 \cell 503 \cell\row
\intbl\cell 509 \cell 521 \cell 523 \cell 541 \cell 547 \cell 557 \cell 563 \cell 569 \cell 571 \cell 577 \cell 587 \cell 593 \cell\row
\intbl\cell 599 \cell 601 \cell 607 \cell 613 \cell 617 \cell 619 \cell 631 \cell 641 \cell 643 \cell 647 \cell 653 \cell 659 \cell\row
\intbl\cell 661 \cell 673 \cell 677 \cell 683 \cell 691 \cell 701 \cell 709 \cell 719 \cell 727 \cell 733 \cell 739 \cell 743 \cell\row
\intbl\cell 751 \cell 757 \cell 761 \cell 769 \cell 773 \cell 787 \cell 797 \cell 809 \cell 811 \cell 821 \cell 823 \cell 827 \cell\row
\intbl\cell 829 \cell 839 \cell 853 \cell 857 \cell 859 \cell 863 \cell 877 \cell 881 \cell 883 \cell 887 \cell 907 \cell 911 \cell\row
\intbl\cell 919 \cell 929 \cell 937 \cell 941 \cell 947 \cell 953 \cell 967 \cell 971 \cell 977 \cell 983 \cell 991 \cell 997 \cell\row
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx806\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1407\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2489\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx3030\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx3571\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4172\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4965\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx5566\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx6071\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx6576\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx7081\pard\intbl 1009 \cell 1013 \cell 1019 1021 \cell\cell\cell\cell\cell\cell\cell\cell\cell\row
\pard\par
\pard\sb100\sa240 990 C++ COMO PROGRAMAR \line 20.7 Objetos fun\'e7\'e3o \line Objetos fun\'e7\'e3o e adaptadores de fun\'e7\'f5es s\'e3o fornecidos para tornar a STL mais f]ex\'edvel. Um objeto fun\'e7\'e3o cont\'e9m uma fun\'e7\'e3o que pode ser tratada sint\'e1tica e semanticamente como uma fun\'e7\'e3o usando operator o. Objetos fun\'e7\'e3o e adaptadores da STL est\'e3o definidos no cabe\'e7alho <functional>. Um objeto fun\'e7\'e3o pode tamb\'e9m encapsular dados com a fun\'e7\'e3o nele inclu\'edda. Os objetos fun\'e7\'e3o padr\'e3o s\'e3o colocados mime para obter melhor desempenho. Os objetos fun\'e7\'e3o da STL s\'e3o mostrados na Fig. 20.4 1. \par
Objetos fun\'e7\'e3o Tipo \par
divides< T > aritm\'e9tico \line equalto< T > relacional \line greater< T > relacional \line greaterequal< T > relaciona! \line less< T > relacional \line lessequal< T > relacional \line logicaland< T > l\'f3gico \line logicalnot< T > l\'f3gico \line logicalor< T > l\'f3gico \line minus< T > aritm\'e9tico \line modulus< T > aritm\'e9tico \line negate< T > aritm\'e9tico \line notequalto< T > relaciona! \line plus< T > aritm\'e9tico \line multiplies< T > aritm\'e9tico \line Fig. 20.41 Objetos fun\'e7\'e3o na biblioteca padr\'e3o. \line O programa da Fig. 20.42 demonstra o uso do algoritmo num\'e9rico accumulate (comentado na Fig. 20.30) para \line calcular a soma dos quadrados dos elementos em um vector. O quarto argumento para accumulate \'e9 um objeto \line fun\'e7\'e3o bin\'e1ria ou uma fun\'e7\'e3o ponteiro para uma fun\'e7\'e3o bin\'e1ria que aceita dois argumentos e retorna um resultado. \line A fun\'e7\'e3o accumulate \'e9 demonstrada duas vezes - uma vez com uma fun\'e7\'e3o no ponteiro para uma fun\'e7\'e3o bin\'e1ria \line e outra vez com um objeto fun\'e7\'e3o. \line 1 II Fig. 20.42: fig20_42.cpp \line 2 // Demonstrando fun\'e7\'f5es objeto. \line 3 #include <iostream> \line 4 \line 5 using std: :cout; \line 6 using std::endl; \line 7 \line 8 #include <vector> \line 9 #include <algorithm> \line 10 #include <numeric> \line 11 #include <functional> \line 12 \line 13 // fun\'e7\'e3o bin\'e1ria que soma o quadrado de seu segundo \line 14 II argumento e o total acumulado em seu primeiro \line 15 II argumento e retorna a soma \line 16 int sumSquares( int total, int value \line 17 \{ return total + value * value; \line 18 \line 19 II gabarito de classe fun\'e7\'e3o bin\'e1ria que define um \line Fig. 20.42 Demonstrando um objeto fun\'e7\'e3o bin\'e1ria (parte 1 de 2). \par
___________ \line CAP\'cdTULO 20 - A BIBLIOTECA PADR\'c3O DE GABARITOS (STL) \line // operatorOsobrecarregado que soma o quadrado \line II de seu segundo argumento e o total acumulado \line // em seu primeiro argumento e retorna a soma \line template< class T > \line class SuxnSquaresClass : public std: :binary function< T, T, T > \line public: \line const T operator() ( const T &total, const T &value \line return total + value * value; \line int main() \line const int SIZE = 10; \line int al[] = \{ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 \}; \line std: :vector< int > v( al, al + SIZE ); \line std: :ostreamiterator< int > output( cout, \ldblquote  \line int result = 0; \line cout \'ab \ldblquote O vector v cont\'e9m:\\n\rdblquote ; \line std::copy( v.beginO), v.end0, output ); \line result = \line std: :accumulate( v.begin() , v.end() , 0, sumSquares ); \line cout \'ab \ldblquote\\n\\nSoma dos quadrados dos elementos no vector v usando \line\'ab \ldblquote\\na fun\'e7\'e3o bin\'e1ria sumSquares: \ldblquote  \'ab result; \line 45 \line 46 result = std: :accumulate( v.begin() , v.end0 , 0, \line 47 SumSquaresClass< int > ); \line 48 cout \'ab \ldblquote\\n\\nSoma dos quadrados dos elementos no vector \line 49 \'ab \ldblquote\\nobjeto fun\'e7\'e3o bin\'e1ria do tipo \line 50 \'ab \ldblquote SumSquaresClass< int >: \ldblquote  \'ab result \'ab endl; \line 51 return 0; \line 52 \line O vector v contem: \line 1 2 3 4 5 6 7 8 9 10 \line Soma dos quadrados dos elementos no vector v usando \line a fun\'e7\'e3o bin\'e1ria sumSquares: 385 \line Soma dos quadrados dos elementos no vector v usando o \line objeto fun\'e7\'e3o bin\'e1ria do tipo SumSquaresClass< int >: 385 \line Fig. 20.42 Demonstrando um objeto fun\'e7\'e3o bin\'e1ria (parte 2 de 2). \line As linhas l6e 17 \line int sumSquares( int total, int value ) \line return total + value * value; \line definem a fun\'e7\'e3o sumSquares. que eleva ao quadrado seu segundo argumento (value), acrescenta o quadrado ao seu primeiro argumento (total) e retorna a soma. A fun\'e7\'e3o accumulate passar\'e1 cada um dos elementos da seq\'fc\'eancia sobre o qual ela itera como segundo argumento para sumSquares no exemplo. Na primeira chamada a suniSquares. o primeiro argumento ser\'e1 o valor inicial de total (que \'e9 fornecido como o terceiro argumento a ser acumulado; O neste programa). Todas as chamadas subseq\'fcentes a sumSquares recebem como primeiro argumento a soma corrente retornada pela chamada anterior a sumSquares. Quando accuniulate termina, ela retorna a soma dos quadrados de todos os elementos na seq\'fc\'eancia. \par
991 \par
20 \line 21 \line 22 \line 23 \line 24 \line 25 \line 26 \line 27 \line 28 \line 29 \line 30 \line 31 \line 32 \line 33 \line 34 \line 35 \line 36 \line 37 \line 38 \line 39 \line 40 \line 41 \line 42 \line 43 \line 44 \par
v usando o\rdblquote  \par
992 C++ COMO PROGRAMAR \line As linhas 23 a 29 \line template< class T > \line class SumSquaresClass public std::binary_function< T, T, T > \line publie: \line const T operator() ( const T &total, const T &value \line return total + value * value; \line definem a classe SumSquaresClass que herda da classe binary function (no arquivo de cabe\'e7alho <functional>). Classes que herdam de binary function definem a fun\'e7\'e3o operator () sobrecarregada com dois argumentos. A classe SuinSquaresClass \'e9 usada para definir objetos fun\'e7\'e3o para os quais as fun\'e7\'f5es sobrecarregadas operator O executam a mesma tarefa que a fun\'e7\'e3o sumSquares. Os tr\'eas par\'e2metros de tipo (T) para o gabarito binary function s\'e3o o tipo do primeiro argumento para operator O , o tipo do segundo argumento para operator () e o tipo de retomo de operator o, respectivamente. A fun\'e7\'e3o accumulate passar\'e1 os elementos da seq\'fc\'eancia sobre a qual ela itera como segundo argumento para a fun\'e7\'e3o operator () do objeto da classe SumSquaresClass que \'e9 passado para o algoritmo accumulate. Na primeira chamada a operator O o primeiro argumento ser\'e1 o valor inicial de total (o qual \'e9 fornecido como terceiro argumento para accumulate: O neste programa). Todas as chamadas subseq\'fcentes a operator () recebem como primeiro argumento o resultado retomado pela chamada anterior a operator O . Quando accumulate termina, retorna a soma dos quadrados de todos os elementos na seq\'fc\'eancia. \line Aslinhas4l e42 \line result = \line std: :accuniulate( v.begin() , v.end() , O, sumSquares \line chamam a fun\'e7\'e3o accumulate com um ponteiro para a fun\'e7\'e3o em sumSquares como seu \'faltimo argumento. O comando nas linhas 46 e 47 \line result = std::accumulate( v.beginO, v.endO, O, \line SumSquaresClass< int > ); \line chama a fun\'e7\'e3o accumulate com um objeto da classe SumSquaresClass como um \'faltimo argumento. A express\'e3o SumSquaresClass< int > () cria uma inst\'e2ncia da classe SumSquares que \'e9 passada para accumulate que envia ao objeto a mensagem (invoca a fun\'e7\'e3o) operator () . A declara\'e7\'e3o precedente poderia ser escrita como duas instru\'e7\'f5es separadas, como segue: \line SumSquaresClass< int > sumSquaresOb \line result = std::accumulate( v.begin, v.endO, O, sumSquaresObj ); \line A primeira linha define um objeto da classe SumSquaresClass. Tal objeto ent\'e3o \'e9 passado para a fun\'e7\'e3o accumulate e a mensagem operator \'e9 enviada. \line Observa\'e7\'e3o de engenharia de software 20.10 \line Diferentemente dos ponteiros para fun\'e7\'e3o, um objeto fun\'e7\'e3o pode tamb\'e9m encapsular dados. \line Resumo \line\bullet  Usar a STL pode economizar tempo e esfor\'e7os consider\'e1veis e resultar em programas da mais alta qualidade. \line\bullet  A escolha de qual cont\'eainer da biblioteca padr\'e3o usar em uma aplica\'e7\'e3o espec\'edfica \'e9 baseada freq\'fcentemente em considera\'e7\'f5es de desempenho. \par
994 C++ COMO PROGRAMAR \line\bullet  Iteradores de acesso aleat\'f3rio combinam as capacidades de um iterador bidirecional com a habilidade de acessar diretamente qualquer elemento de um cont\'eainer, isto \'e9, pular para frente ou para tr\'e1s por um n\'famero arbitr\'e1rio de elementos. \line\bullet  A categoria de iterador suportada por cada cont\'eainer determina se aquele cont\'eainer pode ser usado com algoritmos espec\'edficos na STL. Cont\'eaineres que suportam iteradores de acesso aleat\'f3rio podem ser usados com todos os algoritmos na STL. \line\bullet  Ponteiros para arrays podem ser usados em lugar de iteradores em todos os algoritmos da STL. \line\bullet  A STL inclui aproximadamente 70 algoritmos padr\'e3o. Algoritmos seq\'fcenciais mutantes resultam em modifica\'e7\'f5es nos elementos do cont\'eainer. Algoritmos seq\'fcenciais n\'e3o-mutantes n\'e3o modificam os elementos do cont\'eainer. \line\bullet  As fun\'e7\'f5es f iii e fui n atribuem a cada elemento em um intervalo de elementos de cont\'eainer um valor espec\'edfico. \line\bullet  As fun\'e7\'f5es generate e generate n usam uma fun\'e7\'e3o geradora para criar valores para cada elemento em um intervalo de elementos de cont\'eainer. \line\bullet  A fun\'e7\'e3o equal compara duas seq\'fc\'eancias de valores quanto \'e0 igualdade. \line\bullet  A fun\'e7\'e3o mismatch compara duas seq\'fc\'eancias de valores e retorna um pair de iteradores indicando a posi\'e7\'e3o em cada seq\'fc\'eancia dos elementos diferentes. Se todos os elementos s\'e3o iguais, o pair cont\'e9m o resultado da fun\'e7\'e3o erid para cada seq\'fc\'eancia. \line\bullet  A fun\'e7\'e3o iexicographicai compare compara os conte\'fados de duas seq\'fc\'eancias para determinar se uma seq\'fc\'eancia \'e9 menor que outra seq\'fc\'eancia (similar a uma compara\'e7\'e3o de strings). \line\bullet  As fun\'e7\'f5es remove e remove copy deletam todos os elementos em uma seq\'fc\'eancia que coincidem com um valor especificado. As fun\'e7\'f5es remove if e remove copy if deletam todos os elementos em uma seq\'fc\'eancia para os quais a fun\'e7\'e3o predicado un\'e1ria passada \'e0s fun\'e7\'f5es retoma true. \line\bullet  As fun\'e7\'f5es repiace e replace copy substituem todos os elementos em uma seq\'fc\'eancia iguais a um valor especificado. As fun\'e7\'f5es repiace if e repiace copy if substituem por um novo valor todos os elementos na seq\'fc\'eancia para os quais a fun\'e7\'e3o predicado un\'e1ria passada para as fun\'e7\'f5es retoma true. \line\bullet  A fun\'e7\'e3o random shuffie ordena aleatoriamente os elementos de uma seq\'fc\'eancia. \line\bullet  A fun\'e7\'e3o count conta os elementos com o valor especificado em uma seq\'fc\'eancia. A fun\'e7\'e3o count if conta os elementos em uma seq\'fc\'eancia para os quais a fun\'e7\'e3o predicado un\'e1ria fornecida retorna true. \line\bullet  A fun\'e7\'e3o mm eiement localiza o menor elemento em uma seq\'fc\'eancia. A fun\'e7\'e3o max eiement localiza o maior elemento em uma seq\'fc\'eancia. \line\bullet  A fun\'e7\'e3o accumuiate soma os valores em uma seq\'fc\'eancia. A segunda vers\'e3o desta fun\'e7\'e3o recebe um ponteiro para uma fun\'e7\'e3o gen\'e9rica que aceita argumentos e retorna um resultado. A fun\'e7\'e3o gen\'e9rica determina como os elementos em uma seq\'fc\'eancia s\'e3o acumulados. \line\bullet  A fun\'e7\'e3o for_each aplica uma fun\'e7\'e3o gen\'e9rica sobre cada elemento em uma seq\'fc\'eancia. A fun\'e7\'e3o gen\'e9rica aceita um argumento (que ela n\'e3o deve modificar) e retorna void. \line\bullet  A fun\'e7\'e3o trans form aplica uma fun\'e7\'e3o gen\'e9rica sobre cada elemento em uma seq\'fc\'eancia. A fun\'e7\'e3o gen\'e9rica aceita um argumento (que ela pode modificar) e retorna o resultado transformado. \line\bullet  A fun\'e7\'e3o find localiza um elemento em uma seq\'fc\'eancia e, se o elemento \'e9 encontrado, retorna um iterador para o elemento; caso contr\'e1rio, f ind retorna um iterador indicando o fim da seq\'fc\'eancia. A fun\'e7\'e3o find_if localiza o primeiro elemento para o qual a fun\'e7\'e3o predicado un\'e1ria fornecida retorna true. \line\bullet  A fun\'e7\'e3o sort organiza os elementos de uma seq\'fc\'eancia em ordem classificada (ordem ascendente, por default, ou a ordem indicada por uma fun\'e7\'e3o predicado bin\'e1ria fornecida). \line\bullet  A fun\'e7\'e3o binary search determina se um elemento est\'e1 presente em uma seq\'fc\'eancia ordenada. \line\bullet  A fun\'e7\'e3o swap permuta dois valores. \line\bullet  A fun\'e7\'e3o iter_swap permuta dois valores referenciados por iteradores. \line\bullet  A fun\'e7\'e3o swap ranges permuta os elementos em duas seq\'fc\'eancias de elementos. \line\bullet  A fun\'e7\'e3o copy_backward copia os elementos de uma seq\'fc\'eancia e os coloca em outra seq\'fc\'eancia come\'e7ando do \'faltimo elemento na segunda seq\'fc\'eancia e trabalhando em dire\'e7\'e3o ao in\'edcio da segunda seq\'fc\'eancia. \par
\pard\par
\pard\sb100\sa240 994 C++ COMO PROGRAMAR \line\bullet  Iteradores de acesso aleat\'f3rio combinam as capacidades de um iterador bidirecional com a habilidade de acessar diretamente qualquer elemento de um cont\'eainer, isto \'e9, pular para frente ou para tr\'e1s por um n\'famero arbitr\'e1rio de elementos. \line\bullet  A categoria de iterador suportada por cada cont\'eainer determina se aquele cont\'eainer pode ser usado com algoritmos espec\'edficos na STL. Cont\'eaineres que suportam iteradores de acesso aleat\'f3rio podem ser usados com todos os algoritmos na STL. \line\bullet  Ponteiros para arrays podem ser usados em lugar de iteradores em todos os algoritmos da STL. \line A STL inclui aproximadamente 70 algoritmos padr\'e3o. Algoritmos seq\'fcenciais mutantes resultam em modifica\'e7\'f5es nos elementos do cont\'eainer. Algoritmos seq\'fcenciais n\'e3o-mutantes n\'e3o modificam os elementos do cont\'eainer. \line\bullet  As fun\'e7\'f5es f iii e fui n atribuem a cada elemento em um intervalo de elementos de cont\'eainer um valor espec\'edfico. \line\bullet  As fun\'e7\'f5es generate e generate_n usam uma fun\'e7\'e3o geradora para criar valores para cada elemento em um intervalo de elementos de cont\'eainer. \line\bullet  A fun\'e7\'e3o equal compara duas seq\'fc\'eancias de valores quanto \'e0 igualdade. \line\bullet  A fun\'e7\'e3o mismatch compara duas seq\'fc\'eancias de valores e retoma um pair de iteradores indicando a posi\'e7\'e3o em cada seq\'fc\'eancia dos elementos diferentes. Se todos os elementos s\'e3o iguais, o pair cont\'e9m o resultado da fun\'e7\'e3o end para cada seq\'fc\'eancia. \line\bullet  A fun\'e7\'e3o iexicographicai compare compara os conte\'fados de duas seq\'fc\'eancias para determinar se uma seq\'fc\'eancia \'e9 menor que outra seq\'fc\'eancia (similar a uma compara\'e7\'e3o de strings). \line\bullet  As fun\'e7\'f5es remove e remove copy deletam todos os elementos em uma seq\'fc\'eancia que coincidem com um valor especificado. As fun\'e7\'f5es remove if e remove copy if deletam todos os elementos em uma seq\'fc\'eancia para os quais a fun\'e7\'e3o predicado un\'e1ria passada \'e0s fun\'e7\'f5es retoma true. \line\bullet  As fun\'e7\'f5es repiace e repiace copy substituem todos os elementos em uma seq\'fc\'eancia iguais a um valor especificado. As fun\'e7\'f5es repiace if e repiace copy if substituem por um novo valor todos os elementos na seq\'fc\'eancia para os quais a fun\'e7\'e3o predicado un\'e1ria passada para as fun\'e7\'f5es retorna true. \line\bullet  A fun\'e7\'e3o random shuffle ordena aleatoriamente os elementos de uma seq\'fc\'eancia. \line\bullet  A fun\'e7\'e3o count conta os elementos com o valor especificado em uma seq\'fc\'eancia. A fun\'e7\'e3o count_if conta os elementos em uma seq\'fc\'eancia para os quais a fun\'e7\'e3o predicado un\'e1ria fornecida retoma true. \line\bullet  A fun\'e7\'e3o mm eiement localiza o menor elemento em uma seq\'fc\'eancia. A fun\'e7\'e3o max element localiza o maior elemento em uma seq\'fc\'eancia. \line\bullet  A fun\'e7\'e3o accumuiate soma os valores em uma seq\'fc\'eancia. A segunda vers\'e3o desta fun\'e7\'e3o recebe um ponteiro para uma fun\'e7\'e3o gen\'e9rica que aceita argumentos e retorna um resultado. A fun\'e7\'e3o gen\'e9rica determina como os elementos em uma seq\'fc\'eancia s\'e3o acumulados. \line\bullet  A fun\'e7\'e3o for_each aplica uma fun\'e7\'e3o gen\'e9rica sobre cada elemento em uma seq\'fc\'eancia. A fun\'e7\'e3o gen\'e9rica aceita um argumento (que ela n\'e3o deve modificar) e retoma void. \line\bullet  A fun\'e7\'e3o transform aplica uma fun\'e7\'e3o gen\'e9rica sobre cada elemento em uma seq\'fc\'eancia. A fun\'e7\'e3o gen\'e9rica aceita um argumento (que ela pode modificar) e retoma o resultado transformado. \line\bullet  A fun\'e7\'e3o f ind localiza um elemento em uma seq\'fc\'eancia e, se o elemento \'e9 encontrado, retoma um iterador para o elemento; caso contr\'e1rio, f ind retorna um iterador indicando o fim da seq\'fc\'eancia. A fun\'e7\'e3o find if localiza o primeiro elemento para o qual a fun\'e7\'e3o predicado un\'e1ria fornecida retoma true. \line\bullet  A fun\'e7\'e3o sort organiza os elementos de uma seq\'fc\'eancia em ordem classificada (ordem ascendente, por default, ou a ordem indicada por uma fun\'e7\'e3o predicado bin\'e1ria fomecida). \line\bullet  A fun\'e7\'e3o binary search determina se um elemento est\'e1 presente em uma seq\'fc\'eancia ordenada. \line\bullet  A fun\'e7\'e3o swap permuta dois valores. \line\bullet  A fun\'e7\'e3o iter_swap permuta dois valores referenciados por iteradores. \line\bullet  A fun\'e7\'e3o swap ranges permuta os elementos em duas seq\'fc\'eancias de elementos. \line\bullet  A fun\'e7\'e3o copy backward copia os elementos de uma seq\'fc\'eancia e os coloca em outra seq\'fc\'eancia come\'e7ando do \'faltimo elemento na segunda seq\'fc\'eancia e trabalhando em dire\'e7\'e3o ao in\'edcio da segunda seq\'fc\'eancia. \par
CAP\'cdTULO 20 - A BIBLIOTECA PADR\'c3O DE GABARITOS (STL) 995 \par
\bullet  A fun\'e7\'e3o merge intercala duas seq\'fc\'eancias ordenadas ascendentemente em uma terceira seq\'fc\'eancia ordenada. Observe que merge tamb\'e9m opera com seq\'fc\'eancias n\'e3o-ordenadas, mas n\'e3o produz uma seq\'fc\'eancia ordenada. \par
\bullet  Uma back inserter usa a capacidade default do cont\'eainer para inserir um elemento no final do cont\'eainer. Quando um elemento \'e9 inserido em um cont\'eainer que n\'e3o tem mais elementos dispon\'edveis, o cont\'eainer cresce em tamanho. H\'e1 dois outros insersores frontinserter e inserter. Um front inserter insere um elemento no in\'edcio de um cont\'eainer (especificado como seu argumento) e um inserter insere um elemento antes da posi\'e7\'e3o indicada pelo iterador fornecido corno seu segundo argumento, no cont\'eainer fornecido como seu primeiro argumento. \par
A fun\'e7\'e3o unique remove todos os valores duplicados de uma seq\'fc\'eancia ordenada. \par
A fun\'e7\'e3o reverse coloca na ordem inversa todos os elementos de uma seq\'fc\'eancia. \par
A fun\'e7\'e3o inplace merge intercala duas seq\'fc\'eancias de elementos no mesmo cont\'eainer. \par
\bullet  A fun\'e7\'e3o unique copy faz uma c\'f3pia de todos os elementos \'fanicos em uma seq\'fc\'eancia ordenada. A fun\'e7\'e3o reversecopy faz uma c\'f3pia na ordem inversa dos elementos de uma seq\'fc\'eancia. \par
\bullet  A fun\'e7\'e3o includes compara dois conjuntos ordenados de valores para determinar se cada elemento do segundo conjunto est\'e1 inclu\'eddo no primeiro conjunto. Sendo assim. includes retorna true; caso contr\'e1rio, includes retorna false, \par
\bullet  A fun\'e7\'e3o set_difference determina os elementos do primeiro conjunto de valores ordenados que n\'e3o est\'e3o no segundo conjunto de valores ordenados (os dois conjuntos de valores devem estar em ordem ascendente e usando a mesma fun\'e7\'e3o de compara\'e7\'e3o). \par
\bullet  A fun\'e7\'e3o set intersection determina os elementos do primeiro conjunto de valores ordenados que est\'e3o no segundo conjunto de valores ordenados (os dois conjuntos de valores devem estar em ordem ascendente e usando a mesma fun\'e7\'e3o de \par
compara\'e7\'e3o). \par
A fun\'e7\'e3o set symmetric difference determina os elementos no primeiro conjunto que est\'e3o no segundo conjunto e os elementos no segundo conjunto que n\'e3o est\'e3o no primeiro conjunto (os dois conjuntos de valores devem estar em ordem ascendente e usando a mesma fun\'e7\'e3o de compara\'e7\'e3o). \par
\bullet  A fun\'e7\'e3o set union cria um conjunto de todos os elementos que est\'e3o em um ou em ambos os conjuntos (os dois conjuntos de valores devem estar em ordem ascendente e usando a mesma fun\'e7\'e3o de compara\'e7\'e3o). \par
\bullet  A fun\'e7\'e3o lower bound determina a primeira posi\'e7\'e3o em uma seq\'fc\'eancia ordenada na qual o terceiro argumento pode ser inserido na seq\'fc\'eancia de modo que a seq\'fc\'eancia ainda estaria classificada em ordem ascendente. \par
\bullet  A fun\'e7\'e3o upper bound determina a \'faltima localiza\'e7\'e3o em uma seq\'fc\'eancia ordenada de valores na qual o terceiro argumento poderia ser inserido na seq\'fc\'eancia de modo que a seq\'fc\'eancia ainda estaria classificada em ordem ascendente. \par
\bullet  A fun\'e7\'e3o equal range retorna um pair de iteradores para a frente contendo os resultados combinados da execu\'e7\'e3o de duas opera\'e7\'f5es, uma lower_bound e uma upperbound. \par
Heapsori \'e9 um algoritmo de classifica\'e7\'e3o no qual um array de elementos \'e9 organizado em uma \'e1rvore bin\'e1ria especial denominada heap. A chave do bom desempenho de um heap \'e9 que o maior elemento est\'e1 sempre no topo do heap e os valores dos filhos de qualquer nodo da \'e1rvore bin\'e1ria s\'e3o sempre menores que ou iguais ao valor daquele nodo. Um heap organizado desta maneira \'e9 freq\'fcentemente chamado de maxheap. \par
\bullet  A fun\'e7\'e3o make heap aceita uma seq\'fc\'eancia de valores e cria um heap que pode ser usado para produzir uma seq\'fc\'eancia ordenada. \par
A fun\'e7\'e3o sort heap classifica uma seq\'fc\'eancia de valores que j\'e1 est\'e3o organizados em um heap. \par
A fun\'e7\'e3o push_heap adiciona um valor novo a um heap. push heap assume que o \'faltimo elemento atualmente no cont\'eainer \'e9 o elemento que est\'e1 sendo adicionado ao heap e que todos os outros elementos no cont\'eainer j\'e1 est\'e3o organizados como heap. \par
\bullet  A fun\'e7\'e3o pop_heap remove o elemento do topo do heap. Esta fun\'e7\'e3o assume que os elementos j\'e1 est\'e3o organizados como sheap. \par
\bullet  A fun\'e7\'e3o mm determina o m\'ednimo de dois valores. A fun\'e7\'e3o max determina o m\'e1ximo de dois valores. \par
\bullet  A classe bitset torna mais f\'e1cil criar e manipularbit nets (conjuntos de bits). Conjuntos de bits s\'e3o \'fateis para representar um conjunto de indicadores (flags) booleanos. O tamanho de um bitset \'e9 fixado durante a compila\'e7\'e3o. \par
996 C++ COMO PROGRAMAR \line Terminologia \line <algorithm> erase() \line <deque> filiO \line <functional> filin O \line <iterador> findO \line <list> for each() \line <map> front() \line <numeric> generate O \line <set> generaten O \line <stack> inplacemerge O \line <vector> insertO \line accumuiate () intervalo \line adaptador is tream i terator \line adjacentdifference O iterswap() \line adjacentf ind () iterador \line algoritmo iterador bidirecional \line algoritmo de classifica\'e7\'e3o iterador de acesso aleat\'f3rio \line algoritmo de seq\'fcencial n\'e3o-mutante iterador de entrada \line algoritmos de seq\'fc\'eancia mutante iterador de sa\'edda \line array associativo iterador para a frente \line assign () iterador reverso \line atribui\'e7\'e3o iexicographical_compare O \line back () iowerbound () \line begin O makeheap O \line biblioteca padr\'e3o de gabaritos (STL) mapeamento um para um \line bibliotecas de classes espec\'edficas para uma plataforma max O \line bibliotecas de classes independentes de plataforma maxelement O \line binarysearch O rnaxsize O \line classe de adaptador de cont\'eainer priorityqueue inerge O \line classe de adaptador de cont\'eainer queue mm O \line classe de adaptador de cont\'eainer stack mineiement O \line classes de adaptador de cont\'eainer mismatch O \line colocar em ordem inversa o conte\'fado de um cont\'eainer namespace std \line const_iterator ntheiement \line const_reverseiterator objeto fun\'e7\'e3o \line cont\'eainer operator ! = O \line cont\'eainer associativo operator< O \line cont\'eainer associativo map operator<= O \line cont\'eainer associativo multimap operator O \line cont\'eainer associativo multiset operator> O \line cont\'eainer associativo set operator>= O \line cont\'eainer de seq\'fc\'eancia ostream_iterator \line cont\'eainer seq\'fcencial partiaisort O \line cont\'eainer seq\'fcencial deque partialsortcopy O \line cont\'eainer seq\'fcencial list par tial_sum O \line cont\'eainer seq\'fcencial vector partition () \line cont\'eaineres de primeira classe pop O \line copy() popback() \line copybackward() popfront() \line count() popheap() \line countif () primeiro a entrar, primeiro a sair (FIFO) \line criar uma associa\'e7\'e3o programa\'e7\'e3o gen\'e9rica \line deque<T> push(.) \line deque<T>: :iterator pushback() \line empty O push_front O \line end() pushheap() \line equal() randomshuffle() \line equa 1_range O rbegin O \par
CAP\'cdTULO 20- A BIBLIOTECA PADR\'c3O DE GABARITOS (STL) 997 \line remove () setunion O \line remove copy() size O \line remove copyif O size_type \line removeif () sort O \line rend () sort_heap O \line replace() string \line replace_copy () string () \line replacecopyif O struct less<T> \line replace_if O swap() \line reverse () swap range O \line reversecopy O top O \line reverseiterator trans form O \line rotate O \'faltimo a entrar, primeiro a sair (LIFO) \line rotatecopy() unique() \line seq\'fc\'eancia upperbound O \line set_difference O vai array \line set_intersection () vaiuetype \line setsymmetricdifference O \line Erros comuns de programa\'e7\'e3o \line 20.1 Tentar derreferenciar um iterador posicionado fora de seu cont\'eainer \'e9 um erro l\'f3gico durante a execu\'e7\'e3o. Especialmente, o iterador retornado por end O n\'e3o pode ser derreferenciado ou incrementado. \line 20.2 Tentar criar um iterador n\'e3o-const para um cont\'eainer const \'e9 um erro de sintaxe. \line 20.3 O vector n\'e3o deve estar vazio; caso contr\'e1rio, os resultados das fun\'e7\'f5es front e back s\'e3o indefinidos. \line 20.4 Apagar um elemento que cont\'e9m um ponteiro para um objeto alocado dinamicamente n\'e3o deleta o objeto. \line 20.5 Tentar ordenar um cont\'eainer usando um iterador que n\'e3o seja um iterador de acesso aleat\'f3rio \'e9 um erro de sintaxe. A fun\'e7\'e3o sort requer um iterador de acesso aleat\'f3rio. \line Boas pr\'e1ticas de programa\'e7\'e3o \line 20.1 Usar typedefs para conseguir ler mais facilmente c\'f3digo de programas com tipos com nomes longos (tais como rnultisets). \line 20.2 E uma boa pr\'e1tica verificar se o intervalo especificado em uma chamada para mm element n\'e3o est\'e1 vazio e verificar se o valor de retomo n\'e3o \'e9 um iterador apontando para \ldblquote depois do final\rdblquote . \line Dicas de desempenho \line 20.1 Para qualquer aplica\'e7\'e3o particular, diversos cont\'eaineres da STL diferentes podem ser apropriados. Selecione o cont\'eainer mais apropriado que obt\'e9m o melhor desempenho (ou seja, o equil\'edbrio entre velocidade e tamanho) para aquela aplica\'e7\'e3o. A efici\'eancia foi um aspecto considerado crucial no projeto da STL. \line 20.2 Os recursos da biblioteca padr\'e3o s\'e3o implementados para operar eficientemente em uma ampla variedade de aplica\'e7\'f5es. Para algumas aplica\'e7\'f5es com requisitos especiais de desempenho, pode ser necess\'e1rio escrever suas pr\'f3prias \line implementa\'e7\'f5es. \line 20.3 A STL geralmente evita heran\'e7a e fun\'e7\'f5es virtual em favor da programa\'e7\'e3o gen\'e9rica com gabaritos, para obter um desempenho melhor durante a execu\'e7\'e3o. \line 20.4 Conhe\'e7a seus componentes da STL. Escolher o cont\'eainer mais apropriado para um determinado problema pode maximizar o desempenho e minimizar os requisitos de mem\'f3ria. \line 20.5 A inser\'e7\'e3o no fim de um vector \'e9 eficiente. O vector simplesmente cresce, se necess\'e1rio, para acomodar o novo item. E dispendioso inserir (ou retirar) um elemento no meio de um vector-a por\'e7\'e3o inteira do vector ap\'f3s o ponto de inser\'e7\'e3o (ou retirada) deve ser movida, porque elementos vector ocupam posi\'e7\'f5es cont\'edguas na mem\'f3ria, assim como um array \ldblquote cru\rdblquote  em C ou C++. \line 20.6 Aplica\'e7\'f5es que requeiram freq\'fcentes inser\'e7\'f5es e dele\'e7\'f5es em ambas as extremidades de um cont\'eainer normalmente usam uma deque de prefer\'eancia a um vector. Embora possamos inserir e deletar elementos na frente e atr\'e1s tanto de um vector como de uma deque, a classe deque \'e9 mais eficiente do que vector para fazer inser\'e7\'f5es e dele\'e7\'f5es no in\'edcio. \par
998 C++ COMO PROGRAMAR \par
20.7 Aplica\'e7\'f5es com freq\'fcentes inser\'e7\'f5es e dele\'e7\'f5es no meio e/ou nos extremos de um cont\'eainer, normalmente usam uma list, devido \'e0 sua eficiente implementa\'e7\'e3o de inser\'e7\'e3o e dele\'e7\'e3o em qualquer lugar na estrutura de dados. \line 20.8 Escolha o cont\'eainer vector para obter o melhor desempenho com acesso aleat\'f3rio. \line 20.9 Objetos da classe vector fornecem acesso indexado r\'e1pido com o operador subscrito sobrecarregado [1 porque eles est\'e3o armazenados em uma \'e1rea cont\'edgua, como um array \ldblquote bruto\rdblquote  em C ou C++. \line 20.10 E muito mais r\'e1pido inserir muitos elementos de uma s\'f3 vez do que um elemento de cada vez. \line 20.11 Pode ser um desperd\'edcio dobrar o tamanho de um vector quando \'e9 necess\'e1rio mais espa\'e7o. Por exemplo, um vector com um total de 1.000.000 elementos se redimensiona para acomodar 2.000.000 elementos quando \'e9 adicionado um novo elemento. Isto deixa 999.999 elementos sem uso. Os programadores podem usar resize () para controlar melhor o uso do espa\'e7o. \line 20.12 Depois que um bloco de armazenagem \'e9 alocado para uma deque, em diversas implementa\'e7\'f5es o bloco n\'e3o \'e9 desalocado at\'e9 que a deque seja destru\'edda. Isto torna a opera\'e7\'e3o de uma deque mais eficiente do que se a mem\'f3ria fosse repetida- mente alocada, desalocada e realocada. Mas isso significa que a deque. muito provavelmente, vai usar a mem\'f3ria mais ineficientemente (do que um vector, por exemplo). \line 20.13 Inser\'e7\'f5es e dele\'e7\'f5es no meio de uma deque s\'e3o otimizadas para minimizar o n\'famero de elementos copiados para manter a ilus\'e3o de que os elementos do deque s\'e3o cont\'edguos. \line 20.14 Por raz\'f5es de desempenho, multisets e sets s\'e3o tipicamente implementados como estruturas denominadas \'e1rvores de pesquisa bin\'e1ria vermelho-preto. Com esta representa\'e7\'e3o interna, a \'e1rvore de pesquisa bin\'e1ria tende a ser balanceada, minimizando desta forma os tempos m\'e9dios de pesquisa. \line 20.15 Um multimap \'e9 implementado de modo a localizar eficientemente todos os pares de valores com uma determinada chave. \line 20.16 Cada uma das opera\'e7\'f5es comuns de um stack \'e9 implementada como uma fun\'e7\'e3o mime que chama a fun\'e7\'e3o apropriada do cont\'eainer subjacente. Isto evita o overhead de uma segunda chamada de fun\'e7\'e3o. \line 20.17 Para melhor desempenho, use as classes deque ou vector como o cont\'eainer subjacente para um stack. \line 20.18 Cada uma das opera\'e7\'f5es comuns de uma queue \'e9 implementada como uma fun\'e7\'e3o mime que chama a fun\'e7\'e3o apropriada do cont\'eainer subjacente. Isto evita o overhead de uma chamada de uma segunda fun\'e7\'e3o. \line 20.19 Para melhor desempenho, use a classe deque como o cont\'eainer subjacente para uma queue. \line 20.20 Cada uma das opera\'e7\'f5es comuns de uma priority queue \'e9 implementada como uma fun\'e7\'e3o mime que chama a fun\'e7\'e3o apropriada do cont\'eainer subjacente. Isto evita o overhead de uma segunda fun\'e7\'e3o. \line 20.21 Para melhor desempenho, usar a classe vector como cont\'eainer subjacente para uma priorityqueue. \line Dicas de portabilidade \line 20.1 A STL certamente vai se tomara meio favorito de programa\'e7\'e3o com cont\'eaineres. Programar com a STL vai aumentar a portabilidade de seu c\'f3digo. \line 20.2 Devido aos algoritmos da STL processarem os cont\'eaineres s\'f3 indiretamente, atrav\'e9s dos iteradores, um algoritmo pode freq\'fcentemente ser usado com muitos cont\'eaineres diferentes. \line Observa\'e7\'f5es de engenharia de software \line 20.1 A abordagem da STL permite que programas gen\'e9ricos sejam escritos de maneira que o c\'f3digo n\'e3o dependa do cont\'eainer subjacente. Tal estilo de programa\'e7\'e3o \'e9 chamado de progranw\'e7\'e3o gen\'e9rica. \line 20.2 Evite reinventar a roda; programe com componentes reutiliz\'e1veis da biblioteca padr\'e3o de C++. A STL cont\'e9m muitas das estruturas de dados mais populares, como cont\'eaineres, e fornece v\'e1rios algoritmos populares que os programas usam para processar dados nestes cont\'eaineres. \line 20.3 Os operadores de igualdade e menor do que s\'e3o tecnicamente desnecess\'e1rios para os elementos armazenados em um cont\'eainer, a menos que os elementos necessitem ser comparados. Entretanto, quando se cria c\'f3digo a partir de um gabarito, alguns compiladores requerem que todas as partes do gabarito sejam definidas, enquanto outros compiladores requerem somente as partes do gabarito que s\'e3o realmente usadas no programa. \line 20.4 Usar o \ldblquote iterador mais fraco\rdblquote  que produz um desempenho aceit\'e1vel ajuda a produzir componentes reutiliz\'e1veis ao m\'e1ximo. \line 20.5 A STL \'e9 implementada concisamente. At\'e9 agora, projetistas de classes teriam associado os algoritmos aos cont\'eaineres tornando os algoritmos fun\'e7\'f5es membro dos cont\'eaineres. A STL adota uma abordagem diferente. Os algoritmos est\'e3o separados dos cont\'eaineres e operam sobre os elementos dos cont\'eaineres s\'f3 indiretamente, atrav\'e9s de iteradores. Esta separa\'e7\'e3o torna mais f\'e1cil escrever algoritmos gen\'e9ricos aplic\'e1veis a muitas outras classes de cont\'eaineres. \line 20.6 A STL \'e9 extens\'edvel. E simples adicionar a ela novos algoritmos e fazer isso sem mudan\'e7as nos cont\'eaineres da STL. \line 20.7 Os algoritmos podem operar sobre cont\'eaineres da STL e sobre arrays baseados em ponteiros, no estilo usado em C. \par
CAP\'cdTULO 20 - A BIBLIOTECA PADR\'c3O DE GABARITOS (STL) 999 \line 20.8 Os algoritmos n\'e3o dependem dos detalhes de implementa\'e7\'e3o dos cont\'eaineres sobre os quais eles operam. Enquanto os iteradores de cont\'eaineres (ou de arrays) satisfizerem os requisitos do algoritmo, os algoritmos da STL podem trabalhar com quaisquer arrays no estilo de C, baseados em ponteiros, assim como trabalhar com os cont\'eaineres da STL (e estruturas de dados definidas pelo usu\'e1rio). \line 20.9 Algoritmos podem ser facilmente adicionados \'e0 STL sem modificar as classes cont\'eaineres. \line 20.10 Diferentemente dos ponteiros para fun\'e7\'e3o, um objeto fun\'e7\'e3o pode tamb\'e9m encapsular dados. \line Dicas de teste e depura \'e7\'e3o \line 20.1 Quando programamos com estruturas de dados e algoritmos baseados em ponteiros, devemos fazer nossa pr\'f3pria depura\'e7\'e3o e teste para garantir que nossas estruturas de dados, classes e algoritmos funcionam corretamente. E f\'e1cil cometer erros ao manipular ponteiros neste n\'edvel t\'e3o baixo. Perdas de mem\'f3ria\rdblquote  e viola\'e7\'f5es de acesso \'e0 memoria s\'e3o comuns em tal c\'f3digo customizado. Para a maioria dos programadores, e para maioria das aplica\'e7\'f5es que necessitar\'e3o escrever, as estruturas de dados definidas como gabaritos, pr\'e9-empacotadas, da STL s\'e3o suficientes. Usar o c\'f3digo da STL pode evitar muito tempo de teste e depura\'e7\'e3o. Uma precau\'e7\'e3o a ser tomada com rela\'e7\'e3o a grandes projetos \'e9 que o tempo de compila\'e7\'e3o pode ser significativo. \line 20.2 O operador * (derreferenciador) de qualquer iterador const retorna uma refer\'eancia const ao elemento do cont\'eainer, n\'e3o permitindo, portanto, o uso de fun\'e7\'f5es membro n\'e3o-const. \line 20.3 Opera\'e7\'f5es executadas em um const_iterator retornam refer\'eancias corist para evitar modifica\'e7\'e3o a elementos do cont\'eainer que est\'e1 sendo manipulado. D\'ea prefer\'eancia ao uso de const_iterators em vez de iterators. onde \line apropriado. Este \'e9 um outro exemplo do princ\'edpio do menor privil\'e9gio. \line 20.4 Somente iteradores de acesso aleat\'f3rio suportam <. E melhor usar = e end () para testar o fim do cont\'eainer. \line Exerc\'edcios de auto-revis\'e3o \line 20.1 (VIF) A STL faz uso abundante de heran\'e7a e fun\'e7\'f5es virtual. \line 20.2 Os dois tipos de cont\'eaineres da STL s\'e3o cont\'eaineres seq\'fcenciais e cont\'eaineres __________________ \line 20.3 A STL evita usar new e delete dando prefer\'eancia ao uso de para possibilitar diversos meios de controlar a aloca\'e7\'e3o e a desalo\'e7\'e3o de mem\'f3ria. \line 20.4 Os cinco principais tipos de iterador s\'e3o ________________ ________________, , ________________ e \line 20.5 (V/F) Um ponteiro \'e9 uma forma generalizada de iterador. \line 20.6 (V/F) Os algoritmos da STL podem operar sobre arrays baseados em ponteiros ao estilo de C. \line 20.7 (V/F) Os algoritmos da STL s\'e3o encapsulados como fun\'e7\'f5es dentro de cada classe de cont\'eainer. \line 20.8 (V/F) O algoritmo remove n\'e3o diminui o tamanho do vector dos quais os elementos est\'e3o sendo removidos. \line 20.9 Aloca\'e7\'e3o e desaloca\'e7\'e3o de mem\'f3ria s\'e3o executadas na STL com objetos \line 20.10 Os tr\'eas adaptadores de cont\'eainer da STL s\'e3o _______________ _______________ e _______________ \line 20.11 (V/F) A fun\'e7\'e3o membro de cont\'eainer end () retoma a posi\'e7\'e3o do \'faltimo elemento do cont\'eainer. \line 20.12 Os algoritmos da STL operam sobre elementos de cont\'eainer indiretamente usando ____________________ \line 20.13 O algoritmo sort requer um iterador ___________________ \line Respostas aos exerc\'edcios de auto-revis\'e3o \line 20.1 Falso. Estes foram evitados devido a raz\'f5es de desempenho. \line 20.2 Associativos. \line 20.3 Alocadores. \line 20.4 Entrada, sa\'edda, para a frente, bidirecional e acesso aleat\'f3rio. \line 20.5 Falso. Na realidade \'e9 vice-versa. \line 20.6 Verdadeiro. \par
1000 C++ COMO PROGRAMAR \line 20.7 Falso. Os algoritmos da STL n\'e3o s\'e3o fun\'e7\'f5es membro. Eles operam indiretamente sobre cont\'eaineres atrav\'e9s de iteradores. \line 20.8 Verdadeiro. \line 20.9 Alocador. \line 20.10 stack, queue, priority_qiieue. \line 20.11 Falso. Na realidade, retoma a posi\'e7\'e3o imediatamente ap\'f3s o final do cont\'eainer. \line 20.12 Iteradores. \line 20.13 Acesso aleat\'f3rio. \line Exerc\'edcios \line 20.14 Escrever uma fun\'e7\'e3o gabarito palindrome que aceita como par\'e2metro um const vector e retoma true ou false dependendo de se o vector \'e9 lido ou n\'e3o da mesma forma da frente para tr\'e1s e de tr\'e1s para diante (por exemplo, um vector contendo 1,2, 3, 2, 1 \'e9 um pal\'edndromo e um vector contendo 1, 2,3,4 n\'e3o \'e9). \line 20.15 Modificar o programa da Fig. 20.29, o Crivo de Erat\'f3stenes, de modo que se o n\'famero que o usu\'e1rio digitar no programa \line n\'e3o for primo, o programa exiba os fatores primos do n\'famero. Lembre-se de que os fatores de um n\'famero primo s\'e3o somente 1 \line e o pr\'f3prio n\'famero primo. Todo n\'famero que n\'e3o \'e9 primo tem uma fatura\'e7\'e3o prima \'fanica. Por exemplo, considere o n\'famero 54. \line Os fatores de 54 s\'e3o 2, 3, 3 e 3. Quando estes valores s\'e3o multiplicados juntos, o resultado \'e9 54. Para o n\'famero 54, os fatores \line primos resultantes devem ser 2 e 3. \line 20.16 Modificar o Exerc\'edcio 20.15 de modo que se o n\'famero que o usu\'e1rio digitar no programa n\'e3o for primo, o programa exiba os fatores primos do n\'famero e o n\'famero de vezes que o fator primo aparece na fatora\'e7\'e3o prima \'fanica. Por exemplo, o resultado para o n\'famero 54 deve ser \line A fatora\'e7\'e3o prima \'fanica de 54 \'e9: 2 * 3 * 3 * 3 \line Recursos para a STL na Internet e na World Wide Web \line A seguinte \'e9 uma cole\'e7\'e3o de recursos para a STL existentes na Internet e na World Wide Web. Estes sites incluem tutoriais, refer\'eancias, FAQs, artigos, livros, entrevistas e software. \line Tutorwis \line http: //www. cs .brown . edu/people/jak/prograniming/stl-tutorial/tutorial .html Este tutorial sobre a STL est\'e1 organizado por exemplos, filosofia, componentes e extens\'f5es da STL. Voc\'ea encontrar\'e1 \line exemplos de c\'f3digo usando os componentes da STL, explana\'e7\'f5es \'fateis e diagramas para ajuda. \line http: //web. ftech. net/honeyg/artic1es/eff_st1 . htin \line Este tutorial sobre a STL fornece informa\'e7\'f5es sobre componentes, cont\'eaineres, adaptadores de slreurns e cont\'eaineres, \line al\'e9m de como transformar e selecionar valores, filtrar e transformar valores e objetos. \line http: //www.xraylith.wisc . edu/khan/software/st1/os_examp1es/examp1es .html \line Este site \'e9 feito para pessoas que est\'e3o aprendendo a STL. Voc\'ea encontrar\'e1 uma introdu\'e7\'e3o \'e0 STL e exemplos do \line ObjectSpace STL Tool Kit. \line Refer\'eancias \line http: //www. sgi. com/Technology/STL/other_resources . html \line Este site tem uma lista de muitos sites na Web relativos \'e0 STL e uma lista de livros sugeridos sobre a STL. \line http: //www. cs . rpi edu/projects/STL/stl/stl . html \line Esta \'e9 a homepage da refer\'eancia on-line da biblioteca padr\'e3o de gabaritos do Rensselaer Polytechnic Institute. Voc\'ea \line achar\'e1 explica\'e7\'f5es detalhadas sobre a STL, assim como links para outros recursos \'fateis para informa\'e7\'e3o acerca da STL. \line http: //www. sgi com/Technology/STL/ \par
CAP\'cdTULO 20 - A BIBLIOTECA PADR\'c3O DE GABARITOS (STL) 1001 \line lores. O Silicon Graphics Standard Template Library Programmer\rquote s Guide \'e9 um recurso \'fatil para informa\'e7\'f5es sobre a STL. Voc\'ea pode fazer o download da STL a partir deste site, achar a \'faltima informa\'e7\'e3o, documenta\'e7\'e3o de projeto e links para \line outros recursos da STL. \line http: //www. dinkumware com/refcpp html \line Este sitc cont\'e9m informa\'e7\'f5es \'fateis sobre a biblioteca padr\'e3o ANSI/ISO de C++ e cont\'e9m informa\'e7\'f5es extensas sobre a \line biblioteca padr\'e3o de gabaritos (STL). \line http: //www. roguewave com/products/xplatform/stdlib/ \line A p\'e1gina da Web da biblioteca padr\'e3o de C++ da Rogue Wave Software. Voc\'ea pode fazer download de artigos relacionados com a vers\'e3o deles da biblioteca padr\'e3o de C++. \line FAQs \line alse \line ctor ftp://butler.hpl.hp.com/stl/stl.faq \line Este site FTP \'e9 uma p\'e1gina FAQ para a STL mantida por Marian Corcoran, membro do comit\'ea ANST e uma \ldblquote expert\rdblquote  em \line c++. \line grama \line ente! Artigos, livros e entrevistas \line atores http: //www. sgi com/Technology/STL/other resources html \line Este site tem uma lista de mais de 15 sites na Web relativos \'e0 STL e uma breve lista de livros sugeridos sobre a STL. \line exiba \line ultado http://www.byte.com/art/951O/sec12/art3.htm \line O site do Byte Magazine tem uma c\'f3pia de um artigo sobre a STL escrito por Alexander Stepanov. Stepanov, um dos criadores da biblioteca padr\'e3o de gabaritos, fornece informa\'e7\'f5es sobre o uso da STL em programa\'e7\'e3o gen\'e9rica. \line http: //www. sgi com/Technology/STL/drdobbs-interview.html \line Uma entrevista com Alexander Stepanov que tem algumas informa\'e7\'f5es interessantes acerca da cria\'e7\'e3o da biblioteca \line padr\'e3o de gabaritos. Stepanov fala sobre como a STL foi concebida, programa\'e7\'e3o gen\'e9rica, o acr\'f4nimo STL\rdblquote  e mais. \line toriais, ANSI/ISO C++ Standard \line http://www.ansi.org/ \line Voc\'ea pode comprar uma c\'f3pia completa do documento do padr\'e3o C++ neste site. \line Software \line intrar\'e1 \line http: //www. cs rpi edu/-musser/stl .html \line O site RPI STL inclui informa\'e7\'e3o sobre como a STL difere de outras bibliotecas de C++ e como compilar programas que usem a STL, lista dos principais arquivos de include para a STL, exemplos de programas que usam a STL, classe cont\'eaineres \line ineres, da STL e categorias de iteradores da STL. Ele tamb\'e9m fornece uma lista de compiladores compat\'edveis com a STL, sites FTP para c\'f3digo-fonte da STL e materiais relacionados. \line 1 http://www.mathcs.sjsu.edu/facu1ty/horstinan/safest1 .htnsJ. \line los do Download do SAFESTL.ZIP, uma ferramenta projetada para encontrar erros em programas que usam a STL. \line http: //www. objectspace. com/ jgl/ \line Object Space fornece informa\'e7\'e3o sobre portar programas escritos em C++ para Java, Voc\'ea pode fazer o download gr\'e1tis de suas bibliotecas de classe port\'e1veis Standards<ToolKit>. Aspectos-chave do \ldblquote conjunto de ferramentas\rdblquote  incluem cont\'eaineres, iteradores, algoritmos, alocadores, strings e exce\'e7\'f5es. \line http: //www. cs rpi edu/wiseb/st1-bor1and - html \line\ldblquote Using the Standard Template Library with Borland C++\rdblquote . Este site e uma refer\'eancia \'fatil para pessoas que usam o \line e. Voc\'ea compilador Borland C++. O autor tem se\'e7\'f5es sobre advertert\'eancias e incompatibilidades. \line IaSTL. \line http://msdn.microsoft.com/visua1cI \line Esta \'e9 a homepage do Microsoft Visual C++. Aqui voc\'ea pode encontrar as mais recentes not\'edcias, atualiza\'e7\'f5es, recursos \line t\'e9cnicos, exemplos e downloads de Visual C++. \par
1002 C++ COMO PROGRAMAR \line http: //www borland. cozn/bcppbuilder/ \line Esta \'e9 a homepage do Borland C++ Builder. Aqui voc\'ea pode encontrar diversos recursos para C++. incluindo diversos grupos de not\'edcias sobre C++, informa\'e7\'f5es sobre as \'faltimas melhorias de produtos, FAQs e muitos outros recursos para programadores que usam o C++ Builder. \line Bibliografia da STL \line (Am97) Ammeraal, L., STLfor C++ Programmers, New York, NY: John Wiley, 1997. \line (G195) Glass, G., e B. Schuchert, The STL <Primer>, Upper Saddle River, NJ: Prentice Hail PTR, 1995. \line (He97) Henricson, M., e E. Nyquist, Industrial Strength C++: Ruies e Recornmendations, Upper Saddle River, NJ: Prentice HaIl, 1997. \line (Jo99) Josuttis, N., The C++ Standard Library:A Tutorial and Handbook, Reading, MA: Addison-Wesley, 1999. \line (Ko97) Koenig, A., e B. Moo, Ruminations on C++, Reading, MA: Addison-Wesley, 1997. \line (Mu94) Musser, D. R., e A. A. Stepanov, \ldblquote Algorithm-Oriented Generic Libraries,\rdblquote  Software Practice e Experience, Vol. 24, No. 7, July 1994. \line (Mu96) Musser, D. R., e A. Saini, STL Tutorial e Reference Guide: C++ Programming wjth the Standard Template Libraty, Reading, MA: Addison-Wesley, 1996. \line (Ne95) Nelson, M., C+ + Programmer\rquote s Guide to the Standard Template Library, Foster City, CA: Programmers Press, uma divis\'e3o de IDG Books Worldwide, mc., 1995. \line (Po97) Pohl, 1., C++ Distilled: A ConciseANSi/ISO Reference and Siyle Guide, Reading, MA: Addison-Wesley, 1997. \line (Po97a) PnhI, 1., Object-Oriented Programming Using C++, Second F.dition. Reading, M\'c1: Addison-Wesley, 1997. \line (RoOO) Robson, R., Using the STL: The C++ Standard Template Library, Springer Verlag, 2000. \line (Sc99) Schildt, H., STL Programmingfrom the Ground Up, Osborne McGraw-HilI, 1999. \line (Sr94) Stroustrup, B., \ldblquote Making a vector Fit for a Standard,\rdblquote  The C++ Report, October 1994. \line (Sr94a) Stroustrup, B., The Design and Evolution of C++, Reading, MA: Addison-Wesley, 1994. \line (Sr97) Stroustrup, B., The C++ Programming Language, Third Edition, Reading, MA: Addison-Wesley, 1997. \line (St95) Stepanov, A., e M. Lee, \ldblquote The Standard Template Library\rdblquote , Internet Distribution, Publicado em ftp: II butier hpl hp. com/stl, July 7, 1995. \line (Vi94) Vilot, M. J., \ldblquote An Introduction to the Standard Template Library,\rdblquote  The C++ Report, Vai. 6, No. 8, October 1994. \par
rsos \line 21 \par
L. 24, \par
\pard\lang1033\f1\fs20\par
}
 