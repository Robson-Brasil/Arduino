{\rtf1\ansi\ansicpg1252\deff0\deflang1033{\fonttbl{\f0\fswiss\fprq2\fcharset0 Arial;}{\f1\froman\fcharset0 Times New Roman;}}
\viewkind4\uc1\pard\lang2070\f0\fs24\par
\par
\par
\pard\sb100\sa240\ul 18 \ulnone\line T\'f3picos sobre c\'f3digo legado em C \par
.\par
Objetivos \par
\pard\par
\pard\sb100\sa240 Ser capaz de redirecionar a entrada via teclado para vir de um arquivo e redirecionar a sa\'edda no v\'eddeo para um arquivo. Ser capaz de escrever fun\'e7\'f5es que usam listas de argumentos de comprimento vari\'e1vel. \line Ser capaz de processar argumentos da linha de comando. Ser capaz de processar eventos inesperados, dentro de um programa. \line Ser capaz de alocar mem\'f3ria dinamicamente para arrays usando o estilo C de aloca\'e7\'e3o din\'e2mica de mem\'f3ria. Ser capaz de redimensionar a mem\'f3ria alocada dinamicamente usando o estilo C de aloca\'e7\'e3o din\'e2mica de mem\'f3ria. \line Usaremos um sinal que testei e considerei de longo alcance, e f\'e1cil de gritar Uaa-huu! \line Zane Grey \line Use it up, wear it out; \line rnake it do, or do without. \line An\'f4nimo \line It is quite a three-pipe problem*. \line Sir Arthur Conan Doyle \line Mas ainda assim urna uni\'e3o na divis\'e3o. \line William Shakespeare \line Jamais consegui entender o que aqueles pontos miser\'e1veis queriam dizer \line Winston Churchili \line * N. de R. T.: Tradu\'e7\'e3o literal: \ldblquote\'c9 um problema que d\'e1 para resolver em tr\'eas caximbadas\rdblquote , aludindo aos pires que s\'e3o abordados no texw. \par
868 C++ COMO PROGRAMAR \par
\ul Vis\'e3o Geral \ulnone\line 18.1 Introdu\'e7\'e3o \line 18.2 Redirecionando entradalsa\'edda nos sistemas UNIX e DOS \line 18.3 Lista de argumentos com tamanho vari\'e1vel \line 18.4 Usando argumentos na linha de comando \line 18.5 Notas sobre compila\'e7\'e3o de programas de m\'faltiplos arquivos-fonte \line 18.6 Terminando um programa com exit e atexit \line 18.7 O qualificador de tipo volatile \line 18.8 Sufixos para constantes inteiras e de ponto flutuante \line 18.9 Tratamento de sinais \line 18.10 Aloca\'e7\'e3o din\'e2mica de mem\'f3ria com calloc e realloc \line 18.11 Desvio incondicional: goto \line 18.12 Uni\'f5es \line 18.13 Especifica\'e7\'f5es de liga\'e7\'e3o \line Sum\'e1rio\bullet  Terminologia \bullet  Erros comuns de programa\'e7\'e3o Dicas de desempenho Dicas de portabilidade. Observa\'e7\'f5es de engenharia de sofrtvare Exerc\'edcios de auto-revis\'e3o \bullet  Respostas dos exerc\'edcios de auto- revis\'e3o \bullet  Exerc\'edcios \line 18.1 Introdu\'e7\'e3o \line Este cap\'edtulo apresenta v\'e1rios t\'f3picos avan\'e7ados, n\'e3o abordados em cursos introdut\'f3rios. Muitos dos recursos aqui discutidos s\'e3o espec\'edficos para sistemas operacionais particulares, especialmente UNIX e/ou DOS. Muito deste material serve para beneficiar os programadores C++ que necessitam trabalhar com c\'f3digo mais antigo, legado de C. \line 18.2 Redirecionando entrada/sa\'edda nos sistemas UNIX e Dos \line Normalmente, a entrada de dados para um programa \'e9 feita atrav\'e9s do teclado (entrada padr\'e3o) e a sa\'edda de dados de um programa \'e9 exibida no v\'eddeo (sa\'edda padr\'e3o). Na maioria dos sistemas operacionais de computadores - em particular nos sistemas UNIX e DOS - \'e9 poss\'edvel se redirecionar a entrada de dados para que sejam lidos de arquivos e redirecionar as sa\'eddas para que sejam armazenadas em arquivos. Ambas as formas de redirecionamento podem ser completadas sem o uso dos recursos de processamento das bibliotecas padr\'e3o. \line Existem v\'e1rias maneiras de se redirecionar a entrada e a sa\'edda a partir da linha de comando do UNIX. Considere o arquivo execut\'e1vel sum que l\'ea n\'fameros inteiros, um por vez, e acumula o total dos valores lidos at\'e9 que um indicador de final de arquivo seja encontrado e qIe, ent\'e3o, imprime o resultado. Normalmente, o usu\'e1rio digita n\'fameros inteiros no teclado, bem como o indicador de final de arquivo, sendo este uma combina\'e7\'e3o de teclas que indica que n\'e3o h\'e1 mais valores para serem lidos. Com o redirecionamento de entrada, estes dados podem ser armazenados em um arquivo. Por exemplo, se os dados s\'e3o armazenados no arquivo input, a linha de comando \line $ sum < input \line faz com que o programa sum seja executado; o s\'edmbolo de redirecionamento de entrada (<) indica que os dados do arquivo input (em vez do teclado) devem ser usados como os dados de entrada para o programa. O redirecionamento da entrada no sistema DOS \'e9 executado de forma id\'eantica. \line Note que $ \'e9 o prompt da linha de comando do UNIX (alguns sistemas UNIX usam como prompt o %). \line Estudantes, muitas vezes, t\'eam dificuldade de entender que redirecionamento \'e9 uma fun\'e7\'e3o do sistema operacional e n\'e3o outra caracter\'edstica de C++. \par
CAP\'cdTULO 18 - T\'f3picos SOBRE C\'d3DIGO LEGADO EM C 869 \line O segundo m\'e9todo de redirecionamento de entrada \'e9 o uso de pipes. Um pipe ( 1 ) faz com que a sa\'edda de um programa seja redirecionada como entrada para outro programa. Suponha que o programa random tenha como sa\'edda uma s\'e9rie de n\'fameros inteiros rand\'f4micos; a sa\'edda do programa randoin pode ser \ldblquote canalizada\rdblquote  diretamente para o programa sum usando a linha de comando UNIX \line $ randoin 1 sum \line Isto faz com que seja calculada a soma dos n\'fameros inteiros produzidos por random. Ouso de pipes pode ser feito em UNIX e em DOS. \line A sa\'edda de um programa pode ser redirecionada para um arquivo usando-se o s\'edmbolo de redirecionamento \line (>)(o mesmo s\'edmbolo \'e9 utilizado em UNIX e DOS). Por exemplo, para redirecionar a sa\'edda do programa randorn para o arquivo out, use \line $ random > out \line Finalmente, a sa\'edda de um programa pode ser acrescentada no final de um arquivo que j\'e1 exista utilizando-se o \line s\'edmbolo de acrescentar (\'bb) (o mesmo s\'edmbolo \'e9 utilizado em UNIX e em DOS). Por exemplo, para acrescentar a \line sa\'edda do programa random no final do arquivo out, criado na linha de comando acima, use a linha de comando \line $ random \'bb out \line 18.3 Lista de argumentos com tamanho vari\'e1vel \line [Nota: este material foi inclu\'eddo para beneficiar os programadores de C++ que t\'eam que trabalhar com codigo legado escrito em C. Em C++, os programadores utilizam a sobrecarga de fun\'e7\'f5es para conseguir muito do que os programadores de C conseguem com uma lista de argumentos de tamanho vari\'e1velj. E poss\'edvel se criar fun\'e7\'f5es que recebam uma quantidade n\'e3o especificada de argumentos. Retic\'eancias (. . .) em um prot\'f3tipo de fun\'e7\'e3o indicam que a fun\'e7\'e3o recebe um n\'famero vari\'e1vel de argumentos de qualquer tipo. Note que as retic\'eancias devem ser colocadas no final da lista de argumentos. ou seja. como o \'faltimo nome de argumento da lista. Macros e defini\'e7\'f5es do cabe\'e7alho de argumentos vari\'e1veis <cstdarg> (Fig. 18.1) oferecem os recursos necess\'e1rios para construir fun\'e7\'f5es com listas de argumentos de tamanho vari\'e1vel. \par
Fig. 18.1 O tipo e as macros definidas no cabe\'e7alho cstdarg. \line A Fig. 18.2 demonstra a fun\'e7\'e3o average que recebe um n\'famero vari\'e1vel de argumentos. O primeiro argumento de average \'e9 sempre a quantidade de valores cuja m\'e9dia deve ser calculada. \par
\pard\par
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1231\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx8946\pard\intbl Identificador \cell Descri\'e7\'e3o \cell\row
\intbl va_list \cell Um tipo adequado para armazenar as informa\'e7\'f5es necess\'e1rias para as macros va_arg e va_end. Para acessar os argumentos em uma lista de argumentos de tamanho vari\'e1vel, deve ser declarado um objeto do tipo va_list. \cell\row
\intbl vastart \cell Uma macro que \'e9 chamada antes que se possa acessar os argumentos de uma lista de argumentos de tamanho vari\'e1vel. A macro inicializa o objeto declarado com va list para ser utilizado pelas macros va_arg e vaend. \cell\row
\intbl vaarg \cell Uma macro que \'e9 expandida para uma express\'e3o de valor e tipo do pr\'f3ximo argumento da lista de argumentos de tamanho vari\'e1vel. Cada invoca\'e7\'e3o de va_arg modifica o objeto declarado com va_list de modo que passe a apontar para o pr\'f3ximo argumento na lista. \cell\row
\intbl va_end \cell Uma macro que facilita o retomo normal de uma fun\'e7\'e3o cuja lista de argumentos de tamanho vari\'e1vel foi referenciada pela macro vastart. \cell\row
\pard\par
\pard\sb100\sa240 870 C\'f7+ COMO PROGRAMAR \line 1 // Fig. 18.2: figlBO2.cpp \line 2 II Usando listas de argumentos de tamanho vari\'e1vel \line 3 #include <iostream> \line 4 \line 5 using std::cout; \line 6 using std::endl; \line 7 using std::ios; \line 8 \line 9 #include <iomanip> \line 10 \line 11 using std::setw; \line 12 using std::setprecision; \line 13 using std::setiosflags; \line 14 \line 15 #include <cstdarg> \line 16 \line 17 double average( int, ... \line 18 \line 19 int main() \line 20 \{ \line 21 doublew=37.5, x=22.5, y=l.7, z=10.2; \line 22 \line 23 cout \'ab setiosflags( ios::fixed 1 ios::showpoint \line 24 \'ab setprecision( 1 ) \'ab w = \'ab w \'ab \ldblquote\\nx = \ldblquote  \'ab x \line 25 \'ab \ldblquote\\ny = \'ab y \'ab \lquote\\nz = \ldblquote  \'ab z \'ab endl; \line 26 cout \'ab setprecision( 3 ) \'ab \ldblquote\\nA m\'e9dia de w e x \'e9 \line 27 \'ab average( 2, w, x \line 28 \'ab \ldblquote\\nA m\'e9dia de w, x e y \'e9 \line 29 \'ab average( 3, w, x, y \line 30 \'ab \ldblquote\\nA m\'e9dia de w, x, y e z \'e9 \line 31 \'ab average( 4, w, x, y, z ) \'ab endl; \line 32 return 0; \line 33 \line 34 \line 35 double average( int i, \line 36 \{ \line 37 double total = 0; \line 38 va_list ap; \line 39 \line 40 va_start( ap, i ); \line 41 \line 42 for ( int j = 1; j <= i; ++ \line 43 total += va_arg( ap, double ); \line 44 \line 45 va_end( ap ); \line 46 \line 47 return total / i; \line 48 ) \line w = 37.5 \line x = 22.5 \line y = 1.7 \line z = 10.2 \line Am\'e9dia de w ex \'e9 30.000 \line Am\'e9diadew, xey\'e9 20.567 \line A m\'e9dia de w, x, y e z \'e9 17.975 \line Fig. 18.2 Usando listas de argumentos de tamanho vari\'e1vel. \par
CAP\'cdTULO 18 - T\'f3picos SOBRE C\'d3DIGO LEGADO EM C 871 \par
A fun\'e7\'e3o average usa todas as defini\'e7\'f5es e macros do cabe\'e7alho <cstdarg>. O objeto ap, do tipo valist, \'e9 usado pelas macros va_start, va arg e va_end para processar a lista de argumentos de tamanho vari\'e1vel da fun\'e7\'e3o average. A fun\'e7\'e3o invoca va_start para inicializar o objeto ap que ser\'e1 utilizado em va_arg e va_end. A macro recebe dois argumentos - o objeto ap e o identificador do argumento mais \'e0 direita da lista de argumentos antes das retic\'eancias - i neste caso (va start usa i aqui para determinar onde inicia a lista de argumentos). Em seguida, a fun\'e7\'e3o average, repetidamente, adiciona argumentos da lista de argumentos de tamanho vari\'e1vel \'e0 vari\'e1vel total. O valor a ser adicionado em total \'e9 recuperado atrav\'e9s da lista de argumentos chamando-se a macro va arg. A macro va arg recebe dois argumentos - o objeto ap e o tipo de valor esperado na lista de argumentos (double neste caso) - e retorna o valor do argumento. A fun\'e7\'e3o average chama a macro vaend com o objeto ap como argumento para facilitar o retomo normal de average para main. Finalmente, a m\'e9dia \'e9 calculada e retornada para main. Note que usamos apenas argumentos double para a parte da lista com n\'famero vari\'e1vel de argumentos. Na verdade, qualquer tipo de dados ou a mistura de tipos de dados podem ser usados, visto que o tipo exato \'e9 especificado cada vez que va arg \'e9 usado. \line Erro comum de programa\'e7\'e3o 18.1 \line Colocur as retic\'eancias no meio da lista de par\'e2metros da fun\'e7\'e3o. As retic\'eancias s\'f3 podem ser colocadas nofim da lista de par\'e2metros. \line 18.4 Usando argumentos na linha de comando \line Em muitos sistemas -. DOS e UNIX em particular - \'e9 poss\'edvel se passar argumentos para main atrav\'e9s da linha de comandos, incluindo-se os par\'e2metros int argce char *argv[] na listade par\'e2metros de main. O par\'e2metro argc recebe o n\'famero de argumentos da linha de comando. O par\'e2metro argv \'e9 um array de strings onde foram armazenados os argumentos da linha de comando atual. O uso comum de argumentos da linha de comando inclui imprimir esses argumentos, a passagem de op\'e7\'f5es para o programa e a passagem de nomes de arquivos para o programa. \line A Fig. 18.3 copia um arquivo para outro, um caractere por vez. O nome do arquivo que cont\'e9m o programa execut\'e1vel chama-se copy. Uma linha de comando t\'edpica para o programa copy no sistema UNIX \'e9 \line $ copy input output \line Esta linha de comando indica que o arquivo input \'e9 copiado para o arquivo output. Quando o programa \'e9 executado, se argc n\'e3o \'e9 3 (copy \'e9 contado como um dos argumentos), o programa imprime uma mensagem de erro e termina. Caso contr\'e1rio, o array argv cont\'e9m os strings \ldblquote copy\rdblquote , \ldblquote input\rdblquote  e \ldblquote output\rdblquote . O segundo e terceiro argumentos, na linha de comando, s\'e3o utilizados como nomes de arquivos pelo programa. Os arquivos s\'e3o abertos criando-se um objeto ifstream inFile e um objeto ofstream outFile. Se os dois arquivos s\'e3o abertos com sucesso, os caracteres s\'e3o lidos do arquivo input atrav\'e9s da fun\'e7\'e3o membro get e gravados no arquivo output atrav\'e9s da fun\'e7\'e3o membro put at\'e9 que o indicador de final do arquivo input seja encontrado. Ent\'e3o, o programa termina. O resultado \'e9 a c\'f3pia exata do arquivo input. Note que n\'e3o s\'e3o todos os sistemas operacionais de computadores que suportam argumentos na linha de comando de maneira t\'e3o f\'e1cil como o UNIX e o DOS. Os sistemas Macintosh e VMS, por exemplo, requerem uma inicializa\'e7\'e3o especial para processar argumentos da linha de comando. Veja o manual do seu sistema para maiores informa\'e7\'f5es sobre o uso de argumentos na linha de comando. \line 1 II Fig. 18.3: figl8_03.cpp \line 2 // Usando argumentos de linha de comando \line 3 #include <iostream> \line 4 \line 5 using std::cout; \line 6 using std::endl; \line 7 using std::ios; \line 8 \par
Fig. 18.3 Usando argumentos na linha de comando (parte 1 de 2). \par
872 C++ CoMo PROGRAMAR \line 9 #include <fstream> \line 10 \line 11 using std::ifstream; \line 12 using std::ofstream; \line 13 \line 14 int main( int argc, char *argv[] \line 15 \{ \line 16 if ( argc != 3 \line 17 cout \'ab \ldblquote Uso: copiar entrada saida\rdblquote  \'ab endi; \line 18 else \{ \line 19 ifstream inFile( argv[ 1 1, ios::in ); \line 20 \line 21 if ( !inFile ) \{ \line 22 cout \'ab argv[ 1 ] \'ab \ldblquote  n\'e3o pode ser aberto\rdblquote  \'ab endi; \line 23 return -1; \line 24 ) \line 25 \line 26 ofstream outFile( argv[ 2 ], ios::out ); \line 27 \line 28 if ( !outFile ) \{ \line 29 cout \'ab argv[ 2 ] \'ab \lquote  n\'e3o pode ser aberto\rdblquote  \'ab endl; \line 30 inFile.closeO; \line 31 return -2; \line 32 \line 33 \line 34 while ( \lquote inFile.eof() \line 35 outFile.put( static_cast< char >( inFile.get() ) ); \line 36 \line 37 inFile.close() \line 38 outFile.close(); \line 39 \} \line 40 \line 41 return 0; \line 42 \} \line Fig. 18.3 Usando argumentos na linha de comando (parte 2 de 2). \line 1 \line 18.5 Notas sobre compila\'e7ao de programas de multiplos \line arquivos-fonte \line Como citado anteriormente neste texto, \'e9 poss\'edvel se criar programas que consistam em multiplos arqulvos-tonte (ver Cap\'edtulo 6). Existem v\'e1rias considera\'e7\'f5es quando se criam programas a partir de m\'faltiplos arquivos. Por exempio, a defini\'e7\'e3o de uma fun\'e7\'e3o deve estar contida em um \'fanico arquivo - n\'e3o pode estar espalhada em dois ou mais arquivos. \line No Cap\'edtulo 3, introduzimos os conceitos de classes de mem\'f3ria e escopo. Aprendemos que vari\'e1veis declaradas fora das defini\'e7\'f5es de fun\'e7\'e3o s\'e3o da classe de mem\'f3ria static, por default, e s\'e3o refer\'eancias \'e0s vari\'e1veis globais. Vari\'e1veis globais s\'e3o acess\'edveis por qualquer fun\'e7\'e3o definida no mesmo arquivo, ap\'f3s a declara\'e7\'e3o da vari\'e1vel. Vari\'e1veis globais tamb\'e9m s\'e3o acess\'edveis por fun\'e7\'f5es que est\'e3o em outros arquivos, por\'e9m, vari\'e1veis globais devem ser declaradas em cada arquivo que forem utilizadas. Por exemplo, se definirmos uma vari\'e1vel global inteira flag em um arquivo e nos referirmos a ela em um segundo arquivo, o segundo arquivo deve ter a declara\'e7\'e3o \line extern int flag; \line antes das vari\'e1veis usadas neste arquivo. Na declara\'e7\'e3o acima, o especificador de classe de mem\'f3ria extern indica para o compilador que a vari\'e1vel flag \'e9 definida ou mais adiante, no mesmo arquivo, ou em outro arquivo. O compilador informa ao editor de liga\'e7\'e3o que uma refer\'eancia n\'e3o resolvida para a vari\'e1vel flag aparece no arquivo (o compilador n\'e3o sabe onde flag foi definida, ent\'e3o deixa o editor de liga\'e7\'e3o tentar encontrar flag). Se \par
CAP\'cdTULO 18 - T\'f3picos SOBRE C\'d3DIGo LEGADO EM C 873 \line o editor de liga\'e7\'e3o n\'e3o localizar a defini\'e7\'e3o de flag, um erro de edi\'e7\'e3o de liga\'e7\'e3o \'e9 reportado e o arquivo execut\'e1vel n\'e3o \'e9 gerado. Se a defini\'e7\'e3o global apropriada \'e9 encontrada, o editor de liga\'e7\'e3o resolve a refer\'eancia indicando onde flag foi localizado. \line Dica de desempenho 18.1 \line ______ Vari\'e1veis globais melhoram o desempenho, porque podem ser acessadas diretamente por qualquer fun\'e7\'e3o - o overhead de passagem de dados para fun\'e7\'f5es \'e9 eliminado. \line Observa\'e7\'e3o de engenharia de software 18.1 \line ______ Vari\'e1veis globais devem ser evitadas, a menos que o desempenho da aplica\'e7\'e3o seja importante, porque elas violam o princ\'edpio do m\'ednimo privil\'e9gio e tornam o software de dif\'edcil manuten\'e7\'e3o. \line Da mesma forma que as declara\'e7\'f5es extern podem ser usadas para declarar vari\'e1veis globais para outros arquivos de programa, prot\'f3tipos de fun\'e7\'e3o podem estender o escopo de uma fun\'e7\'e3o al\'e9m do arquivo em que foi definida (o especificador extern n\'e3o \'e9 requerido no prot\'f3tipo de fun\'e7\'e3o). Isto se consegue incluindo-se o prot\'f3tipo da fun\'e7\'e3o em cada arquivo em que a fun\'e7\'e3o for chamada e compilando os arquivos todos juntos (ver Se\'e7\'e3o 17.2). Prot\'f3tipos de fun\'e7\'e3o indicam para o compilador que a fun\'e7\'e3o especificada foi definida ou mais adiante, no mesmo arquivo, ou em outro arquivo. O compilador n\'e3o tenta resolver refer\'eancias a tal fun\'e7\'e3o - esta \'e9 uma tarefa para o editor de liga\'e7\'e3o. Se o editor de liga\'e7\'e3o n\'e3o localizar uma defini\'e7\'e3o da fun\'e7\'e3o, \'e9 gerado um erro. \line Como um exemplo do uso de prot\'f3tipos de fun\'e7\'e3o para estender o escopo de uma fun\'e7\'e3o, considere qualquer programa contendo a diretiva do pr\'e9-processador #include <cstring>. Esta diretiva inclui no arquivo prot\'f3tipos de fun\'e7\'f5es, tais como strcmp e strcat. Outras fun\'e7\'f5es no arquivo podem usar strciup e strcat para completar as suas tarefas. As fun\'e7\'f5es strcmp e strcat foram definidas para n\'f3s separadamente. N\'e3o precisamos saber onde elas foram definidas. Simplesmente reutilizamos o c\'f3digo em nossos programas. O editor de liga\'e7\'e3o resolve nossas refer\'eancias para essas fun\'e7\'f5es. Esse processo nos permite usar as fun\'e7\'f5es da biblioteca padr\'e3o. \line Observa\'e7\'e3o de engenharia de software 18.2 \line ______ Criar programas em m\'faltiplos arquivos-fonte facilita a reutiliza\'e7\'e3o e a boa engenharia de soflware. Fun\'e7\'f5es podem ser comuns a muitas aplica\'e7\'f5es. Em tais casos, essas fun\'e7\'f5es devem ser armazenadas em seu pr\'f3prio arquivo-fonte e cada arquivo-fonte deve ter um arquivo de cabe\'e7alho correspondente, contendo os prot\'f3tipos das fun\'e7\'f5es. Isto permite que os programadores de diferentes aplica\'e7\'f5es reutilizem o mesmo c\'f3digo, incluindo o arquivo de cabe\'e7alho apropriado e compilando a sua aplica\'e7\'e3o com o arquivo-fonte correspondente. \line Dica de portabilidade 18.1 \line ______ Alguns sistemas n\'e3o suportam nomes de vari\'e1veis globais ou nomes de fun\'e7\'f5es com mais de 6 caracteres. Isto deve ser considerado quando escrevemos programas que ser\'e3o portados para m\'faltiplas plataformas. \line\'c9 poss\'edvel se restringir o escopo de uma vari\'e1vel global ou fun\'e7\'e3o ao arquivo onde \'e9 definida. O especificador da classe de armazenamento static, quando aplicado a uma vari\'e1vel global ou a uma fun\'e7\'e3o, evita que ela seja usada por qualquer fun\'e7\'e3o que n\'e3o tenha sido definida no mesmo arquivo. Isto \'e9 chamado de liga\'e7\'e3o interna. Vari\'e1veis globais e fun\'e7\'f5es que n\'e3o s\'e3o precedidas por static em suas defini\'e7\'f5es t\'eam liga\'e7\'e3o externa - elas podem ser acessadas em outros arquivos se estes arquivos contiverem declara\'e7\'f5es e/ou prot\'f3tipos de fun\'e7\'f5es apropriados. \line A declara\'e7\'e3o da vari\'e1vel global \line static double pi = 3.14159; \line cria a vari\'e1vel pi do tipo double, inicializa-a com 3. 14159 e indica que pi somente \'e9 conhecida por fun\'e7\'f5es no arquivo onde \'e9 definida. \line Ouso do especificador static \'e9 comum em fun\'e7\'f5es utilit\'e1rias que s\'e3o chamadas apenas por fun\'e7\'f5es em um arquivo particular. Se uma fun\'e7\'e3o n\'e3o \'e9 requerida fora de um arquivo particular, o princ\'edpio de m\'ednimo privil\'e9gio deve ser refor\'e7ado com o uso de static. Se uma fun\'e7\'e3o \'e9 definida antes de ser usada em um arquivo, static deve ser aplicado \'e0 defini\'e7\'e3o da fun\'e7\'e3o. Caso contr\'e1rio, static deve ser aplicado ao prot\'f3tipo da fun\'e7\'e3o. \par
874 C++ COMO PROGRAMAR \line Quando constru\'edmos programas grandes, distribu\'eddos em m\'faltiplos arquivos-fonte, compilar o programa se torna tedioso se pequenas altera\'e7\'f5es devem ser feitas em um dos arquivos e \'e9 preciso recompilar todo o programa. Muitos sistemas oferecem utilit\'e1rios para recompilar apenas o arquivo do programa modificado. No sistema UNIX, \line o utilit\'e1rio \'e9 chamado make. O utilit\'e1rio make l\'ea um arquivo chamado makefile, que cont\'e9m instru\'e7\'f5es para compilar e ligar o programa. Sistemas como o Borland C++ e o Microsoft Visual C++ para PCs oferecem utilit\'e1rios make e \ldblquote projetos\rdblquote . Para maiores informa\'e7\'f5es sobre os utilit\'e1rios make, veja o manual do seu sistema em particular. \line 18.6 Terminando um programa com exit e atexit \line A biblioteca de utilit\'e1rios gen\'e9ricos (cstdlib) oferece m\'e9todos para terminar a execu\'e7\'e3o de um programa, diferentes do retorno convencional da fun\'e7\'e3o main. A fun\'e7\'e3o exit for\'e7a o programa a terminar como se tivesse sido executado normalmente. Esta fun\'e7\'e3o \'e9 utilizada para terminar um programa quando \'e9 detectado um erro na entrada ou se o arquivo a ser processado pelo programa n\'e3o pode ser aberto. A fun\'e7\'e3o atexit registra uma fun\'e7\'e3o para ser chamada no programa chamador quando esse termina com sucesso - i.e., quando o programa termina encontrando o fim de main ou quando exit \'e9 chamada. \line A fun\'e7\'e3o atexit recebe um ponteiro para uma fun\'e7\'e3o (i.e., o nome da fun\'e7\'e3o) como um argumento. Fun\'e7\'f5es chamadas para o t\'e9rmino de programas n\'e3o t\'eam argumentos e n\'e3o podem retornar um valor. At\'e9 32 fun\'e7\'f5es podem ser registradas para execu\'e7\'e3o no t\'e9rmino de um programa. \line A fun\'e7\'e3o exit recebe um argumento. O argumento \'e9 normalmente a constante simb\'f3lica EXIT_SUCCESS ou EXIT FAILURE. Se exit \'e9 chamado com EXIT SUCCESS, o valor definido na implementa\'e7\'e3o para t\'e9rmino com sucesso \'e9 retornado para o ambiente no qual foi chamado o programa. Se exit \'e9 chamado com EXIT_FAILURE. o valor definido na implementa\'e7\'e3o para t\'e9rmino sem sucesso \'e9 retornado. Quando a fun\'e7\'e3o exit \'e9 chamada, todas as fun\'e7\'f5es previamente registradas por atexit s\'e3o chamadas, em ordem inversa \'e0 do seu registro, iodos os streams associados ao programa s\'e3o liberados e fechados e o controle retorna ao ambiente hospedeiro. A Fig. 18.4 testa as fun\'e7\'f5es exit e atexit. O programa est\'e1 preparado para que o usu\'e1rio determine de que forma o programa deve terminar, ou por exit ou encontrando o fim de main. Note que a fun\'e7\'e3o print \'e9 executada ao t\'e9rmino do programa em cada caso. \line 1 // Fig. 18.4: figl8O4.cpp \line 2 II Usando as fun\'e7\'f5es exit e atexit \line 3 #include <iostream> \line 4 \line 5 using std::cout; \line 6 using std::endl; \line 7 using std::cin; \line 8 \line 9 #include <cstdlib> \line 10 \line 11 void print( void ); \line 12 \line 13 int main() \line 14 \line 15 atexit( print ); II registra a fun\'e7\'e3o print \line 16 cout \'ab \lquote Digite 1 para terminar o programa com a fun\'e7\'e3o exit \line 17 \'ab \ldblquote\\nDigite 2 para terminar o programa normalmente\\n\rdblquote ; \line 18 \line 19 int answer; \line 20 cm \'bb answer; \line 21 \line 22 if ( answer 1 \line 23 cout \'ab \lquote\\nTerminando o programa com a fun\'e7\'e3o exit\\n; \line 24 exit( EXITSUCCESS ); \line Fig. 18.4 Usando as fun\'e7\'f5es exit e atexit (parte 1 de 2). \par
CAP\'cdTULO 18 - T\'f3picos SOBRE C\'d3DIGO LEGADO EM C 875 \line 25 \} \line 26 \line 27 cout \'ab \lquote  \\nTerminando o programa atingindo o fim de main\rdblquote  \line 28 \'ab endi; \line 29 \line 30 return 0; \line 31 \line 32 \line 33 void print( void \line 34 \line 35 cout \'ab \ldblquote Executando a fun\'e7\'e3o print ao terminar o programa\\n\rdblquote  \line 36 \'ab \ldblquote Programa terminado\rdblquote  \'ab endi; \line 37 1 \line Digite 1 para terminar o programa com a fun\'e7\'e3o exit \line Digite 2 para terminar o programa normalmente \line :1 \line Terminando o programa com a fun\'e7\'e3o exit \line Executando a fun\'e7\'e3o print ao terminar o programa \line Programa terminado \line Digite 1 para terminar o programa com a fun\'e7\'e3o exit \line Digite 2 para terminar o programa normalmente \line :2 \line Terminando o programa atingindo o fim de main \line Executando a fun\'e7\'e3o print ao terminar o programa \line Programa terminado \line Fig. 18.4 Usando as fun\'e7\'f5es exit e atexit (parte 2 de 2). \line 18.7 O qualificador de tipo volatile \line O qualificador de tipo volatile \'e9 aplicado a uma defini\'e7\'e3o de uma vari\'e1vel que pode vir a ser alterada de fora do programa (i.e., a vari\'e1vel n\'e3o est\'e1 completamente sob controle do programa). Assim, o compilador n\'e3o pode executar otimiza\'e7\'f5es (como acelerar a execu\'e7\'e3o do programa ou reduzir o consumo de mem\'f3ria, por exemplo) que dependem de \ldblquote saber que o comportamento de uma vari\'e1vel \'e9 influenciado somente pelas atividades do programa que o compilador pode observar\rdblquote . \line 18.8 Sufixos para constantes inteiras e de ponto flutuante \line C++ oferece sufixos inteiros e de ponto flutuante para especificar os tipos de constantes inteiras e de ponto flutuante. Os sufixos de inteiros s\'e3o: u ou U para um inteiro unsigned, 1 ou L para um inteiro long e ul ou UL para um inteiro uns igned long. As seguintes constantes s\'e3o do tipo unsigned. long e uns igned long, respectivamente: \line 174u \line 8358L \line 28373u1 \line Se uma constante inteira n\'e3o \'e9 seguida por um sufixo, seu tipo \'e9 determinado pelo primeiro tipo capaz de armazenar um valor daquele tamanho ( primeiro int, depois long int e, ent\'e3o, uns igned long int). \par
876 c++ COMO PROGRAMAR \line Os sufixos de ponto flutuante s\'e3o: f ou F para float e 1 ou L para um long double. As constantes a \line seguir s\'e3o do tipo long double e float, respectivamente: \line 3. 14159L \line 1. 28f \line Uma constante de ponto flutuante sem sufixo \'e9 do tipo double. Uma constante sem um sufixo apropriado resulta ou em um aviso ou um erro do compilador. \line 18.9 Tratamento de sinais \line Um evento inesperado, ou sinal, pode terminar um programa prematuramente. Alguns eventos inesperados incluem interrup\'e7\'f5es (pressionar Ctrl-c em um sistema UNIX ou DOS), instru\'e7\'f5es ilegais, viola\'e7\'f5es de segmenta\'e7\'e3o, ordens de t\'e9rmino vindas do sistema operacional e exce\'e7\'f5es de ponto flutuante ( divis\'e3o por zero ou multiplica\'e7\'e3o de valores muito grandes em ponto flutuante). A biblioteca de tratamento de sinais oferece a fun\'e7\'e3o signal para capturar eventos inesperados. A fun\'e7\'e3o signal recebe dois argumentos - um n\'famero de sinal inteiro e um ponteiro de acesso \'e0 fun\'e7\'e3o de tratamento de sinal. Sinais podem ser gerados pela fun\'e7\'e3o raise. que recebe um n\'famero de sinal inteiro como um argumento. A Fig. 18.5 resume os sinais padr\'e3o definidos no arquivo de cabe\'e7alho <csignal>. A Fig. 18.6 demonstra as fun\'e7\'f5es signal e raise. \par
Fig. 18.5 Os sinais definidos no cabe\'e7alho csignal. \line A Fig. 18.6 captura um sinal interativo (SIGINT) com a fun\'e7\'e3o signal. O programa chama signal com SIGINT e um ponteiro para a fun\'e7\'e3o signal handler (lembre que o nome de uma fun\'e7\'e3o \'e9 um ponteiro para a fun\'e7\'e3o). Agora. quando ocorre um sinal do tipo SIGINT. a fun\'e7\'e3o signal handier \'e9 chamada. uma mensagem \'e9 impressa e o usu\'e1rio recebe a op\'e7\'e3o de continuar a execu\'e7\'e3o do programa normalmente. Se o usu\'e1rio optar por continuar a execu\'e7\'e3o, o acesso ao sinal \'e9 reinicializado chamando-se signal novamente (alguns sistemas exigem que o tratador de sinal seja reinicializado) e o controle retorna ao ponto do programa em que foi detectado o sinal. Neste programa, a fun\'e7\'e3o raise \'e9 utilizada para simular um sinal interativo. Um n\'famero rand\'f4mico entre 1 e 50 \'e9 escolhido. Se o n\'famero \'e9 25, ent\'e3o raise \'e9 chamada para gerar um sinal. Normalmente, sinais interativos s\'e3o inicial izados fora do programa. Por exemplo, pressionar Ctrl-c durante a execu\'e7\'e3o de um programa nos sistemas UNIX e DOS gera um sinal que termina a execu\'e7\'e3o do programa. O tratamento de sinais pode ser usado para capturar o sinal interativo e evitar que o programa seja terminado. \line 1 II Fig. 18.6: figl8_06.cpp \line 2 // Utilizando tratamento de sinais \line 3 #include <iostreani> \line 4 \line Fig. 18.6 Utilizando tratamento de sinais (parte 1 de 3). \par
\pard\par
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx899\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx7843\pard\intbl Sinal \cell Explica\'e7\'e3o \cell\row
\intbl SIGABRT \cell T\'e9rmino anormal de um programa (como uma chamada para abort). \cell\row
\intbl 5 IGFPE \cell Uma opera\'e7\'e3o aritm\'e9tica errada, como divis\'e3o por zero uma opera\'e7\'e3o resultando em estouro. \cell\row
\intbl SIGILL \cell Detec\'e7\'e3o de uma instru\'e7\'e3o ilegal. \cell\row
\intbl SIGINT \cell Recebimento de um sinal de aten\'e7\'e3o interativo. \cell\row
\intbl SIGSEGV \cell Acesso \'e0 mem\'f3ria inv\'e1lido. \cell\row
\intbl SIGTERM \cell Requisi\'e7\'e3o de t\'e9rmino enviada a um programa. \cell\row
\pard\par
\pard\sb100\sa240 CAP\'cdTULO 18 - T\'f3picos SOBRE C\'d3DIGo LEGADO EM C 877 \line 5 using std: :cout; \line 6 using std::cin; \line 7 using std::endl; \line 8 \line 9 #include <iomanip> \line 10 \line 11 using std::setw; \line 12 \line 13 #include <csignal> \line 14 #include <cstdlib> \line 15 #include <ctime> \line 16 \line 17 void signal_handler( int ); \line 18 \line 19 int main() \line 20 \line 21 signal( SIGINT, signalhandier ); \line 22 srand( time( O ) ); \line 23 \line 24 for ( int i = 1; i < 101; i++ \line 25 int x = 1 \'f7 randO % 50; \line 26 \line 27 if (x==25) \line 28 raise( SIGINT ); \line 29 \line 30 cout \'ab setw( 4 ) \'ab i; \line 31 \line 32 if(i%10=0) \line 33 cout \'ab endi; \line 34 \} \line 35 \line 36 return 0; \line 37 \} \line 38 \line 39 void signal_handler( int signalValue \line 40 \line 41 cout \'ab \ldblquote\\nSinal de interrup\'e7\'e3o (\ldblquote  \'ab signalValue \line 42 \'ab \ldblquote ) recebido.\\ri\rquote  \line 43 \'ab Deseja continuar (1 = sim ou 2 = n\'e3o)? \line 44 \line 45 int response; \line 46 cm \'bb response; \line 47 \line 48 while ( response != 1 && response = 2 ) \{ \line 49 cout \'ab \ldblquote (1 = sim ou 2 = n\'e3o)? \line 50 cm \'bb response; \line 51 \line 52 \line 53 if ( response == 1 \line 54 signal( SIGINT, signalhandier ); \line 55 else \line 56 exit( EXITSUCCESS ); \line 57 \} \line 1 2 3 4 5 6 7 8 9 10 \line 11 12 13 14 15 16 17 18 19 20 \line 21 22 23 24 25 26 27 28 29 30 \line 31 32 33 34 35 36 37 38 39 40 \line Fig. 18.6 Usando tratamento de sinais (parte 2 de 3). \par
78 C++ COMO PROGRAMAR \line 41 42 43 44 45 46 47 48 49 50 \line 51 52 53 54 55 56 57 58 59 60 \line 61 62 63 64 65 66 67 68 69 70 \line 71 72 73 74 75 76 77 78 79 80 \line 81 82 83 84 85 86 87 88 \line Sinal de interrup\'e7\'e3o (4) recebido. \line Deseja continuar (1 = sim ou 2 = n\'e3o)? 1 \line 89 90 \line 91 92 93 94 95 96 97 98 99 100 \line Fig. 18.6 Utilizando tratamento de sinais (parte 3 de 3). \line 1810 Aloca\'e7\'e3o din\'e2mica de mem\'f3ria com calloc e realloc \line No Cap\'edtulo 7, quando discutimos o estilo de aloca\'e7\'e3o din\'e2mica de mem\'f3ria de C\'f7+ com new e delete. comparamos new e delete com as fun\'e7\'f5es de C malloc e free. Os programadores de C++ devem usar new e delete e n\'e3o malloc e free. Entretanto, a maioria dos programadores de C+\rquote i- vai ter necessidade de ler uma grande quantidade de c\'f3digo legado escrito em C e, por isso, inclu\'edmos essa discuss\'e3o adicional sobre o estilo C de aloca\'e7\'e3o din\'e2mica de mem\'f3ria. \line A biblioteca de utilit\'e1rios gen\'e9ricos (<cstdlib>) oferece duas outras fun\'e7\'f5es para aloca\'e7\'e3o din\'e2mica de mem\'f3ria - calloc e realloc. Estas fun\'e7\'f5es podem ser utilizadas para criar e modificar arrays din\'e2micos. Como mostrado no Cap\'edtulo 5, o ponteiro para um array pode ser subscrito como um array. Assim, um ponteiro para uma por\'e7\'e3o cont\'edgua de mem\'f3ria, criada por cal].oc, pode ser manipulado como um array. A fun\'e7\'e3o calloc aloca dinamicamente mem\'f3ria para um array e inicializa automaticamente a mem\'f3ria com zeros, O prot\'f3tipo de calloc \'e9 \line void *cajloc ( size_t ninemb, size_t size ); \line Ela recebe dois argumentos o n\'famero de elementos (nmexnb) co tamanho de cada elemento (size) - e inicializa os elementos do array com zero. A fun\'e7\'e3o retorna um ponteiro para a mem\'f3ria alocada, ou um ponteiro nuil (0) se a mem\'f3ria n\'e3o foi alocada. \line A fun\'e7\'e3o realloc altera o tamanho de um objeto alocado anteriormente por uma chamada a malloc, calloc ou realloc. O conte\'fado original dos objetos n\'e3o \'e9 modificado, desde que a mem\'f3ria alocada seja maior do que a quantidade alocada anteriormente. Caso contr\'e1rio, o conte\'fado se mant\'e9m inalterado at\'e9 o tamanho do novo objeto. O prot\'f3tipo para realloc \'e9 \line void *realloc ( void *ptr, size_t size ); \line A fun\'e7\'e3o realloc recebe dois argumentos - um ponteiro para o objeto original (ptr) e o novo tamanho do objeto (size). Se ptr \'e9 0, realloc age da mesma forma que malloc. Se size \'e9 O e ptr \'e9 diferente de 0, a mem\'f3ria para o objeto \'e9 liberada. Por outro lado, se ptr \'e9 diferente de O e size \'e9 maior do que zero, realJ.oc tenta alocar um novo bloco de mem\'f3ria. Se o novo espa\'e7o n\'e3o pode ser alocado, o objeto apontado por ptr n\'e3o \'e9 alterado. A fun\'e7\'e3o realloc retorna ou um ponteiro para a mem\'f3ria realocada ou um ponteiro nulo. \line 18.11 Desvio incondicional: goto \line Ao longo de todo o texto, temos salientado a import\'e2ncia do uso das t\'e9cnicas de programa\'e7\'e3o estruturada para se construir software consistente de f\'e1cil depura\'e7\'e3o, manuten\'e7\'e3o e modifica\'e7\'e3o. Em alguns casos, o desempenho \'e9 mais importante do que uma restrita observ\'e2ncia \'e0s t\'e9cnicas de programa\'e7\'e3o estruturada. Nestes casos, podem ser utilizadas algumas t\'e9cnicas de programa\'e7\'e3o n\'e3o-estruturada. Por exemplo, podemos usar break para terminar a execu\'e7\'e3o de uma estrutura de repeti\'e7\'e3o antes que a condi\'e7\'e3o do la\'e7o de continua\'e7\'e3o seja falsa. Isto evita repeti\'e7\'f5es desnecess\'e1rias do la\'e7o se a tarefa foi completada antes do t\'e9rmino do la\'e7o. \line Outra inst\'e2ncia da programa\'e7\'e3o n\'e3o-estruturada \'e9 o comando goto - um desvio incondicional. O resultado \line do comando goto \'e9 o desvio do fluxo de controle do programa para o primeiro comando ap\'f3s o r\'f3tulo especificado \par
CAP\'cdTULO 18 - T\'f3picos SOBRE C\'d3DIGO LEGADO EM C 879 \par
no comando goto. Um r\'f3tulo \'e9 um identificador seguido por dois-pontos (:). Um r\'f3tulo deve aparecer na mesma fun\'e7\'e3o que o comando goto que se refere a esse r\'f3tulo . A Fig. 18.7 usa o comando goto para repetir um la\'e7o dez vezes e imprime o valor do contador a cada itera\'e7\'e3o. Depois de inicializar count com 1, o programa testa se count \'e9 maior do que 10 (o r\'f3tulo start \'e9 saltado porque r\'f3tulos n\'e3o executam nenhuma a\'e7\'e3o). Se for, o controle \'e9 transferido por goto para o primeiro comando depois do r\'f3tulo end. Caso contr\'e1rio, count \'e9 impresso e incrementado e o controle \'e9 transferido por goto para o primeiro comando depois do r\'f3tulo start. \line No Cap\'edtulo 2, estabelecemos que eram necess\'e1rias apenas tr\'eas estruturas de controle para se escrever qualquer programa - seq\'fc\'eancia, sele\'e7\'e3o e repeti\'e7\'e3o. Quando s\'e3o seguidas as regras da programa\'e7\'e3o estruturada, \'e9 poss\'edvel se criar estruturas de controle profundamente aninhadas, das quais \'e9 dif\'edcil sair de uma maneira eficiente. Alguns programadores usam o comando goto em tais situa\'e7\'f5es como uma sa\'edda r\'e1pida de uma estrutura profundamente aninhada. Isso elimina a necessidade de testar diversas condi\'e7\'f5es para sair de uma estrutura de controle. \line II Fig. 18.7: figl8_07.cpp \line II Usando goto \line #include <iostream> \line using std::cout; \line using std::endl; \line int main() \line int count = 1; \line start: II r\'f3tulo \line if ( count > 10 \line goto end; \line cout \'ab count \'ab \line ++count; \line goto start; \line end: // r\'f3tulo \line cout \'ab endl; \line return 0; \par
1 \line 2 \line 3 \line 4 \line 5 \line 6 \line 7 \line 8 \line 9 \line 10 \line 11 \line 12 \line 13 \line 14 \line 15 \line 16 \line 17 \line 18 \line 19 \line 20 \line 21 \line 22 \line 23 \par
2 3 4 5 6 7 8 9 10 \par
\pard\sb100\sa100 Fig. 18.7 Usando goto. \line Dica de desempenho 18.2 \line _____ O comando goto pode ser usado para sair de maneira eficiente de uma estrutura de controle profundamente aninhada. \line Observa\'e7\'e3o de engenharia de software 18.3 \line ______ O comando goto deve ser utilizado apenas em aplica\'e7\'f5es orientadas para desempenho. O comando goto \'e9 n\'e3o-estruturado e pode levar a programas que s\'e3o mais dif\'edceis de se depurar manter e modi ficar \par
\pard\sb100\sa240 880 C++ COMO PROGRAMAR \line 18.12 Uni\'f5es \line Uma uni\'e3o (definida com a palavra-chave union) \'e9 uma regi\'e3o de mem\'f3ria que, a cada momento, pode conter objetos de tipos diferentes. Contudo, em um determinado momento, uma uniori pode conter no m\'e1ximo um objeto, porque os membros de uma uni\'e3o compartilham o mesmo espa\'e7o de armazenamento. E de responsabilidade do programador assegurar que o dado em uma union seja referenciado com um nome de membro do tipo de dado apropriado. \line Erro comum de programa\'e7\'e3o 18.2 \line O resultado da refer\'eancia a um membro de uma uni\'e3o diferente do \'faltimo armazenado \'e9 indefinido. Ela trata os dados armazenados como um tipo diferente. \line Dica de portabilidade 18.2 \line ______ Se dados s\'e3o armazenados em uma uni\'e3o como um tipo e s\'e3o referenciados como outro tipo, os resultados s\'e3o dependentes da implementa\'e7\'e3o. \line Em momentos diferentes durante a execu\'e7\'e3o de um programa, alguns objetos podem n\'e3o ser relevantes, enquanto outro objeto \'e9 - assim, uma union compartilha o espa\'e7o em vez de desperdi\'e7ar mem\'f3ria com objetos que n\'e3o est\'e3o sendo usados, O n\'famero de bytes usados para armazenar uma uni\'e3o deve ser pelo menos suficiente para conter o maior membro. \line\ul tDica \ulnone de desempenho 18.3 \line\bullet  Usar union economiza mem\'f3ria. \line Dica de portabilidade 18.3 \line _____ A quantidade de mem\'f3ria requerida para armazenar uma union \'e9 dependente da implementa\'e7\'e3o. \line Dica deportabilidade 18.4 \line _____ A/guinas union podem n\'e3o ser f\'e1ceis de se portar para outros sistemas de computador Se uma uni\'e3o \'e9 port\'e1vel ou n\'e3o freq\'fcentemente depende dos requisitos de alinhamento de mem\'f3ria para os tipos de dados \line dos membros da uni\'e3o em um dado sistema. \line Uma union \'e9 declarada com o mesmo formato de uma estrutura ou de uma classe. Por exemplo, \line union Number \{ \line int x; \line double y; \line indica que Number \'e9 um tipo uriion com os membros int x e double y. A defini\'e7\'e3o de union normalmente precede main em um programa, de modo que a defini\'e7\'e3o pode ser utilizada para declarar vari\'e1veis em todas as fun\'e7\'f5es do programa. \line Observa\'e7\'e3o de engenharia de software 18.4 \line ______ Assim como uma declara\'e7\'e3o de uma struct ou de uma class, uma declara\'e7\'e3o de uma union simplesmente cria um novo tipo. Colocar uma declara\'e7\'e3o de union ou structfora de qualquer fun\'e7\'e3o \line n\'e3o cria uma vari\'e1vel global. \line As \'fanicas opera\'e7\'f5es primitivas v\'e1lidas que podem ser executadas sobre uma uni\'e3o s\'e3o: atribu\'ed-la a outra uni\'e3o do mesmo tipo, obter o endere\'e7o (&) de uma uni\'e3o e acessar membros da uni\'e3o utilizando o operador de membro de estrutura ( . ) e o operador de ponteiro de estrutura (->). Uni\'f5es n\'e3o podem ser comparadas, pelo mesmo motivo que estruturas n\'e3o podem ser comparadas. \par
CAP\'cdTULO 18 - T\'f3picos SOBRE C\'d3DIGO LEGADO EM C 881 \line Erro comum de programa\'e7\'e3o 18.3 \line Comparar unions \'e9 um erro de sintaxe, porque o compilador n\'e3o sabe qual membro de cada uni\'e3o est\'e1 \line ativo e, portanto, qual membro de uma deve ser comparado a qual membro da outra. \line Uma union \'e9 similar a uma classe, no que diz respeito a poder ter um construtor para inicializar qualquer um dos seus membros. Uma union que n\'e3o tenha um construtor pode ser inicializada com uma outra union do mesmo tipo, com uma express\'e3o do tipo do primeiro membro da union ou com um inicializador (colocado entre chaves ( \}) do tipo do primeiro membro da union. Union podem ter outras fun\'e7\'f5es membro, tais como destruidores, mas as fun\'e7\'f5es membro de uma union n\'e3o podem ser declaradas como virtual. Os membros de uma union s\'e3o public por default. \line Erro comum de programa\'e7\'e3o 18.4 \line Inicializar uma union em uma declara\'e7\'e3o com um valor ou uma express\'e3o cujo tipo \'e9 diferente do tipo \line do primeiro membro da union. \line Uma union n\'e3o pode ser usada como uma classe b\'e1sica em heran\'e7a, i.e., classes n\'e3o podem ser derivadas de unions. Unions podem ter objetos como membros se esses objetos n\'e3o tiverem um construtor, um destruidor ou um operador de atribui\'e7\'e3o sobrecarregado. Nenhum dos membros de dados de uma union pode ser declarado como static. \line O programa na Fig. 18.8 usa a vari\'e1vel value do tipo union nuniber para exibir o valor armazenado na union tanto como um int quanto como um double. A sa\'edda do programa \'e9 dependente da implementa\'e7\'e3o. A sa\'edda do programa mostra que a representa\'e7\'e3o interna de um valor double pode ser bem diferente da representa\'e7\'e3o de um int. \line 1 II Fig. 18.8: figl8O8.cpp \line 2 1/ Um exemplo de urna uni\'e3o \line 3 #include <iostrearn> \line 4 \line 5 using std::cout; \line 6 using std: :endl; \line 7 \line 8 union Nuinber \{ \line 9 intx; \line 10 double y; \line 11 \}; \line 12 \line 13 int main() \line 14 \line 15 Nuniber value; \line 16 \line 17 value.x = 100; \line 18 cout \'ab \ldblquote Coloca um valor no membro int\\n\rdblquote  \line 19 \'ab \ldblquote e imprime os dois membros.\\nint: \line 20 \'ab value.x \'ab \ldblquote\\ndouble: \ldblquote  \'ab value.y \'ab \ldblquote\\n\\n\rdblquote ; \line 21 \line 22 value.y = 100.0; \line 23 cout \'ab \ldblquote Coloca um valor no membro double\\n\rdblquote  \line 24 \'ab \ldblquote e imprime os dois mernbros.\\nint: \line 25 \'ab value.x \'ab \ldblquote\\ndouble: \ldblquote  \'ab value.y \'ab endl; \line 26 return 0; \line 27 \line Fig. 18.8 Imprimindo o valor de uma union com os tipos de dados dos dois membros (parte 1 de 2). \par
882 C++ COMO PROGRAMAR \line Coloca um valor no membro int \line e imprime os dois membros. \line int: 100 \line double: -9.25596e+06l \line Coloca um valor no membro double \line e imprime os dois membros. \line int: O \line double: 100 \line Fig. 18.8 Imprimindo o valor de uma union com os tipos de dados dos dois membros (parte 2 de 2). \line Uma union an\'f4nima \'e9 uma uni\'e3o sem um nome de tipo, que n\'e3o tenta definir objetos ou ponteiros antes de seu ponto-e-v\'edrgula final. Uma union como esta n\'e3o cria um tipo, mas cria um objeto sem nome. Os membros de uma union an\'f4nima podem ser acessados diretamente no escopo em que a union an\'f4nima foi declarada, como se fosse outra vari\'e1vel local - n\'e3o h\'e1 necessidade do uso dos operadores ponto ( .) e seta (->). \line Union an\'f4nimas t\'eam algumas restri\'e7\'f5es. Uni\'f5es an\'f4nimas podem conter somente membros de dados. Todos \line os membros de uma union an\'f4nima s\'e3o public. E uma union an\'f4nima declarada globalmente (i.e., em escopo de arquivo) deve ser explicitamente declarada static. A Fig. 18.9 ilustra o uso de uma union an\'f4nima. \line 1 II Fig. 18.9: figl809.cpp \line 2 // Usando uma uni\'e3o an\'f4nima \line 3 #include <iostream> \line 4 \line 5 using std: :cout; \line 6 using std: :endl; \line 7 \line 8 int main() \line 9\{ \line 10 // Declara urna uni\'e3o an\'f4nima. \line 11 // Note que os membros b, d e fPtr compartilham o mesmo espa\'e7o. \line 12 union \{ \line 13 int b; \line 14 double d; \line 15 char *fptr; \line 16 \}; \line 17 \line 18 // Declara vari\'e1veis locais convencionais \line 19 intal; \line 20 double c = 3.3; \line 21 char *eptr = Uni\'e3o; \line 22 \line 23 II Atribui um valor para cada membro da uni\'e3o \line 24 II sucessivamente e imprime cada um deles. \line 25 cout\'aba\'ab \line 26 b=2; \line 27 cout \'ab b \'ab endl; \line 28 \line 29 cout \'ab c \'ab \line 30 d=4.4; \line 31 cout \'ab d \'ab endl; \line 32 \line Fig. 18.9 Usando uma union an\'f4nima (parte 1 de 2). \par
CAP\'cdTULO 18 - T\'f3picos SOBRE C\'d3DIGO LEGADO EM C 883 \line 33 cout \'ab ePtr \'ab \line 34 fPtr = an\'f4nima\rdblquote ; \line 35 cout \'ab fPtr \'ab endl; \line 36 \line 37 return O; \line 38 \} \line 12 \line 3.3 4.4 \line Uni\'e3o an\'f4nima \line Fig. 18.9 Usando uma union an\'f4nima (parte 2 de 2). \line 18.13 Especifica\'e7\'f5es de liga\'e7\'e3o \line\'c9 poss\'edvel, a partir de um programa em C++, se chamar fun\'e7\'f5es escritas e compiladas por um compilador C. Como afirmado na Se\'e7\'e3o 3.20, C++ codifica de maneira especial nomes de fun\'e7\'f5es para garantir a edi\'e7\'e3o de liga\'e7\'e3o segura quanto ao tipo. C por outro lado, n\'e3o codifica esses nomes de fun\'e7\'f5es. Assim, uma fun\'e7\'e3o compilada em C n\'e3o pode ser reconhecida quando \'e9 feita uma tentativa de se ligar o c\'f3digo C com o c\'f3digo C++, porque o c\'f3digo C++ espera uma codifica\'e7\'e3o especial do nome da fun\'e7\'e3o. C++ permite que o programador forne\'e7a especifica\'e7\'f5es de liga\'e7\'e3o para informar ao compilador que aquela fun\'e7\'e3o foi compilada por um compilador C e preveni-lo de que o nome da fun\'e7\'e3o foi inicialmente codificado por um compilador C++. As especifica\'e7\'f5es de liga\'e7\'e3o s\'e3o de grande ajuda quando foram desenvolvidas grandes bibliotecas de fun\'e7\'f5es especializadas e o usu\'e1rio ou n\'e3o tem acesso ao c\'f3digo- fonte para uma recompila\'e7\'e3o em C++ ou n\'e3o tem tempo para converter a biblioteca de fun\'e7\'f5es de C para C++. \line Para se informar ao compilador que uma ou v\'e1rias fun\'e7\'f5es foram compiladas em C, escreva os prot\'f3tipos de \line fun\'e7\'f5es da seguinte maneira: \line extern \lquote C\rdblquote  prot\'f3tipo da fun\'e7\'e3o II uma \'fanica fun\'e7\'e3o \line extern \ldblquote C\rdblquote  II m\'faltiplas fun\'e7\'f5es \line prot\'f3tipos das fun\'e7\'f5es \line Essas declara\'e7\'f5es informam ao compilador que as fun\'e7\'f5es especificadas n\'e3o foram compiladas em C++, de modo que a codifica\'e7\'e3o de nomes n\'e3o deve ser executada sobre as fun\'e7\'f5es listadas na especifica\'e7\'e3o de edi\'e7\'e3o. Essas fun\'e7\'f5es podem ent\'e3o ser adequadamentre ligadas com o programa. Os ambientes de C++ normalmente incluem as bibliotecas padr\'e3o de C e n\'e3o exigem que o programador use especifica\'e7\'f5es de liga\'e7\'e3o para essas fun\'e7\'f5es. \line Resumo \line Em muitos sistemas - em particular nos sistemas UNIX e DOS - \'e9 poss\'edvel se redirecionar entrada para um programa e sa\'edda de um programa. A entrada \'e9 redirecionada das linhas de comando do UNIX e do DOS usando o s\'edmbolo de redirecionamento de entrada (<) ou usando pipe (1). A sa\'edda \'e9 redirecionada a partir da linha de comando do UNIX e do DOS usando o s\'edmbolo de redirecionamento de sa\'edda (>) ou o s\'edmbolo de acrescentar \'e0 sa\'edda (\'bb). O s\'edmbolo de redirecionamento de sa\'edda armazena a sa\'edda do programa em um arquivo e o s\'edmbolo de acrescentar \'e0 sa\'edda coloca a sa\'edda do programa no final de um arquivo. \line\bullet  As macros e as defini\'e7\'f5es do cabe\'e7alho de argumentos vari\'e1veis cstdarg fornecem os recursos necess\'e1rios para se criar \line fun\'e7\'f5es com listas de argumentos de tamanho vari\'e1vel. \line\bullet  Retic\'eancias (. . .) em um prot\'f3tipo de fun\'e7\'e3o indicam que a fun\'e7\'e3o recebe um n\'famero vari\'e1vel de argumentos. \line\bullet  O tipo va list \'e9 usado para reter informa\'e7\'f5es necess\'e1rias \'e0s macros va start, va arg e va end. Para se acessar os argumentos em uma lista de argumentos de tamanho vari\'e1vel, um objeto do tipo va list deve ser declarado. \par
S84 C++ COMO PROGRAMAR \line A macro va start \'e9 invocada antes que os argumentos de uma lista de argumentos de tamanho vari\'e1vel possam ser acessados. A macro inicializa o objeto declarado com va list para ser usado pelas macros va arg e vaend. \line\bullet  A macro va arg expande para uma express\'e3o com o valor e o tipo do pr\'f3ximo argumento da lista de argumentos de tamanho vari\'e1vel. Cada chamada de va arg modifica o objeto declarado por va list, cujo objeto agora aponta para o pr\'f3ximo argumento da lista. \line\bullet  A macro va end facilita o retomo normal da fun\'e7\'e3o cuja lista de argumentos de tamanho vari\'e1vel foi referenciada pela macro vastart. \line\bullet  Em muitos sistemas - DOS e UNIX em particular - \'e9 poss\'edvel se passar argumentos para main atrav\'e9s da linha de comando, incluindo na lista de par\'e2metros de main os par\'e2metros int argc e char *argv (]. O par\'e2metro argc \'e9 o n\'famero de argumentos na linha de comando. O par\'e2metro argv \'e9 um array de strings contendo os argumentos da linha de comando. \line\bullet  A defini\'e7\'e3o de uma fun\'e7\'e3o deve estar contida em um arquivo - n\'e3o pode estar espalhada em dois ou mais arquivos. \line\bullet  Vari\'e1veis globais devem ser declaradas em cada arquivo em que s\'e3o utilizadas. \line\bullet  Prot\'f3tipos de fun\'e7\'f5es podem estender o escopo da fun\'e7\'e3o para fora do arquivo no qual elas foram definidas (o especificador extern n\'e3o \'e9 requerido no prot\'f3tipo da fun\'e7\'e3o). tsto \'e9 conseguido com a inclus\'e3o do prot\'f3tipo da fun\'e7\'e3o em cada arquivo em que a fun\'e7\'e3o for chamada e a compila\'e7\'e3o em conjunto desses arquivos. \line\bullet  O especificador de classe de armazenamento static, quando aplicado a uma vari\'e1vel global ou a uma fun\'e7\'e3o. evita o uso desta por outras fun\'e7\'f5es que n\'e3o foram definidas no mesmo arquivo. Isto \'e9 chamado de liga\'e7\'e3o interna. Vari\'e1veis globais e fun\'e7\'f5es que n\'e3o s\'e3o precedidas por static em suas defini\'e7\'f5es t\'eam uma liga\'e7\'e3o externa - elas podem ser acessadas em outros arquivos se esses arquivos contiverem as declara\'e7\'f5es e/ou prot\'f3tipos de fun\'e7\'f5es apropriados. \line\bullet  O especificador static \'e9 comumente usado em fun\'e7\'f5es utilit\'e1rias que s\'e3o chamadas por fun\'e7\'f5es em um arquivo particular. Se a fun\'e7\'e3o n\'e3o \'e9 requerida fora desse arquivo, o princ\'edpio de m\'ednimo privil\'e9gio deve ser garantido pelo uso de static. \line\bullet  Quando constru\'edmos programas grandes em m\'faltiplos arquivos-fonte, a compila\'e7\'e3o pode vir a ser tediosa se pequenas altera\'e7\'f5es s\'e3o feitas em um arquivo e se recompila todos os programas. Muitos sistemas fornecem utilit\'e1rios especiais para recompilar apenas do programa alterado. No sistema UNIX, o utilit\'e1rio \'e9 chamado de make. O utilit\'e1rio make l\'ea o arquivo chamado niakefile que cont\'e9m instru\'e7\'f5es para compilar e ligar o programa. \line\bullet  A fun\'e7\'e3o exit for\'e7a um programa a terminar como se tivesse executado normalmente. \line\bullet  A fun\'e7\'e3o atexit registra uma fun\'e7\'e3o do programa para ser chamada ao t\'e9rmino normal do programa - i.e., ou quando um programa termina encontrando o final de mairi ou quando exit \'e9 chamada. \line\bullet  A fun\'e7\'e3o atexit recebe um ponteiro para uma fun\'e7\'e3o (i.e., um nome de fun\'e7\'e3o) como um argumento. Fun\'e7\'f5es chamadas para terminar um programa n\'e3o podem ter argumentos e n\'e3o retornam valores. At\'e9 32 fun\'e7\'f5es podem ser registradas para a execu\'e7\'e3o no t\'e9rmino de um programa. \line\bullet  A fun\'e7\'e3o ezit recebe um argumento. O argumento normalmente \'e9 a constante simb\'f3lica EXIT SUCCESS ou a constante simb\'f3lica EXIT FAILURE. Se exit \'e9 chamada com EXIT SUCCESS, o valor definido na implementa\'e7\'e3o para o t\'e9rmino com sucesso \'e9 retornado para o ambiente chamador. Se exit \'e9 chamada com EXIT FAILURE, o valor definido na implementa\'e7\'e3o para t\'e9rmino sem sucesso \'e9 retornado. \line\bullet  Quando exit \'e9 chamada, todas as fun\'e7\'f5es registradas por atexit s\'e3o chamadas, na ordem inversa do seu registro, todas as \'e1reas associadas ao programa s\'e3o liberadas e fechadas e o controle retorna ao ambiente principal. \line\bullet  O qualificador volatile \'e9 usado para evitar otimiza\'e7\'f5es de uma vari\'e1vel, porque ela pode ser modificada fora do escopo do programa. \line\bullet  C++ oferece sufixos de inteiros e ponto flutuante para especificar constantes do tipo inteiro e ponto flutuante. Os sufixos de inteiros s\'e3o: u ou U para um inteiro unsigned. 1 ou L para um inteiro long e uJ. ou uL para um inteiro unsigned long. Se uma constante inteira n\'e3o tiver sufixo, o seu tipo \'e9 determinado pelo primeiro tipo capaz de armazenar o tamanho do seu valor (primeiro int, depois long int e por fim unsigned long int). Os sufixos de ponto flutuante s\'e3o f ou F para float e 1 ou L para long double. Uma constante de ponto flutuante sem sufixo \'e9 do tipo double. \line\bullet  A biblioteca de acesso a sinais prov\'ea a capacidade de registrar uma fun\'e7\'e3o para tratar eventos inesperados com a fun\'e7\'e3o signal. A fun\'e7\'e3o signal recebe dois argumentos - um n\'famero de sinal inteiro e um ponteiro de acesso \'e0 fun\'e7\'e3o signal. \line\bullet  Sinais podem ser gerados com a fun\'e7\'e3o raise e um argumento inteiro. \line\bullet  A biblioteca de utilit\'e1rios gen\'e9ricos cstdlib prov\'ea as fun\'e7\'f5es calloc e realloc para aloca\'e7\'e3o din\'e2mica de mem\'f3ria. Estas fun\'e7\'f5es podem ser utilizadas para se criar arrays din\'e2micos. \par
CAP\'cdTULO 18 - T\'f3picos SOBRE C\'d3DIGO LEGADO EM C 885 \line\bullet  A fun\'e7\'e3o calloc recebe dois argumentos - o n\'famero de elementos (nmemb) e o tamanho de cada elemento (size) - e inicializa os elementos do array com zeros. A fun\'e7\'e3o retoma ou um ponteiro para a mem\'f3ria alocada ou um ponteiro nulo se a mem\'f3ria n\'e3o foi alocada. \line\bullet  A fun\'e7\'e3o realloc altera o tamanho de um objeto alocado previamente por uma chamada a malloc, calloc ou realloc. O conte\'fado original dos objetos n\'e3o \'e9 modificado desde que o tamanho da mem\'f3ria seja maior do que a que foi alocada anteriormente. \line\bullet  A fun\'e7\'e3o realloc recebe dois argumentos - um ponteiro para o objeto original (ptr) e o novo tamanho do objeto (size). Se ptr \'e9 NULL, realloc age exatamente como malloc. Se size \'e9 O e o ponteiro recebido n\'e3o \'e9 NULL, a mem\'f3ria para o objeto \'e9 liberada. Por outro lado, se ptr n\'e3o \'e9 NULL e size \'e9 maior do que zero, realloc tenta alocar o novo bloco de mem\'f3ria para o objeto. Se o novo espa\'e7o n\'e3o pode ser alocado o ponteiro ptr do objeto n\'e3o \'e9 alterado. A fun\'e7\'e3o realloc pode retornar ou um ponteiro para a mem\'f3ria realocada ou um ponteiro NULL. \line\bullet  O resultado do comando goto \'e9 a altera\'e7\'e3o do fluxo de controle de um programa. A execu\'e7\'e3o do programa continua a partir do primeiro comando depois do r\'f3tulo do comando goto. \line\bullet  Um r\'f3tulo \'e9 um identificador seguido de dois pontos (:). Um r\'f3tulo deve aparecer na mesma fun\'e7\'e3o que o comando goto que se refere a ele. \line\bullet  Uma uriion \'e9 um tipo de dado derivado, cujos membros compartilham o mesmo espa\'e7o na mem\'f3ria. Os membros podem ser de qualquer tipo. A \'e1rea reservada para uma union \'e9 tal que possa conter o seu maior membro. Em muitos casos, union podem conter dois ou mais tipos de dados. Somente um membro e, conseq\'fcentemente, um tipo de dado pode ser referenciado a cada momento. \line\bullet  Uma union \'e9 declarada da mesma forma que uma estrutura. \line\bullet  Uma union pode ser inicializada somente com um valor do tipo do seu primeiro membro. \line\bullet  C++ habilita o programador a prover especifica\'e7\'f5es de liga\'e7\'e3o para informar ao compilador que certas fun\'e7\'f5es foram compiladas por um compilador C e para evitar que os nomes dessas fun\'e7\'f5es sejam codificados pelo compilador C++. \line\bullet  Para in\'cdhrmar para o compilador que uma ou mais fun\'e7\'f5es foram compiladas pelo compilador C, escreva os prot\'f3tipos de fun\'e7\'e3o como segue: \line extern \ldblquote C\rdblquote  prot\'f3tipo da fun\'e7\'e3o // um \'fanica fun\'e7\'e3o \line extern \ldblquote C\'b0 II m\'faltiplas fun\'e7\'f5es \line prot\'f3tipos das fun\'e7\'f5es \line\bullet  Essas declara\'e7\'f5es informam ao compilador que as fun\'e7\'f5es especificadas n\'e3o s\'e3o compiladas em C++, de modo que a codifica\'e7\'e3o de nomes n\'e3o deve ser feita para as fun\'e7\'f5es listadas na especifica\'e7\'e3o de liga\'e7\'e3o. Essas fun\'e7\'f5es podem ent\'e3o ser ligadas corretamente com o programa. \line\bullet  Os ambientes de C++ normalmente incluem bibliotecas padr\'e3o C e n\'e3o requerem que o programador use especifica\'e7\'f5es de liga\'e7\'e3o para utiliz\'e1-las. \line Terminologia \line argumentos de linha de comando especificador de classe armazenamento extern \line argv evento \line arrays din\'e2micos exce\'e7\'e3o de ponto flutuante \line atexit exit \line biblioteca de tratamento de sinais EXITFAILURE \line calloc EXITSUCCESS \line capturar extern \ldblquote C\rdblquote  \line comando goto instru\'e7\'e3o ilegal \line cons t interrup\'e7\'e3o \line csigna]. liga\'e7\'e3o externa \line cstdarg liga\'e7\'e3o interna \line especificador da classe armazenamento static lista de argumentos de tamanho vari\'e1vel \par
CAP\'cdTULO 18 - T\'f3picos SOBRE C\'d3DIGO LEGADO EM C 887 \line Exerc\'edcios de auto-revis\'e3o \line 18.1 Preencha os espa\'e7os em branco em cada um dos seguintes: \line a) O s\'edmbolo ___________ redireciona dados de entrada do teclado para obt\'ea-los de um arquivo. \line b) O s\'edmbolo ___________ \'e9 usado para redirecionar a sa\'edda para a tela a ser colocada em um arquivo. \line c) O s\'edmbolo___________ \'e9 usado para acrescentar a saida de um programa ao fim de um arquivo. \line d) Um ___________ \'e9 usado para dirigir a sa\'edda de um programa como a entrada para outro programa. \line e) na lista de argumentos de uma fun\'e7\'e3o indicam que a fun\'e7\'e3o recebe um n\'famero vari\'e1vel de argumentos. \line f) A macro ___________ deve ser invocada antes que os par\'e2metros em uma lista vari\'e1vel de argumentos possam ser acessados. \line g) A macro ___________ \'e9 usada para acessar os par\'e2metros individuais de uma lista vari\'e1vel de par\'e2metros. \line h) A macro ___________ facilita um retorno normal de uma fun\'e7\'e3o cuja lista vari\'e1vel de par\'e2metros foi referida pela macro vastart. \line i) O par\'e2metro de main recebe o n\'famero de par\'e2metros em uma linha de comando. \line j) O par\'e2metro de main armazena par\'e2metros de linha de comando como strings de caracteres. \line k) O utilit\'e1rio do UNIX ___________ l\'ea um arquivo chamado que cont\'e9m instru\'e7\'f5es para compilar e ligar \line um programa que consiste em m\'faltiplos arquivos-fonte. O utilit\'e1rio somente recompila um arquivo se o mesmo foi \line modificado desde que foi compilado pela \'faltima vez. \line 1) A fun\'e7\'e3o for\'e7a um programa a terminar a execu\'e7\'e3o. \line m) A fun\'e7\'e3o registra uma fun\'e7\'e3o para ser chamada no t\'e9rmino normal do programa. \line n) O qualificador de tipo indica que um objeto n\'e3o deve ser modificado depois de \'e9 inicializado. \line o) Um ____________ de inteiro ou ponto flutuante pode ser anexado a uma constante inteira ou de ponto flutuante para especificar o tipo exato da constante. \line p) A fun\'e7\'e3o pode ser usada para registrar uma fun\'e7\'e3o para capturar eventos inesperados. \line q) A fun\'e7\'e3o gera um sinal de dentro de um programa. \line r) A fun\'e7\'e3o aloca mem\'f3ria dinamicamente para um array e inicializa os elementos com zeros. \line s) A fun\'e7\'e3o muda o tamanho de um bloco de mem\'f3ria alocada dinamicamente. \line t) Uma ___________ \'e9 uma classe contendo uma cole\'e7\'e3o de vari\'e1veis que ocupam a mesma mem\'f3ria, mas em tempos \line diferentes. \line u) A palavra-chave \'e9 usada para introduzir uma defini\'e7\'e3o de uma uni\'e3o. \line Respostas aos exerc\'edcios de auto revis\'e3o \line 18.1 a) redireciona a entrada (<). b) redireciona a sa\'edda (>). c) anexa \'e0 sa\'edda (> >). d) pipe( 1). e) retic\'eancias (. . .). f) va_start.g)vaarg. h)va end. i)argc. j)argv. k)make, makefile. l)exit. m)atexit. n)const. o) \line sufixo, p) signal. q) raise. r) calloc. s) realloc. t)uni\'e3o. u) union. \line Exerc\'edcios \line 18.2 Escreva um programa que calcula o produto de uma s\'e9rie de inteiros que s\'e3o passados para a fun\'e7\'e3o product usando uma lista de argumentos de tamanho vari\'e1vel. Teste sua fun\'e7\'e3o com v\'e1rias chamadas, cada uma com um n\'famero diferente de argumentos. \line 18.3 Escreva um programa que imprime os argumentos da linha de comando do programa. \line 18.4 Escreva um programa que classifica um array de inteiros em ordem ascendente ou descendente. O programa deve usar argumentos da linha de comando para passar o par\'e2metro -a para ordem ascendente ou o par\'e2metro -d para ordem descendente. (Nota: este \'e9 o formato padr\'e3o para passar op\'e7\'f5es a um programa em UNIX.) \line 18.5 Leia os manuais do seu sistema para determinar que sinais s\'e3o suportados pela biblioteca de tratamento de sinais (csignal). Escreva um programa com tratadores de sinal para os sinais SIGABRT e SIGINT. O programa deve testar a captura destes sinais chamando a fun\'e7\'e3o abort para gerar um sinal do tipo SIG.ABRT e pela digita\'e7\'e3o de Ctrl-c para gerar um sinal do tipo SIGINT. \line 18.6 Escreva um programa que aloca dinamicamente um array de inteiros, O tamanho do array deve ser fornecido pelo teclado. Os elementos do array devem ser valores atribu\'eddos a partir da entrada pelo teclado. Imprima os valores do array. Em seguida, \par
888 C++ COMO PROGRAMAR \line realoque a mem\'f3ria do array para metade do n\'famero atual de elementos. Imprima os valores restantes no array para confirmar se eles correspondem aos valores da primeira metade do array original. \line 18.7 Escreva que um programa que recebe dois nomes de arquivos como argumentos da linha de comando, l\'ea os caracteres do primeiro arquivo um de cada vez e escreve os caracteres em ordem contr\'e1ria no segundo arquivo. \line 18.8 Escreva um programa que usa comandos goto para simular uma estrutura de la\'e7os aninhados que imprime um quadrado de asteriscos, como segue: \line **** * \line * * \line * * \line * * \line **** * \line O programa deve usar s\'f3 os tr\'eas comandos de sa\'edda seguintes: \line cout \'ab *\bullet  \line cout\'ab \line cout \'ab endi; \line 18.9 Forne\'e7a a defini\'e7\'e3o para union Data contendo char c, short s, long 1, f].oat f e double d. \line 18.10 Crie union Integer com membros char c, short s, int i e long 1. Escreva um programa que recebe como entrada valores dos tipos char, short. int e long e armazena os valores em vari\'e1veis uni\'e3o do tipo union Integer. Cada vari\'e1vel uni\'e3o deve ser impressa como um char. um short, um int e um long. Os valores s\'e3o sempre impressos corretamente? \line 18.11 Crie union FloatingPoint com membros fJ.oat f, double de long doubJ.e 1. Escreva um programa que recebe como entrada valores dos tipo float, double e long double e armazena os valores em vari\'e1veis uni\'e3o do tipo union FloatingPoint. Cada vari\'e1vel uni\'e3o deve ser impressa como um float. um double e um long double. Os valores s\'e3o sempre impressos corretamente? \line 18.12 Dada aunion \line union A \{ \line double y; \line char *Z; \line qual dos seguintes itens s\'e3o comandos corretos para inicializar esta union? \line a) A p = B; // B \'e9 do mesmo tipo que A \line b)A q = x; //x \'e9 uns double \line c)A r = 3.14159; \line d)A $ = \{ 79.63 \}; \line e) A t = \{ \ldblquote Oi,voc\'ea!\rquote  \}; \line fA u = \{ 3.14159, \ldblquote Pi\rdblquote  \}; \par
ar se \par
\pard\lang1033\f1\fs20\par
}
 