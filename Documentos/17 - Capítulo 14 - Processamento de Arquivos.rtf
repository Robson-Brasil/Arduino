{\rtf1\ansi\ansicpg1252\deff0\deflang1033{\fonttbl{\f0\fswiss\fprq2\fcharset0 Arial;}{\f1\froman\fcharset0 Times New Roman;}}
\viewkind4\uc1\pard\sb100\sa240\lang2070\f0\fs24\par
\par
\ul 14 \ulnone\line Processamento de arquivos \line\line Objetivos \line\bullet  Ser capaz de criar, ler, gravar e atualizar arquivos. \line\bullet  Familiarizar-se com o processamento de arquivos de acesso seq\'fcencial. \line\bullet  Familiarizar-se com o processamento de arquivos de acesso aleat\'f3rio. \line\bullet  Ser capaz de especificar opera\'e7\'f5es de EIS n\'e3o-formatadas de alto desempenho. \line\bullet  Compreender a diferen\'e7a entre o processamento de arquivos com dados formatados e dados brutos. \line\bullet  Construir um programa de processamento de transa\'e7\'f5es com processamento aleat\'f3rio de arquivos. \line Li parte dele at\'e9 ofim. \line Samuel Goldwyn \line S\'f3 posso supor que um documento marcado como \ldblquote N\'e3o arquivar\rdblquote  est\'e1 arquivado em um documento marcado como \ldblquote N\'e3o arquivar\rdblquote . \line Senador Frank Church \line Depoimento ao Subcomit\'ea de Intelig\'eancia do Senado, 1975 \par
CAP\'cdTULO 14 - PROCESSAMENTO DE ARQUIVOS 727 \line Vis\'e3o geral \line 14.1 Introdu\'e7\'e3o \line 14.2 A hierarquia de dados \line 14.3 Arquivos e streams \line 14.4 Criando um arquivo de acesso seq\'fcencial \line 14.5 Lendo dados de um arquivo de acesso seq\'fcencial \line 14.6 Atualizando arquivos de acesso seq\'fcencial \line 14.7 Arquivos de acesso aleat\'f3rio \line 14.8 Criando um arquivo de acesso aleat\'f3rio \line 14.9 Gravando dados aleatoriamente em um arquivo de acesso aleat\'f3rio \line 14.10 Lendo dados seq\'fcencialmente de um arquivo de acesso aleat\'f3rio \line 14.11 Exemplo: um programa de processamento de transa\'e7\'f5es \line 14.12 Entrada/sa\'edda de objetos \line Resumo\bullet  Terminologia. Erros comuns de programa\'e7\'e3o . Boa pr\'e1tica de programa\'e7\'e3o Dica de desempenho \line Dica de portabilidade . Exerc\'edcios de auto-revis\'e3o Respostas aos exerc\'edcios de auto-revis\'e3o \bullet  Exerc\'edcios \line 14.1 Introdu\'e7\'e3o \line O armazenamento de dados em vari\'e1veis e arrays \'e9 tempor\'e1rio. Arquivos s\'e3o usados para conserva\'e7\'e3o permanente de grandes quantidades de dados. Os computadores armazenam arquivos em dispositivos secund\'e1rios de armazenamento, tais como discos magn\'e9ticos, discos \'f3pticos e fitas. Neste cap\'edtulo, explicamos como os arquivos de dados S\'e3o criados, atualizados e processados por programas em C++. Examinamos aqui tanto os arquivos de acesso seq\'fcencial como os arquivos de acesso aleat\'f3rio. Comparamos o processamento de arquivos com dados formatados e dados n\'e3o-formatados. Examinamos t\'e9cnicas para a entrada de dados de, e a sa\'edda de dados para, strings, em vez de arquivos, no Cap\'edtulo 19. \line 14.2 A hierarquia de dados \line Basicamente, todos os itens de dados processados por um computador s\'e3o reduzidos a combina\'e7\'f5es de zeros e uns. Isso ocorre porque \'e9 simples e econ\'f4mico se construir dispositivos eletr\'f4nicos que podem assumir dois estados est\'e1veis - um dos estados representa O e o outro representa 1. E not\'e1vel que as impressionantes fun\'e7\'f5es executadas pelos computadores envolvam apenas as manipula\'e7\'f5es mais elementares de Os e is. \line O menor item de dados em um computador pode assumir o valor O ou o valor 1. Tal item de dados \'e9 chamado de bit (abrevia\'e7\'e3o de \ldblquote binary digit\rdblquote , ou \ldblquote d\'edgito bin\'e1rio\rdblquote  - um d\'edgito que pode assumir um de dois valores). Os circuitos computacionais realizam v\'e1rias manipula\'e7\'f5es simples de bits, tais como determinar o valor de um bit, redefinir o valor de um bit e inverter o valor de um bit (de 1 para O ou de O para 1). \line E complicado para os programadores trabalhar com dados na forma de baixo n\'edvel dos bits. Em vez disso, os programadores preferem trabalhar com dados na forma de d\'edgitos decimais (i.e., O, 1, 2, 3, 4, 5, 6, 7, 8 e 9), letras (i.e., de A at\'e9 Z e de a at\'e9 z) e s\'edmbolos especiais (i.e., $, @, %, &, , (, ), -, +,\ldblquote , :, ?,Ie muitos outros). D\'edgitos, letras e s\'edmbolos especiais s\'e3o chamados de caracteres. O conjunto de todos os caracteres usados para escrever programas e representar itens de dados em um determinado computador \'e9 chamado de conjunto de caracteres daquele computador. Como os computadores podem processar apenas is e Os, qualquer caractere do conjunto de caracteres de um computador \'e9 representado por uma combina\'e7\'e3o de is e Os (chamada de byte). Atualmente, os bytes s\'e3o compostos normalmente de oito bits. Os programadores criam programas e itens de dados como caracteres; os computadores manipulam e processam esses caracteres como combina\'e7\'f5es de bits. \par
728 C++ COMO PROGRAMAR \par
Da mesma forma que os caracteres s\'e3o compostos de bits, os campos s\'e3o compostos de caracteres. Um campo \'e9 um grupo de caracteres que possui um significado. Por exemplo, um campo consistindo unicamente em letras mai\'fasculas e min\'fasculas pode ser usado para representar o nome de uma pessoa. \line Os itens de dados processados pelos computadores formam uma hierarquia de dados na qual os itens de dados se tornam maiores e mais complexos na estrutura \'e0 medida que evolu\'edmos de bits para caracteres, campos e assim por diante. \line Um registro (i.e., uma struct ou class em C++) \'e9 composto de v\'e1rios campos (chamados de membros \line em C++). Em um sistema de folha de pagamento, por exemplo, um registro de um determinado empregado pode consistir nos seguintes campos: \line 1. N\'famero de identifica\'e7\'e3o de empregado \line 2. Nome \line 3. Endere\'e7o \line 4. Valor do sal\'e1rio-hora \line 5. N\'famero de dispensas solicitadas \line 6. Total de vencimentos no ano em curso \line 7. Total de impostos federais retidos na fonte, etc. \line Assim, um registro \'e9 um grupo de campos relacionados. No exemplo anterior, cada um dos campos pertence ao mesmo empregado. Naturalmente, uma empresa espec\'edfica pode ter muitos empregados e ter\'e1 um registro da folha de pagamento para cada um. Um arquivo \'e9 um grupo de registros relacionados. Um arquivo de folha de pagamento de uma empresa cont\'e9m um registro para cada empregado. Assim, o arquivo de folha de pagamento de uma pequena empresa pode conter apenas 22 registros, ao passo que o arquivo da folha de pagamento de uma grande empresa pode conter 100.000 registros. N\'e3o \'e9 raro uma organiza\'e7\'e3o ter muitos arquivos, cada um deles possuindo milh\'f5es de caracteres de informa\'e7\'f5es. A Fig. 14.1 ilustra a hierarquia de dados. \line Para facilitar a recupera\'e7\'e3o de registros espec\'edficos de um arquivo, pelo menos um campo em cada registro \'e9 escolhido como uma chave de registro. A chave de registro identifica um registro como pertencendo a uma determinada pessoa ou entidade que \'e9 distinto de todos os outros registros no arquivo. No registro de folha de pagamento descrito anteriormente, o n\'famero de identifica\'e7\'e3o do empregado seria normalmente escolhido como a chave dos registros. \par
Sally Ireto 1 \par
ITom 1Azu1 1 \line Judy Iverae 1 1 Arquivo \par
Verde JJ Registro \line t \line Judy Campo \line t \line 01001010 Byte (Caractere ASCII J) \line 1 \line Fig. 14.1 A hierarquia de dados. \par
\pard\par
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx562\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2158\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2575\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2983\pard\intbl Iris \cell ILarafia 1 \cell 1 \cell 1 \cell\row
\intbl Randy \cell It1h0I \cell 1 \cell 1 \cell\row
\pard\par
\pard\sb100\sa240 CAP\'cdTULO 14 - PROCESSAMENTO DE ARQUIVOS 729 \par
H\'e1 muitas maneiras de se organizar registros em um arquivo. No tipo mais comum de organiza\'e7\'e3o, denominado arquivo seq\'fcencial, registros s\'e3o normalmente armazenados em ordem segundo o campo-chave dos registros. Em um arquivo de folha de pagamento, os registros geralmente s\'e3o colocados em ordem segundo o n\'famero de identifica\'e7\'e3o do empregado. O registro do primeiro empregado no arquivo cont\'e9m o menor n\'famero de identifica\'e7\'e3o do empregado, e os registros subseq\'fcentes possuem n\'fameros de identifica\'e7\'e3o do empregado em ordem crescente. \line A maioria das empresas utiliza muitos arquivos diferentes para armazenar dados. Por exemplo, as empresas podem ter arquivos de folha de pagamento, arquivos de contas a receber (listando o dinheiro devido pelos clientes), arquivos de contas a pagar (listando o dinheiro devido aos fornecedores), arquivos de estoques (listando caracter\'edsticas a respeito de todos os itens manipulados pela empresa) e muitos outros tipos de arquivos. Algumas vezes, um grupo de arquivos relacionados entre si \'e9 chamado de banco de dados. Um conjunto de programas que se destina a criar e gerenciar bancos de dados \'e9 chamado de sistema de gerenciamento de banco de dados (SGBD, ou database management system, DBMS). \line 14.3 Arquivos e streams \line C++ v\'ea cada arquivo simplesmente como uma seq\'fc\'eancia de bytes (Fig. 14.2). Cada arquivo termina ou com um marcador defim de arquivo ou em um byte espec\'edfico, cujo n\'famero \'e9 gravado em uma estrutura administrativa de dados mantida pelo sistema. Quando um arquivo \'e9 aberto, um objeto \'e9 criado e um stream \'e9 associado \'e0quele objeto. No Cap\'edtulo II, vimos que quatro objetos s\'e3o criados para n\'f3s - cm. cout. cerr e clog - quando <iostreani> \'e9 inclu\'eddo. Os streams associados com estes objetos fornecem canais de comunica\'e7\'e3o entre um programa e um arquivo ou dispositivo particular. Por exemplo, o objeto cm (o objeto stream padr\'e3o de entrada) permite que um programa leia dados do teclado ou de outros dispositivos, o objeto cout (o objeto stream padr\'e3o de sa\'edda) permite que um programa exiba dados na tela ou em outros dispositivos e os objetos cerr e clog (os objetos stream padr\'e3o de erros) permitem a um programa enviar mensagens de erro para a tela ou outros dispositivos. \par
i O 1 2 3 4 5 6 8 9 marcador de fim de arquivo \par
Fig. 14.2 Como a linguagem C++ visualiza um arquivo de n bytes. \line Para executar o processamento de arquivos em C++, devem ser inclu\'eddos os arquivos de cabe\'e7alho <iostream> e <fstream>. O cabe\'e7alho <fstream> inclui as defini\'e7\'f5es para as classes stream ifstream (para fazer entrada de um arquivo), ofstream (para fazer sa\'edda para um arquivo) e fstream (para entrada e sa\'edda de um arquivo). Os arquivos s\'e3o abertos criando-se objetos destas classes stream. Estas classes stream s\'e3o derivadas das (i.\'e9, herdam a funcionalidade de) classes istreain, ostream e iostream. respectivamente. Assim, as fun\'e7\'f5es membro, operadores e manipuladores descritos no Cap\'edtulo 11, \ldblquote Entradalsa\'edda com streams em C++\rdblquote , podem todos tamb\'e9m ser aplicados a streams de arquivos.Os relacionamentos de heran\'e7a das classes de EIS discutidas at\'e9 aqui s\'e3o resumidas na Fig. 14.3. \line 14.4 Criando um arquivo de acesso seq\'fcencial \line C++ n\'e3o imp\'f5e nenhuma estrutura a um arquivo. Assim, conceitos como o de \ldblquote registro\rdblquote  n\'e3o existem em arquivos em C++. Portanto, o programador deve estruturar os arquivos de modo a satisfazer as exig\'eancias das aplica\'e7\'f5es. No exemplo a seguir, vemos como o programador pode impor uma estrutura de registros simples a um arquivo. Primeiro, apresentamos o programa e, ent\'e3o, o analisamos em detalhe. \line A Fig. 14.4 cria um arquivo simples de acesso seq\'fcencial que pode ser usado em um sistema de contas a receber para ajudar a controlar as quantias devidas pelos clientes devedores de uma empresa. Para cada cliente, o programa obt\'e9m um n\'famero de conta, o nome do cliente e o saldo do cliente (i.e., a quantia que o cliente deve \'e0 empresa por bens e servi\'e7os recebidos no passado). Os dados obtidos para cada cliente constituem um registro para aquele cliente. O n\'famero da conta \'e9 usado como campo-chave dos registros nessa aplica\'e7\'e3o isto \'e9, o arquivo ser\'e1 \par
730 C++ COMO PROGRAMAR \line jos \line istream ostream \line /N \line ifstream iostream ofstream \line fs tream \line Fig. 14.3 Parte da hierarquia de classes de EIS com streams. \line criado e mantido segundo a ordem dos n\'fameros de contas. Esse programa assume que o usu\'e1rio fornece os registros na ordem dos n\'fameros das contas. Em um grande sistema de contas a receber, seria fornecido um recurso de ordena\'e7\'e3o para que o usu\'e1rio pudesse entrar com os registros em qualquer ordem. Os registros seriam ent\'e3o ordenados e gravados no arquivo. \line 1 II Fig. 14.4: figl4_04.cpp \line 2 // Criando um arquivo seq\'fcencial \line 3 #include <iostream> \line 4 \line 5 using std::cout; \line 6 using std: :cin; \line 7 using std: :ios; \line 8 using std: :cerr; \line 9 using std::endl; \line lo \line 11 #include <fstream> \line 12 \line 13 using std::ofstreani; \line 14 \line 15 #include <cstdlib> \line 16 \line 17 int main() \line 18 \line 19 II construtor de ofstream abre o arquivo \line 20 ofstream outClientFile( \ldblquote clients.dat\rdblquote , ios::out ); \line 21 \line 22 if ( \lquote outClientFile ) \{ II operador ! sobrecarregado \line 23 cerr \'ab \ldblquote Arquivo n\'e3o pode ser aberto \'ab endi; \line 24 exit( 1 ); II prot\'f3tipo em cstdlib \line 25 \line 26 \line 27 cout \'ab \ldblquote Digite a conta, o nome e o saldo.\\n\rdblquote  \line 28 \'ab \ldblquote Digite fim de arquivo para terminar entrada.\\n? \ldblquote ; \line 29 \line 30 int account; \line 31 char name[ 30 ]; \line 32 double balance; \line 33 \line 34 while ( cm \'bb account \'bb name \'bb balance ) \line Fig. 14.4 Criando um arquivo seq\'fcencial (parte 1 de 2). \par
CAP\'cdTULO 14 - PROCESSAMENTO DE ARQUIVOS 731 \par
35 outClientFile \'ab account \'ab \'ab naxne \line 36 \'ab \'ab balance \'ab \lquote\\n\rquote ; \line 37 cout \'ab \ldblquote ? \line 38 \line 39 \line 40 return 0; // destruidor de ofstream fecha o arquivo \line 41 \line Digite a conta, o nome e o saldo. \line Digite fim de arquivo para terminar entrada. \line ? 100 Jones 24.98 \line ? 200 Doe 345.67 \line ? 300 White 0.00 \line ? 400 Stone -42.16 \line ? 500 Rich 224.62 \line ? AZ \line Fig. 14.4 Criando um arquivo sequerluial parte ue ). \line Agora, examinemos esse programa. Como afirmado anteriormente, arquivos s\'e3o abertos criando-se objetos das classes stream ifstream. ofstream ou fstream. Na Fig. 14.4,0 arquivo deve ser aberto para sa\'edda, assim um objeto ofstream \'e9 criado. Dois argumentos s\'e3o passados para o construtor do objeto - o nome do arquivo e o modo de abertura do arquivo. Para um objeto ofstream, o modo de abertura do arquivo pode ser tanto ios: : out para fazer sa\'edda para um arquivo como ios: app para acrescentar dados ao final de um arquivo (sem modificar qualquer dado j\'e1 existente no arquivo). Arquivos existentes abertos com modo ios: out s\'e3o truncados - todos os dados no arquivo s\'e3o eliminados. Se o arquivo especificado ainda n\'e3o existe, ent\'e3o \'e9 criado um arquivo com aquele nome de arquivo. \line A declara\'e7\'e3o \line ofstream outClientFile( \ldblquote clients.dat\rdblquote , ios::out ); \line na linha 20 cria um objeto ofstreani de nome outClientFile associado ao arquivo clients . dat que \'e9 aberto para sa\'edda. Os argumentos \ldblquote clients . dat\rdblquote  e ios: : out s\'e3o passados para o construtor de ofstreaxn. que abre o arquivo. Isto estabelece uma \ldblquote linha de comunica\'e7\'e3o\rdblquote  com o arquivo. Por default, objetos ofstream s\'e3o abertos para sa\'edda, de modo que o comando \line ofstream outClientFile( \ldblquote clients.dat\rdblquote  ); \line poderia ter sido usado para abrir clients . dat para sa\'edda. A Fig. 14.5 lista os modos de abertura de arquivos. \par
Fig. 14.5 Modos de abertura de arquivos. \line Erro com um de programa\'e7\'e3o 14.1 \line Abrir um arquivo existente para sa\'edda (ios: : out) quando, na verdade, o usu\'e1rio quer preservar o arquivo; o conte\'fado do arquivo \'e9 descartado sem aviso. \par
\pard\par
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1391\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx8946\pard\intbl Modo \cell Descri\'e7\'e3o \cell\row
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx493\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1391\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx8946\pard\intbl ios: \cell : app \cell Grava toda a sa\'edda no fim do arquivo. \cell\row
\intbl ios: \cell ate \cell Abre um arquivo para sa\'edda e avan\'e7a at\'e9 o fim do arquivo (normalmente usado para acrescentar dados a um arquivo). Os dados podem gravados em qualquer lugar no arquivo. \cell\row
\intbl ios: \cell : in \cell Abre um arquivo para entrada. \cell\row
\intbl ios: \cell out \cell Abre um arquivo para sa\'edda. \cell\row
\intbl ios: \cell : trunc \cell Elimina o conte\'fado do arquivo se ele existe (esta tamb\'e9m \'e9 a a\'e7\'e3o default para ios: : out) \cell\row
\intbl ios: \cell : binary \cell Abre um arquivo para entrada ou sa\'edda bin\'e1ria (i.e., n\'e3o-texto). \cell\row
\pard\par
\pard\sb100\sa240 732 C++ COMO PROGRAMAR \line\ul Erro comum de programa\'e7\'e3o 14.2 \ulnone\line Usar um objeto ofstream incorreto para se referir a um arquivo. \line Um objeto ofstream pode ser criado sem abrir um arquivo espec\'edfico - um arquivo pode ser associado ao objeto posteriormente. Por exemplo, a declara\'e7\'e3o \line ofstream outclientFile; \line cria o objeto ofstreain de nome outClientFile. A fun\'e7\'e3o membro open de ofstream abre um arquivo e o associa a um objeto ofstream existente como segue: \line outClientFile.open( \ldblquote clients.dat\rdblquote , ios: :out ); \line Erro comum de programa\'e7\'e3o 14.3 \line N\'e3o abrir um arquivo antes de tentar referenci\'e1-lo em um programa. \line Ap\'f3s criar um objeto ofstream e tentar abri-lo, o programa testa se a opera\'e7\'e3o de abertura foi bem-sucedida. A estrutura if nas linhas 22 a 25 \line if ( !outClientFile ) \{ II operador sobrecarregado \line cerr \'ab \lquote Arquivo n\'e3o pode ser aberto\rdblquote  \'ab endi; \line exit( 1 ); // prot\'f3tipo em cstdlib \line usa a fun\'e7\'e3o membro operador operator! sobrecarregada de ios para determinar se a opera\'e7\'e3o de abertura foi bem-sucedida. A condi\'e7\'e3o retorna um valor n\'e3o-zero (verdadeiro) se ou o failbit ou o badbit \'e9 ligado para o stream na opera\'e7\'e3o open. Alguns erros que podem acontecer s\'e3o: tentar abrir um arquivo n\'e3o-existente para leitura, tentar abrir um arquivo para leitura sem permiss\'e3o e abrir um arquivo para grava\'e7\'e3o quando n\'e3o h\'e1 espa\'e7o dispon\'edvel em disco. \line Quando a condi\'e7\'e3o indica que a tentativa de abertura foi mal-sucedida, a mensagem de erro \ldblquote Arquivo n\'e3o pode ser aberto\rquote  \'e9 exibida e a fun\'e7\'e3o exit termina o programa. O argumento para exit \'e9 retornado para o ambiente do qual o programa foi invocado. O argumento O indica que o programa terminou normalmente; qualquer outro valor indica que o programa terminou devido a um erro. O ambiente chamador (muito provavelmente o sistema operacional) usa o valor retornado por exit para responder adequadamente ao erro. \line Uma outra fun\'e7\'e3o membro operador sobrecarregada de ios - operator void* - converte o stream em um ponteiro, de modo que ele possa ser testado como O (o ponteiro nulo) ou n\'e3o-zero (qualquer outro valor de ponteiro). Se o failbit ou o badbit (ver Cap\'edtulo II) foram ligados para o stream, O (falso) \'e9 retornado. A condi\'e7\'e3o no cabe\'e7alho de while seguinte (linha 34) invoca implicitamente a fun\'e7\'e3o membro operator void*: \line while ( cm \'bb account \'bb name \'bb balance \line A condi\'e7\'e3o permanece true enquanto nem o failbit nem obadbit forem ligados para cm. Digitar o indicador de fim de arquivo liga o failbit para cm. A fun\'e7\'e3o operator void * pode ser usada para testar um objeto de entrada quanto ao fim de arquivo em vez de chamar explicitamente a fun\'e7\'e3o membro eof para o objeto de entrada. \line Se o arquivo \'e9 aberto com sucesso, o programa come\'e7a a processar dados. O comando seguinte (linhas 27 e 28) solicita ao usu\'e1rio para digitar os diversos campos para cada registro, ou para digitar fim de arquivo quando a entrada de dados est\'e1 completa: \line cout \'ab \ldblquote Digite a conta, o nome e o saldo.\\n\rdblquote  \line\'ab \ldblquote Digite fim de arquivo para terminar entrada.\\n? \ldblquote ; \line A Fig. 14.6 lista as combina\'e7\'f5es de teclas para digitar fim de arquivo em diversos sistemas de computadores. \par
CAP\'cdTULO 14 - PROCESSAMENTO DE ARQUIVOS 733 \par
Fig. 14.6 Combina\'e7\'f5es de teclas que indicam fim de arquivo para v\'e1rios sistemas computacionais populares. \line A linha 34 \line while ( cm \'bb account \'bb name \'bb balance \line extrai cada conjunto de dados e determina se fim de arquivo foi digitado. Quando o fim de arquivo ou dados inv\'e1lidos s\'e3o digitados, a opera\'e7\'e3o \'bb de extra\'e7\'e3o do stream de cm retorna O (normalmente operator void* \line retorna verdadeiro) e a estrutura whi le termina. O usu\'e1rio digita fim de arquivo para informar ao programa que n\'e3o h\'e1 mais dados para serem processados. O indicador de fim de arquivo \'e9 inicializado quando a combina\'e7\'e3o de teclas que indica fim de arquivo \'e9 digitada pelo usu\'e1rio. A estrutura while continua a executar o la\'e7o enquanto o indicador de fim de arquivo n\'e3o for digitado. \line As linhas 35 e 36 \line outClientFile \'ab account \'ab \'ab name \line\'ab \lquote  \'ab balance \'ab \\n\rquote ; \line gravam um conjunto de dados no arquivo \ldblquote clients .dat\rdblquote  usando o operador \'ab de inser\'e7\'e3o em stream e o objeto outClientFile associado com o arquivo no come\'e7o do programa. Os dados podem ser recuperados por um programa projetado para ler o arquivo (ver Se\'e7\'e3o 14.5). Note que o arquivo criado na Fig. 14.4 \'e9 um arquivo- texto. Ele pode ser lido por qualquer editor de texto. \line Uma vez que o indicador de fim de arquivo \'e9 digitado, main termina. Isto faz com que o objeto outClientFile seja destru\'eddo, invocando desta forma sua fun\'e7\'e3o destruidor, a qual fecha o arquivo clients . dat. Um objeto ofstream pode ser fechado explicitamente pelo programador usando a fun\'e7\'e3o membro dose como segue: \line outClientFile . dose O; \line Dica de desempenho 14.1 \line ______ Feche explicitamente cada arquivo t\'e3o logo se saiba que o programa n\'e3o far\'e1 refer\'eancia ao arquivo novamente. isso pode reduzir o consumo de recursos no programa que vai continuar sendo executado \line ap\'f3s n\'e3o mais necessitar de um arquivo particular Essa pr\'e1tica tamb\'e9m melhora a clareza do programa. \line No exemplo de execu\'e7\'e3o do programa da Fig. 14.4, o usu\'e1rio digita informa\'e7\'f5es para cinco contas e, ent\'e3o, sinaliza que a entrada de dados est\'e1 completa digitando-se fim de arquivo (AZ aparece nas telas de compat\'edveis com o IBM PC). Esta janela de di\'e1logo n\'e3o mostra como os registros de dados efetivamente aparecem no arquivo. Para verificar se o arquivo foi criado com sucesso, na pr\'f3xima se\'e7\'e3o criamos um programa para ler o arquivo e imprimir seu conte\'fado. \line 14.5 Lendo dados de um arquivo de acesso seq\'fcencial \line Os dados s\'e3o armazenados em arquivos de modo que possam ser recuperados para processamento quando necess\'e1rio. A se\'e7\'e3o anterior demonstrou como criar um arquivo para acesso seq\'fcencial. Nesta se\'e7\'e3o, analisaremos como ler dados seq\'fcencialmente de um arquivo. \par
\pard\par
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2081\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx6844\pard\intbl Sistema computacional \cell Combina\'e7\'e3o de teclas \cell\row
\intbl Sistemas UNIX \cell <ctrl> d (em uma linha isolada) \cell\row
\intbl IBM PC e compat\'edveis \cell <ctrl> z (\'e0s vezes seguido pelo pressionamento da tecla Enter) \cell\row
\intbl Macintosh \cell <ctrl> d \cell\row
\intbl VAX (VMS) \cell <ctrl> z \cell\row
\pard\par
\pard\sb100\sa240 734 C++ COMO PROGRAMAR \line A Figura 14.7 l\'ea registros do arquivo \ldblquote clients dat\rdblquote  criados pelo programa da Fig.14.4 e imprime o \line conte\'fado dos registros. Arquivos s\'e3o abertos para entrada criando-se um objeto da classe ifstream. Dois argumentos s\'e3o passados para o objeto - o nome do arquivo e o modo de abertura do arquivo. A declara\'e7\'e3o \line ifstream inClientFile( \ldblquote clients.dat\rdblquote , ios::in ); \line na linha 29 cria um objeto ifstream denominado inClientFile e o associa com o arquivo clients dat que ser\'e1 aberto para entrada. Os argumentos entre par\'eanteses s\'e3o passados \'e0 fun\'e7\'e3o construtor de ifstream, a qual abre o arquivo e estabelece uma \ldblquote linha de comunica\'e7\'e3o\rdblquote  com o arquivo. \line 1 // Fig. 14.7: figl4O7.cpp \line 2 // Lendo e imprimindo um arquivo seq\'fcencial \line 3 #include <iostreain> \line 4 \line 5 using std: :cout; \line 6 using std::cin; \line 7 using std::ios; \line 8 using std: :cerr; \line 9 using std: :endl; \line 10 \line 11 #include <fstream> \line 12 \line 13 using std::ifstream; \line 14 \line 15 #include <iomanip> \line 16 \line 17 using std::setiosflags; \line 18 using std::resetiosflags; \line 19 using std::setw; \line 20 using std::setprecision; \line 21 \line 22 #include <cstdlib> \line 23 \line 24 void outputLine( int, const char * const, double ); \line 25 \line 26 int main() \line 27 \{ \line 28 II construtor de ifstream abre o arquivo \line 29 ifstream inClientFile( \ldblquote clients.dat\rdblquote , ios::in ); \line 30 \line 31 if ( inC1ientFi1e ) \{ \line 32 cerr \'ab \ldblquote Arquivo n\'e3o pode ser aberto\\n; \line 33 exit( 1 ); \line 34 1 \line 35 \line 36 int account; \line 37 char name[ 30 ]; \line 38 double balance; \line 39 \line 40 cout \'ab setiosflags( ios::left ) \'ab setw( 10 ) \'ab \ldblquote Conta\rquote  \line 41 \'ab setw( 13 ) \'ab \ldblquote Nome\rdblquote  \'ab \ldblquote Saldo\\n\rdblquote  \line 42 \'ab setiosflags( ios::fixed 1 ios::showpoint ); \line 43 \line 44 while ( inClientFile \'bb account \'bb name \'bb balance \line 45 outputLine( account, name, balance ); \line 46 \line Fig. 14.7 Lendo e imprimindo um arquivo seq\'fcencial (parte 1 de 2). \par
\pard\par
\pard\sb100\sa240 CAP\'cdTULO 14 - PROCESSAMENTO DE ARQUIVOS 735 \par
47 \line 48 \} \line 49 \line 50 void outputLine( int acct, const char * const name, double bal \line 51 \line 52 cout \'ab setiosflags( ios::left ) \'ab setw( 10 ) \'ab acct \line 53 \'ab setw( 13 ) \'ab name \'ab setw( 7 ) \'ab setprecision( 2 \line 54 \'ab resetiosflags( ios: :left \line 55 \'ab bal \'ab \lquote\\n\rquote ; \line 56 \} \par
Fig. 14.7 Lendo e imprimindo um arquivo seq\'fcencial (parte 2 de 2). \line Objetos da classe ifstream s\'e3o abertos para entrada por default; assim, o comando \line ifstream inclientFile( \lquote clients.dat\rdblquote  ); \line poderia ter sido usado para abrir clients . dat para entrada. Exatamente como com um objeto ofstreain, um objeto ifstream pode ser criado sem abrir um arquivo espec\'edfico e um arquivo pode ser associado a ele mais tarde. \line Boa pr\'e1tica de programa\'e7\'e3o 14.1 \line Abrir um arquivo somente para entrada (usando ios: : in), se o conte\'fado do arquivo n\'e3o deve ser modificado. isso evita a modifica\'e7\'e3o n\'e3o-intencional do conte\'fado do arquivo. Esse \'e9 um exemplo do princ\'edpio do privil\'e9gio m\'ednimo. \line O programa usa a condi\'e7\'e3o ! inClientEile para determinar se o arquivo foi aberto com sucesso, antes de tentar recuperar dados do arquivo. A linha 44 \line while ( inClientFile \'bb account \'bb name \'bb balance \line l\'ea um conjunto de dados (i.e., um registro) do arquivo. Ap\'f3s a linha precedente ser executada pela primeira vez, account tem o valor 100, name tem o valor \ldblquote Jones\rdblquote  e balance tem o valor 24 . 98. Cada vez que a linha \'e9 executada, um outro registro \'e9 lido do arquivo para as vari\'e1veis account. name e balance. Os registros s\'e3o exibidos usando-se a fun\'e7\'e3o outputLine. a qual usa manipuladores de stream parametrizados para formatar os dados para exibi\'e7\'e3o. Quando o fim do arquivo \'e9 encontrado, a chamada impl\'edcita para operator void* na estrutura while retorna O (normalmente operator void* retorna verdadeiro), o arquivo \'e9 fechado pela fun\'e7\'e3o destruidor de ifstream e o programa termina. \line Para recuperar seq\'fcencialmente dados de um arquivo, os programas normalmente come\'e7am a ler a partir do in\'edcio do arquivo e l\'eaem todos os dados, um ap\'f3s o outro, at\'e9 que os dados desejados sejam encontrados. Pode ser necess\'e1rio processar o arquivo seq\'fcencialmente v\'e1rias vezes (desde o in\'edcio do arquivo) durante a execu\'e7\'e3o de um programa. Tanto a classe is treaxn como a classe os tream fornecem fun\'e7\'f5es membro para reposicionar o ponteiro de posi\'e7\'e3o do arquivo (o n\'famero de byte do pr\'f3ximo byte do arquivo a ser lido ou gravado). Estas fun\'e7\'f5es membro s\'e3o seekg (\ldblquote seek get\rdblquote ) para a classe istream e seekp (\ldblquote seek put\rdblquote ) para a classe ostream. Cada objeto istream tem um \ldblquote ponteiro get\rdblquote  que indica o n\'famero do byte do arquivo do qual a pr\'f3xima leitura deve ocorrer e cada objeto ostrearn tem um \ldblquote ponteiro put\rdblquote  que indica o n\'famero do byte do arquivo no qual a pr\'f3xima sa\'edda dever\'e1 ser colocada. O comando \par
return 0; // destruidor de ifstream fecha o arquivo \par
inclientFile.seekg( O ); \par
\pard\par
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx589\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1286\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2079\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2315\pard\intbl Conta \cell Nome \cell Saldo \cell\cell\row
\intbl 100 \cell Jones \cell 24.98 \cell\cell\row
\intbl 200 \cell Doe \cell 345.67 \cell . \cell\row
\intbl 300 \cell White \cell 0.00 \cell\cell\row
\intbl 400 \cell Stone \cell -42.16 \cell\cell\row
\intbl 500 \cell Rich \cell 224.62 \cell\cell\row
\pard\par
\par
\pard\sb100\sa240 736 C++ COMO PROGRAMAR \par
reposiciona o ponteiro de posi\'e7\'e3o do arquivo no come\'e7o do arquivo (posi\'e7\'e3o O) associado com inClientFile. O argumento para seekg \'e9 normalmente um inteiro long. Um segundo argumento pode ser especificado para indicar a dire\'e7\'e3o de seek. A dire\'e7\'e3o de seek pode ser ios: : beg (o default), para posicionamento relativo ao in\'edcio de um stream, ios: : cur para posicionamento relativo \'e0 posi\'e7\'e3o corrente em um stream ou ios: : end para posicionamento relativo ao fim de um stream. O ponteiro de posi\'e7\'e3o do arquivo \'e9 um valor inteiro que especifica a posi\'e7\'e3o no arquivo como um n\'famero de bytes desde a posi\'e7\'e3o de in\'edcio do arquivo (isso \'e9, algumas vezes, chamado de offset - ou deslocamento - desde o come\'e7o do arquivo). Alguns exemplos de posicionamento do ponteiro get de posi\'e7\'e3o do arquivo s\'e3o: \line II posiciona no n-\'e9simo byte do fileObject \line // assume ios: :beg \line fileObject.seekg( n ); \line II posiciona n bytes para a frente no fileObject \line fileObject.seekg( n, ios::cur ); \line II posiciona y bytes para tr\'e1s a partir do fim do fileObject \line fileObject.seekg( y, ios::end ); \line // posiciona no fim do fileObect \line fileObject.seekg( O, ios::end ); \line As mesmas opera\'e7\'f5es podem ser executadas com a fun\'e7\'e3o membro seekp de ostream. As fun\'e7\'f5es membro tellg e tellp s\'e3o fornecidas para retornar as posi\'e7\'f5es correntes dos ponteiros gel e put, respectivamente. O comando seguinte atribui o valor do ponteiro de posi\'e7\'e3o get do arquivo para a vari\'e1vel location do tipo long: \line location = fileObect.tellg \line A Fig. 14.8 possibilita a um gerente de cr\'e9dito exibir as informa\'e7\'f5es da conta para aqueles clientes com saldo zero ______ (i.e., clientes que n\'e3o devem dinheiro \'e0 empresa), saldos credores (i.e., clientes para os quais a empresa deve dinheiro) e saldos devedores (i.e., clientes que devem dinheiro \'e0 empresa por bens e servi\'e7os recebidos no passado). O programa exibe um menu e permite ao gerente de cr\'e9dito digitar uma de tr\'eas op\'e7\'f5es para obter informa\'e7\'f5es de cr\'e9dito. A op\'e7\'e3o 1 produz uma lista de contas com saldo zero. A op\'e7\'e3o 2 produz uma lista de contas com saldos credores. A op\'e7\'e3o 3 produz uma lista de contas com saldos devedores. A op\'e7\'e3o 4 termina a execu\'e7\'e3o do programa. Digitar uma op\'e7\'e3o inv\'e1lida simplesmente exibe a solicita\'e7\'e3o para digitar uma outra op\'e7\'e3o. A sa\'edda do programa \'e9 mostrada na Fig. 14.9. \line 1 1/ Fig. 14.8: figl4O8.cpp \line 2 II Programa de consulta de cr\'e9dito \line 3 #include <iostream> \line 4 \line 5 using std::cout; \line 6 using std::cin; \line 7 using std::ios; \line 8 using std: :cerr; \line 9 using std::endl; \line 10 \line 11 #include <fstream> \line 12 \line 13 using std: :ifstream; \line 1 14 \line 15 #include <iomanip> \line 16 \line 17 using std::setiosflags; \line 18 using std::resetiosflags; \par
Fig. 14.8 Programa de consulta de cr\'e9dito (parte 1 de 3). \par
CAP\'cdTULO 14 - PROCESSAMENTO DE ARQUIVOS 737 \line 19 using std::setw; \line 20 using std: :setprecision; \line 21 \line 22 #include <cstdlib> \line 23 \line 24 enum RequestType \{ ZERO BALANCE = 1, CREDIT BALANCE, \line 25 DEBIT BALANCE, END \}; \line 26 int getRequestO; \line 27 bool shouldDisplay( int, double ); \line 28 void outputLine( int, const char * const, double ); \line 29 \line 30 int main() \line 31 \{ \line 32 II construtor de ifstream abre o arquivo \line 33 ifstream inClientFile( \ldblquote clients.dat\rdblquote , ios: :in ); \line 34 \line 35 if ( !inClientFile ) \{ \line 36 cerr \'ab \lquote Arquivo n\'e3o pode ser aberto\rdblquote  \'ab endl; \line 37 exit( 1 ); \line 38 \} \line 39 \line 40 int request, account; \line 41 char name[ 30 ); \line 42 double balance; \line 43 \line 44 cout \'ab \ldblquote Digite op\'e7\'e3o\\n\rdblquote  \line 45 \'ab \ldblquote  1 - Listar contas com saldo zero\\n\rdblquote  \line 46 \'ab \ldblquote  2 - Listar contas com saldo credor\\n\rdblquote  \line 47 \'ab \ldblquote  3 - Listar contas com saldo devedor\\n\rdblquote  \line 48 \'ab \ldblquote  4 - Fim da execu\'e7\'e3o\rdblquote  \line 49 \'ab setiosflags( ios: :fixed 1 ios: ;showpoint ); \line 50 request = getRequestQ; \line 51 \line 52 while ( request != END ) \{ \line 53 \line 54 switch ( request \line 55 case ZERO BALANCE: \line 56 cout \'ab \ldblquote\\nContas com saldo zero:\\n\rdblquote ; \line 57 break; \line 58 case CREDIT BALANCE: \line 59 cout \'ab \ldblquote\\nContas com saldo credor:\\n\rdblquote ; \line 60 break; \line 61 case DEBIT BALANCE: \line 62 cout \'ab \ldblquote\\nContas com saldo devedor:\\n\rdblquote ; \line 63 break; \line 64 \line 65 \line 66 inClientFile \'bb account \'bb naxne \'bb balance; \line 67 \line 68 while ( !inClientFile.eof O) \line 69 if ( shouldDisplay( request, balance \line 70 outputLine( account, name, balance \line 71 \line 72 inClientFile \'bb account \'bb name \'bb balance; \line 73 \} \line 74 \line 75 inClientFile.clearO; II desliga fim de arquivo p/pr\'f3xima entrada \line 76 inClientFile.seekg( O ); II vai para o in\'edcio do arquivo \line 77 request getRequestO); \line Fig. 14.8 Programa de consulta de cr\'e9dito (parte 2 de 3). \par
738 C\'f7+ COMO PROGRAMAR \line 78 \} \line 79 \line 80 cout \'ab Fim da execu\'e7\'e3o.\rdblquote  \'ab endi; \line 81 \line 82 return 0; // destruidor de ifstream fecha o arquivo \line 83 ) \line 84 \line 85 int getRequest() \line 86 \{ \line 87 int request; \line 88 \line 89 do\{ \line 90 cout \'ab \ldblquote\\n? \line 91 cm \'bb request; \line 92 \} while( request < ZERO_BALANCE && request > END ); \line 93 \line 94 return request; \line 95 \} \line 96 \line 97 bool shouldDisplay( int type, double balance \line 98 \{ \line 99 if ( type == CREDIT BALANCE && balance < O \line 100 return true; \line 101 \line 102 if ( type == DEBIT BALANCE && balance > O \line 103 return true; \line 104 \line 105 if ( type ZERO BALANCE && balance == O \line 106 return true; \line 107 \line 108 return false; \line 109 \} \line 110 \line 111 void outputLine( int acct, const char * const name, double bal \line 112 \line 113 cout \'ab setiosflags( ios::left ) \'ab setw( 10 ) \'ab acct \line 114 \'ab setw( 13 ) \'ab name \'ab setw( 7 ) \'ab setprecision( 2 \line 115 \'ab resetiosflags( ios::left \line 116 \'ab bal \'ab \lquote\\n; \line 117 ) \line Fig. 14.8 Programa de consulta de cr\'e9dito (parte 3 de 3). \line Digite op\'e7\'e3o \line 1 - Listar contas com saldo zero \line 2 - Listar contas com saldo credor \line 3 - Listar contas com saldo devedor \line 4 - Fim da execu\'e7\'e3o \line Contas com saldo zero: \line 300 White 0.00 \line Contas com saldo credor: \line 400 Stone -42.16 \line Fig. 14.9 Exemplo de sa\'edda do programa da Fig. 14.8 (parte 1 de 2). \par
CAP\'cdTULO 14- PROCESSAMENTO DE ARQUIVOS 739 \par
Fig. 14.9 Exemplo de sa\'edda do programa da Fig. 14.8 (parte 2 de 2). \par
14.6 Atualizando arquivos de acesso seq\'fcencial \par
Dados que s\'e3o formatados e gravados em um arquivo de acesso seq\'fcencial como mostrado na Se\'e7\'e3o 14.4 n\'e3o podem ser modificados sem o risco de destruir outros dados no arquivo. Por exemplo, se o nome \ldblquote White\rdblquote  precisa ser mudado para Worthington, o nome velho n\'e3o pode ser simplesmente gravado por cima, O registro para White foi gravado no arquivo como \par
300 White 0.00 \par
Se esse registro fosse regravado come\'e7ando na mesma posi\'e7\'e3o no arquivo e usando o nome mais longo, o registro ficaria \par
300 Worthington 0.00 \par
O novo registro cont\'e9m seis caracteres a mais que o registro original. Portanto, os caracteres depois do segundo \ldblquote o\rdblquote  \line em \ldblquote Worthington\rdblquote  seriam sobrepostos ao come\'e7o do pr\'f3ximo registro seq\'fcencial no arquivo. O problema aqui \line\'e9 que no modelo de entradaJsa\'edda formatada usando o operador de inser\'e7\'e3o \'ab e o operador de extra\'e7\'e3o\'bb, campos \line - e portanto registros - podem variar em tamanho. Por exemplo, 7, 14, -117, 2074 e 27383 s\'e3o todos ints e cada um \line\'e9 armazenado no mesmo n\'famero de bytes de \ldblquote dados brutos\rdblquote  internamente, mas quando estes inteiros s\'e3o enviados \line como texto formatado (seq\'fc\'eancias de caracteres) para a tela ou para um arquivo em disco, eles se tornam campos de \line tamanhos diferentes. Portanto, o modelo de entradalsa\'edda formatada n\'e3o \'e9 normalmente usado para atualizar registros em sua posi\'e7\'e3o original. \line Tal atualiza\'e7\'e3o pode ser feita, mas \'e9 complicada. Por exemplo, para efetuar a mudan\'e7a de nome precedente, os registros antes de 300 White 0. 00 em um arquivo de acesso seq\'fcencial poderiam ser copiados para um novo arquivo, o registro atualizado seria ent\'e3o gravado no novo arquivo e os registros ap\'f3s 300 White O . 00 seriam copiados para o novo arquivo. Isto requer processar todos os registros no arquivo para atualizar um registro. Se muitos registros est\'e3o sendo atualizados em uma \'fanica passagem pelo arquivo, ent\'e3o essa t\'e9cnica pode ser aceit\'e1vel. \par
14.7 Arquivos de acesso aleat\'f3rio \par
At\'e9 aqui, vimos como criar e acessar arquivos seq\'fcenciais e pesquis\'e1-los para localizar informa\'e7\'f5es particulares. Arquivos de acesso seq\'fcencial s\'e3o inadequados para as chamadas aplica\'e7\'f5es de acesso instant\'e2neo, nas quais um registro de informa\'e7\'f5es particular deve ser localizado imediatamente. Aplica\'e7\'f5es comuns de acesso instant\'e2neo s\'e3o sistemas de reservas de linhas a\'e9reas, sistemas banc\'e1rios, sistemas de pontos de venda, caixas autom\'e1ticos e outros tipos de sistemas de processamento de transa\'e7\'f5es que exigem acesso a dados espec\'edficos. O banco no qual voc\'ea tem sua conta pode ter centenas de milhares ou mesmo milh\'f5es de outros clientes e, ainda assim, quando voc\'ea usa um caixa autom\'e1tico, \'e9 verificado se sua conta tem fundos suficientes em segundos. Este tipo de acesso instant\'e2neo \'e9 poss\'edvel com arquivos de acesso aleat\'f3rio. Os registros individuais de um arquivo de acesso aleat\'f3rio podem ser acessados diretamente (e rapidamente) sem pesquisar os outros registros. \line Como j\'e1 dissemos, C++ n\'e3o imp\'f5e estruturas a um arquivo. Assim, uma aplica\'e7\'e3o que queira usar arquivos de \line acesso aleat\'f3rio deve cri\'e1-los. Diversass t\'e9cnicas podem ser usadas para criar arquivos de acesso aleat\'f3rio. Talvez a \par
Contas \line 100 \line 200 \line 500 \par
com saldo devedor: \line Jones \line Doe \line Rich \par
24.98 \line 345.67 \line 224.62 \par
Fim da execu\'e7\'e3o. \par
740 C++ COMO PROGRAMAR \line mais simples seja exigir que todos os registros em um arquivo sejam do mesmo comprimento fixo. Usar registros de comprimento fixo torna f\'e1cil para um programa calcular (como uma fun\'e7\'e3o do tamanho do registro e da chave do registro) a localiza\'e7\'e3o exata de qualquer registro em rela\'e7\'e3o ao come\'e7o de um arquivo. Logo veremos como isso facilita o acesso imediato a registros espec\'edficos, mesmo em grandes arquivos. \line A Fig. 14.10 ilustra a vis\'e3o de C++ de um arquivo de acesso aleat\'f3rio composto por registros de comprimento \line fixo (cada registro tem 100 bytes de comprimento). Um arquivo de acesso aleat\'f3rio \'e9 como um comboio ferrovi\'e1rio com muitos vag\'f5es - alguns vazios e alguns com conte\'fado. \par
Fig. 14.10 A vis\'e3o de C++ de um arquivo de acesso aleat\'f3rio. \line Dados podem ser inseridos em um arquivo de acesso aleat\'f3rio sem destruir outros dados no arquivo. Dados armazenados previamente tamb\'e9m podem ser atualizados ou exclu\'eddos sem regravar todo o arquivo. Nas se\'e7\'f5es seguintes, explicamos como criar um arquivo de acesso aleat\'f3rio, digitar dados, ler os dados tanto seq\'fcencial como aleatoriamente, atualizar os dados e eliminar dados n\'e3o mais necess\'e1rios. \line 14.8 Criando um arquivo de acesso aleat\'f3rio \line A fun\'e7\'e3o membro write de ostream envia um n\'famero fixo de bytes come\'e7ando em uma posi\'e7\'e3o espec\'edfica da mem\'f3ria para o stream de sa\'edda especificado. Quando o stream \'e9 associado a um arquivo, os dados s\'e3o gravados come\'e7ando na posi\'e7\'e3o do arquivo especificada pelo ponteiro put de posi\'e7\'e3o do arquivo. A fun\'e7\'e3o membro read de istream l\'ea um n\'famero fixo de bytes do stream de entrada especificado para uma \'e1rea na mem\'f3ria come\'e7ando em um endere\'e7o especificado. Se o stream est\'e1 associado a um arquivo, os bytes s\'e3o lidos come\'e7ando na posi\'e7\'e3o do arquivo especificada pelo ponteiro get de posi\'e7\'e3o do arquivo. \line Agora, quando gravarmos um inteiro nurnber em um arquivo, em vez de usar \line outFile \'ab number; \line o qual poderia imprimir tanto somente 1 d\'edgito como at\'e9 11 d\'edgitos (10 d\'edgitos mais um suial, cada uni dos quais exige 1 byte de mem\'f3ria) para um inteiro de 4 bytes, podemos usar \line outFile.write( reiriterpret_cast<const char *>( &number ), \line sizeof( nuniber ) ); \line a qual sempre grava 4 bytes (em uma m\'e1quina com inteiros de 4 bytes). A fun\'e7\'e3o write espera um dado do tipo \line const char * como seu primeiro argumento, por isso usamos o operador reinterpret cast<const char* \line > para converter o endere\'e7o de number para um ponteiro const char* . O segundo argumento de write \'e9 um \line inteiro do tipo size_t que especifica o n\'famero de bytes a serem gravados. Como veremos, a fun\'e7\'e3o read de \line istream pode ent\'e3o ser usada para ler os 4 bytes de volta para a vari\'e1vel inteira number. \line Se um programa vai ler dados n\'e3o-formatados (gravados por write), ele precisa ser compilado e executado \line em um sistema que seja compat\'edvel com o programa que gravou os dados. \line Programas de processamento de arquivos de acesso aleat\'f3rio raramente gravam um \'fanico campo em um \line arquivo. Normalmente, eles gravam um objeto struct ou class por vez, como mostraremos nos exemplos seguintes. Considere a seguinte defini\'e7\'e3o de problema: \par
F \par
\pard\par
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx337\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx976\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1492\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2131\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2647\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx3286\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx3802\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4441\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4957\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx5596\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx6112\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx6751\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx8279\pard\intbl O  1 \cell\cell 100  1 \cell\cell 200  Ir \cell\cell 300  , \cell\cell 400  , \cell\cell 500 \cell\cell offsets dos bytes \cell\row
\intbl 1 \cell\cell\cell\cell II \cell\cell II \cell\cell II \cell\cell II \cell\cell 1 \cell\row
\intbl\cell 100 \cell\cell 100 \cell\cell 100 \cell\cell 100 \cell\cell 100 \cell\cell 100 \cell\cell\row
\intbl\cell bytes \cell\cell bytes \cell\cell bytes \cell\cell bytes \cell\cell bytes \cell\cell bytes \cell\cell\row
\pard\par
\pard\sb100\sa240 CAP\'cdTULO 14- PROCESSAMENTO DE ARQUIVOS 741 \line Crie um programa de processamento de cr\'e9dito capaz de armazenar at\'e9 100 registros de comprimento fixo para uma empresa que pode ter at\'e9 100 clientes. Cada registro deve consistirem um n\'famero de conta que ser\'e1 usado como a chave do registro, um sobrenome, um nome e um saldo. O programa deve ser capaz de atualizar uma conta, inserir uma nova conta, eliminar uma conta e listar todos os registros de conta em um arquivo-texto formatado para impress\'e3o. \line As se\'e7\'f5es seguintes apresentam as t\'e9cnicas necess\'e1rias para criarmos esse programa de processamento de cr\'e9dito. A Fig. 14.11 ilustra a abertura de um arquivo de acesso aleat\'f3rio, a defini\'e7\'e3o do formato do registro usando uma struct (definida no arquivo de cabe\'e7alho clntdata . h) e grava\'e7\'e3o de dados no disco em formato bin\'e1rio (o modo bin\'e1rio \'e9 especificado na linha 33). Este programa inicializa todos os 100 registros do arquivo \ldblquote credit. dat\rdblquote  \line com structs vazias, usando a fun\'e7\'e3o write. Cada struct vazia cont\'e9m O no campo de n\'famero da conta, o _______ string nulo (representado por aspas vazias) no campo de sobrenome, o string nulo no campo de nome e O . O no \line campo de saldo. Cada registro \'e9 inicializado com a quantidade de espa\'e7o vazio na qual os dados da conta ser\'e3o armazenados e para determinar nos programas subseq\'fcentes se um registro est\'e1 vazio ou cont\'e9m dados. \line 1 // clntdata.h \line 2 1/ Defini\'e7\'e3o da struct clientData usada \line 3 1/ nas Figs. 14.11, 14.12, 14.14 e 14.15. \line 4 #ifndef CLNTDATAH \line 5 #define CLNTDATAH \line 6 \line 7 struct clientData \{ \line 8 int accountNuniber; \line 9 char lastName[ 15 ]; \line 10 char firstName[ 10 ]; \line 11 double balance; \line 12 ); \line 13 \line 14 #endif \line Fig. 14.11 Arquivo de cabe\'e7alho clntdata.h. \line 15 II Fig. 14.11: figl4ll.cpp \line 16 /1 Criando um arquivo de acesso aleat\'f3rio seq\'fcencialmente \line 17 #include <iostream> \line 18 \line 19 using std::cerr; \line 20 using std::endl; \line 21 using std::ios; \line 22 \line 23 #include <fstream> \line 24 \line 25 using std::ofstream; \line 26 \line 27 #include <cstdlib> \line 28 \line 29 #include \ldblquote clntdata.h\rdblquote  \line 30 \line 31 int main() \line 32 \line 33 ofstream outCredit( \ldblquote credit.dat\rdblquote , ios::binary ); \line 34 \line 35 if ( outCredit ) \{ \line 36 cerr \'ab \ldblquote Arquivo n\'e3o pode ser aberto.\rdblquote  \'ab endi; \line 37 exit( 1 ); \line Fig. 14.12 Criando um arquivo de acesso aleat\'f3rio seq\'fcencialmente (parte 1 de 2). \par
742 C++ COMO PROGRAMAR \par
38 \} \line 39 \line 40 clientData blankClient = \{ 0, \ldblquote\lquote , \ldblquote\ldblquote , 0.0 \}; \line 41 \line 42 for ( int i = 0; i < 100; i++ \line 43 outCredit.write( \line 44 reinterpretcast<const char *>( &blankClient ), \line 45 sizeof( clientData ) ); \line 46 return 0; \line Fig. 14.12 Criando um arquivo de acesso aleat\'f3rio seq\'fcencialmente (parte 2 de 2). \line Na Fig. 14.11,0 comando nas linhas 43 a45 \line outCredit . write \line reinterpret_cast<const char *>( &blankClient ), \line sizeof( clientData ) ); \line faz com que a estrutura blankClient de tamanho sizeof ( clientData ) seja gravada no arquivo credit. dat associado ao objeto outCredit de ofstream. Lembre-se de que o operador sizeof retoma o tamanho em bytes do objeto contido entre par\'eanteses (ver Cap\'edtulo 5). Note que o primeiro argumento para a fun\'e7\'e3o write na linha 43 deve ser do tipo const char . Contudo, o tipo de dados de &blankClient \'e9 clientData \line *. Para converter &blankClient para o tipo de ponteiro apropriado, a express\'e3o \line reinterpretcast<const char >( &blankClient ), \line usa o operador de coer\'e7\'e3o reinterpret_cast para converter o endere\'e7o de blankClient em um const char *, de modo que a chamada para write \'e9 compilada sem provocar um erro de sintaxe. \line 14.9 Gravando dados aleatoriamente em um arquivo de acesso aleat\'f3rio \line A Fig. 14.12 grava dados no arquivo \ldblquote credit.dat\rdblquote . Ele usa a combina\'e7\'e3o das fun\'e7\'f5es seekp e write de \line ostream para armazenar dados em posi\'e7\'f5es precisas no arquivo. A fun\'e7\'e3o seekp inicializa o ponteiro put de \line posi\'e7\'e3o do arquivo para uma posi\'e7\'e3o espec\'edfica no arquivo, ent\'e3o write grava os dados. Um exemplo de execu\'e7\'e3o \line\'e9 mostrado na Fig. 14.13. Note que o programa da Fig. 14.12 inclui (linha 16)0 arquivo de cabe\'e7alho clntdata . h \line definido na Fig. 14.11. \line 1 // Fig. 14.12: figl4l2.cpp \line 2 II Gravando dados aleatoriamente em um arquivo de acesso aleat\'f3rio \line 3 #include <iostream> \line 4 \line 5 using std: :cerr; \line 6 using std::endl; \line 7 using std::cout; \line 8 using std::cin; \line 9 using std::ios; \line 10 \line 11 #include <fstream> \line 12 \line 13 using std::ofstream; \line 14 \line 15 #include <cstdlib> \line 16 #include \ldblquote clntdata.h\rdblquote  \line 17 \par
Fig. 14.12 Criando um arquivo de acesso aleat\'f3rio seq\'fcencialmente (parte 1 de 2). \par
CAP\'cdTULO 14 - PROCESSAMENTO DE ARQUIVOS 743 \line 18 int main() \line 19 \line 20 ofstream outCredit( \ldblquote credit.dat\rdblquote , ios::binary ); \line 21 \line 22 if ( !outCredit \line 23 cerr \'ab \lquote Arquivo n\'e3o pode ser aberto.\rdblquote  \'ab endi; \line 24 exit( 1 ); \line 25 \line 26 \line 27 cout \'ab \ldblquote Digite o n\'famero da conta \line 28 \'ab \ldblquote (1 a 100, O para terminar entrada)\\n? \ldblquote ; \line 29 \line 30 clientData client; \line 31 cm \'bb client.accountNuniber; \line 32 \line 33 while ( client.accountNumber > O && \line 34 client.accountNuinber <= 100 ) \{ \line 35 cout \'ab \ldblquote Digite sobrenome, primeiro nome, saldo\\n? \ldblquote ; \line 36 cm \'bb client.lastName \'bb client.firstName \line 37 \'bb client.balance; \line 38 \line 39 outCredit.seekp( ( client.accountNumber - 1 ) * \line 40 sizeof( clientData ) ); \line 41 outCredit.write \line 42 reinterpret_cast<const char *>( &client ), \line 43 sizeof( clientData ) ); \line 44 \line 45 cout \'ab \ldblquote Digite n\'famero da conta\\n? \line 46 cm \'bb client.accountNumber; \line 47 \} \line 48 \line 49 return 0; \line 50 \line Fig. 14.12 Criando um arquivo de acesso aleat\'f3rio seq\'fcencialmente (parte 2 de 2). \line Digite o n\'famero da conta (1 a 100, O para terminar entrada) \line ? 37 \line Digite sobrenome, primeiro nome, saldo \line ? Barker Doug 0.00 \line Digite o n\'famero da conta \line ? 29 \line Digite sobrenome, primeiro nome, saldo \line ? Brown Nancy -24.54 \line Digite o n\'famero da conta \line ? 96 \line Digite sobrenome, primeiro nome, saldo \line ? Stone San 34.98 \line Digite o n\'famero da conta \line ? 88 \line Digite sobrenome, primeiro nome, saldo \line ? Smith Dave 258.34 \line Digite o n\'famero da conta \line ? 33 \line Digite sobrenome, primeiro nome, saldo \line ? Dunn Stacey 314.33 \line Digite o n\'famero da conta \line Fig. 14.13 Exemplo de execu\'e7\'e3o do programa da Fig. 14.12. \par
744 C++ COMO PROGRAMAR \line As linhas 39 e 40 26 \line 27 \line outCredit.seekp( ( client.accountNuxnber - 1 ) * 28 \line sizeof( clientData ) ); 29 \line 30 \line posicionam o ponteiro de posi\'e7\'e3o par do arquivo para o objeto outCredit na posi\'e7\'e3o em bytes calculada por 31 \line (client . accountNumber - 1) * sizeof ( clientData) Como o n\'famero da conta est\'e1 entre 1 e 100, \line i \'e9 subtraido do n\'famero da conta quando se calcula a posi\'e7\'e3o em bytes do registro. Desta forma, para o registro 1, 34 \line o ponteiro de posi\'e7\'e3o do arquivo \'e9 inicializado com o byte O do arquivo. Note que o objeto outCredit de ofstream 35 \line\'e9 aberto com o modo de abertura de arquivo ios: :binary. 36 \line 14.10 Lendo dados seq\'fcencialmente de um arquivo de acesso aleat\'f3rio \line Nas se\'e7\'f5es anteriores, criamos um arquivo de acesso aleat\'f3rio e gravamos dados nesse arquivo. Nesta se\'e7\'e3o, desen- 41 \line volvemos um programa que l\'ea todo o arquivo seq\'fcencialmente e imprime somente aqueles registros que cont\'e9m 42 \line dados. Este programa fornece um benef\'edcio adicional. Veja se voc\'ea pode determinar qual \'e9 ele; n\'f3s o revelaremos no 43 \line fim desta se\'e7\'e3o. \line A fun\'e7\'e3o read de istream l\'ea um n\'famero de bytes especificado da posi\'e7\'e3o corrente no stream especificado \line para um um objeto. Por exemplo, as linhas 43 e 44 \line inCredit.read(reinterpret_cast<char *>( &client ), \line sizeof(clientData) ); 50 \line 51 \line da Fig 14.14 Icem o numero de bytes especificado por sizeof ( clientData ) do arquivo associado ao objeto 52 \line inCredit de ifstream e armazenam os dados na estrutura client. Note que a fun\'e7\'e3o read exige um 53 \line primeiro argumento do tipo char . Como &client \'e9 do tipo clientData , &client deve sofrer uma 54 \line coer\'e7\'e3o para char* com o operador de coer\'e7\'e3o reinterpret cast. Note que o programa da Fig. 14.14 55 \line inclui o arquivo de cabe\'e7alho clntdata . h definido na Fig. 14.11. 56 57 \line 58 \line 1 II Fig. 14.14: figl4_14.cpp \line 2 II Lendo seq\'fcencialmente um arquivo de acesso aleat\'f3rio 60 \line 3 #include <iostream> 61 \line 4 62 \line 5 using std::cout; 63 \line 6 using std::endl; 64 \line 7 using std: :ios; 65 \line 8 using std::cerr; 66 \line 10 #include <iomanip> Cor \line 11 29 \line 12 using std::setprecision; \line 13 using std::setiosflags; 1 \line 14 using std: :resetiosflags; 88 \line 15 using std::setw; \line 16 \line 17 #include <fstream> Fini \line 18 \line 19 using std::ifstream; \line 20 using std::ostream; AFig \line 21 ele co \line 22 #include <cstdlib> \line 23 #include \ldblquote clntdata.h\rdblquote  \line 24 \line 25 void outputLine( ostream&, const clientData & ); usaal \line Fig. 14.14 Lendo seq\'fcencialmente um arquivo de acesso aleat\'f3rio (parte 1 de 2). daest. \par
CAP\'cdTULO 14 - PROCESSAMENTO DE ARQUIVOS 745 \line 26 \line 27 int main() \line 28 \line 29 ifstream inCredit( \ldblquote credit.dat\rdblquote , ios::in ); \line 30 \line 31 if ( 1inCredit ) \{ \line 32 cerr \'ab \ldblquote Arquivo n\'e3o pode ser aberto.\rdblquote  \'ab endi; \line 33 exit( 1 ); \line 34 \} \line 35 \line 36 cout \'ab setiosflags( ios::left ) \'ab setw( 10 ) \'ab \ldblquote Conta\rdblquote  \line 37 \'ab setw( 16 ) \'ab \ldblquote Sobrenome\rdblquote  \'ab setw( 11 \line 38 \'ab \ldblquote Primeiro nome\rdblquote  \'ab resetiosflags( ios::left \line 39 \'ab setw( 10 ) \'ab \ldblquote Saldo\rdblquote  \'ab endi; \line 40 \line 41 clientData client; \line 42 \line 43 inCredit.read( reinterpretcast<char*>( &client ), \line 44 sizeof( clientData ) ); \line 45 \line 46 while ( inCredit && !inCredit.eof O ) \{ \line 47 \line 48 if ( client.accountNumber != O \line 49 outputLine( cout, client ); \line 50 \line 51 inCredit.read( reinterpret_cast<char *>( &client ), \line 52 sizeof( clientData ) ); \line 53 ) \line 54 \line 55 return 0; \line 56 \line 57 \line 58 void outputLine( ostream &output, const clientData &c \line 59 \{ \line 60 output \'ab setiosflags( ios::left ) \'ab setw( 10 \line 61 \'ab c.accountNimiber \'ab setw( 16 ) \'ab c.lastName \line 62 \'ab setw( 11 ) \'ab c.firstName \'ab setw( 10 \line 63 \'ab setprecision ( 2 ) \'ab resetiosflags ( ios: : left \line 64 \'ab setiosflags( ios::fixed 1 ios::showpoint \line 65 \'ab c.balance \'ab \lquote\\n\rquote ; \line 66 \} \par
4 Fig. 14.14 Lendo seq\'fcencialmente um arquivo de acesso aleat\'f3rio (parte 2 de 2). \line A Fig. 14.14 l\'ea seq\'fcencialmente todos os registros no arquivo \ldblquote credit . dat\rdblquote , examina cada registro para ver se ele cont\'e9m dados e exibe sa\'eddas formatadas para os registros que cont\'eam dados. A condi\'e7\'e3o na linha 46 \line while ( inCredit && \lquote inCredit.eof() ) \{ \line usa a fun\'e7\'e3o membro eof de ios para determinar quando o fim do arquivo \'e9 encontrado e faz com que a execu\'e7\'e3o da estrutura while termine. Al\'e9m disso, se h\'e1 um erro de leitura do arquivo, o la\'e7o terminar\'e1 porque inCredit \par
\pard\par
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx589\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1670\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx3712\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx3948\pard\intbl Conta \cell Sobrenome \cell Primeiro nome Saldo \cell\cell\row
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx589\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1670\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2691\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx3712\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx3948\pard\intbl 29 \cell Brown \cell Nancy \cell -24.54 \cell\cell\row
\intbl 33 \cell Dunn \cell Stacey \cell 314.33 \cell\cell\row
\intbl 37 \cell Barker \cell Doug \cell 0.00 \cell\cell\row
\intbl 88 \cell Smith \cell Dave \cell 258.34 \cell\cell\row
\intbl 96 \cell Stone \cell Sam \cell 34.98 \cell\cell\row
\pard\par
\pard\sb100\sa240 746 C++ COMO PROGRAMAR \par
assumir\'e1 o valor false. Os dados udos do arquivo s\'e3o enviados para a sa\'edda por outputLine, que aceita dois argumentos - um objeto ostream e uma estrutura clientData para ser enviada para a sa\'edda. O tipo de par\'e2metro ostream \'e9 interessante porque qualquer objeto ostream (tal como cout) ou qualquer objeto de uma classe derivada de ostream (tal como um objeto do tipo ofstreain) pode ser fornecido como o argumento. Isso significa que a mesma fun\'e7\'e3o pode ser usada, por exemplo, para executar sa\'edda pelo stream de sa\'edda padr\'e3o e para um stream de arquivo, sem necessidade de escrever fun\'e7\'f5es separadas. \line Mas qual o benef\'edcio adicional que prometemos? Se voc\'ea examinar a janela de sa\'edda, voc\'ea notar\'e1 que os registros s\'e3o listados em ordem (classificados pelo n\'famero de conta)! Isto \'e9 uma simples conseq\'fc\'eancia do modo como armazenamos estes registros no arquivo, usando as t\'e9cnicas de acesso direto. Comparado ao bubble sort que vimos (Cap\'edtulo 4), classificar com t\'e9cnicas de acesso direto \'e9 extremamente r\'e1pido. A velocidade \'e9 obtida fazendo- se os arquivos suficientemente grandes para manter quaisquer registros que possam ser criados. Isso, naturalmente, significa que o arquivo poderia ser, na maioria das vezes, esparsamente ocupado, o que \'e9 um desperd\'edcio de mem\'f3ria. Assim, aqui temos um outro exemplo da solu\'e7\'e3o de compromisso de trocar espa\'e7o por tempo: por usarmos grandes volumes de espa\'e7o, somos capazes de desenvolver um algoritmo de classifica\'e7\'e3o muito mais r\'e1pido. \line 14.11 Exemplo: um programa de processamento de transa\'e7\'f5es \line Agora, apresentamos um programa deporte para processamento de transa\'e7\'f5es (Fig. 14.15), usando um arquivo de acesso aleat\'f3rio para obter processamento de acesso \ldblquote instant\'e2neo\rdblquote . O programa mant\'e9m informa\'e7\'f5es de contas banc\'e1rias. O programa atualiza contas existentes, acrescenta novas contas, elimina contas e armazena uma lista formatada de todas as contas correntes em um arquivo-texto para impress\'e3o. Assumimos que o programa da Fig. 14. II foi executado para criarmos o arquivo credit . dat e que o programa da Fig. 14.12 foi executado para inserir os dados iniciais. \line O programa tem cinco op\'e7\'f5es (a op\'e7\'e3o \'e9 para terminar o programa). A op\'e7\'e3o 1 chama a fun\'e7\'e3o textFile para armazenar uma lista formatada de todas as informa\'e7\'f5es das contas em um arquivo-texto chamado print. txt que pode ser impresso mais tarde. A fun\'e7\'e3o textFile aceita um objeto fstream como argumento para ser usado para a leitura dos dados do arquivo credit . dat. A fun\'e7\'e3o textFile usa a fun\'e7\'e3o membro read de istream e as t\'e9cnicas de acesso a arquivos seq\'fcenciais da Fig. 14.14 para ler dados de credito . dat. A fun\'e7\'e3o outputLine discutida na Se\'e7\'e3o 14.10 \'e9 usada para a sa\'edda dos dados para o arquivo print. txt. Note que textFile usa a fun\'e7\'e3o membro seekg de istream para garantir que o ponteiro de posi\'e7\'e3o do arquivo est\'e1 no come\'e7o do arquivo. Ap\'f3s a escolha da op\'e7\'e3o 1, o arquivo print. txt cont\'e9m: \line A op\'e7\'e3o 2 chama a fun\'e7\'e3o updateRecord para atualizar uma conta. A fun\'e7\'e3o somente atualizar\'e1 um registro j\'e1 existente, assim a fun\'e7\'e3o primeiro verifica se o registro especificado est\'e1 vazio. O registro \'e9 lido para a estrutura client com a fun\'e7\'e3o membro read de istream, ent\'e3o client. accountNumber \'e9 comparado com zero para determinar se o registro cont\'e9m informa\'e7\'f5es. Se client . accountNuniber \'e9 zero, uma mensagem \'e9 impressa dizendo que o registro est\'e1 vazio e as op\'e7\'f5es do menu s\'e3o exibidas. Se o registro cont\'e9m informa\'e7\'f5es, a fun\'e7\'e3o updateRecord exibe o registro na tela usando a fun\'e7\'e3o outputLine. l\'ea o montante da transa\'e7\'e3o, calcula o novo saldo e regrava o registro no arquivo. A sa\'edda t\'edpica para a op\'e7\'e3o 2 \'e9: \par
Conta Sobrenome Primeiro nome Saldo \line 29 Brown Nancy -24.54 \line 33 Dunn Stacey 314.33 \line 37 Barker Doug 0.00 \line 88 Smith Dave 258.34 \line 96 Stone Sam 34.98 \par
Digite n\'famero da conta a ser atualizada (1 a 100): 37 \line 37 Barker Doug 0.00 \line Digite d\'e9bito (+) ou pagamento (-): +87.99 \line 37 Barker Doug 87.99 \par
CAP\'cdTULO 14 - PROCESSAMENTO DE ARQUIVOS 747 \par
using \line using \line using \line using \par
using \line using \line using \par
using \line using \line using \line using \par
void \line void \par
std: :cerr; std: :cin; std: :endl; std: :ios; \par
std: :ofstream; std: :ostream; std: :fstream; \line std: : setiosflags; std: : resetiosflags; std: :setw; \line std: : setprecision; \par
A op\'e7\'e3o 3 chama a fun\'e7\'e3o newRecord para adicionar um novo registro ao arquivo. Se o usu\'e1rio fornecer um n\'famero de conta j\'e1 existente, newRecord exibir\'e1 uma mensagem de erro informando que a conta j\'e1 existe e as op\'e7\'f5es do menu ser\'e3o exibidas novamente. Essa fun\'e7\'e3o usa o mesmo processo que o programa da Fig. 14.12 para adicionar uma nova conta. Uma sa\'edda t\'edpica da op\'e7\'e3o 3 \'e9 \par
Digite o n\'famero da nova conta (1 a 100): 22 \line Digite sobrenome, primeiro nome, saldo \line ? Johnston Sarah 247.45 \par
A op\'e7\'e3o 4 chama a fun\'e7\'e3o deleteRecord para excluir um registro de um arquivo. A exclus\'e3o \'e9 realizada pedindo ao usu\'e1rio um n\'famero de conta. Somente um registroj\'e1 existente pode ser exclu\'eddo; assim, caso a conta especificada esteja vazia, \'e9 exibida uma mensagem de erro. Uma mensagem \'e9 exibida para informar ao usu\'e1rio que o registro foi exclu\'eddo. Uma sa\'edda t\'edpica da op\'e7\'e3o 4 \'e9 \par
Digite n\'famero da conta a ser eliminada (1 a 100): 29 Conta N\'b029 eliminada. \par
O arquivo \ldblquote credit. dat\rdblquote  \'e9 aberto criando-se um objeto fstream para ler e gravar usando-se um \ldblquote ou\rdblquote  dos modos ios: : in e ios: : out. \par
II Fig. 14.15: figl4_15.cpp \line II Este programa l\'ea um arquivo de acesso aleat\'f3rio \line II seq\'fcencialmente, atualiza dados j\'e1 gravados no arquivo, \line // cria novos dados a serem colocados no arquivo \line // e elimina dados que j\'e1 est\'e3o no arquivo. \line #include <iostream> \line using std::cout; \par
#include <fstream> \par
#include <iomanip> \par
1 \line 2 \line 3 \line 4 \line 5 \line 6 \line 7 \line 8 \line 9 \line 10 \line 11 \line 12 \line 13 \line 14 \line 15 \line 16 \line 17 \line 18 \line 19 \line 20 \line 21 \line 22 \line 23 \line 24 \line 25 \line 26 \line 27 \line 28 \line 29 \line 30 \line 31 \line 32 \line 33 \line 34 \line 35 \line Fig. 14.15 Programa de contas banc\'e1rias (parte 1 de 5). \par
#include <cstdlib> \line #include \lquote clntdata.h\rquote  \line int enterChoiceO; \line void textFile( fstream& ); \line void updateRecord( fstream& ); \line void newRecord( fstream& ); \line deleteRecord( fstream& ); \line outputLine( ostream&, const clientData & ); \par
1 \par
748 C++ COMO PROGRAMAR \line 36 int getAccount( const char * const ); \line 37 \line 38 enuzn Choices \{ TEXTFILE = 1, UPDATE, NEW, DELETE, END \}; \line 39 \line 40 int main() \line 41 \line 42 fstream inOutCredit( \ldblquote credit.dat\rdblquote , ios::in 1 ios::out ); \line 43 \line 44 if ( \lquote inOutCredit \line 45 cerr \'ab \ldblquote Arquivo n\'e3o pode ser aberto.\rdblquote  \'ab endi; \line 46 exit ( 1 ); \line 47 \} \line 48 \line 49 int choice; \line 50 \line 51 while ( ( choice = enterChoice() ) != END ) \{ \line 52 \line 53 switch ( choice \line 54 case TEXTFILE: \line 55 textFile( inOutCredit ); \line 56 break; \line 57 case UPDATE: \line 58 updateRecord( inOutCredit ); \line 59 break; \line 60 case NEW: \line 61 newRecord( inOutCredit ); \line 62 break; \line 63 case DELETE: \line 64 deleteRecord( inOutCredit ); \line 65 break; \line 66 default: \line 67 cerr \'ab \ldblquote Op\'e7\'e3o incorreta\\n\rdblquote ; \line 68 break; \line 69 \} \line 70 \line 71 inOutCredit.clearO; II desliga indicador de fim de arquivo \line 72 \line 73 \line 74 return 0; \line 75 \} \line 76 \line 77 II Pede para selecionar uma op\'e7\'e3o do menu \line 78 int enterChoice() \line 79 \{ \line 80 cout \'ab \ldblquote\\nDigite sua op\'e7\'e3o\rdblquote  \'ab endl \line 81 \'ab \ldblquote 1 - criar um arquivo de contas no formato de texto\\n\rdblquote  \line 82 \'ab \ldblquote  chamado \\\ldblquote print.txt\\\rdblquote  para impress\'e3o\\n\rdblquote  \line 83 \'ab \ldblquote 2 - atualizar uma conta\\n\rdblquote  \line 84 \'ab \ldblquote 3 - acrescentar uma nova conta\\n\rdblquote  \line 85 \'ab \ldblquote 4 - eliminar uma conta\\n\rdblquote  \line 86 \'ab \ldblquote 5 - terminar o programa\\n? \line 87 \line 88 int menuChoice; \line 89 cm \'bb menuChoice; \line 90 return menuChoice; \line 91 \} \line 92 \line 93 // Cria arquivo no formato de texto para impress\'e3o \line Fig. 14.15 Programa de contas banc\'e1rias (parte 2 de 5). \par
CAP\'cdTULO 14 - PROCESSAMENTO DE ARQUIVOS 749 \par
94 void textFile( fstream &readFromFile \line 95 \{ \line 96 ofstream outPrintFile( \ldblquote print.txt\rdblquote , ios::out ); \line 97 \line 98 if ( \lquote outPrintFile \line 99 cerr \'ab \lquote Arquivo n\'e3o pode ser aberto. \'ab endi; \line 100 exit( 1 ); \line 101 \line 102 \line 103 outPrintFile \'ab setiosflags( ios::left ) \'ab setw( 10 \line 104 \'ab \ldblquote Conta\rdblquote  \'ab setw( 16 ) \'ab \ldblquote Sobrenome\rdblquote  \'ab setw( 11 \line 105 \'ab \ldblquote Primeiro nome\rdblquote  \'ab resetiosflags( ios::left \line 106 \'ab setw( 10 ) \'ab \ldblquote Saldo\rdblquote  \'ab endl; \line 107 readFromFile.seekg( O ); \line 108 \line 109 clientflata client; \line 110 readFromFile.read( reinterpret_cast<char *>( &client ), \line 111 sizeof( clientData ) ); \line 112 \line 113 while ( \lquote readFromFile.eof() ) \{ \line 114 if ( client.accountNumber != O \line 115 outputLine( outPrintFile, client ); \line 116 \line 117 readFromFile.read( reinterpret_cast<char *>( &client ), \line 118 sizeof( clientData ) ); \line 119 \} \line 120 \} \line 121 \line 122 // Atualiza o saldo de uma conta \line 123 void updateRecord( fstream &updateFile \line 124 \line 125 int account = getAccount( \ldblquote Digite n\'famero da conta a ser atualizada\rdblquote  ); \line 126 \line 127 updateFile.seekg( ( account - 1 ) * sizeof( clientData ) ); \line 128 \line 129 clientData client; \line 130 updateFile.read( reinterpret_cast<char *>( &client ), \line 131 sizeof( clientData ) ); \line 132 \line 133 if ( client.accountNumber ! O ) \{ \line 134 outputLine( cout, client ); \line 135 cout \'ab \ldblquote\\nDigite d\'e9bito (+) ou pagamento (-): \ldblquote ; \line 136 \line 137 double transaction; // d\'e9bito ou pagamento \line 138 cm \'bb transaction; II deveria validar \line 139 client.balance + transaction; \line 140 outputLine( cout, client ); \line 141 updateFile.seekp( ( account-1 ) * sizeof( clientData ) ); \line 142 updateFile .write( \line 143 reinterpret_cast<const char *>( &client ), \line 144 sizeof( clientData ) ); \line 145 \} \line 146 else \line 147 cerr \'ab \ldblquote Conta N\'b0\rdblquote  \'ab account \line 148 \'ab \ldblquote  n\'e3o tem informa\'e7\'e3o.\rdblquote  \'ab endl; \line 149 \line 150 \line 151 // Cria e insere um novo registro \par
Fig. 14.15 Programa de contas banc\'e1rias (parte 3 de 5). \par
1 \par
750 C++ COMO PROGRAMAR \line 152 void newRecord( fstream &insertlnFile \line 153 \line 154 int account = getAccount( \ldblquote Digite o niunero da nova conta\rdblquote  ); \line 155 \line 156 insertlnFile.seekg( ( account-1 ) * sizeof( clientData ) ); \line 157 \line 158 clientData client; \line 159 insertlnFile.read( reinterpret_cast<char *>( &client ), \line 160 sizeof( clientData ) ); \line 161 \line 162 if ( client.accountNumber == O ) \{ \line 163 cout \'ab \ldblquote Digite sobrenome, primeiro nome, saldo\\n? \line 164 cm \'bb client.lastName \'bb client.firstName \line 165 \'bb client.balance; \line 166 c1ient.accountNi.mber = account; \line 167 insertlnFile.seekp( ( account - 1 ) * \line 168 sizeof( clientData ) ); \line 169 insertlnFile .write \line 170 reinterpret_cast<const char *>( &client ), \line 171 sizeof( clientData ) ); \line 172 \} \line 173 else \line 174 cerr \'ab \ldblquote Conta N\rquote  \'ab account \line 175 \'ab \ldblquote  j\'e1 cont\'e9m informa\'e7\'e3o.\rdblquote  \'ab endi; \line 176 \line 177 \line 178 1/ Elimina um registro j\'e1 existente \line 179 void deleteRecord( fstream &deleteFromFile \line 180 \{ \line 181 int account = getAccount( Digite n\'famero da conta a ser eliminada\rdblquote  ); \line 182 \line 183 deleteFromFile.seekg( (account-1) * sizeof( clientData ) ); \line 184 \line 185 clientData client; \line 186 deleteFromFile.read( reinterpret_cast<char *>( &client ), \line 187 sizeof( clientData ) ); \line 188 \line 189 if ( client.accountNwnber != O ) \{ \line 190 clientData blankClient = \{ 0, \lquote\lquote , \ldblquote , 0.0 \}; \line 191 \line 192 deleteFromFile.seekp( ( account - 1) * \line 193 sizeof( clientData ) ); \line 194 deleteFromFile .write \line 195 reinterpretcast<const char *>( &blankClient ), \line 196 sizeof( clientData ) ); \line 197 cout \'ab \ldblquote Conta N\'b0\rdblquote  \'ab account \'ab \lquote  eliminada.\rdblquote  \'ab endi; \line 198 \} \line 199 else \line 200 cerr \'ab \ldblquote Conta N\'b0 \'ab account \'ab \ldblquote  est\'e1 vazia.\rdblquote  \'ab endl; \line 201 \} \line 202 \line 203 /1 Envia uma linha com informa\'e7\'f5es do cliente para a sa\'edda \line 204 void outputLine( ostream &output, const clientData &c \line 205 \{ \line 206 output \'ab setiosflags( ios::left ) \'ab setw( 10 \line 207 \'ab c.accountNumber \'ab setw( 16 ) \'ab c.lastName \line 208 \'ab setw( 11 ) \'ab c.firstName \'ab setw( 10 \line 209 \'ab setprecision( 2 ) \'ab resetiosflags( ios::left \line Fig. 14.15 Programa de contas banc\'e1rias (parte 4 de 5). \par
CAP\'cdTULO 14 - PROCESSAMENTO DE ARQUIVOS 751 \par
210 \'ab setiosflags( ios::fixed 1 ios::showpoint \line 211 \'ab c.balance \'ab \lquote\\n\rquote ; \line 212 \} \line 213 \line 214 // L\'ea um n\'famero de conta do teclado \line 215 int getAccount( const char * const prompt \line 216 \{ \line 217 int account; \line 218 \line 219 do \line 220 cout \'ab prompt \'ab (1 a 100): \line 221 cm \'bb account; \line 222 \} while ( account < 1 1 1 account > 100 ); \line 223 \line 224 return account; \line 225 \line Fig. 14.15 Programa de contas banc\'e1rias (parte 5 de 5). \line 14.12 Entrada/sa\'edda de objetos \line Neste cap\'edtulo e no Cap\'edtulo 11, discutimos o estilo de entradaJsa\'edda orientado a objetos de C++. Mas nossos exemplos se concentraram sobre a EIS de tipos de dados tradicionais e n\'e3o sobre objetos de classes definidas pelo usu\'e1rio. No Cap\'edtulo 8, mostramos como fazer entrada e sa\'edda de objetos de classes usando sobrecarga de operadores. Executamos a entrada de objetos sobrecarregando o operador de extra\'e7\'e3o de stream \'bb para as classes istream apropriadas. Executamos a sa\'edda de objetos sobrecarregando o operador de inser\'e7\'e3o em stream \'ab para as classes ostream apropriadas. Em ambos os casos, somente os membros de dados de um objeto foram udos ou transferidos para a sa\'edda e, em cada caso, de uma forma com significado para objetos daquele tipo de dados abstrato particular. As fun\'e7\'f5es membro de um objeto est\'e3o dispon\'edveis internamente no computador e s\'e3o combinadas com os valores de dados \'e0 medida que estes dados s\'e3o lidos atrav\'e9s do operador de inser\'e7\'e3o em stream sobrecarregado. \line Quando membros de dados de objetos s\'e3o enviados na sa\'edda para um arquivo em disco, perdemos as informa\'e7\'f5es sobre o tipo do objeto. Temos somente bytes de dados, n\'e3o informa\'e7\'f5es sobre seu tipo, em um disco. Se o programa que vai ler estes dados sabe a que tipos de objetos eles correspondem, ent\'e3o os dados s\'e3o simplesmente lidos para objetos daquele tipo. \line Um problema interessante ocorre quando armazenamos objetos de diferentes tipos no mesmo arquivo. Como podemos distingui-los (ou suas cole\'e7\'f5es de membros de dados) quando os lemos para um programa? O problema, naturalmente, \'e9 que objetos tipicamente n\'e3o t\'eam campos de tipo (estudamos este problema cuidadosamente no Cap\'edtulo lo). \line Uma abordagem seria fazer cada operador de sa\'edda sobrecarregado colocar na sa\'edda um c\'f3digo de tipo precedendo cada cole\'e7\'e3o de membros de dados que representa um objeto. Ent\'e3o, a entrada de objetos sempre come\'e7aria pela leitura do campo de c\'f3digo de tipo e usaria um comando switch para invocar a fun\'e7\'e3o sobrecarregada apropriada. Embora esta solu\'e7\'e3o n\'e3o tenha a eleg\'e2ncia da programa\'e7\'e3o polim\'f3rfica, ela fornece um mecanismo pr\'e1tico para guardar objetos em um arquivo e recuper\'e1-los conforme necess\'e1rio. \line Resumo \line\bullet  Todos os itens de dados processados por um computador s\'e3o reduzidos a combina\'e7\'f5es de zeros e uns. \line\bullet  O menor item dados em um computador pode assumir o valor O ou o valor 1. Tal item de dados \'e9 chamado de bit. \line\bullet  D\'edgitos, letras e s\'edmbolos especiais s\'e3o conhecidos como caracteres. O conjunto de todos os caracteres que podem ser usados para escrever programas e representar itens de dados em um computador em particular \'e9 chamado de conjunto de caracteres daquele computador. Cada caractere no conjunto de caracteres do computador \'e9 representado como uma combina\'e7\'e3o de oito is e Os (chamada de byte). \par
Um campo \'e9 um grupo de caracteres (ou bytes) que tem um significado. \par
752 C++ COMO PROGRAMAR \line\bullet  Um registro \'e9 um grupo de campos relacionados. \line\bullet  Pelo menos um campo em um registro \'e9 escolhido como a chave do registro para identificar um registro como pertencente a uma pessoa ou entidade particular, que \'e9 diferente de todos os outros registros no arquivo. \line\bullet  O acesso seq\'fcencial \'e9 o m\'e9todo mais popular para acessar dados em um arquivo. \line\bullet  Uma cole\'e7\'e3o de programas projetada para criar e gerenciar bancos de dados \'e9 chamada de sistema gerenciador de bancos de dados (SGBD). \line\bullet  C\'f7+ v\'ea cada arquivo como um stream seq\'fcencial de bytes. \line\bullet  Cada arquivo termina com alguma forma de marcador de fim de arquivo dependente da m\'e1quina. \line\bullet  Streams fornecem canais de comunica\'e7\'e3o entre arquivos e programas. \line\bullet  Os arquivos de cabe\'e7alho <iostream> e <fstreaiu> devem ser inclu\'eddos em um programa para executar a EIS com arquivo ao estilo de C+\'f7. O arquivo de cabe\'e7alho <fstreani> inclui as defini\'e7\'f5es das classes para streams ifstream. ofstream efstream. \line\bullet  Arquivos s\'e3o abertos instanciando-se objetos das classes para streams ifstream. ofstream e fstream. \line\bullet  C++ n\'e3o imp\'f5e estruturas a um arquivo. Desta forma, conceitos como \ldblquote registro\rdblquote  n\'e3o existem em C++. O programador deve estruturar um arquivo para atender aos requisitos de uma aplica\'e7\'e3o particular. \line\bullet  Arquivos s\'e3o abertos para sa\'edda criando-se um objeto da classe ofstream. Dois argumentos s\'e3o passados ao objeto - o nome do arquivo e o modo de abertura do arquivo. Para um objeto ofstream. o modo de abertura do arquivo pode ser ios: : out, para sa\'edda de dados para um arquivo, ou ios: : app, para acrescentar dados ao fim de um arquivo. Arquivos existentes abertos com modo ios: : out s\'e3o truncados. Se o arquivo n\'e3o existe, ele \'e9 criado. \line\bullet  A fun\'e7\'e3o membro operador operator 1 de ios retorna um valor verdadeiro se o failbit ou o badbit foi ligado para um stream na opera\'e7\'e3o open. \line\bullet  A fun\'e7\'e3o membro operador operator void* de ios converteco stream em um ponteiro para compara\'e7\'e3o com O (o ponteiro nulo). Se o failbit ou o badbit foi ligado para o stream, \'e9 retornado O (falso). \line\bullet  Programas podem n\'e3o processar arquivos, processar somente um arquivo ou v\'e1rios arquivos. Cada arquivo tem um nome que \'e9 \'fanico e est\'e1 associado com um objeto arquivo stream apropriado. Todas as fun\'e7\'f5es de processamento de arquivo devem referenciar um arquivo com o objeto apropriado. \line\bullet  Um \ldblquote ponteiro get\rdblquote  indica a posi\'e7\'e3o do arquivo da qual a pr\'f3xima leitura ocorrer\'e1 e um \ldblquote ponteiro put\rdblquote  indica a posi\'e7\'e3o no arquivo na qual a pr\'f3xima sa\'edda ser\'e1 colocada. Tanto a classe istreaiu como a classe ostream fornecem fun\'e7\'f5es membro para reposicionar o ponteiro de posi\'e7\'e3o no arquivo. As fun\'e7\'f5es s\'e3o seekg (\ldblquote seek get\rdblquote ) para a classe istream e seekp (\ldblquote seekput\rdblquote ) para a classe ostream. \line\bullet  As fun\'e7\'f5es membro tellp e tellg retornam as posi\'e7\'f5es correntes dos ponteiros put e get. \line\bullet  Uma maneira conveniente de implementar arquivos de acesso aleat\'f3rio \'e9 usar somente registros de comprimento fixo. Usando esta t\'e9cnica, um programa pode rapidamente calcular a posi\'e7\'e3o exata de um registro em rela\'e7\'e3o ao come\'e7o do arquivo. \line\bullet  Dados podem ser inseridos em um arquivo de acesso aleat\'f3rio sem destruir outros dados no arquivo. Dados podem ser atualizados ou exclu\'eddos sem regravar todo o arquivo. \line\bullet  A fun\'e7\'e3o membro write de ostream faz a sa\'edda para um stream especificado de algum n\'famero de bytes, come\'e7ando em uma posi\'e7\'e3o designada na mem\'f3ria. Quando o stream est\'e1 associado com um arquivo, os dados s\'e3o gravados na posi\'e7\'e3o especificada pelo ponteiro put de posi\'e7\'e3o no arquivo. \line\bullet  A fun\'e7\'e3o membro read de isream extrai um n\'famero especificado de bytes do stream especificado para uma \'e1rea na mem\'f3ria come\'e7ando em um endere\'e7o designado. Os bytes s\'e3o extra\'eddos come\'e7ando pela posi\'e7\'e3o especificada pelo ponteiro ge! de posi\'e7\'e3o no arquivo. A fun\'e7\'e3o read requer um primeiro argumento do tipo char*. \line\bullet  A fun\'e7\'e3o write espera um primeiro argumento do tipo const char*. de modo que este argumento deve sofrer uma coer\'e7\'e3o para const char* se for de algum outro tipo de ponteiro. O segundo argumento \'e9 um inteiro que especifica o n\'famero de bytes a serem gravados. \line\bullet  O operador un\'e1rio sizeof retorna, durante a compila\'e7\'e3o, o tamanho em bytes do objeto contido entre par\'eanteses; sizeof retorna um uns igned integer. \par
CAP\'cdTULO 14- PROCESSAMENTO DE ARQUIVOS 753 \par
\bullet  A fun\'e7\'e3o membro eof de ias informa se o indicador de fim de arquivo foi ligado no stream designado. O fim de arquivo \'e9 ligado ap\'f3s falhar uma tentativa de leitura. \par
Terminologia \par
abrir um arquivo \line arquivo \line arquivo de acesso aleat\'f3rio \line arquivo de acesso seq\'fcencial arquivo de cabe\'e7alho <fstream> \par
bit \par
byte \par
campo \par
campo alfab\'e9tico campo de caracteres campo num\'e9rico \par
cerr (sa\'edda padr\'e3o para erros, sem buifer) \line chave de registro \line cm (entrada padr\'e3o) \par
classe fstream classe ifstreain classe istream classe ofstrearn \par
classe ostream \line clog (sa\'edda padr\'e3o para erros, com buifer) conjunto de caracteres \par
cout (sa\'edda padr\'e3o) \line database / banco de dados \line database management system (DB MS) d\'edgito bin\'e1rio \line d\'edgito decimal \line EIS em mem\'f3ria \par
EIS em n\'facleo fechar um arquivo \par
fim de arquivo \line fun\'e7\'e3o membro dose fun\'e7\'e3o membro open \line fun\'e7\'e3o membro operator void* fun\'e7\'e3o membro operator fun\'e7\'e3o membro seekg de istream fun\'e7\'e3o membro seekp de ostream fun\'e7\'e3o membro tellg de istreaxn \par
fun\'e7\'e3o membro tellp de ostreani hierarquia de dados \line manipulator de stream ends \par
marcador de fim de arquivo modo de abertura de arquivo ios: : app modo de abertura de arquivo ios: : ate \par
modo de abertura de arquivo ios: : binary modo de abertura de arquivo ias: : in modo de abertura de arquivo ias: : out modo de abertura de arquivo ias: : trunc nome de arquivo \line ponteiro de posi\'e7\'e3o no arquivo ponto de in\'edcio de seek ias: : beg ponto de in\'edcio de seek ias: : cur ponto de in\'edcio de seek ias: : end registro \par
s\'edmbolo especial stream \line stream de entrada \par
stream de sa\'edda truncar um arquivo existente \par
Erros comuns de programa\'e7\'e3o \par
14.1 Abrir um arquivo existente para sa\'edda(ias: : aut) quando, na verdade, o usu\'e1rio quer preservar o arquivo; o conte\'fado do arquivo \'e9 descartado sem aviso. \par
14.2 Usar um objeto afstream incorreto para se referir a um arquivo. \line 14.3 N\'e3o abrir um arquivo antes de tentar referenci\'e1-lo em um programa. \par
Boa pr\'e1tica de programa\'e7\'e3o \par
14.1 Abrir um arquivo somente para entrada (usando ias: : in), se o conte\'fado do arquivo n\'e3o deve ser modificado. Isso evita a modifica\'e7\'e3o n\'e3o-intencional do conte\'fado do arquivo. Esse \'e9 um exemplo do princ\'edpio do privil\'e9gio m\'ednimo. \par
Dica de desempenho \par
14.1 Feche explicitamente cada arquivo t\'e3o logo se saiba que o programa n\'e3o far\'e1 refer\'eancia ao arquivo novamente. Isso pode reduzir o consumo de recursos no programa que vai continuar sendo executado ap\'f3s n\'e3o mais necessitar de um arquivo \line particular. Essa pr\'e1tica tamb\'e9m melhora a clareza do programa. \par
754 C++ COMO PROGRAMAR \line Exerc\'edcios de auto-revis\'e3o \line 14.1 Preencha os espa\'e7os em branco em cada um dos seguintes itens: \line a) Em \'faltima inst\'e2ncia, todos os items de dados processados por um computador s\'e3o reduzidos a combina\'e7\'f5es de \line _______ e _______ \line b) O menor item de dados que um computador pode processar \'e9 chamado de __________ \line c) Um \'e9 um grupo de registros relacionados. \line d) D\'edgitos, letras e s\'edmbolos especiais s\'e3o chamados de ________________________ \line e) Um grupo de arquivos relacionados \'e9 chamado de______________ \line f) A fun\'e7\'e3o membro _______________ das classes stream de arquivo fstream. ifstream e ofstreazn fecha um arquivo. \line g) A fun\'e7\'e3o membro _________________ de istreani l\'ea um caractere do stream especificado. \line h) As fun\'e7\'f5es membro ________________ e ________________ de is tream l\'eaem uma linha do stream especificado. \line i) A fun\'e7\'e3o membro ______________das classes streamde arquivo fstream. ifstream e ofstream abre um arquivo. \line j) A fun\'e7\'e3o membro _______________ de istream\'e9 normalmente usada quando da leitura de dados de um arquivo em aplica\'e7\'f5es de acesso aleat\'f3rio. \line k) As fun\'e7\'f5es membro ____________ e _________________ das classes istream e ostream inicializam o ponteiro de posi\'e7\'e3o para uma posi\'e7\'e3o espec\'edfica em um stream de entrada ou sa\'edda, respectivamente. \line 14.2 Indique quais das seguintes afirma\'e7\'f5es s\'e3o verdadeiras e quais s\'e3o falsas. Se forem explique por qu\'ea: \line a) A fun\'e7\'e3o membro read n\'e3o pode ser usada para ler dados do objeto de entrada cm. \line b) O programador deve criar explicitamente os objetos ci cout. cerr e clog. \line c) Um programa deve chamar explicitamente a fun\'e7\'e3o dose para fechar um arquivo associado a um objeto ifstream. ofstream ou fstream. \line d) Se o ponteiro de posi\'e7\'e3o no arquivo aponta para uma posi\'e7\'e3o em um arquivo seq\'fcencial diferente do come\'e7o do arquivo, o arquivo deve ser fechado e reaberto para se ler desde o come\'e7o do arquivo. \line e) A fun\'e7\'e3o membro write de ostream pode escrever no stream padr\'e3o de sa\'edda cout. \line f) Dados em arquivos de acesso seq\'fcencial s\'e3o sempre atualizados sem gravar por cima dos dados vizinhos. \line g) N\'e3o \'e9 necess\'e1rio pesquisar todos os registros em arquivos de acesso aleat\'f3rio para encontrar um registro espec\'edfico. \line h) Registros em um arquivo de acesso aleat\'f3rio devem ser de comprimento uniforme. \line i) As fun\'e7\'f5es membro seekp e seekg devem come\'e7ar a pesquisa no in\'edcio de um arquivo. \line 14.3 Assuma que cada uma das seguintes afirama\'e7\'f5es se aplica ao mesmo programa. \line a) Escreva um comando que abre o arquivo \ldblquote  oldmast . dat\rdblquote  para entrada; use o objeto inOidMaster de ifstreaxn. \line b) Escreva um comando que abre o arquivo \ldblquote trans . dat para entrada; use o objeto inTransaction de ifstreain. \line c) Escreva um comando que abre o arquivo \ldblquote  newmast. dat\rquote  para sa\'edda (e cria\'e7\'e3o); use o objeto outnewMaster de ofstream. \line d) Escreva um comando que l\'ea um registro do arquivo \lquote oldmast . dat\rdblquote . O registro consiste no inteiro accountNum. do string name e do valor em ponto flutuante currentBalance: use o objeto inOidmaster de ifstrearn. \line e) Escreva um comando que l\'ea um registro do arquivo \ldblquote trans. dat\rquote . O registro consiste no inteiro accouritNum e do valor em ponto flutuante dollarAmount: use o objeto inTransaction de ifstream. \line f) Escreva um comando que grava um registro no arquivo newmast. dat\rdblquote . O registro consiste no inteiro accountNum, do string name e do valor em ponto flutuante currentBalance: use o objeto outNewMaster \line de ofstream. \line 14.4 Encontre o(s) erro(s) e mostre como corrigi-lo(s) em cada um dos seguintes itens. \line a) O arquivo \ldblquote payables . dat\rdblquote  referenciado pelo objeto outPayable de ofstream n\'e3o foi aberto. \line outPayable \'ab account \'ab company \'ab amount \'ab endi; \line b) O seguinte comando deveria ler um registrn do arquivo \ldblquote payables . dat\rdblquote . O objeto inPayable de ifstream referencia este arquivo e o objeto inReceivable de istream referencia o arquivo \ldblquote receivables . dat\rdblquote . \line inReceivable \'bb account \'bb company \'bb arnount; \line e) O arquivo \ldblquote tools . dat\rdblquote  deveria ser aberto para adicionar dados ao arquivo sem descartar os dados correntes. \line ofstream outTools( \ldblquote tools.dat\rdblquote , ios::out ); \par
CAP\'cdTULO 14 - PROCESSAMENTO DE ARQUIVOS 755 \line Respostas aos exerc\'edcios de auto-revis\'e3o \line 14.1 a) is, Os. b) Bit. c) Arquivo. d) Caracteres, e) Database/Banco de dados. 1) dose. g) get. h) get, getline. i) open. j) read. k) seekg. seekp. \line 14.2 a) Falsa. A fun\'e7\'e3o read pode ler de qualquer objeto de entrada stream derivado de istreain. \line b) Falsa. Estes quatro streain.s s\'e3o criados automaticamente para o programador. O arquivo de cabe\'e7alho <iostreaan deve ser inclu\'eddo em um arquivo para us\'e1-los. Este cabe\'e7alho inclui declara\'e7\'f5es de cada um destes objetos stream. \line c) Falsa. Os arquivos ser\'e3o fechados quando destruidores para os objetos ifstreaxn. ofstream ou fstreain s\'e3o executados, quando os objetos stream saem do escopo ou antes da execu\'e7\'e3o do programa terminar, mas \'e9 uma boa \line pr\'e1tica de programa\'e7\'e3o fechar explicitamente todos os arquivos com dose quando eles n\'e3o s\'e3o mais necess\'e1rios. \line d) Falsa. A fun\'e7\'e3o membro seekp ou seekg pode ser usada para reposicionar o ponteiro put ou get de posi\'e7\'e3o no arquivo no come\'e7o do arquivo. \line e) Verdadeira. \line f) Falsa. Na maioria dos casos, os registros de arquivos seq\'fcenciais n\'e3o s\'e3o de comprimento uniforme. Portanto, \'e9 poss\'edvel que a atualiza\'e7\'e3o de um registro fa\'e7a com que dados de outros registros sejam sobrepostos. \line g) Verdadeira. \line h) Falsa. Os registros em arquivos de acesso aleat\'f3rio s\'e3o normalmente de comprimento uniforme, \line i) Falsa. E poss\'edvel pesquisar do come\'e7o do arquivo, do fim do arquivo e da posi\'e7\'e3o corrente no arquivo. \line 14.3 a) ifstream inOidMaster( \ldblquote oidmast.dat\rquote , ios: :in \line b) ifstream inTransaction( \ldblquote trans.dat\rdblquote , ios::in ); \line c) ofstream outNewMaster( riewmast.dat\rdblquote , ios::out ); \line d) iriOidmaster \'bb accountNum \'bb name \'bb currentBaiance; \line e) inTransaction \'bb accountNuin \'bb doiiarPanount; \line outNewMaster \'ab accountNum \'ab name \'ab currentBaiance; \line 14.4 a) Erro: o arquivo \ldblquote payables . dat\rdblquote  n\'e3o foi aberto antes de se tentar fazer uma sa\'edda dados para o stream. \line Corre\'e7\'e3o: use a fun\'e7\'e3o open de ostream para abrir \ldblquote payabies . dat\rquote  para sa\'edda. \line b) Erro: o objeto incorreto de istream est\'e1 sendo usado para ler um registro do arquivo \ldblquote payabies . dat\rdblquote . Corre\'e7\'e3o: use o objeto inPayabie de istream para referenciar \ldblquote payabies dat\rdblquote . \line c) Erro: o conte\'fado do arquivo \'e9 descartado porque o arquivo est\'e1 aberto para sa\'edda (ios: out). \line Corre\'e7\'e3o: para adicionar dados ao arquivo, abra o arquivo para atualiza\'e7\'e3o (ios: : ate) ou abra o arquivo para acr\'e9scimo (ios: : app). \line Exerc\'edcios \line 14.5 Preencha os espa\'e7os em cada um dos seguintes itens: \line a) Computadores armazenam grandes volumes de dados em dispositivos de mem\'f3ria secund\'e1ria como________________ \line b) Um ________________ \'e9 composto de v\'e1rios campos. \line c) Um campo que pode conter somente d\'edgitos, letras e espa\'e7os \'e9 chamado de campo \line d) Para facilitar a recupera\'e7\'e3o de registros espec\'edficos de um arquivo, em cada registro \'e9 escolhido um campo como a \line e) A grande maioria das informa\'e7\'f5es armazenadas em sistemas de computadores \'e9 armazenada em arquivos \line O Um grupo de caracteres relacionados com um significado \'e9 chamado de ________________ \line g) Os objetos stream padr\'e3o declarados pelo arquivo de cabe\'e7alho <iostream> s\'e3o \line _________ _________ e _________ \line h) A fun\'e7\'e3o membro ostreaxn ________________ faz a sa\'edda de um caractere para o stream especificado. \line i) A fun\'e7\'e3o membro ostream geralmente \'e9 usada para gravar dados em um arquivo acessado \line aletoriamente. \line j) A fun\'e7\'e3o membro istream reposiciona o ponteiro de posi\'e7\'e3o do arquivo em um arquivo. \line 14.6 Diga quais das seguintes senten\'e7as s\'e3o verdadeiras e quais s\'e3o falsas. Se forem falsas, explique porqu\'ea: \line a) As impressionantes fun\'e7\'f5es executadas por computadores envolvem essencialmente a manipula\'e7\'e3o de zeros e uns. \line b) As pessoas preferem manipular bits em vez de caracteres e campos porque bits s\'e3o mais compactos. \line c) As pessoas especificam programas e items de dados como caracteres; os computadores ent\'e3o manipulam e processam estes caracteres como grupos de zeros e uns. \line d) O CEP de 5 d\'edgitos de uma pessoa \'e9 um exemplo de um campo num\'e9rico. \par
756 C\'f7+ COMO PROGRAMAR \line e) O endere\'e7o de uma pessoa \'e9 geralmente considerado um campo alfab\'e9tico nas aplica\'e7\'f5es de computador. \line f) Os itens de dados representados em computadores formam uma hierarquia de dados na qual os items de dados se tornam maiores e mais complexos \'e0 medida que progredimos de campos para caracteres, para bits, etc. \line g) A chave do registro identifica um registro como pertencendo a um campo particular. \line h) A maioria das organiza\'e7\'f5es armazenam toda a informa\'e7\'e3o em um \'fanico arquivo para facilitar o processamento por computador. \line i) Cada comando que processa um arquivo em um programa C++ explicitamente faz refer\'eancia \'e0quele arquivo por nome. \line j) Quando um programa cria um arquivo, o arquivo \'e9 automaticamente conservado pelo computador para refer\'eancia futura. \line 14.7 O Exerc\'edcio 14.3 pediu ao leitor para escrever uma s\'e9rie de comandos simples. Na verdade, esses comandos formam o n\'facleo de um importante tipo de programa de processamento de arquivos, ou seja, um programa de matching - compara\'e7\'e3o e correspond\'eancia de arquivos. No processamento comercial de dados, \'e9 comum ter-se v\'e1rios arquivos em cada sistema de aplica\'e7\'e3o. Em um sistema de contas a receber, por exemplo, geralmente h\'e1 um arquivo mestre contendo informa\'e7\'f5es detalhadas sobre cada cliente, tais como o nome do cliente, o endere\'e7o, o n\'famero do telefone, o saldo pendente, o limite de cr\'e9dito, as condi\'e7\'f5es de desconto, aspectos contratuais e, possivelmente, um hist\'f3rico condensado das compras recentes e pagamentos em dinheiro. \line A medida que ocorrem as transa\'e7\'f5es (por exemplo, s\'e3o feitas vendas e os pagamentos chegam), elas s\'e3o digitadas em um arquivo. No fim de um determinado per\'edodo (um m\'eas para algumas empresas, uma semana para outras e um dia em alguns casos) o arquivo de transa\'e7\'f5es (chamado \ldblquote trans . dat\rdblquote  no Exerc\'edcio 14.3) \'e9 aplicado ao arquivo mestre (chamado \ldblquote oldmast . dat\rdblquote  no Exerc\'edcio 14.3), atualizando desta forma o registro de compras e pagamentos para cada conta. Durante um processamento de atualiza\'e7\'e3o, o arquivo mestre \'e9 regravado como um novo arquivo (\ldblquote newmast. dat), o qual ent\'e3o \'e9 usado, no fim do pr\'f3ximo per\'edodo, para come\'e7ar o processo de atualiza\'e7\'e3o novamente. \line Programas de matching de arquivos devem lidar com certos problemas que n\'e3o existem em programas de um \'fanico arquivo. Por exemplo, nem sempre ocorre uma correspond\'eancia. Um cliente no arquivo mestre pode n\'e3o ter feito quaisquer compras ou pagamentos no exerc\'edcio corrente e, portanto, nenhum registro para este cliente aparecer\'e1 no arquivo de transa\'e7\'e3o. Similarmente, um cliente que efetuou algumas compras ou pagamentos pode ter acabado de entrar para o grupo de clientes e a empresa pode n\'e3o ter tido oportunidade de criar um registro mestre para este cliente. \line Use os comandos do Exerc\'edcio 14.3 como base para escrever um programa completo de contas a receber que efetua \line matching de arquivos. Use o n\'famero da conta em cada arquivo como a chave do registro para fins de matching. Assuma que cada arquivo \'e9 um arquivo seq\'fcencial, com registros armazenados em ordem crescente por n\'famero de conta. \line Quando ocorre uma correspond\'eancia (i.e., um registro com o mesmo n\'famero de conta aparece nos arquivos mestre e de \line transa\'e7\'e3o), some a quantia em dinheiro no arquivo de transa\'e7\'e3o ao saldo corrente no arquivo mestre e grave o registro em newmast. dat\rdblquote . (Assuma que compras s\'e3o indicadas por quantias positivas no arquivo de transa\'e7\'e3o e pagamentos s\'e3o indicados por quantias negativas.) Quando h\'e1 um registro mestre para uma conta particular, mas n\'e3o existe o registro de transa\'e7\'e3o correspondente, simplesmente grave o registro em \ldblquote newmast. dat. Quando h\'e1 um registro de transa\'e7\'e3o, mas n\'e3o um registro mestre correspondente, imprima a mensagem \ldblquote Registro de transa\'e7\'e3o sem correspondente para a conta n\'famero (preencha o n\'famero da conta pelo registro de transa\'e7\'e3o). \line 14.8 Ap\'f3s escrever o programa do Exerc\'edcio 14.7, escreva um programa simples para criar alguns dados de teste para verificar o programa. Use os seguintes exemplos de dados de contas: \par
100 AlanJones 348,17 \line 300 MarySmith 27,19 \line 500 Sam Sharp 0,00 \line 700 Suzy Green -14,22 \par
100 27,14 \line 300 62,11 \line 400 100,56 \line 900 82,17 \par
\pard\par
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2720\pard\intbl Arquivo Mestre \cell\row
\intbl N\'famero da Conta Nome Saldo \cell\row
\pard\sa240\par
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx3269\pard\intbl Arquivo de Transa\'e7\'e3o \cell\row
\intbl N\'famero da conta Valor da transa\'e7\'e3o \cell\row
\pard\par
\pard\sb100\sa240 758 C++ COMO PROGRAMAR \par
Tipo de dados Tamanho \par
char 1 \line unsigned char 1 \line short int 2 \line unsigned short int 2 \line int 4 \line unsigned int 4 \line long int 4 \line unsigned long int 4 \line float 4 \line double 8 \line long double 16 \line Nota: os tamanhos dos tipos de dados primitivos de seu computador podem diferir dos listados acima. \par
\par
\pard\lang1033\f1\fs20\par
}
 