{\rtf1\ansi\ansicpg1252\deff0\deflang1046\deflangfe1046\deftab708{\fonttbl{\f0\fswiss\fprq2\fcharset0 Arial;}{\f1\froman\fcharset0 Helvetica, sans-serif;}{\f2\fmodern\fprq1\fcharset0 Courier;}{\f3\froman\fprq2\fcharset0 Times New Roman;}}
\viewkind4\uc1\pard\sb100\sa240\lang2070\f0\fs24\par
\par
Sobrecarga de operadores \par
\par
\line Objetivos \par
\line . Entender como redefinir (sobrecarregar) operadores para trabalhar com novos tipos. \line . Entender como converter objetos de uma classe para outra classe. \line 1 Aprender quando sobrecarregar e quando n\'e3o sobrecarregar operadores. \line . . Estudar v\'e1rias classes interessantes que usam operadores \line sobrecarregados. \line . Criar classes Array. String e Date. \line A grande diferen\'e7a entre constru\'e7\'e3o e cria\'e7\'e3o \'e9 esta: que urna coisa constru\'edda s\'f3 pode ser amada depois de ser constru\'edda; mas urna coisa criada \'e9 amada antes de existi, Gilbert Keith Chesterton, Pref\'e1cio a Dickens, Pickwick Papers \line A sorte est\'e1 lan\'e7ada. \line J\'falio C\'e9sar \line Nosso m\'e9dico s\'f3 operaria sefosse realmente necess\'e1rio. Ele \'e9 assim. Se n\'e3o precisasse do dinheiro, ele n\'e3o poria as m\'e3os em voc\'ea. \line Herb Shriner \line [:44 . . 1 L \par
8 \par
516 c++ COMO PROGRAMAR \line\ul Vis\'e3o Geral \ulnone\line 8.1 Introdu\'e7\'e3o \line 8.2 Fundamentos da sobrecarga de operadores \line 8.3 Restri\'e7\'f5es sobre a sobrecarga de operadores \line 8.4 Fun\'e7\'f5es operador como membros de classe versus como fun\'e7\'f5es friend \line 8.5 Sobrecarregando os operadores de inser\'e7\'e3o em stream e extra\'e7\'e3o de stream \line 8.6 Sobrecarregando operadores un\'e1rios \line 8.7 Sobrecarregando operadores bin\'e1rios \line 8.8 Estudo de caso: uma classe Array \line 8.9 Convertendo entre tipos \line 8.10 Estudo de caso: uma classe String \line 8.11 Sobrecarregando ++ e -- \line 8.12 Estudo de caso: uma classe Date \line Resumo . Terminologia \bullet  Erros comuns de programa\'e7\'e3o \bullet  Boas pr\'e1ticas de programa\'e7\'e3o . Dicas de desempenho \bullet  Observa\'e7\'f5es de engenharia de software . Dica de teste e depura\'e7\'e3o \bullet  Exerc\'edcios de auto-revis\'e3o. Respostas aos exerc\'edcios de auto-revis\'e3o \bullet  Exerc\'edcios \line 8.1 Introdu\'e7\'e3o \line Nos Cap\'edtulos 6 e 7, introduzimos os fundamentos de classes em C++ e a no\'e7\'e3o de tipos de dados abstratos (ADTs). As manipula\'e7\'f5es sobre objetos de classes (i.e., inst\'e2ncias de ADTs) eram realizadas enviando-se mensagens (na forma de chamadas a fun\'e7\'f5es membro) para os objetos. Esta nota\'e7\'e3o de chamada de fun\'e7\'e3o \'e9 inc\'f4moda a certos tipos de classes, especialmente classes matem\'e1ticas. Para estes tipos de classes seria mais agrad\'e1vel usar o rico conjunto de operadores primitivos de C++ para especificar manipula\'e7\'f5es de objetos. Neste cap\'edtulo, mostramos como habilitar os operadores de C++ a trabalhar com objetos de uma classe. Este processo \'e9 chamado de sobrecarga de operadores. E simples e natural se estender C++ com estes novos recursos. Isso tamb\'e9m exige um grande cuidado porque, quando usamos mal a sobrecarga, ela pode tornar um programa dif\'edcil de se entender. \line o operador \'ab tem v\'e1rias finalidades em C++ - como o operador de inser\'e7\'e3o em stream e como o operador de deslocamento \'e0 esquerda sobre bits. Este \'e9 um exemplo de sobrecarga de operadores. De modo semelhante, \'bb tamb\'e9m \'e9 sobrecarregado; \'e9 usado tanto como o operador de extra\'e7\'e3o de stream como o operador de deslocamento \'e0 direita sobre bits. [Nota: os operadores de deslocamento \'e0 esquerda sobre bits e deslocamento \'e0 direita sobre bits s\'e3o discuti- dos em detalhes no Cap\'edtulo 16.] Estes dois operadores s\'e3o sobrecarregados na biblioteca de classes de C++. A linguagem C++ propriamente dita sobrecarrega + e - . Estes operadores s\'e3o executados de maneira diferente, dependendo de seu contexto ser a aritm\'e9tica de inteiros, a aritm\'e9tica de ponto flutuante e a aritm\'e9tica de ponteiros. \line C++ habilita o programador a sobrecarregar a maioria dos operadores para serem sens\'edveis ao contexto em que s\'e3o usados. O compilador gera o c\'f3digo apropriado com base na maneira como o operador \'e9 usado. Alguns operadores s\'e3o freq\'fcentemente sobrecarregados, especialmente o operador de atribui\'e7\'e3o e v\'e1rios operadores aritm\'e9ticos, tais como + e - . O trabalho executado por operadores sobrecarregados tamb\'e9m pode ser executado por chamadas expl\'edcitas de fun\'e7\'f5es, mas a nota\'e7\'e3o de operador freq\'fcentemente \'e9 mais clara. \line Discutiremos quando devemos usar a sobrecarga de operadores ou n\'e3o. Mostraremos como sobrecarregar \line operadores e apresentaremos muitos programas completos usando operadores sobrecarregados. \line 8.2 Fundamentos da sobrecarga de operadores \line A programa\'e7\'e3o em C++ \'e9 um processo sens\'edvel a tipos e enfocado nos tipos. Os programadores podem usar tipos primitivos e podem definir novos tipos. Os tipos primitivos podem ser usados com a rica cole\'e7\'e3o de operadores de \par
CAP\'cdTULO 8 - SOBRECARGA DE OPERADORES 517 \line c++. Os operadores fornecem aos programadores uma nota\'e7\'e3o concisa para expressar manipula\'e7\'f5es de objetos de tipos primitivos. \line Os programadores tamb\'e9m podem usar operadores com tipos definidos pelo usu\'e1rio. Embora C++ n\'e3o permita criar novos operadores, ela permite que a maioria dos operadores existentes sejam sobrecarregados, de forma que, quando estes operadores forem usados com objetos de classe, eles tenham o significado apropriado aos novos tipos. Este \'e9 um dos recursos mais poderosos de C++. \line\ul Observa\'e7\'e3o de engenharia de software 8.1 \ulnone\line ______ A sobrecarga de operadores contribuipara a extensibilidade de C++, um dos atributos mais atraentes da linguagem. \line\ul Boa pr\'e1tica de programa\'e7\'e3o 8.1 \ulnone\line Use a sobrecarga de operadores quando ela tornar um programa mais claro do que realizar as mesmas \line opera\'e7\'f5es com chamadas expl\'edcitas de fun\'e7\'e3o. \line\ul Boa pr\'e1tica de programa\'e7\'e3o 8.2 \ulnone\line Evite o uso excessivo ou incompat\'edvel da sobrecarga de operadores, pois isto pode tornar um programa \line cr\'edptico e dif\'edcil de ler \line lo \bullet  Embora a sobrecarga de operadores possa parecer um recurso ex\'f3tico, a maioria dos programadores usa regular- mente operadores sobrecarregados implicitamente. Por exemplo, o operador adi\'e7\'e3o (+) opera de maneira bastante diferente sobre ints, fioats e doubles. N\'e3o obstante, a adi\'e7\'e3o funciona bem com vari\'e1veis do tipo int, float, double e v\'e1rios outros tipos primitivos, porque o operador adi\'e7\'e3o (+) j\'e1 foi sobrecarregado na pr\'f3pria linguagem C++. \line Os operadores s\'e3o sobrecarregados escrevendo-se uma defini\'e7\'e3o de fun\'e7\'e3o (com um cabe\'e7alho e corpo) \line rs). como voc\'ea faria normalmente. exceto pelo fato de que o nome da fun\'e7\'e3o agora se torna a palavra-chave operator (na seguida pelo s\'edmbolo do operador que est\'e1 sendo sobrecarregado. Por exemplo, o nome de fun\'e7\'e3o operator+ os seria usado para sobrecarregar o operador adi\'e7\'e3o (+). \line Ico Para usar um operador com objetos de classes, aquele operador deve ser sobrecarregado - com duas exce\'e7\'f5es. los O operador de atribui\'e7\'e3o (=) pode ser usado com todas as classes sem sobrecarga expl\'edcita. O comportamento rga default do operador de atribui\'e7\'e3o \'e9 um atribui\'e7\'e3o membro a membro dos membros de dados da classe. Logo vereido mos que tal atribui\'e7\'e3o membro a membro por default \'e9 perigosa para classes com membros do tipo ponteiro; iremos \line sobrecarregar explicitamente o operador de atribui\'e7\'e3o para tais classes. O operador de endere\'e7o (&) tamb\'e9m pode de ser usado com objetos de qualquer classe sem ser sobrecarregado; ele simplesmente retoma o endere\'e7o do objeto na Lrn mem\'f3ria. O operador de endere\'e7o tamb\'e9m pode ser sobrecarregado. \line ia Sobrecarregar \'e9 mais apropriado para classes matem\'e1ticas. Estas classes exigem freq\'fcentemente que um iti- conjunto significativo de operadores seja sobrecarregado, para garantir a consist\'eancia com o modo com que estas ua- classes matem\'e1ticas s\'e3o manipuladas no mundo real. Por exemplo, seria incomum sobrecarregar somente a adi\'e7\'e3o de para uma classe de n\'fameros complexos, porque outros operadores aritm\'e9ticos s\'e3o tamb\'e9m comumente usados com \line n\'fameros complexos. \line em c++ \'e9 uma linguagem rica em operadores. Os programadores de C++ que entendem o significado e o iIs contexto de cada operador provavelmente far\'e3o escolhas razo\'e1veis quando sobrecarregarem operadores para no- \line nt- vas classes. \line )or O motivo da sobrecarga de operadores \'e9 fornecer, para os tipos definidos pelo usu\'e1rio, as mesmas express\'f5es concisas que C++ fornece com sua rica cole\'e7\'e3o de operadores para tipos primitivos. No entanto, a sobrecarga \line ar de operadores n\'e3o \'e9 autom\'e1tica; o programador deve escrever fun\'e7\'f5es que sobrecarregam operadores para executar as opera\'e7\'f5es desejadas. As vezes, estas fun\'e7\'f5es s\'e3o mais bem definidas como fun\'e7\'f5es membro; \'e0s vezes, s\'e3o mais bem definidas como fun\'e7\'f5es friend; e, ocasionalmente, elas podem ser definidas como fun\'e7\'f5es n\'e3o- membro, n\'e3o-friend. \line S\'e3o poss\'edveis usos extremos da sobrecarga, tais como sobrecarregar o operador + para executar opera\'e7\'f5es \line )05 como subtra\'e7\'f5es ou sobrecarregar o operador / para executar opera\'e7\'f5es como multiplica\'e7\'f5es. Tais usos da sobre- \line de carga tornam um programa extremamente dif\'edcil de se compreender. \par
518 c++ COMO PROGRAMAR \line Boa pr\'e1tica de programa\'e7\'e3o 8.3 \line Sobrecarregue operadores para executar a mesmafun\'e7\'e3o oufun\'e7\'f5es semelhantes com objetos de classes da mesma maneira como os operadores s\'e3o executados com objetos de tipos primitivos. Evite usos n\'e3o- intuitivos de operadores. \line Boa pr\'e1tica de programa\'e7\'e3o 8.4 \line Antes de escreverprogramas em C++ com operadores sobrecarregados, consulte os manuais de seu com- \line piladorpara se tornar ciente de restri\'e7\'f5es e requisitos especiais aplic\'e1veis a operadores particulares. \line 8.3 Restri\'e7\'f5es sobre a sobrecarga de operadores \line A maioria dos operadores em C++ podem ser sobrecarregados. Estes s\'e3o mostrados na Fig. 8.1. A Fig. 8.2 mostra os operadores que n\'e3o podem ser sobrecarregados. \line Erro comum de programa\'e7\'e3o 8.1 \line Tentar sobrecarregar um operador n\'e3o-sobrecarreg\'e1vel \'e9 um erro de sintaxe. \line A sobrecarga n\'e3o pode mudar a preced\'eancia de um operador. Isso pode levar a situa\'e7\'f5es estranhas em que um operador \'e9 sobrecarregado de uma maneira para a qual sua preced\'eancia fixa \'e9 impr\'f3pria. Por\'e9m, podem ser usados par\'eanteses para for\'e7ar a ordem de avalia\'e7\'e3o de operadores sobrecarregados em uma express\'e3o. \par
Fig. 8.2 Operadores que n\'e3o podem ser sobrecarregados. \line A sobrecarga n\'e3o pode mudar a associatividade de um operador. \line N\'e3o \'e9 poss\'edvel mudar a \ldblquote aridade\rdblquote  de um operador (i.e. , o n\'famero de operandos que um operador aceita): operadores un\'e1rios sobrecarregados permanecem como operadores un\'e1rios; operadores bin\'e1rios sobrecarregados permanecem como operadores bin\'e1rios. O \'fanico operador tern\'e1rio de C++ (? : ) n\'e3o pode ser sobrecarregado (Fig. 8.2). Cada um dos operadores &, , + e - tem vers\'f5es un\'e1rias e bin\'e1rias; estas vers\'f5es un\'e1rias e bin\'e1rias podem ser separadamente sobrecarregadas. \par
\pard\par
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4662\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx5145\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx5758\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx6623\pard\intbl 1 Operadores que podem ser sobrecarregados \cell\cell\cell\cell\row
\intbl + - * 1 %  -. 1 = < >  1= %= A... = 1=  \'ab= == != <= >=  -- , -> [1  new[] c1ete[] \cell A  +=  \'ab  &&  () \cell -=  \'bb  1 1  new \cell 1  *=  \'bb=  +=  delete \cell\row
\intbl Fig. 8.1 Operadores que podem ser sobrecarregados. \cell\cell\cell\cell\row
\intbl Operadores que n\'e3o podem ser sobrecarregados \cell\cell\cell\cell\row
\intbl . .* :: \cell ?: \cell\cell sizeof \cell\row
\pard\par
\pard\sb100\sa240 518 c++ COMO PROGRAMAR \line Boa pr\'e1tica de programa\'e7\'e3o 8.3 \line Sobrecarregue operadores para executar a mesmafun\'e7\'e3o oufun\'e7\'f5es semelhantes com objetos de classes da mesma maneira como os operadores s\'e3o executados com objetos de tipos primitivos. Evite usos n\'e3o- intuitivos de operadores. \line Boa pr\'e1tica de programa\'e7\'e3o 8.4 \line Antes de escreverprogramas em C++ com operadores sobrecarregados, consulte os manuais de seu com- \line piladorpara se tornar ciente de restri\'e7\'f5es e requisitos especiais aplic\'e1veis a operadores particulares. \line 8.3 Restri\'e7\'f5es sobre a sobrecarga de operadores \line A maioria dos operadores em C++ podem ser sobrecarregados. Estes s\'e3o mostrados na Fig. 8. 1 . A Fig. 8.2 mostra os operadores que n\'e3o podem ser sobrecarregados. \line Erro comum deprograma\'e7\'e3o 8.1 \line Tentar sobrecarregar um operador n\'e3o-sobrecarreg\'e1vel \'e9 um erro de sintaxe. \line A sobrecarga n\'e3o pode mudar a preced\'eancia de um operador. Isso pode levar a situa\'e7\'f5es estranhas em que um operador \'e9 sobrecarregado de uma maneira para a qual sua preced\'eancia fixa \'e9 impr\'f3pria. Por\'e9m. podem ser usados par\'eanteses para for\'e7ar a ordem de avalia\'e7\'e3o de operadores sobrecarregados em uma express\'e3o. \par
Fig. 8.2 Operadores que n\'e3o podem ser sobrecarregados. \line A sobrecarga n\'e3o pode mudar a associatividade de um operador. \line N\'e3o \'e9 poss\'edvel mudar a \ldblquote aridade\rdblquote  de um operador (i.e., o n\'famero de operandos que um operador aceita): operadores un\'e1rios sobrecarregados permanecem como operadores un\'e1rios; operadores bin\'e1rios sobrecarregados permanecem como operadores bin\'e1rios. O \'fanico operador tern\'e1rio de C++ (? : ) n\'e3o pode ser sobrecarregado (Fig. 8.2). Cada um dos operadores &, *, + e - tem vers\'f5es un\'e1rias e bin\'e1rias; estas vers\'f5es un\'e1rias e bin\'e1rias podem ser separadamente sobrecarregadas. \par
\pard\par
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4662\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx5112\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx5689\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx6554\pard\intbl 1 Operadores que podem ser sobrecarregados \cell\cell\cell\cell\row
\intbl + - * 1 %  -. ! = < > \cell A  += \cell -= \cell 1  *= \cell\row
\intbl 1= %= A... = 1=  \'ab= == != <= >=  -- , -> [1  new[] c1ete[] \cell\'ab  &&  () \cell\'bb  1 1  new \cell\'bb=  +=  delete \cell\row
\intbl Fig. 8.1 Operadores que podem ser sobrecarregados. \cell\cell\cell\cell\row
\intbl Operadores que n\'e3o podem ser sobrecarregados \cell\cell\cell\cell\row
\intbl . .* :: \cell ?: \cell\cell sizeof \cell\row
\pard\par
\pard\sb100\sa240 CAP\'cdTULO 8 - SOBRECARGA DE OPERADORES 519 \line N\'e3o \'e9 poss\'edvel se criar novos operadores; somente os operadores existentes podem ser sobrecarregados. Infelizmente, isso impede que o programador use nota\'e7\'f5es populares como o operador usado em BASIC para exponencia\'e7\'e3o. \line Erro comum de programa\'e7\'e3o 8.2 \line Tentar criar novos operadores atrav\'e9s da sobrecarga de operadores \'e9 um erro de sintaxe. \line A sobrecarga de operadores n\'e3o pode mudar o significado de como um operador funciona com objetos de tipos primitivos. O programador n\'e3o pode, por exemplo, mudar o significado de como + soma dois inteiros. A sobrecarga de operadores funciona somente com objetos de tipos definidos pelo usu\'e1rio ou com uma mistura de um objeto de um tipo definido pelo usu\'e1rio e um objeto de um tipo primitivo. \line Erro comum de programa\'e7\'e3o 8.3 \line Tentar modWcar como um operadorfunciona com objetos de tipos primitivos \'e9 um erro de sintaxe. \line Observa\'e7\'e3o de engenharia de software 8.2 \line ______ Pelo menos um dos argumentos de umafun\'e7\'e3o operador deve ser um objeto de classe ou uma refer\'eancia a um objeto de classe. isto impede que os programadores mudem a maneira como os operadoresfuncionain \line sobre tipos primitivos. \line Sobrecarregar um operador de atribui\'e7\'e3o e um operador adi\'e7\'e3o para permitir comandos como \line object2 = object2 + objecti; \line n\'e3o implica que o operador += seja tamb\'e9m sobrecarregado para permitir comandos tal como \line object2 += objecti; \line Tal comportamento pode ser obtido sobrecarregando-se explicitamente o operador + para aquela classe. \line Erro comum de programa\'e7\'e3o 8.4 \line Assumirque sobrecarregar um operador tal como + sobrecarrega operadores relacionados, tais como +, ou que sobrecarregar = sobrecarrega um operador relacionado como ! =. Operadores podem ser sobre- carregados somente explicitamente; n\'e3o existe sobrecarga impl\'edcita. \line Erro comum de programa\'e7\'e3o 8.5 \line Tentar mudar a \ldblquote aridade \ldblquote  de um operador atrav\'e9s da sobrecarga de operadore e um erro de sintaxe. \line Boa pr\'e1tica de programa\'e7\'e3o 8.5 \line Para garantir a consist\'eancia entre operadores relacionados, use um operadorpara implementar os outros \line (i.e., use uni operador + sobrecarregado para implementar um operador + sobrecarregado). \line 8.4 Fun\'e7\'f5es operador como membros de classe versus como fun\'e7\'f5es friend \line As fun\'e7\'f5es operador podem ser fun\'e7\'f5es membro ou fun\'e7\'f5es n\'e3o-membro; as fun\'e7\'f5es n\'e3o-membro s\'e3o frequentemente definidas como friends por raz\'f5es de desempenho. Fun\'e7\'f5es membro usam o ponteiro thjs implicitamente para obter um dos argumentos do seu objeto de classe (o argumento \'e0 esquerda para operadores bin\'e1rios). Os dois argumentos de classe devem ser listados explicitamente em uma chamada de fun\'e7iio n\'e3o-membro. \par
5 \par
6 \line 7 \line 8 \line 9 \line lo \par
11 \line 12 \par
13 \par
15 \line 16 \line 17 \line 18 \line 19 \line 20 \line 21 \line 22 \line 23 \line 24 \line 25 \line 26 \line 27 \line 28 \line 29 \line 30 \line 31 \line 32 \line 33 \line 34 \line 35 \line 36 \line 37 \line 38 \line 39 \line 40 \line 41 \line 42 \line 43 \line 44 \line 45 \line 46 \line 47 \line 48 \line 49 \line 50 \line 51 \line 52 \line 53 \par
CAP\'cdTULO 8 - SOBRECARGA DE OPERADORES 521 \line dos operadores de extra\'e7\'e3o de stream e de inser\'e7\'e3o em stream, para tratar dados de n\'fameros de telefone de uma classe definida pelo usu\'e1rio chamada PhoneNuniber. Este programa assume que os n\'fameros de telefone s\'e3o fornecidos corretamente. Deixamos para os exerc\'edcios o desenvolvimento da verifica\'e7\'e3o de erros de entrada. \par
1 II Fig. 8.3: figo8_03.cpp \line 2 II Sobrecarregando os operadores de \line 3 II inser\'e7\'e3o em stream e extra\'e7\'e3o de stream. \line 4 #include <iostream> \line using std: :cout; \line using std: :cin; \line using std::endl; \line using std: :ostreaxn; \line using std: :istream; \line #include <iomanip> \line 14 using std::setw; \line class PhoneNumber \{ \line friend ostream &operator\'ab ( ostream& , const PhoneNumber & ) friend istream &operator\'bb( istream&, PhoneNumber & ); \par
private: \line char areaCode[ 4 ] ; /1 \line char exchange [ 4 1; \line char line[ 5 ]; \par
c\'f3digo de \'e1rea com 3 d\'edgitos e caractere nulo II n\'famero da central com 3 d\'edgitos e nulo II n\'famero da linha com 4 d\'edgitos e nulo \par
II Operador de inser\'e7\'e3o em streaxn sobrecarregado (n\'e3o pode \line II ser urna fun\'e7\'e3o membro se quisermos invoc\'e1-la com \line II cout \'ab somePhoneNumber;). \line ostream &operator\'ab( ostream &output, const PhoneNumber &num \line output \'ab \lquote  (\ldblquote  \'ab num.areaCode \'ab \ldblquote ) \line\'ab nuin.exchange \'ab \ldblquote -\ldblquote  \'ab num.line; \line return output; II possibilita cout \'ab a \'ab b \'ab c; \line istreaxn &operator\'bb( istreaxn &input, PhoneNumber &nuut \par
input.ignore(); input \'bb setw( 4 input.ignore( 2 ); input \'bb setw( 4 input.ignore(); input \'bb setw( 5 return input; \par
II salta \line\'bb num.areaCode; II l\'ea c\'f3digo de \'e1rea \line II salta ) e espa\'e7o \'bb num.exchange; II l\'ea n\'famero da central \line II salta h\'edfen (-) \'bb nuxu.line; // l\'ea n\'famero da linha II possibilita cm \'bb a \'bb b \'bb c; \par
int main() \line PhoneNumber phone; /1 create object phone \line cout \'ab \ldblquote Digite n\'famero do telefone no formato (123) 456-7890:\\n\rdblquote ; II cm \'bb phone invoca a fun\'e7\'e3o operator\'bb \par
Fig. 8.3 Operadores de inser\'e7\'e3o em stream e extra\'e7\'e3o de stream definidos pelo usu\'e1rio (parte 1 de 2). \par
1 \line 522 c++ COMO PROGRAMAR \line 54 II fazendo a chamada operator\'bb( cm, phone ). \line 55 cm \'bb phone; \line 56 \line 57 II cout \'ab phone invoca a fun\'e7\'e3o operator\'ab \line 58 II fazendo a chamada operator\'ab( cout, phone ) \line 59 cout \'ab \ldblquote O n\'famero de telefone digitado foi: \'ab phone \'ab endl; \line 60 return O; \line 61 \} \line Digite n\'famero do telefone no formato (123) 456-7890: \line (800) 555-1212 \line o n\'famero de telefone digitado foi: (800) 555-1212 \line Fig. 8.3 Operadores de inser\'e7\'e3o em stream e extra\'e7\'e3o de stream definidos pelo usu\'e1rio (parte 2 de 2). \line A fun\'e7\'e3o operador de extra\'e7\'e3o de stream operator\'bb (linha 36) recebe uma refer\'eancia para istream chama- da de input e uma refer\'eancia a PhoneNumber chamada de num como argumentos, retornando uma refer\'eancia istream. A fun\'e7\'e3o operador operator\'bb \'e9 usada para ler n\'fameros de telephone no formato \line (800) 555-1212 \line para objetos da classe PhoneNuniber. Quando o compUador encontra a express\'e3o \line cm \'bb phone \line em main. o compilador gera a chamada da fun\'e7\'e3o \line operator\'bb( cm, phone ); \line Q uando esta chamada \'e9 executada, o argumento de refer\'eancia input torna-se um nome alternativo (alias) para cm e o argumento de refer\'eancia num torna-se um alias para phone. A fun\'e7\'e3o operador l\'ea como strings as tr\'eas partes do n\'famero de telefone para os membros areaCode. exchange e linha do objeto PhoneNumber referenciado (num na fun\'e7\'e3o operador e phone em main). O manipulador de streum setw limita o n\'famero de caracteres lidos para cada array de caracteres. Lembre-se de que, quando usado com cm. setw restringe o n\'famero de caracteres lidos a um a menos que seu argumento (i.e. . setw (4) permite que tr\'eas caracteres sejam lidos e reserva uma posi\'e7\'e3o para um caractere nulo terminal). Os par\'eanteses, o espa\'e7o e os tra\'e7os s\'e3o saltados chamando-se a fun\'e7\'e3o membro de istream ignore. que descarta o n\'famero especificado de caracteres no stream recebido como entrada (um caractere por default). A fun\'e7\'e3o operator\'bb retorna a refer\'eancia input a istream (i.e., cm). Isto possibilita que opera\'e7\'f5es de entrada sobre objetos do tipo PhoneNumber sejam encadeadas com opera\'e7\'f5es de entrada sobre outros objetos PhoneNuniber ou com objetos de outros tipos de dados. Por exemplo, dois objetos PhoneNumber poderiam ser recebidos como entrada, como segue: \line cm \'bb phonel \'bb phone2; \line Primeiro, a express\'e3o cm \'bb phonel seria executada, fazendo a chamada \line operator\'bb( cm, phonel ); \line Esta chamada ent\'e3o retornaria uma refer\'eancia para cm como o valor de cm \'bb phonel, de modo que a parte restante da express\'e3o seria interpretada simplesmente como cm \'bb phone2 . Esta seria executada fazendo-se a chamada \line operator\'bb( cm, phone2 ); \line O operador de inser\'e7\'e3o em streams recebe uma refer\'eancia a ostream (output) e uma refer\'eancia (num para um tipo definido pelo usu\'e1rio (PhoneNumber) como argumentos e retorna uma refer\'eancia a ostreani. A fun\'e7\'e3o operator\'ab exibe objetos do tipo PhoneNumber. Quando o compilador encontra a express\'e3o \line cout \'ab phone \par
1 \par
\bullet 1\bullet  \par
CAP\'cdTULO 8 - SOBRECARGA DE OPERADORES 523 \par
em main. o compilador gera a chamada para fun\'e7\'e3o n\'e3o-membro \line operator\'ab( cout, phone ); \line A fun\'e7\'e3o operator\'ab exibe as partes do n\'famero de telefone como strings porque s\'e3o armazenadas no formato de string. \line Note que as fun\'e7\'f5es operator\'bb e operator\'ab s\'e3o declaradas na classe PhoneNuniber como fun\'e7\'f5es friend, n\'e3o-membro. Estes operadores devem ser n\'e3o-membros porque o objeto da classe PhoneNumber aparece em cada caso como o operando \'e0 direita do operador; o operando de classe deve aparecer \'e0 esquerda do operador para sobrecarregar aquele operador como uma fun\'e7\'e3o membro. Operadores de entrada e sa\'edda sobrecarregados s\'e3o declarados como friends se eles necessitam acessar diretamente membros n\'e3o-public da classe por raz\'f5es de desempenho. Tamb\'e9m note que a refer\'eancia para PhoneNuinber na lista de argumentos de operator\'ab \'e9 const (porque PhoneNunber simplesmente ser\'e1 enviado para a sa\'edda) e a refer\'eancia para PhoneNumber na lista de argumentos de operator\'bb n\'e3o \'e9 const (porque o objeto PhoneNumber deve ser modificado para armazenar o n\'famero de telefone lido no objeto). \line Observa\'e7\'e3o de engenharia de software 8.3 \line ______ Novos recursos de entrada/sa\'edda para tipos definidos pelo usu\'e1rio podem ser acrescentados a C++ sem modificar as declara\'e7\'f5es ou os membros de dados private para a classe ostream ou para a classe istream. Este \'e9 outro exemplo de extensibilidade da linguagem de programa\'e7\'e3o C++. \line 8.6 Sobrecarregando operadores un\'e1rios \line Um operador un\'e1rio para uma classe pode ser sobrecarregado como uma fun\'e7\'e3o membro n\'e3o-static sem argumentos ou como uma fun\'e7\'e3o n\'e3o-membro com um argumento; esse argumento deve ser ou um objeto da classe ou uma refer\'eancia para um objeto da classe. As fun\'e7\'f5es membro que implementam operadores sobrecarregados devem ser n\'e3o-stat\'edc, de modo que elas possam acessar os dados n\'e3o-static da classe. Lembre-se de que fun\'e7\'f5es membro static somente podem acessar membros de dados static da classe. \line Mais tarde, neste cap\'edtulo, sobrecarregaremos o operador un\'e1rio ! para testar se um objeto de nossa classe String \'e9 vazio, retornando um bool como resultado. ao sobrecarregar um operador un\'e1rio tal como ! como uma fun\'e7\'e3o membro n\'e3o-static sem argumentos, se s, \'e9 um objeto da classe String ou uma refer\'eancia para um objeto da classe String. quando o compilador encontra a express\'e3o ! s o compilador gera a chamada s . operator ! ( ) . O operando s \'e9 o objeto de classe para o qual a fun\'e7\'e3o membro operator ! da classe String est\'e1 sendo invocada. A fun\'e7\'e3o \'e9 declarada na defini\'e7\'e3o de classe como segue: \line class String \line public: \line bool operator! O const; \line Um operador un\'e1rio tal como ! pode ser sobrecarregado como uma fun\'e7\'e3o n\'e3o-membro com um argumento de dois modos diferentes - ou com um argumento que \'e9 um objeto (isto exige uma c\'f3pia do objeto, de modo que os efeitos colaterais da fun\'e7\'e3o n\'e3o sejam aplicados ao objeto original), ou com um argumento que \'e9 uma refer\'eancia para um objeto (nenhuma c\'f3pia do objeto original \'e9 feita, de modo que todos os efeitos colaterais desta fun\'e7\'e3o s\'e3o aplicados ao objeto original). Se s \'e9 um objeto da classe String (ou uma refer\'eancia para um objeto da classe String), ent\'e3o ! s \'e9 tratado como se tivesse sido escrita a chamada operator ! ( s ) , invocando a fun\'e7\'e3o friend n\'e3o- membro da classe String declarada abaixo: \par
class String \line friend bool operator\rquote  ( const String & \par
524 c++ COMO PROGRAMAR \line Boa pr\'e1tica de programa\'e7\'e3o 8.6 \line Ao se sobrecarregar operadores un\'e1rios, \'e9 prefer\'edvel tornar asfun\'e7\'f5es operador membros da classe, em vez de fun\'e7\'f5es friend n\'e3o-membro. As fun\'e7\'f5es e classes friend devem ser evitadas, a menos que sejam absolutamente necess\'e1rias. O uso de friends viola o encapsulamento de uma classe. \line 8.7 Sobrecarregando operadores bin\'e1rios \line Um operador bin\'e1rio pode ser sobrecarregado como uma fun\'e7\'e3o membro n\'e3o-static com um argumento, ou com uma fun\'e7\'e3o n\'e3o-membro com dois argumentos (um desses argumentos deve ser ou um objeto de classe ou uma refer\'eancia para um objeto de classe). \line Mais tarde neste cap\'edtulo, sobrecarregaremos += para indicar a concatena\'e7\'e3o de dois objetos string. Ao sobre- carregar o operador bin\'e1rio += como uma fun\'e7\'e3o membro n\'e3o-static de uma classe String com um argumento, se y e z s\'e3o objetos da classe String, ent\'e3o y += z \'e9 tratado como se y . operator+= ( z ) tivesse sido escrito, invocando a fun\'e7\'e3o membro operator+= declarada abaixo \line class String \{ \line publie: \line const String &operator+=( const String & ); \line Se o operador bin\'e1rio += deve ser sobrecarregado como uma fun\'e7\'e3o n\'e3o-membro, deve aceitar dois argumentos - um dos quais deve ser um objeto da classe ou uma refer\'eancia para um objeto da classe. Se y e z s\'e3o objetos da classe String ou refer\'eancias para objetos da classe String, ent\'e3o y += z \'e9 tratado como se a chamada operator+= 1 ) tivesse sido escrita no programa, invocando a fun\'e7\'e3o friend n\'e3o-membro operator+=, declarada \line abaixo \line class String \line friend const String &operator+=( String &, \line const String & ); \line 8.8 Estudo de caso: uma classe Array \line Em C++, a nota\'e7\'e3o de array \'e9 somente uma alternativa \'e0 nota\'e7\'e3o de ponteiro, de modo que arrays t\'eam grande \line 1 potencial para causar erros. Por exemplo, um programa poderia facilmente passear\rdblquote  para al\'e9m dos limites de um \line\lquote fl array porque C++ n\'e3o verifica se um subscrito est\'e1 fora dos limites de um array. Arrays de tamanho n devem \line 1 numerar seus elementos de O n-l ; n\'e3o s\'e3o permitidos intervalos de subscritos alternativos. Um array n\'e3o-char \line completo n\'e3o pode ser lido ou impresso de uma s\'f3 vez; cada elemento do array deve ser lido ou impresso \line\lquote 4 individualmente. N\'e3o tem significado se comparar dois arrays com operadores de igualdade ou operadores relacionais \line ,, (porque os nomes dos arrays s\'e3o simplesmente ponteiros para o come\'e7o do array na mem\'f3ria). Quando um array \'e9 \line passado para uma fun\'e7\'e3o de uso geral projetada para tratar arrays de qualquer tamanho, o tamanho do array deve ser \line passado como um argumento adicional. Um array n\'e3o pode ser atribu\'eddo a outro com o(s) operador(es) de atribui\'e7\'e3o \line (porque nomes de array s\'e3o ponteiros const e um ponteiro constante n\'e3o pode ser usado \'e0 esquerda de um opera- \line dor de atribui\'e7\'e3o). Estes e outros recursos certamente parecem \ldblquote naturais\rdblquote  para se lidar com arrays, mas C++ n\'e3o fornece tais recursos. Por\'e9m, C\'f7+ fornece os meios para implementar tais recursos para arrays, atrav\'e9s dos mecanis mo de sobrecarga de operadores. \line Neste exemplo, desenvolvemos uma classe array que faz a verifica\'e7\'e3o de intervalo para garantir que os subs crito permane\'e7am dentro dos limites do array. A classe permite que um objeto array seja atribu\'eddo a outro com o \line operador de atribui\'e7\'e3o. Os objetos desta classe array sabem seu tamanho, de modo que o tamanho n\'e3o necessita ser \line\lquote  passado separadamente como um argumento quando passarmos um array para uma fun\'e7\'e3o. Os arrays inteiros po \par
CAP\'cdTULO 8 - SOBRECARGA DE OPERADORES 525 \line dem ser udos ou enviados para a sa\'edda com os operadores de inser\'e7\'e3o em streams e extra\'e7\'e3o de streams, respectiva- mente. Compara\'e7\'f5es de arrays podem ser definidas com os operadores de igualdade e ! . Nossa classe array usa um membro est\'e1tico para controlar o n\'famero de objetos array que foram instanciados no programa. \line Este exemplo vai agu\'e7ar seu apre\'e7o pela abstra\'e7\'e3o de dados. Voc\'ea provavelmente vai querer sugerir muitas \line melhorias a esta classe array. O desenvolvimento de classes \'e9 uma atividade interessante, criativa e intelectualmente desafiadora - feita sempre com o objetivo de \ldblquote criar classes valiosas\rdblquote . \line o programa da Fig. 8.4 demonstra a classe Array e seus operadores sobrecarregados. Primeiro, caminhamos pelo programa controlador em main. A seguir, consideramos a defini\'e7\'e3o da classe e cada uma das defini\'e7\'f5es das fun\'e7\'f5es membro e friends da classe. \line 1 II Fig. 8.4: arrayl.h \line 2 /1 Classe Array simples (para inteiros) \line 3 #ifndef AR1AYlH \line 4 #define ARRAY1H \line 5 \line 6 #include <iostream> \line 7 \line 8 using std: :ostreaxn; \line 9 using std::istream; \line lo \line 11 class Array \{ \line 12 friend ostream &operator\'ab( ostreaut &, const Array & ); \line 13 friend istream &operator\'bb( istreazn &, Array & ); \line 14 public: \line 15 Array( int = 10 ); II construtor default \line 16 Array( const Array & ) ; II construtor de c\'f3pia \line 17 Array() ; // destruidor \line 18 int getSize() const; // retorna tamanho \line 19 const Array &operator=( const Array & ) ; II atribui arrays \line 20 bool operator==( const Array & ) const; // testa quanto \'e0 igualdade \line 21 \line 22 II Determina se dois arrays n\'e3o s\'e3o iguais e \line 23 II retorna true, caso contr\'e1rio retorna false (usa operator==) \line 24 bool operator!=( const Array &right ) const \line 25 \{ return ! ( *this = right ) ; \} \line 26 \line 27 int &operator[) ( int ) ; 1/ operador subscrito \line 28 const int &operator[] ( int ) const; // operador subscrito \line 29 static int getArrayCountQ; II Retorna quantidade de \line 30 II arrays instanciados. \line 31 private: \line 32 int size; // tamanho do array \line 33 int *ptr; II ponteiro para primeiro elemento do array \line 34 static int arrayCount; II # de Arrays instanciados \line 35 \}; \line 36 \line 37 #endif \par
Fig. 8.4 Uma classe Array com sobrecarga de operadores - arrayl . cpp (parte 1 de 4). \par
\pard\par
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx425\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx930\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx3163\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4140\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx5605\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx6302\pard\intbl Fig. \cell 8.4 \cell Uma classe Array com sobr \cell ecarga de \cell operadores - arr \cell ayl . h. \cell\row
\intbl 38 \cell II \cell Fig 8.4: arrayl.cpp \cell\cell\cell\cell\row
\intbl 39 \cell II \cell Defini\'e7\'f5es de fun\'e7\'f5es \cell membro \cell para a classe \cell Array \cell\row
\intbl 40 \cell #in \cell clude <iostreaxn> \cell\cell\cell\cell\row
\intbl 41 \cell\cell\cell\cell\cell\cell\row
\pard\par
\pard\sb100\sa240 526 c++ COMO PROGRAMAR \par
42 using std: :cout; \line 43 using std::cin; \line 44 using std: :endl; \line 45 \line 46 #include <iomanip> \line 47 \line 48 using std::setw; \line 49 \line 50 #include <cstdlib> \line 51 #include \line 52 #include \ldblquote arrayl.h\rdblquote  \line 53 \line 54 II Inicializa membro de dados static em escopo de arquivo \line 55 int Array::arrayCount = O; 1/ nenhum objeto ainda \line 56 \line 57 II Construtor default para a classe Array (tamanho default 10) \line 58 Array: :Array( int arraySize \line 59 \{ \line 60 size = ( arraySize > O ? arraySize : 10 ); \line 61 ptr = new int[ size ) ; /1 cria espa\'e7o para o array \line 62 assert( ptr != O ) ; II termina se mem\'f3ria n\'e3o foi alocada \line 63 ++arrayCount; 1/ conta mais um obieto \line 64 \line 65 for (inti=0; i<size; i++ \line 66 ptr[ i ] = 0; 1/ inicializa o array \line 67 \} \line 68 \line 69 /1 Construtor de c\'f3pia para a classe Array \line 70 /1 deve receber urna refer\'eancia para evitar recurs\'e3o infinita \line 71 Array::Array( const Array &init ) : size( init.size \line 72 \{ \line 73 ptr = new int[ size ] ; /1 cria espa\'e7o para o array \line 74 assert( ptr != O ) ; /1 termina se mem\'f3ria n\'e3o foi alocada \line 75 ++arrayCount; II conta mais um objeto \line 76 \line A for ( int i = 0; i < size; i++ \line 78 ptr[ i ] = init.ptr[ i ]; II copia init para o objeto \line 79 \line 80 \line 81 /1 Destruidor para a classe Array \line 82 Array: :-Array() \line 83 \line 84 delete [] ptr; /1 recupera o espa\'e7o para o array \line 85 -arrayCount; II um objeto a menos \line 86 \} \line 87 \line 88 II Obt\'e9m o tamanho do array \line 89 int Array: :getsize() const \{ return size; \} \line 90 \line 91 II Operador de atribui\'e7\'e3o sobrecarregado \line 92 1/ retorno de const evita: ( ai = a2 ) = a3 \line 93 const Array &Array: :operator=( const Array &right \line 94 \{ \line 95 if ( &right != this ) \{ /1 verifica auto-atribui\'e7\'e3o \line 96 \line 97 II para arrays de tamanhos diferentes, desaloca o array \'e0 \line 98 II esquerda original e ent\'e3o aloca novo array \'e0 esquerda. \line 99 if ( size != right.size ) \{ \line Fig. 8.4 Uma classe Array com sobrecarga de operadores - arrayi . cpp (parte 2 de 4). \par
CAP\'cdTULO 8 - SOBRECARGA DE OPERADORES 527 \line 100 delete [] ptr; // recupera espa\'e7o \line 101 size right.size; 1/ redimensiona este objeto \line 102 ptr new int[ size ] ; 1/ cria espa\'e7o para c\'f3pia do array \line 103 assert( ptr ! O ) ; // termina se n\'e3o alocado \line 104 \line 105 \line 106 for ( int i 0; i < size; i++ \line 107 ptr[ i ] right.ptr[ i ]; /1 copia array para o objeto \line 108 \line 109 \line 110 return *this; /1 possibilita x = y = z; \line 111 \} \line 112 \line 113 II Determina se dois arrays s\'e3o iguais e \line 114 II retorna true, caso contr\'e1rio retorna false. \line 115 bool Array: :operator==( const Array &right ) const \line 116 \line 117 if ( size != right.size \line 118 return false; // arrays de tamanhos diferentes \line 119 \line 120 for ( int i = 0; i < size; i++ \line 121 if ( ptr[ i ] ! right.ptr[ i ] \line 122 return false; // arrays n\'e3o s\'e3o iguais \line 123 \line 124 return true; // arrays s\'e3o iguais \line 125 \} \line 126 \line 127 II Operador de subscrito sobrecarregado para Arrays n\'e3o-const \line 128 II retorno de refer\'eancia cria um ivalue \line 129 int &Array: :operator[] ( int subscript \line 130 \{ \line 131 II verifica erro de subscrito fora do intervalo v\'e1lido \line 132 assert( O < subscript && subscript < size ); \line 133 \line 134 return ptr[ subscript ]; II retorna refer\'eancia \line 135 \} \line 136 \line 137 II Operador de subscrito sobrecarregado para Arrays const \line 138 II retorno de refer\'eancia const cria um rvalue \line 139 const int &Array: :operator[] ( int subscript ) const \line 140 \{ \line 141 II verifica erro de subscrito fora do intervalo v\'e1lido \line 142 assert( O <= subscript && subscript < size ); \line 143 \line 144 return ptr[ subscript ] ; II retorna refer\'eancia const \line 145 ) \line 146 \line 147 II Retorna o n\'famero de objetos Array instanciados \line 148 II fun\'e7\'f5es static n\'e3o podem ser const \line 149 int Array: :getArrayCount() \{ return arrayCount; \} \line 150 \line 151 II Operador de entrada sobrecarregado para a classe Array; \line 152 II l\'ea valores para o array inteiro. \line 153 istream &operator\'bb( istream &input, Array &a \line 154 \{ \line 155 for ( int i 0; i < a.size; i++ \line 156 input \'bb a.ptr[ i ]; \line 157 \line 158 return input; // possibilita cm \'bb x \'bb y; \line Fig. 8.4 Uma classe Array com sobrecarga de operadores - arrayl . cpp (parte 3 de 4). \par
\bullet (c ap 1. eiJed) dd \bullet  O8Obt - saiopEiedo ep 6ieooiqos woo Aey OSSI3 wn 9 6ij \line ,u\\:sotaut LT TTG. \'bb flOD \line sie5e:p.it e seba;ui awxdwt e // \line oI \line u\\, \'bb se5e:tr\'e7 \'bb 6O \line T1\\:o\'f3?ztTtDtut sod \'bb 8O \line\'bb LO \line o e szee;ut Ai\'80 op ot.rnui,, \'bb no 9O \line s1ee;uT P OP\'c7UO a oiuui eur\'e71dux // \line u\\ \'bb Tszee:IuT \'bb EO \line u\\:oztTtDtut S\'c7dE i1yu\\, \'bb \line ez-rse6ise5eut \'bb to \line fl e tse5eut \'c1x op otuui,, \'bb rto oo \line s1aa;u-\'e7 ep op\'e7teuoo e ouum; uitidur\'e7 // 66T \line 86t \line u\\u\\, \'bb uno3t\'c7eJye5::A12y \'bb L61 \line\'ab = sop-\'e7Dusu-\'e7 sii ep ,, \'bb ;no 961 \line se5e:uT \lquote ( L )1seeuT 961 \line si\'c7iiy ep pp\'e7;unb w aur\'e7durr e s\'c3ii stop ti // 61 \line\'a361 \line :\bullet U\\ \'bb \'bb 6T \line\'ab = sop-\'e7zue;su sii ep \'bb ;noz 161 \line pU-\'e7 oe\'c7qo uirnueu // 061 \line\} 681 Ou-\'e7ui :pit 881 \line L81 \line tUTJ. epntDut# 981 \line 981 \line\lquote ipue::p;s 5utsn 81 \line !utD::p;s 5utsn E81 \line noD::ps &itsn 8T \line 181 \line <weJ;sot> epnTu-r# 081 \line setduits 4\'c7i:ty esst ese ep euxex5o // 6L1 \line ddzo8o5t; P8 \bullet 5T. II 8L1 \line\bullet (t7 P t\rquote  eiEd) dd - seiopaiedo ep ioeiqos woo eiy esso \line\{ LLI \line !i\'e7 \'bb x \'bb ;no ftqssod // ndno uinej 9L1 \line 9L1 \line ipue \'bb ;nd;no \lquote L1 \line ( o =i % -\'e7 ) ;i: ELI \line L1 \line\{ ILI \line :ipue \'bb ndno OLI \line p\bullet es ep tTi-\'e7T iod soeunu // ( o == % ( t \'f7 i ) ) ;i 691 \line 891 \line ![ i: ]id \'bb ( t )n;es \'bb ndno L91 \line\} ( ++i !eztse > -\'e7 o = t ) 991 \line 991 \line !T 9t \line ) \'a391 \line ( e 4\'c7y suo \lquote ndno uxeso )\'bbxowedo uieeiso 91 \line\'c7iiy essTz xed op5eJDe1qos p-rs ep opexedj // 191 \line 091 \line\{ 691 \line IVNVDOId 0N03 ++D \par
CAP\'cdTULO 8 - SOBRECARGA DE OPERADORES 529 \par
213 \line 214 \line 215 \line 216 \line 217 \line 218 \line 219 \line 220 \line 221 \line 222 \line 223 \line 224 \line 225 \line 226 \line 227 \line 228 \line 229 \line 230 \line 231 \line 232 \line 233 \line 234 \line 235 \line 236 \line 237 \line 238 \line 239 \line 240 \line 241 \line 242 \line 243 \line 244 \line 245 \line 246 \line 247 \line 248 \line 249 \line 250 \line 251 \line 252 \line 253 \line 254 \line 255 \line 256 ) \par
cm \'bb integersi \'bb integers2; \line cout \'ab \ldblquote Ap\'f3s entrada, os arrays cont\'eam:\\n\rdblquote  \line\'ab \ldblquote integersl:\\n\rdblquote  \'ab integersl \line\'ab \ldblquote integers2:\\n\rdblquote  \'ab integers2 \'ab \\n; \line II usa operador de desigualdade (=) sobrecarregado cout \'ab \ldblquote Avaliando: integersi != integers2\\n\rdblquote ; \line if ( integersl != integers2 \line cout \'ab \ldblquote Eles n\'e3o s\'e3o iguais\\n\rquote ; \line II cria array integers3 usando integersl como \line II inicializador; imprime tamanho e conte\'fado \line Array integers3 ( integersl ); \line cout \'ab \ldblquote\\nTamanho do array integers3 \'e9 \line\'ab integers3 . getSize O \line\'ab \ldblquote\\riArray ap\'f3s inicializa\'e7\'e3o:\\n\rdblquote  \line\'ab integers3 \'ab \lquote\\n\rquote ; \line II usa operador de atribui\'e7\'e3o (=) sobrecarregado \line cout \'ab \ldblquote Atribuindo integers2 a integersl:\\n\rdblquote ; \line integersi = integers2; \line cout \'ab \ldblquote integersl:\\n\rdblquote  \'ab integersi \line\'ab \ldblquote integers2:\\n\rdblquote  \'ab integers2 \'ab \lquote\\n\rquote ; \line II usa operador de igualdade (==) sobrecarregado \line cout \'ab \ldblquote Avaliando: integersl == integers2\\n\rdblquote ; \line if ( integersi = integers2 \line cout \'ab \ldblquote Eles s\'e3o iguais\\n\\n\rquote ; \line II usa operador de subscrito sobrecarregado para criar rvalue cout \'ab \ldblquote integersl[5] \'e9 \ldblquote  \'ab integersl[ 5 ] \'ab \lquote\\n\rquote ; \line II usa operador de subscrito sobrecarregado para criar lvalue cout \'ab \ldblquote Atribuindo 1000 a integersl[5]\\n\rdblquote ; \line integersl[ 5 ] = 1000; \line cout \'ab \ldblquote integersl:\\n\rdblquote  \'ab integersl \'ab \lquote\\n\rquote ; \line II tentativa de uso de subscrito fora do intervalo v\'e1lido cout \'ab \ldblquote Tentativa de atribuir 1000 a integersl[15]\rdblquote  \'ab endl; integersl[ 15 ] = 1000; II ERRO: fora do intervalo v\'e1lido \line return 0; \par
[- \line a \par
Fig. 8.4 Uma classe Array com sobrecarga de operadores - figO8O4 . cpp (parte 2 de 3). \par
\pard\par
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2725\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx3085\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx3421\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx3757\pard\intbl N\'b0 de arrays instanciados \cell O \cell\cell\cell\row
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx3085\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx3421\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx3757\pard\intbl N\'b0 de arrays instanciados = 2 \cell\cell\cell\row
\intbl Tamanho do array integersi \'e9 7 \cell\cell\cell\row
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2725\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx3085\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx3421\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx3757\pard\intbl Array ap\'f3s inicializa\'e7\'e3o: \cell\cell\cell\cell\row
\intbl o o \cell\cell o \cell o \cell\row
\intbl o o \cell\cell o \cell\cell\row
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx3085\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx3421\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx3757\pard\intbl Tamanho do array integers2 \'e9 10 \cell\cell\cell\row
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2725\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx3085\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx3421\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx3757\pard\intbl Array ap\'f3s inicializa\'e7\'e3o: \cell\cell\cell\cell\row
\intbl o o \cell\cell o \cell o \cell\row
\intbl o o \cell\cell o \cell o \cell\row
\intbl o o \cell\cell\cell\cell\row
\pard\par
\pard\sb100\sa240 530 c++ COMO PROGRAMAR \par
Digite 17 inteiros: \line 1234567891011121314151617 \line Ap\'f3s entrada, os arrays cont\'eam: \line integersl: \par
integers2: \par
Avaliando: integersl != integers2 Eles n\'e3o s\'e3o iguais \par
Tamanho do array integers3 \'e9 7 \line Array ap\'f3s inicializa\'e7\'e3o: \par
Atribuindo integers2 \line integersi: \par
8 \line 12 \par
16 \par
8 \par
12 \par
16 \par
Avaliando : integersl \line Eles s\'e3o iguais \par
integersl[5] \'e9 13 \line Atribuindo 1000 a integersl[5] integersi: \par
3 \line 7 \par
3 \line 7 \par
11 \line 15 \par
11 \line 15 \par
Tentativa de atribuir 1000 a integersl[15] Assertion failed: O < subscript && subscript line 132 abnormal program termination \par
< size, file Arrayl.cpp, \par
Fig. 8.4 Uma classe Array com sobrecarga de operadores - figo8_04 . cpp (parte 3 de 3). \line A vari\'e1vel de classe est\'e1tica arrayCount, da classe Array. cont\'e9m o n\'famero de objetos Array intanciados durante a execu\'e7\'e3o do programa. O programa come\'e7a usando a fun\'e7\'e3o membro est\'e1tica getArrayCount (linha 1 92) para obter o n\'famero de Arrays instanciados at\'e9 agora. Em seguida, o programa instancia dois objetos da classe Array (linha 1 95): integers 1, com sete elementos, e integers2. com tamanho default de 10 elementos (o valor default especificado pelo construtor default de Array). A linha 197 chama a fun\'e7\'e3o getArrayCount para obter novamente o valor da vari\'e1vel de classe arrayCount. As linhas 200 a 203 usam a fun\'e7\'e3o membro getSize para determinar o tamanho do Array integersi e exibir integersi usando o operador de inser\'e7\'e3o em streams sobrecarregado para Array para confirmar que os elementos do Array foram corretamente inicializados pelo construtor. Em seguida, as linhas 206 a 209 exibem o tamanho do Array integers2 e exibem integers2 usando o operador de inser\'e7\'e3o em streams sobrecarregado para Array. \par
1 \line 5 \line 8 \line 12 \line 16 \par
2 \line 6 \line 9 \line 13 \line 17 \par
4 \par
10 \line 14 \par
11 \line 15 \par
1 \line 5 \par
4 \par
integers2: \par
10 \line 14 \par
2 \line 6 \line a integersl: \line 9 \line 13 \line 17 \line 9 \line 13 \line 17 \line == integers2 \par
lo \line 14 \par
8 \line 12 \line 16 \par
9 \line 1000 \line 17 \par
10 \line 14 \par
11 \line 15 \par
CAP\'cdTULO 8 - SOBRECARGA DE OPERADORES 531 \line o usu\'e1rio \'e9 ent\'e3o solicitado a digitar 17 inteiros. O operador de extra\'e7\'e3o de streams sobrecarregado para Array \'e9 usado para ler estes valores para ambos os arrays com a linha 213 \line cm \'bb integersl \'bb integers2; \line Os primeiros sete valores s\'e3o armazenados em integersi e os 10 valores restantes s\'e3o armazenados em integers2. Nas linhas 214 a 216, os dois arrays s\'e3o exibidos com o operador de inser\'e7\'e3o em streams para Array. para confirmar que a entrada foi executada corretamente. \line A linha 220 testa o operador de desigualdade sobrecarregado, avaliando a condi\'e7\'e3o \line integersi != integers2 \line e o programa informa que os arrays realmente n\'e3o s\'e3o iguais. \line A linha 225 instancia um terceiro array, chamado de integers3, e inicializa este com oArray integersi. \line Isto invoca o construtor de c\'f3pia de Array para copiar os elementos de integersi para integers3. Discuti- remos os detalhes do construtor de c\'f3pia em breve. \line As linhas 227 a 230 exibem o tamanho de integers3 e exibem integers3 usando o operador de inser\'e7\'e3o em streams sobrecarregado para Array, para confirmar que os elementos do array foram corretamente inicializados pelo construtor. \line Em seguida, a linha 234 testa o operador de atribui\'e7\'e3o sobrecarregado (=) com o comando \line integersi = integers2; \line Ambos os arrays s\'e3o impressos nas linhas 235 e 236 para confirmar que a atribui\'e7\'e3o foi bem-sucedida. Observe que integersi originalmente guardava 7 inteiros e precisou ser redimensionado para manter uma c\'f3pia dos 10 ele- mentos em integers2. Como veremos, o operador de atribui\'e7\'e3o sobrecarregado faz isto redimensionando o tamanho de um modo transparente para o invocador do operador. \line Em seguida, a linha 240 usa o operador de igualdade sobrecarregado (==) para confirmar que os objetos \line integersi e integers2 est\'e3o realmente id\'eanticos depois da atribui\'e7\'e3o. \line A linha 244 usa o operador subscrito sobrecarregado para referenciar integersi [ 5 ] - um elemento no intervalo v\'e1lido de integersi. Este nome com subscrito \'e9 usado como um rvalue para imprimir o valor em integersi [ 5 ] . A linha 248 usa integersi [ 5 ] como um ivalue no lado esquerdo de um comando de atribui\'e7\'e3o, para atribuir um novo valor, 1000. ao elemento 5 de integersi. Note que o operator [1 retorna a refer\'eancia para usar como o Ivalue depois dele determinar que 5 est\'e1 no intervalo v\'e1lido para integersi. \line A linha 253 tenta atribuir o valor 1000 a integersi [ 15 1 - um elemento fora do intervalo. O operador \line [ ] sobrecarregado para Array captura este erro e a execu\'e7\'e3o do programa termina anormalmente. \line E interessante notar que o operador de subscrito de array [ 1 n\'e3o est\'e1 restrito a ser usado somente com arrays; ele pode ser usado para selecionar elementos de outros tipos de classes cont\'eainer ordenadas, tais como listas encadeadas, strings, dicion\'e1rios e assim por diante. Al\'e9m disso, os subscritos tamb\'e9m n\'e3o precisam mais ser inteiros; podem ser usados caracteres, strings. floats ou at\'e9 objetos de classes definidas pelo usu\'e1rio. \line Agora que vimos como funciona este programa, iremos examinar passo a passo o cabe\'e7alho de classe e as \line defini\'e7\'f5es de fun\'e7\'f5es membro. As linhas 32 a 34 \line int size; II tamanho do array \line int *ptr; II ponteiro para o primeiro elemento do array static int arrayCount; // #de arrays intanciados \line representam os membros de dados private da classe. O array consiste em um membro size, que indica o n\'famero de elementos no array, um ponteiro int - ptr- que apontar\'e1 para o array de inteiros alocado dinamicamente armazenado em um objeto do tipo Array e o membro static arrayCount que indica o n\'famero de objetos do tipo Array que foram instanciados. \line Aslinhas l2e 13 \line friend ostream &operator\'ab( ostream &, const Array & ); \line friend istream &operator\'bb( istream &, Array & ); \par
532 C++ COMO PROGRAMAR \line declaram os operadoresde inser\'e7\'e3o em streams sobrecarregado e o operador de extra\'e7\'e3o de streams sobrecarregado \line - como friends da classe Array. Quando o compilador encontra uma express\'e3o como \line cout \'ab arrayObject \line ele invoca a fun\'e7\'e3o operator\'ab ( ostreain & , const Array & ) gerando a chamada \line operator\'ab( cout, arrayObject \line Quando o compilador encontra uma express\'e3o como \line cm \'bb arrayObject \line ele invoca a fun\'e7\'e3o operator\'bb ( istreain & , Array & ) gerando a chamada \line operator\'bb( cm, arrayObject \line Notamos novamente que estas fun\'e7\'f5es operador de inser\'e7\'e3o em streams e de extra\'e7\'e3o de streams n\'e3o podem ser membros da classe Array porque um objeto do tipo Array \'e9 sempre mencionado \'e0 direita de um operador de inser\'e7\'e3o em streams e de um operador de extra\'e7\'e3o de streams. Se estas fun\'e7\'f5es operador fossem membros da classe Array, os seguintes comandos estranhos teriam que ser usados para enviar para a sa\'edda e receber como entrada um \line Array: \line arrayObject \'ab cout; \line arrayObject \'bb cm; \line A fun\'e7\'e3o operator\'ab (definida na linha 162) imprime o n\'famero de elementos indicado pelo size do array \line armazenado em ptr. A fun\'e7\'e3o operator\'bb (definida na linha 153) fornece dados de entrada diretamente para \line o array apontado por ptr. Cada uma destas fun\'e7\'f5es operador retorna uma refer\'eancia apropriada para possibilitar \line comandos encadeados de sa\'edda ou entrada, respectivamente. \line Alinha 15 \line Array( int 10 ); II construtor default \line declara o construtor default para a classe e especifica que o tamanho default de Array \'e9 de 1 O elementos, Quando \line o compilador encontra uma declara\'e7\'e3o como \line Array integersi ( 7 ); \line ou a forma equivalente \line Array mntegersi = 7; \line ele invoca o construtor default (lembre-se de que o construtor default, neste exemplo, na verdade recebe um \'fanico argumento int, que tem um valor default de 10). O construtor default (definido na linha 58) valida e atribui o argumento ao membro de dados size, usa new para obter o espa\'e7o para manter a representa\'e7\'e3o interna deste array, atribui o ponteiro retornado por new ao membro de dados ptr, usa assert para testar se new foi bem sucedido, incrementa arrayCount e, ent\'e3o, usa um la\'e7o for para inicializar todos os elementos do array com zero. E poss\'edvel se ter uma classe Array que n\'e3o inicializa seus membros se, por exemplo, estes membros devem ser lidos em algum instante posterior. Mas isto \'e9 considerado uma pr\'e1tica ruim de programa\'e7\'e3o. Arrays e objetos em geral devem ser sempre mantidos corretamente inicializados e em um estado consistente. \line A linha 16 \line Array( const Array & ) ; II construtor de c\'f3pia \line declara um construtor de c\'f3pia (definido na linha 7 1 ) que inicializa um Array fazendo uma c\'f3pia de um objeto existente do tipo Array. Tal c\'f3pia deve ser feita cuidadosamente, para evitar a armadilha de deixar ambos os objetos de tipo Array apontando para a mesma mem\'f3ria alocada dinamicamente, exatamente o problema que aconteceria com a c\'f3pia default membro a membro. Os construtores de c\'f3pia s\'e3o invocados sempre que uma c\'f3pia de um objeto \'e9 necess\'e1ria, tal como em uma chamada por valor, ao retornar um objeto por valor de uma chamada de fun\'e7\'e3o ou ao inicializar um objeto para ser uma c\'f3pia de outro objeto da mesma classe. O construtor de c\'f3pia \'e9 \par
CAP\'cdTULO 8 - SOBRECARGA DE OPERADORES 533 \line do chamado em uma defini\'e7\'e3o quando um objeto da classe Array \'e9 instanciado e inicializado com outro objeto da classe Array, como na declara\'e7\'e3o seguinte: \line Array integers3( integersi ); \line ou a declara\'e7\'e3o equivalente \line Array integers3 integersi; \line Erro comum de programa\'e7\'e3o 8.6 \line Note que o construtor de c\'f3pia deve usar chamada por rej\'e8r\'eancia, e n\'e3o chamada por valor. Caso contra- rio, a chamada ao construtor de c\'f3pia resulta em uma recurs\'e3o infinita (um erro de l\'f3gicafatal) porque, para uma chamada por valo\'e7 deve serfeita uma c\'f3pia do objeto passado para o construtor de c\'f3pia, o que \line ;er resulta no construtor de c\'f3pia sendo chamado recursivamente! \line de \line se o construtor de c\'f3pia para Array usa um inicializador de membro para copiar o size do array usado para m inicializa\'e7\'e3o para o membro de dados size, usa new para obter o espa\'e7o para manter a representa\'e7\'e3o interna deste \line array, atribui o ponteiro retornado por new ao membro de dados ptr, usa assert para testar se new foi bem- sucedido, incrementa arrayCount e, ent\'e3o, usa um la\'e7o for para copiar todos os elementos do array inicializador para este array. \line ay Erro comum de programa\'e7\'e3o 8.7 \line ia Se o construtor de c\'f3pia simplesmente copiasse o ponteiro no objeto de origem para o ponteiro no objeto ar de destino, ent\'e3o ambos os objetos apontariam para a mesma mem\'f3ria alocada dinamicamente. O primeiro destruidor a ser executado iria, ent\'e3o, apagar a mem\'f3ria alocada dinamicamente e o ptr do outro objeto ficaria indefinido, uma situa\'e7\'e3o chamada de \ldblquote ponteiro indefinido \ldblquote , que provavelmente resultaria em um erro s\'e9rio durante a execu\'e7\'e3o. \line Observa\'e7\'e3o de engenharia de software 8.4 \line ______ Um construtor um destruidor um operador de atribui\'e7\'e3o sobrecarregado e um construtor de c\'f3pia s\'e3o normalmentefornecidos como um grupopara qualquer classe que usa mem\'f3ria alocada dinamicamente. \line A linha 17 \line\lquote Array() ; II destruidor \line o declara o destruidor (definido na linha 82) para a classe. O destruidor \'e9 invocado quando a vida de um objeto da y, classe Array termina. O destruidor usa delete [ 1 para recuperar a mem\'f3ria alocada dinamicamente por new no \line o, construtor e ent\'e3o decrementa arrayCount. \line\'c9 Alinhal8 \line )s \line ai int getSize() const; /1 retorna size \line declara uma fun\'e7\'e3o que l\'ea o tamanho do array. \line Alinha 19 \line const Array &operator= ( const Array & ) ; II atribui arrays \line e declara a fun\'e7\'e3o operador de atribui\'e7\'e3o sobrecarregado para a classe. Quando o compilador encontra uma express\'e3o \line La como \line [e \line\'e9 integersi = integers2; \par
534 c++ CoMo PROGRAMAR \line ele invoca a fun\'e7\'e3o operator= gerando a chamada \line integersl.operator=( integers2 \line A fun\'e7\'e3o membro operator= (definida na linha 93) testa a auto-atribui\'e7\'e3o. Se uma auto-atribui\'e7\'e3o est\'e1 sendo tentada, a atribui\'e7\'e3o \'e9 saltada i.e., o objetoj\'e1 \'e9 ele mesmo; em seguida, veremos por que a auto-atribui\'e7\'e3o \'e9 perigosa). Se n\'e3o \'e9 uma auto-atribui\'e7\'e3o, ent\'e3o a fun\'e7\'e3o membro determina se os tamanhos dos dois arrays s\'e3o id\'eanticos - caso em que o array de inteiros original, \'e0 esquerda do objeto Array, n\'e3o \'e9 realocado. Caso contr\'e1rio, usa o operador delete para recuperar o espa\'e7o originalmente alocado para o array de destino, copia size do array de origem para size do array de destino, usa new para alocar aquela quantidade de espa\'e7o para o array de destino, coloca o ponteiro retornado por new no membro ptr do array e usa as sert para verificar se new teve sucesso. Ent\'e3o, operator= usa um la\'e7o for para copiar os elementos de array do array de origem para o array de destino. N\'e3o importando se esta \'e9 uma auto- atribui\'e7\'e3o ou n\'e3o, a fun\'e7\'e3o membro ent\'e3o retorna o objeto corrente (i.e., *this) como uma refer\'eancia constante; isto possibilita atribui\'e7\'f5es encadeadas de Array, tais como x = y = z. \line Erro comum de programa\'e7\'e3o 8.8 \line N\'e3ofornecer um operador de atribui\'e7\'e3o sobrecarregado e um construtor de c\'f3pia para uma classe, quando objetos daquela classe cont\'eam ponteiros para mem\'f3ria alocada dinamicamente, \'e9 um erro de l\'f3gica. \line Observa\'e7\'e3o de engenharia de software 8.5 \line _______ \'c9 poss\'edvel se evitar que um objeto de uma classe seja atribu\'eddo a outro. Isto \'e9 feito declarando-se o operador de atribui\'e7\'e3o como um membro private da classe. \line Observa\'e7\'e3o de engenharia de software 8.6 \line\'c9poss\'edvel se evitar que objetos de classes sejam copiados; parafazer isto, simplesmente torne private \line tanto o operador de atribui\'e7\'e3o sobrecarregado como o construtor de c\'f3pia. \line A linha 20 \line bool operator == ( const Array & ) const; II testa igualdade \line declara o operador de igualdade sobrecarregado (==) para a classe. Quando o compilador encontra a express\'e3o \line integersl == integers2 \line em main, o compilador invoca a fun\'e7\'e3o membro operator== gerando a chamada \line integersl.operator= ( integers2 \line A fun\'e7\'e3o membro operator== (definida na linha 1 15) retorna imediatamente false se os membros size dos \line arrays s\'e3o diferentes. Caso contr\'e1rio, a fun\'e7\'e3o membro compara cada par de elementos. Se eles forem todos iguais, \line\'e9 retomado true. O primeiro par de elementos a diferir faz com que false seja imediatamente retornado. As linhas 24 e 25 \line bool operator!=( const Array &right ) const \line\{ return ( *this == right ) ; \} \line definem o operador de desigualdade sobrecarregado ( ! =) para a classe. A fun\'e7\'e3o membro operator ! = \'e9 definida em termos do operador de igualdade sobrecarregado. A defini\'e7\'e3o da fun\'e7\'e3o usa a fun\'e7\'e3o sobrecarregada operator== para determinar se um Array \'e9 igual a outro e, ent\'e3o, retorna o oposto daquele resultado. Escrever a fun\'e7\'e3o operator ! desta maneira possibilita ao programador reutilizar a fun\'e7\'e3o operator== e reduz a quantidade de c\'f3digo que deve ser escrito para a classe. Note, tamb\'e9m, que a defini\'e7\'e3o completa da fun\'e7\'e3o para operator ! = \par
CAP\'cdTULO 8 - SOBRECARGA DE OPERADORES 535 \line est\'e1 no arquivo de cabe\'e7alho de Array. Isto permite que o compilador coloque mime a defini\'e7\'e3o de operator para eliminar o overhead da chamada de fun\'e7\'e3o extra. \line As linhas 27 e 28 \line int &operator[] ( int ) ; // operador subscrito \line const int &operator[) ( int ) const; // operador subscrito \line declaram dois operadores subscritos sobrecarregados (definidos nas linhas 129 e 139, respectivamente) para a classe. Quando o compilador encontra a express\'e3o \line integersl[ 5 1 \line em main. o compilador invoca a fun\'e7\'e3o membro sobrecarregada operator [ ) apropriada, gerando a chamada integersl.operator[] ( 5 \line o compilador cria uma chamada para a vers\'e3o const de operator [ ] quando o operador subscrito \'e9 usado sobre um objeto Array const. Por exemplo, se o objeto const z \'e9 instanciado com o comando \line const Array z ( 5 ); \line ent\'e3o uma vers\'e3o const de operator [ 1 \'e9 requerida quando um comando tal como \line cout \'ab z[ 3 ] \'ab endi; \line\'e9 executado. Um objeto const pode ter somente suas fun\'e7\'f5es membro const chamadas. \line Cada detini\'e7\'e3o do operator [ 1 testa se o subscrito est\'e1 no intervalo v\'e1lido e, se n\'e3o estiver, o programa termina anormalmente. Se o subscrito estiver no intervalo v\'e1lido, o elemento apropriado do array \'e9 retornado como uma refer\'eancia, de forma que ele possa ser usado como um Ivalue (por exemplo, \'e0 esquerda de um comando de atribui\'e7\'e3o) no caso da vers\'e3o n\'e3o-const de operator [ 1 , ou um rvalue no caso da vers\'e3o const de operator [1. \line A linha 29 \line static int getArrayCount() ; // Retorna quantidade de \line II arrays instanciados. \line declara a fun\'e7\'e3o est\'e1tica getArrayCount. que retorna o valor do membro de dados est\'e1tico arrayCount, ainda que n\'e3o exista nenhum objeto da classe Array. \line 8.9 Convertendo entre tipos \line A maioria dos programas processa informa\'e7\'f5es de diversos tipos. \'c0s vezes, todas as opera\'e7\'f5es \ldblquote se limitam a um tipo\rdblquote . Por exemplo, somar um inteiro a um inteiro produz um inteiro (desde que o resultado n\'e3o seja muito grande para ser representado como um inteiro). Mas, freq\'fcentemente, \'e9 necess\'e1rio converter dados de um tipo em dados de outro tipo. Isto pode acontecer em atribui\'e7\'f5es, em c\'e1lculos, na passagem de valores a fun\'e7\'f5es e no retorno de valores de fun\'e7\'f5es. O compilador sabe como executar convers\'f5es de certos tipos primitivos. Os programadores podem for\'e7ar convers\'f5es entre tipos primitivos por coer\'e7\'e3o. \line Mas e os tipos definidos pelo usu\'e1rio? O compilador n\'e3o pode saber como fazer a convers\'e3o entre tipos defini- dos pelo usu\'e1rio e tipos primitivos. O programador deve especificar como tais convers\'f5es devem ser feitas. Tais convers\'f5es podem ser executadas cum construtores de convers\'e3o - construtores de um \'fanico argumento que convertem objetos de outros tipos (inclusive tipos primitivos) para objetos de uma classe particular. Usaremos um construtor de convers\'e3o mais tarde, neste cap\'edtulo, para converter strings de char* comuns em objetos da classe String. \line Um operador de convers\'e3o (tamb\'e9m chamado de operador de coer\'e7\'e3o) pode ser usado para converter um \line objeto de uma classe em um objeto de outra classe ou em um objeto de um tipo primitivo. Tal operador de \par
536 c++ COMO PROGRAMAR \line convers\'e3o deve ser uma fun\'e7\'e3o membro n\'e3o-est\'e1tica; este tipo de operador de convers\'e3o n\'e3o pode ser uma fun\'e7\'e3o friend, \line o prot\'f3tipo de fun\'e7\'e3o \line A: :operator char *0 const; \line declara uma fun\'e7\'e3o operador de coer\'e7\'e3o sobrecarregado para criar um objeto do tipo char* tempor\'e1rio, a partir de um objeto de um tipo A, definido pelo usu\'e1rio. Umafun\'e7\'e3o operador de coer\'e7\'e3o sobrecarregada n\'e3o especifica um tipo de retorno - o tipo de retomo \'e9 o tipo para o qual o objeto est\'e1 sendo convertido. Se s um objeto da classe, quando o compilador encontra a express\'e3o (char * ) s o compilador gera a chamada s . operator char * o. \line o operando s \'e9 o objeto da classe s para o qual a fun\'e7\'e3o membro operator char* est\'e1 sendo invocada. As fun\'e7\'f5es operador de coer\'e7\'e3o sobrecarregados podem ser definidas para converter objetos de tipos definidos pelo usu\'e1rio para tipos primitivos ou para objetos de outros tipos definidos pelo usu\'e1rio. Os prot\'f3tipos \line A: :operator int() const; \line A: :operator otherClass() const; \line declaram fun\'e7\'f5es operadores de coer\'e7\'e3o sobrecarregados para converter um objeto de tipo A definido pelo usu\'e1rio em um inteiro e para converter um objeto de tipo A definido pelo usu\'e1rio para um objeto do tipo definido pelo usu\'e1rio otherClass. \line Uma das caracter\'edsticas agrad\'e1veis dos operadores de coer\'e7\'e3o e construtores de convers\'e3o \'e9 que, quando necess\'e1rio, o compilador pode chamar estas fun\'e7\'f5es para criar objetos tempor\'e1rios. Por exemplo, se um objeto s de uma classe String definida pelo usu\'e1rio aparece em um programa em uma posi\'e7\'e3o onde um char * comum \'e9 esperado, tal como \line cout \'ab s; \line o compilador chama a fun\'e7\'e3o operador de coer\'e7\'e3o sobrecarregado operator char * para converter o objeto em um char * e usa o char resultante na express\'e3o. Com este operador de coer\'e7\'e3o fornecido para nossa classe String, o operador de inser\'e7\'e3o em streams n\'e3o precisa ser sobrecarregado para enviar um String para a sa\'edda usando cout. \line 8.10 Estudo de caso: uma classe string \line Como um exerc\'edcio de coroamento de nosso estudo de sobrecarga, construiremos uma classe que processa a cria\'e7\'e3o e manipula\'e7\'e3o de strings (Fig. 8.5). A classe string agora \'e9 parte das bibliotecas padr\'e3o de C++ - estudamos a classe string em detalhes no Cap\'edtulo 19. No momento, faremos uso extenso da sobrecarga de operadores para elaborar nossa pr\'f3pria classe String. \line Primeiro, apresentamos o cabe\'e7alho para a classe String. Discutimos os dados privados usados para representar objetos de String. Ent\'e3o, percorremos passo a passo a interface p\'fablica da classe, discutindo cada um dos servi\'e7os que a classe oferece. Em seguida, percorreremos passo a passo o programa de teste em main. Discutiremos o estilo de codifica\'e7\'e3o que \ldblquote desejamos\rdblquote , i.e., os tipos de express\'f5es concisas, com muitos operadores, que gostar\'edamos de ser capazes de escrever para objetos de nossa nova classe String e com a cole\'e7\'e3o de operadores sobrecarrega- dos da classe. \line Ent\'e3o, discutimos as defini\'e7\'f5es das fun\'e7\'f5es membro para a classe String. Para cada um dos operadores \line sobrecarregados, mostramos o c\'f3digo no programa de teste que invoca a fun\'e7\'e3o operador sobrecarregado e inclu\'edmos uma explica\'e7\'e3o sobre como funciona a fun\'e7\'e3o operador sobrecarregado. \line 1 II Fig. 8.5: stringl.h \line 2 II Defini\'e7\'e3o de urna classe String \line 3 #ifndef STRING1H \line 4 #define STRING1H \line Fig. 8.5 Uma classe String com sobrecarga de operadores - stringl .h (parte 1 de 2). \par
CAP\'cdTULO 8 - SOBRECARGA DE OPERADORES 537 \par
6 #include <iostream> \line 8 using std: :ostream; \line 9 using std::istream; \par
lo \line 11 \line 12 \line 13 \line 14 \par
24 \line 25 \line 26 \line 27 \line 28 \line 29 \line 30 \line 31 \line 32 \line 33 \line 34 \line 35 \line 36 \line 37 \line 38 \line 39 \line 40 \line 41 \line 42 \line 43 \line 44 \line 45 \line 46 \line 47 \line 48 \line 49 \line 50 \line 51 \line 52 \line 53 \par
int length; char *sptr; \par
atribui\'e7\'e3o \line concatena\'e7\'e3o \line o String est\'e1 vazio? testa se sl == s2 testa se sl < s2 \par
o \par
Fig. 8.5 Uma classe String com sobrecarga de operadores - stringl . h (parte 2 de 2). \line 54 \line 55 \line 56 \line 57 \par
5 \par
7 \par
class String \{ \line friend ostream &operator\'ab( ostream &, const String & ); friend istream &operator\'bb( istream &, String & ); \line 15 public: \line 16 String( const char * \ldblquote  ) ; // construtor de convers\'e3o/default \line 17 String( const String & ) ; II construtor de c\'f3pia \line 18 String() ; II destruidor \line 19 const String &operator=( const String & ); II \line 20 const String &operator+=( const String & ); II \line 21 bool operator! O const; II \line 22 bool operator==( const String & ) const; // \line 23 bool operator<( const String & ) const; II \par
II testa se si != s2 \line bool operator\rquote =( const String & right ) const ( return ! ( *this == right ) ; \} \line II testa se si > s2 \line bool operator>( const String &right ) const \{ return right < *this; \line II testa se si <= s2 \line bool operator<=( const String &right ) const ( return ! ( right < *this ) ; ) \line II testa se si > s2 \line bool operator>=( const String &right ) const \{ return ( *this < right ) ; \} \par
char &operator[] ( int ); \line const char &operator[] ( int ) const; String operator() ( int, int ); int getLength() const; \line private: \par
z \line o \par
II operador de subscrito \line II operador de subscrito \line II retorna um substring \line II retorna o tamanho do string \line II tamanho do string \line II ponteiro para o in\'edcio do string \par
void setString( const char * ); // fun\'e7\'e3o utilit\'e1ria #endif \par
II Fig. 8.5: stringi.cpp \line II Defini\'e7\'f5es de fun\'e7\'f5es membro para a classe String #include <iostream> \par
Fig.8.5 Uma classe String com sobrecarga de operadores - stringi . cpp (parte 1 de 4). \par
1 \par
538 c++ COMO PROGRAMAR \par
58 \line 59 \line 60 \line 61 \line 62 \line 63 \line 64 \line 65 \line 66 \line 67 \line 68 \line 69 \line 70 \line 71 \line 72 \line 73 \line 74 \line 75 \line 76 \line 77 \line 78 \line 79 \line 80 \line 81 \line 82 \line 83 \line 84 \line 85 \line 86 \line 87 \line 88 \line 89 \line 90 \line 91 \line 92 \line 93 \line 94 \line 95 \line 96 \line 97 \line 98 \line 99 \line 100 \line 101 \line 102 \line 103 \line 104 \line 105 \line 106 \line 107 \line 108 \line 109 \line 110 \line 111 \line 112 \line 113 \line 114 \line 115 \par
using std::cout; using std::endl; \line #include <iomanip> \line using std::setw; \line #include <cstring> #include <cassert> #include \ldblquote stringl .h\rdblquote  \par
\} \par
II Destruidor String: :-String() \par
\{ \line\} \par
cout \'ab \ldblquote operator= chamado\\n\rdblquote ; \line if ( &right != this ) delete [1 sPtr; \line else \par
II evita auto-atribui\'e7\'e3o \line II previne perda de mem\'f3ria \line II novo tamanho do String \line II chama fun\'e7\'e3o utilit\'e1ria \line guarda, para poder deletar novo tamanho do String cria espa\'e7o \line termina se a mem\'f3ria n\'e3o foi alocada parte esquerda do novo String parte direita do novo String \par
II Construtor de convers\'e3o: converte char * para String String::String( const char * ) : length( strlen( s ) \line cout \'ab \lquote Construtor de convers\'e3o: \'ab s \'ab \lquote\\n\rquote ; \line setString( s ); /1 chama fun\'e7\'e3o utilit\'e1ria \line II Construtor de c\'f3pia \line String: :String( const String &copy ) : length( copy.length \line cout \'ab \ldblquote Construtor de c\'f3pia: \lquote  \'ab copy.sPtr \'ab \\n\rquote ; setString( copy.sPtr ); /1 chama fun\'e7\'e3o utilit\'e1ria \par
cout \'ab \ldblquote Destruidor: \ldblquote  \'ab sPtr \'ab \lquote\\n\rquote ; \line delete [J sPtr; // recupera string \line II Operador = sobrecarregado; evita auto-atribui\'e7\'e3o const String &String::operator=( const String &right \par
length = right.length; setString( right.sPtr ); \par
cout \'ab \ldblquote Tentou atribuir um String a si mesmo\\n\rdblquote ; return *this; II possibilita atribui\'e7\'f5es encadeadas \line II Concatena operando \'e0 direita a este objeto \line II e armazena neste objeto. \line const String &String::operator+=( const String &right \par
char *tempptr = sPtr; length += right.length; sPtr = new char[ length + 1 assert( sPtr != O ); strcpy( sPtr, tempPtr ); strcat( sPtr, right.sPtr ); \par
:1; \par
II \line II \line II \line II \line II \line II \par
Fig. 8.5 Uma classe string com sobrecarga de operadores - stringl . cpp (parte 2 de 4). \par
CAP\'cdTULO 8 - SOBRECARGA DE OPERADORES 539 \line 116 delete [1 tempPtr; II recupera espa\'e7o antigo \line 117 return *this; II possibilita chamadas encadeadas \line 118 \line 119 \line 120 II Este String est\'e1 vazio? \line 121 bool String: :operator\rquote  () const \{ return length == O; \line 122 \line 123 II Este String \'e9 igual ao String \'e0 direita? \line 124 bool String: :operator==( const String &right ) const \line 125 \{ return strcmp( sPtr, right.sPtr ) O; \line 126 \line 127 II Este String \'e9 menor do que o String \'e0 direita? \line 128 bool String: :operator<( const String &right ) const \line 129 \{ return strcmp( sptr, right.sPtr ) < O; \line 130 \line 131 II Retorna urna refer\'eancia a um caractere em um String como um ivalue. \line 132 char &String: :operator[) ( int subscript \line 133 \line 134 II Primeiro, testa se o subscrito est\'e1 fora do intervalo v\'e1lido \line 135 assert( subscript > O && subscript < length ); \line 136 \line 137 return sPtr[ subscript J; II cria um lvalue \line 138 \} \line 139 \line 140 II Retorna uma refer\'eancia para uni caractere em um String como um rvalue. \line 141 const char &String: :operator[) ( int subscript ) const \line 142 \{ \line 143 II Primeiro, testa se o subscrito est\'e1 fora do intervalo v\'e1lido \line 144 assert( subscript >= O && subscript < length ); \line 145 \line 146 return sPtr[ subscript ]; II cria um rvalue \line 147 \} \line 148 \line 149 II Retorna um substring come\'e7ando em index \line 150 II e com tamanho subLength \line 151 String String: :operator() ( int index, int subLength \line 152 \{ \line 153 II assegura que index est\'e1 no intervalo v\'e1lido e que subLength > O \line 154 assert( index >= O && index < length && subLength > O ); \line 155 \line 156 II determina tamanho do substring \line 157 int len; \line 158 \line 159 if ( ( subLength == O ) 1 ( index + subLength > length ) \line 160 len = length - index; \line 161 else \line 162 len = subLength; \line 163 \line 164 II aloca array tempor\'e1rio para substring \line 165 II e o seu caractere de termina\'e7\'e3o nulo \line 166 char *tempPtr new char[ len + 1 ); \line 167 assert( tempPtr != O ) ; II assegura que o espa\'e7o foi alocado \line 168 \line 169 II copia substring para array char; coloca caractere terminal no string \line 170 strncpy( tempPtr, &sPtr[ index ] , len ); \line 171 tempPtr[ len ] = \line 172 \line Fig. 8.5 Uma classe String com sobrecarga de operadores - stringl . cpp (parte 3 de 4). \par
540 c++ COMO PROGRAMAR \line 173 II cria objeto String tempor\'e1rio contendo o substring \line 174 String tempString( tempPtr ); \line 175 delete [] tempPtr; /1 deleta o array tempor\'e1rio \line 176 \line 177 return tempString; II retorna c\'f3pia do String tempor\'e1rio \line 178 \line 179 \line 180 II Retorna tamanho do string \line 181 int String: :getLength() const \{ return length; \line 180 \line 183 II Fun\'e7\'e3o utilit\'e1ria para ser chamada por construtores \line 184 II e pelo operador de atribui\'e7\'e3o. \line 185 void String::setString( const char *string2 \line 186 \{ \line 187 sPtr = new char[ length + 1 1; II aloca mem\'f3ria \line 188 assert( sPtr != O ) ; 1/ termina se mem\'f3ria n\'e3o foi alocada \line 189 strcpy( sPtr, string2 ); /1 copia literal para o objeto \line 190 \} \line 191 \line 192 II Operador de sa\'edda sobrecarregado \line 193 ostream &operator\'ab( ostream &output, const String &s \line 194 \line 195 output \'ab s.sPtr; \line 196 return output; 1/ possibilita encadeamento \line 197 \} \line 198 \line 199 II Operador de entrada sobrecarregado \line 200 istream &operator\'bb( istream &input, String &s \line 201 \line 202 char temp[ 100 ]; /1 buffer para armazenar entrada \line 203 \line 204 input \'bb setw( 100 ) \'bb temp; \line 205 5 = temp; II usa o operador de atribui\'e7\'e3o da classe String \line 206 return input; /1 possibilita encadeamento \line 207 \} \line Fig. 8.5 Uma classe String com sobrecarga de operadores - stringl . cpp (parte 4 de 4). \line 208 II Fig. 8.5: figo8_05.cpp \line 209 II Programa de teste para a classe String \line 210 #include <iostream> \line 211 \line 212 using std::cout; \line 213 using std: :endl; \line 214 \line 215 #include stringl.h\rquote  \line 216 \line 217 int main() \line 218 \line 219 String sl( feliz\rdblquote  ), s2( \ldblquote  anivers\'e1rio\rquote  ), s3; \line 220 \line 221 II testa operadores sobrecarregados de igualdade e relacionais \line 222 cout \'ab \ldblquote si \'e9 \\\ldblquote\ldblquote  \'ab si \'ab \ldblquote\\\ldblquote ; s2 \'e9 \\\ldblquote  \'ab s2 \line 223 \'ab \ldblquote\\\ldblquote ; s3 \'e9 \\\ldblquote  \'ab s3 \'ab \lquote\\\ldblquote\lquote  \line 224 \'ab \ldblquote\\nOs resultados de comparar s2 e si:\rdblquote  \line Fig. 8.5 Uma classe String com sobrecarga de operadores - figOBO5 . cpp (parte 1 de 4). \par
CAP\'cdTULO 8 - SOBRECARGA DE OPERADORES 541 \line 225 \'ab \ldblquote\\ns2 == si produz \line 226 \'ab ( s2 == si ? true\rdblquote  : \ldblquote false\rdblquote  \line 227 \'ab \ldblquote\\ns2 = si produz \line 228 \'ab ( s2 ! si ? \ldblquote true\rdblquote  : \ldblquote false\rdblquote  \line 229 \'ab \ldblquote\\ns2 > si produz \line 230 \'ab ( s2 > si ? \ldblquote true\rdblquote  : \ldblquote faise\rdblquote  \line 231 \'ab \lquote\\ns2 < si produz \line 232 \'ab ( s2 < si ? \lquote true\rdblquote  : false\rdblquote  ) \line 233 \'ab \ldblquote\\ns2 >= si produz \line 234 \'ab ( s2 >= si ? true\rdblquote  : \ldblquote false\rdblquote  \line 235 \'ab \ldblquote\\ns2 < si produz \line 236 \'ab ( s2 < si ? \ldblquote true : \ldblquote faise\rdblquote  ) ; \line 237 \line 238 II testa o operador sobrecarregado String vazio () \line 239 cout \'ab \ldblquote\\n\\nTestando !s3:\\n; \line ada 240 if ( !s3 ) \{ \line 24i cout \'ab s3 \'e9 vazio; atribuindo si a s3;\\n\rdblquote ; \line 242 s3 = si; II testa atribui\'e7\'e3o sobrecarregada \line 243 cout \'ab \ldblquote 53 \'e9 \\\ldblquote\lquote  \'ab s3 \'ab \ldblquote\\\ldblquote ; \line 244 \} \line 238 \line 246 II testa operador sobrecarregado de concatena\'e7\'e3o de String \line 247 cout \'ab \ldblquote\\n\\nsi += s2 produz si = \line 248 si + s2; // testa concatena\'e7\'e3o sobrecarregada \line 249 cout \'ab si; \line 250 \line 25i // testa construtor de convers\'e3o \line 252 cout \'ab \ldblquote\\n\\nsi += \\\ldblquote  para voc\'ea\\\rdblquote  produz\\n\rdblquote ; \line 253 si += \ldblquote  para voc\'ea\rdblquote ; II testa construtor de convers\'e3o \line 254 cout \'ab \ldblquote si = \ldblquote  \'ab si \'ab \ldblquote\\n\\n\rdblquote ; \line 255 \line 256 /1 testa operador de chamada de fun\'e7\'e3o () sobrecarregado para substring \line 257 cout \'ab \ldblquote O substring de si come\'e7ando na\\n\rdblquote  \line 258 \'ab \ldblquote posi\'e7\'e3o O com 17 caracteres, si(0, i7), \'e9:\\n\rquote  \line 259 \'ab si( 0, i7 ) \'ab \ldblquote\\n\\n\rquote ; \line 260 \line 26i II testa op\'e7\'e3o de substring \lquote at\'e9 o fim do String\rdblquote  \line 262 cout \'ab \ldblquote O substring de si come\'e7ando na\\n\rdblquote  \line 263 \'ab \ldblquote posi\'e7\'e3o i8, si(i8, 0), \'e9: \line 264 \'ab si( i8, O ) \'ab \ldblquote\\n\\n\rquote ; /1 O \'e9 \ldblquote at\'e9 o fim do String\rquote  \line 265 \line 266 II testa construtor de c\'f3pia \line 267 String *s4Ptr new String( si ); \line 268 cout \'ab \ldblquote *s4ptr = \ldblquote  \'ab *s4ptr \'ab \ldblquote\\n\\n\rdblquote ; \line 269 \line 270 II testa operador de atribui\'e7\'e3o (=) com auto-atribui\'e7\'e3o \line 27i cout \'ab \ldblquote atribuindo *s4ptr a *s4Ptr\\n\rdblquote ; \line 272 *s4ptr = *s4Ptr; II testa atribui\'e7\'e3o sobrecarregada \line 273 cout \'ab \ldblquote *s4ptr \ldblquote  \'ab *s4ptr \'ab \\n\rquote ; \line 274 \line 275 /1 testa destruidor \line 276 delete s4Ptr; \line 277 \line 278 II testa uso do operador subscrito para criar ivalue \line 279 si[ O ] = \lquote E\rquote ; \line 280 si[ 6 ] = A\rquote ; \line 28i cout \'ab \ldblquote\\nsi ap\'f3s si[0] = \lquote F\rquote  e si[6] = \lquote A\rquote  \'e9: \line Fig. 8.5 Uma classe String com sobrecarga de operadores - figo8_05 . cpp (parte 2 de 4). \par
\pard\sb100\sa100 r- 54 \par
\pard\sb100\sa240 c++ COMO PROGRAMAR \line 282 \'ab si \'ab \ldblquote\\n\\n; \line 28i \line 284 II testa subscrito fora do intervalo v\'e1lido \line 285 cout \'ab \ldblquote Tentativa de atribuir \lquote d a sl[30] produz:\rdblquote  \'ab endl; \line 286 si[ 30 J = \lquote d\rquote ; 1/ ERRO: subscrito fora do intervalo v\'e1lido \line 287 \line 288 return O; \line 289 ) \line Construtor de convers\'e3o: feliz \line Construtor de convers\'e3o: anivers\'e1rio \line Construtor de convers\'e3o: \line si \'e9 \ldblquote feliz\rdblquote ; s2 \'e9 \ldblquote  anivers\'e1rio\rdblquote ; s3 \'e9 \line Os resultados de comparar s2 e si: \line s2 == sl produz false \line s2 != si produz true \line s2 > si produz false \line s2 < si produz true \line s2 >= si produz false \line s2 <= si produz true \line Testando \lquote s3: \line s3 \'e9 vazio; atribuindo si a s3; \line operator chamado \line 53 \ldblquote feliz\rdblquote  \line si += s2 produz si = feliz anivers\'e1rio \line si += \ldblquote  para voc\'ea\rdblquote  produz \line Construtor de convers\'e3o: para voc\'ea \line Destruidor: para voc\'ea \line si = feliz anivers\'e1rio para voc\'ea \line Construtor de convers\'e3o: feliz anivers\'e1rio \line Construtor de c\'f3pia: feliz anivers\'e1rio \line Destruidor: feliz anivers\'e1rio \line O substring de si come\'e7ando na \line posi\'e7\'e3o O com 17 caracteres, si(O, i7), \'e9: \line feliz anivers\'e1rio \line Destruidor: feliz anivers\'e1rio \line Construtor de convers\'e3o: para voc\'ea \line Construtor de c\'f3pia: para voc\'ea \line Destruidor: para voc\'ea \line O substring de si come\'e7ando na \line posi\'e7\'e3o 18, 51(18, O), \'e9: para voc\'ea \line Destruidor: para voc\'ea \line Construtor de c\'f3pia: feliz anivers\'e1rio para voc\'ea \line *s4ptr feliz anivers\'e1rio para voc\'ea \line atribuindo *s4ptr a *s4ptr \line operator chamado \line Tentou atribuir um String para si mesmo \line *s4ptr feliz anivers\'e1rio para voc\'ea \line Destruidor: feliz anivers\'e1rio para voc\'ea \line Fig. 8.5 Uma classe String com sobrecarga de operadores - figO8_05 . cpp (parte 3 de 4). \par
CAP\'cdTULO 8 - SOBRECARGA DE OPERADORES 543 \line si ap\'f3s sl[O] \lquote F\rquote  e si[6] = \lquote A\rquote  \'e9: Feliz Anivers\'e1rio para voc\'ea \line Tentativa de atribuir \lquote d\rquote  a sl[30] produz: \line Assertion failed: subscript > O && subscript < length, file stringl.cpp, line 135 \line bnortnal prograin termination \line Fig. 8.5 Uma classe String com sobrecarga de operadores - figO8_05 . cpp (parte 4 de 4). \line Come\'e7amos com a representa\'e7\'e3o interna de um string. As linhas 47 e 48 \line int length; // tamanho do string \line char *sptr; // ponteiro para o in\'edcio do string \line declaram os membros de dados private da classe. Nossa implementa\'e7\'e3o de um objeto do tipo String tem um campo lenght que representa o n\'famero de caracteres no string (n\'e3o incluindo o caractere nulo no fim do string de \line caracteres) e tem um ponteiro sPtr para sua mem\'f3ria alocada dinamicamente que representa o string de caracteres. Agora. percorremos o arquivo de cabe\'e7alho da classe String na Fig. 8.5. As linhas 12 e 13 \line friend ostream &operator\'ab( ostream &, const String & ) \line friend istream &operator\'bb( istreani &, String & ); \line declaram a fun\'e7\'e3o operador de inser\'e7\'e3o em streams sobrecarregado operator\'ab (definida na linha 193) e a fun\'e7\'e3o operador de extra\'e7\'e3o de streams sobrecarregado operator\'bb (definida na linha 200) como friends da classe. A implementa\'e7\'e3o destas \'e9 direta. \line A linha 16 \line String( const char * O\rdblquote  ) ; // construtor de convers\'e3o/default \line declara um construtor de convers\'e3o. Este construtor (definido na linha 70) aceita um argumento const char * (cujo default \'e9 o string vazio) e instancia um objeto de tipo String que inclui o mesmo string de caracteres. Qualquer construtor de um \'fanico argumento pode ser pensado como um construtor de convers\'e3o. Como veremos, tais construtores s\'e3o \'fateis quando estivermos fazendo qualquer opera\'e7\'e3o com String usando argumentos char \line *. o construtor de convers\'e3o converte o string de char * em um objeto do tipo String, que \'e9 ent\'e3o atribu\'eddo ao objeto do tipo String de destino. A disponibilidade deste construtor de convers\'e3o significa que n\'e3o \'e9 necess\'e1rio fornecer um operador de atribui\'e7\'e3o sobrecarregado para atribuir especificamente strings de caracteres a objetos String. O compilador invoca o construtor de convers\'e3o para criar um objeto do tipo String tempor\'e1rio, contendo o string de caracteres. Ent\'e3o, o operador de atribui\'e7\'e3o sobrecarregado \'e9 invocado para atribuir o objeto do tipo String tempor\'e1rio a outro objeto do tipo String. \line Observa\'e7\'e3o de engenharia de software 8.7 \line _______ Quando \'e9 usado um construtor de convers\'e3o para executar uma convers\'e3o impl\'edcita, C++ pode aplicar somente uma \'fanica chamada impl\'edcita de construtor para tentar atender \'e0s necessidades de um outro operador sobrecarregado. N\'e3o \'e9poss\'edvel atender \'e0s necessidades de um operador sobrecarregado executando uma s\'e9rie de convers\'f5es impl\'edcitas, definidas pelo usu\'e1rio. \line o construtor de convers\'e3o de String poderia ser invocado em uma declara\'e7\'e3o tal como String s 1 ( \ldblquote  feli \ldblquote ). o construtor de convers\'e3o calcula o comprimento do string de caracteres e o atribui ao membro de dados privado lenght, na lista de inicializadores de membro e, ent\'e3o, chama a fun\'e7\'e3o utilit\'e1ria private setString. A fun\'e7\'e3o setString (definida na linha 185) usa new para alocar uma quantidade suficiente de espa\'e7o para o membro de dados privado sPtr, usa assert para testar se new teve sucesso e, se teve, usa strcpy para copiar o string de caracteres para o objeto. \par
CAP\'cdTULO 8 - SOBRECARGA DE OPERADORES 543 \line si ap\'f3s si[O] = \lquote F\rquote  e si(6] = \lquote A\rquote  \'e9: Feliz Anivers\'e1rio para voc\'ea \line Tentativa de atribuir d\rquote  a si[30) produz: \line Assertion faiied: subscript >= O && subscript < iength, file stringi.cpp, ijne 135 \line Abnormal prograxn termination \line Fig. 8.5 Uma c\rquote asse String com sobrecarga de operadores - figO8_05 . cpp (parte 4 de 4). \line Come\'e7amos com a representa\'e7\'e3o interna de um string. As linhas 47 e 48 \line int length; II tamanho do string \line char *sptr; /1 ponteiro para o inicio do string \line declaram os membros de dados private da classe. Nossa implementa\'e7\'e3o de um objeto do tipo String tem um campo lenght que representa o n\'famero de caracteres no string (n\'e3o incluindo o caractere nulo no fim do string de caracteres) e tem um ponteiro sPtr para sua mem\'f3ria alocada dinamicamente que representa o string de caracteres. \line Agora, percorremos o arquivo de cabe\'e7alho da classe String na Fig. 8.5. As linhas 12 e 13 \line friend ostream &operator\'ab( ostream &, const String & ); \line friend istreain &operator\'bb( istream , String & ); \line declaram a fun\'e7\'e3o operador de inser\'e7\'e3o em s!reams sobrecarregado operator\'ab (definida na linha 193) e a fun\'e7\'e3o operador de extra\'e7\'e3o de streams sobrecarregado operator\'bb (definida na linha 200) como friends da classe. A implementa\'e7\'e3o destas \'e9 direta. \line A linha 16 \line String( const char * \ldblquote  ) ; // construtor de convers\'e0o/default \line declara um construtor de convers\'e3o. Este construtor (definido na linha 70) aceita um argumento const char * (cujo default \'e9 o string vazio) e instancia um objeto de tipo String que inclui o mesmo string de caracteres. Qualquer construtor de um \'fanico argumento pode ser pensado como um construtor de convers\'e3o. Como veremos, tais construtores s\'e3o \'fateis quando estivermos fazendo qualquer opera\'e7\'e3o com String usando argumentos char \line *. o construtor de convers\'e3o converte o string de char * em um objeto do tipo String, que \'e9 ent\'e3o atribu\'eddo ao objeto do tipo String de destino. A disponibilidade deste construtor de convers\'e3o significa que n\'e3o \'e9 necess\'e1rio fornecer um operador de atribui\'e7\'e3o sobrecarregado para atribuir especificamente strings de caracteres a objetos String. O compilador invoca o construtor de convers\'e3o para criar um objeto do tipo String tempor\'e1rio, contendo o string de caracteres. Ent\'e3o, o operador de atribui\'e7\'e3o sobrecarregado \'e9 invocado para atribuir o objeto do tipo String tempor\'e1rio a outro objeto do tipo String. \line Observa\'e7\'e3o de engenharia de software & 7 \line ______ Q uando \'e9 usado um construtor de convers\'e3o para executar uma convers\'e3o impl\'edcita, C-i-+ pode aplicar somente uma \'fanica chamada impl\'edcita de construtor para tentar atender \'e0s necessidades de um outro operador sobrecarregado. N\'e3o \'e9poss\'edvel atender \'e0s necessidades de um operador sobrecarregado executando uma s\'e9rie de convers\'f5es impl\'edcitas, definidas pelo usu\'e1rio. \line o construtor de convers\'e3o de String poderia ser invocado em uma declara\'e7\'e3o tal como String si ( \lquote  i\rdblquote ) o construtor de convers\'e3o calcula o comprimento do string de caracteres e o atribui ao membro de dados privado lenght, na lista de inicializadores de membro e, ent\'e3o, chama a fun\'e7\'e3o utilit\'e1ria private setString. A fun\'e7\'e3o setString (definida na linha 1 85) usa new para alocar uma quantidade suficiente de espa\'e7o para o membro de dados privado sPtr. usa assert para testar se new teve sucesso e, se teve, usa strcpy para copiar o string de caracteres para o objeto. \par
544 c++ COMO PROGRAMAR \line A linha 17 \line String( const String & ) ; /1 construtor de c\'f3pia \line\'e9 um construtor de c\'f3pia (definido na linha 77) que inicializa um objeto String fazendo uma c\'f3pia de um objei String existente. Tal c\'f3pia deve ser feita cuidadosamente, para evitar a armadilha de deixar ambos os objet String apontando para a mesma mem\'f3ria alocada dinamicamente, exatamente o problema que aconteceria com c\'f3pia default membro a membro. O construtor de c\'f3pia funciona de modo semelhante ao construtor de convers\'e3o, a n\'e3o ser pelo fato de ele simplesmente copiar o membro lenght do objeto String de origem para o objeto String de destino. Note que o construtor de c\'f3pia cria um novo espa\'e7o para o string de caracteres interno e objeto de destino. Se ele simplesmente copiasse sPtr do objeto de origem para o sPtr do objeto de destino, ent\'e3o ambos os objetos apontariam para a mesma mem\'f3ria alocada dinamicamente. O primeiro destruidor a ser executado iria, ent\'e3o, liberar a mem\'f3ria alocada dinamicamente e o sPtr do outro objeto ficaria indefinido (i.e., sPtr seria um ponteiro indefinido), uma situa\'e7\'e3o que provavelmente causaria um erro s\'e9rio durante a execu\'e7\'e3o. \line A linha 18 \line -.String() ; II destruidor \line declara o destruidor (definido na linha 84) para a classe String. O destruidor usa delete para recuperar mem\'f3ria din\'e2mica obtida por new para criar espa\'e7o para o string de caracteres. \line A linha 19 \line const String &operator( const String & ); II atribui\'e7\'e3o \line declara a fun\'e7\'e3o operador de atribui\'e7\'e3o sobrecarregado operator= (definida na linha 9 1 ). Quando o compilad \line encontra uma express\'e3o como stringl = string2, o compilador gera a chamada de fun\'e7\'e3o \line stringl.operator=( string2 ); \line A fun\'e7\'e3o operador de atribui\'e7\'e3o sobrecarregado operator= testa a auto atribui\'e7\'e3o. Se esta \'e9 uma auto-atribui\'e7\'e3o, fun\'e7\'e3o retorna, porque o objeto j\'e1 \'e9 ele pr\'f3prio. Se este teste fosse omitido, a fun\'e7\'e3o liberaria imediatamente o espa\'e7 do objeto de destino, perdendo deste modo o string de caracteres - um exemplo cl\'e1ssico de uma perda de mem\'f3ria. n\'e3o existe nenhuma auto-atribui\'e7\'e3o, a fun\'e7\'e3o libera o espa\'e7o, copia o campo lenght do objeto de origem para objeto de destino e chama setString (linha 1 85), para criar um novo espa\'e7o para o objeto de destino, determina new teve sucesso e usa strcpy para copiar o string de caracteres do objeto de origem para o objeto de destino. Qw esta seja ou n\'e3o uma auto-atribui\'e7\'e3o, *this \'e9 retornado para possibilitar atribui\'e7\'f5es encadeadas. \line A linha 20 \line const String &operator+=( const String & ); II concatena\'e7\'e3o \line declara o operador de concatena\'e7\'e3o de string sobrecarregado (definido na linha 108). Quando o compilador encoi tra a express\'e3o si += s2 em main, \'e9 gerada a chamada de fun\'e7\'e3o si . operator+= ( s2 ) . A fun\'e7\'e3o operator+ cria um ponteiro tempor\'e1rio para manter o string de caracteres do objeto corrente at\'e9 que a mem\'f3ria do string ( caracteres possa ser liberada, calcula o comprimento combinado do string concatenado, usa new para reserv espa\'e7o para o string, usa assert para testar se new teve sucesso, usa strcpy para copiar O String original para espa\'e7o rec\'e9m-alocado, usa strcat para concatenar o string de caracteres do objeto de origem ao espa\'e7o rec\'e9n alocado, usa delete para recuperar o espa\'e7o ocupado pelo string de caracteres original deste objeto e retorr \line *thjs como um String & para possibilitar o encadeamento de operadores +=. \line Precisamos de um segundo operador de concatena\'e7\'e3o sobrecarregado, para permitir a concatena\'e7\'e3o de ui String e um char *? N\'e3o. O construtor de convers\'e3o const char * converte um string convencional para ui objeto String tempor\'e1rio que, ent\'e3o, coincide com o argumento do operador de concatena\'e7\'e3o sobrecarregad existente. Uma vez mais, C++ somente pode executar tais convers\'f5es com um n\'edvel de profundidade, para facilit uma coincid\'eancia. C++ tamb\'e9m pode executar uma convers\'e3o impl\'edcita, definida pelo compilador, entre tipos primitivos antes de executar a convers\'e3o entre um tipo primitivo e uma classe. Note que, quando um objeto tempor\'e1ri do tipo String \'e9 criado, o construtor de convers\'e3o e o destruidor s\'e3o chamados (ver a sa\'edda resultante de si + \par
\pard\par
\pard\sb100\sa240 CAP\'cdTULO 8 - SOBRECARGA DE OPERADORES 545 \line para vOC\'ea\rdblquote  na Fig. 8.5). Este \'e9 um exemplo do overhead de chamada de fun\'e7\'e3o que \'e9 oculto do cliente da classe quando objetos de classes tempor\'e1rios s\'e3o criados e destru\'eddos durante convers\'f5es impl\'edcitas. Overheads semelhantes s\'e3o gerados por construtores de c\'f3pia na passagem de par\'e2metros em chamadas por valor e no retomo de objetos de classe por valor. \line Dica de desempenho 8.2 \line _____ Ter o operador de concatena\'e7\'e3o += sobrecarregado, que recebe um \'fanico argumento do tipo const char , torna a execu\'e7\'e3o mais eficiente do que ter que fazer primeiro a convers\'e3o impl\'edcita e, ent\'e3o, a \line concatena\'e7\'e3o. Convers\'f5es impl\'edcitas exigem menos c\'f3digo e causam menos erros. \line A linha 21 \line bool operator\rquote  () const; II o String est\'e1 vazio? \line declara o operador de nega\'e7\'e3o sobrecarregado (definido na linha 121). Este operador \'e9 comumente usado com as classes de strings para testar se um string \'e9 vazio. Por exemplo, quando o compilador encontra a express\'e3o ! stringi, ele gera a chamada de fun\'e7\'e3o \line stringi . operator! O \line Esta fun\'e7\'e3o simplesmente retoma o resultado de testar se iength \'e9 igual a zero. \line As linhas \line bool operator==( const String & ) const; II testa se si == s2 \line bool operator<( const String & ) const; /1 testa se si < s2 \line declaram o operador de igualdade sobrecarregado (definido na linha 124) e o operador menor do que sobrecarregado (definido na linha 128) para a classe String. Estes s\'e3o todos semelhantes, de modo que iremos discutir um exemplo, isto \'e9, sobrecarregar o operador ==. Quando o compilador encontra a express\'e3o stringi == string2, o compilador gera a chamada de fun\'e7\'e3o \line stringi.operator==( string2 \line que retoma true se stringi \'e9 igual string2. Cada um destes operadores usa strcmp para comparar os strings de caracteres nos objetos String. Note que usamos a fun\'e7\'e3o strcnip de <cstring>. Muitos programadores de C++ defendem usar algumas das fun\'e7\'f5es operador sobrecarregadas para implementar outras. Assim, os operadores ! =, >, <= e >= s\'e3o implementados (linhas 26 a 39) em termos de operator == e operator<. Por exemplo, a fun\'e7\'e3o operador sobrecarregado >= \'e9 implementada na linha 38 no arquivo de cabe\'e7alho, como segue: \line bool operator>=( const String &right ) const \line\{ return ( *this < right ); \} \line A defini\'e7\'e3o de operator>= precedente usa o operador < sobrecarregado para determinar se um objeto String \line\'e9 maior do que ou igual a outro. Note que as fun\'e7\'f5es operador para ! =, >, <= e >= s\'e3o definidas no arquivo de \line cabe\'e7alho. O compilador coloca estas defini\'e7\'f5es mime para eliminar o overhead das chamadas extras de fun\'e7\'f5es. \line Observa\'e7\'e3o de engenharia de software 8.8 \line ______ Ao implementarfun\'e7\'f5es membro usandofun\'e7\'f5es membro definidas anteriormente, o programador reutiliza c\'f3digo para reduzir a quantidade de c\'f3digo que deve ser escrito. \line As linhas 41 e 42 \line char &operator[] ( int ); II operador de subscrito \line const char &operator[) ( int ) const; II operador de subscrito \par
546 C++ COMO PROGRAMAR \par
declaram dois operadores subscrito sobrecarregados (definidos nas linhas 132 e 141) - um para Strings n\'e3o const e um para Strings const. Quando o compilador encontra uma express\'e3o como stringl [ O ], o compilador gera a chamada stringl . operator [] ( O ) (usando a vers\'e3o apropriada de operator [) baseado no fato de String ser ou n\'e3o const). A fun\'e7\'e3o operator [1 primeiro usa assert para executar uma verifica\'e7\'e3o de intervalo de validade do subscrito; se o subscrito estiver fora do intervalo, o programa imprimir\'e1 uma mensagem de erro e terminar\'e1 anormalmente. Se o subscrito estiver no intervalo v\'e1lido, a vers\'e3o n\'e3o-const de operator [] retoma um char & para o caractere apropriado do objeto String; este char & pode ser usado como um lvalue para modificar o caractere designado do objeto String. A vers\'e3o const de operator [J \line retoma const char & para o caractere apropriado do objeto String; este char & pode ser usado como um 4 rvalue para ler o valor do caractere. \line\'ae Dica de teste e depura \'e7\'e3o 8.1 \line Retornar uma refer\'eancia char de um operador subscrito sobrecarregado em uma classe String \'e9perigoso. Por exemplo, o cliente poderia usar esta refer\'eancia para inserir um nulo (\lquote  \\O \lquote )em qualquer posi\'e7\'e3o no string. \line A linha 43 \line String operator() ( int, int ); II retorna um substring \line declara o operador de chamada de fun\'e7\'e3o sobrecarregado (definido na linha 151). Em classes string, \'e9 comum sobrecarregar este operador para selecionar um substring de um String. Os dois par\'e2metros inteiros especificam a posi\'e7\'e3o de in\'edcio e o comprimento do substring sendo selecionado de String. Se a posi\'e7\'e3o de in\'edcio estiver fora do intervalo v\'e1lido ou o comprimento do substring \'e9 negativo, \'e9 gerada uma mensagem de erro. Se o comprimento do substring for O, ent\'e3o \'e9 selecionado o substring at\'e9 o fim do objeto String. Por exemplo, suponha que s tringi \'e9 um objeto String contendo o string de caracteres \lquote AEIOU\rdblquote . Quando o compilador encontra a express\'e3o stringl ( 2, 2 ), gera a chamada stringl . operator () ( 2, 2 ). Quando esta chamada \'e9 executada, ela produz e retoma um novo objeto String alocado dinamicamente, contendo o string \ldblquote 10. \line Sobrecarregar o operador de chamada de fun\'e7\'e3o \'e9 um recurso poderoso, porque as fun\'e7\'f5es podem receber listas de argumentos arbitrariamente longas e complexas. Assim, podemos usar este recurso para muitas finalidades interessantes. Um destes usos do operador de chamada de fun\'e7\'e3o \'e9 uma nota\'e7\'e3o de subscritos de array alternativa: \line em vez de usar a nota\'e7\'e3o desajeitada de C, colchetes duplos para arrays bidimensionais, tal como em a [ b ] [ c ). alguns programadores preferem sobrecarregar o operador de chamada de fun\'e7\'e3o para possibilitar a nota\'e7\'e3o a ( b, e ). O operador de chamada de fun\'e7\'e3o sobrecarregado pode ser somente uma fun\'e7\'e3o membro n\'e3o-est\'e1tica. Este operador \'e9 usado somente quando o \ldblquote nome da fun\'e7\'e3o\rdblquote  \'e9 um objeto da classe String. \line A linha 44 \line mime int getLength() const; II retorna o tamanho do string \line declara uma fun\'e7\'e3o que retorna o tamanho do String. Note que esta fun\'e7\'e3o (definida na linha 181) obt\'e9m o \line tamanho retornando o valor do membro de dados privado de String. \line Neste ponto, o leitor deveria percorrer o c\'f3digo em main, examinar a janela de sa\'edda e conferir cada uso de um operador sobrecarregado. \line 8.11 Sobrecarregando ++ e-- \line Os operadores de incremento e decremento - pr\'e9-incremento, p\'f3s-incremento, pr\'e9-decremento e p\'f3s-decremento - podem ser todos sobrecarregados. Veremos como o compilador distingue entre a vers\'e3o de prefixo e a vers\'e3o p\'f3sfixa de um operador de incremento ou decremento. \line Para sobrecarregar o operador de incremento para permitir tanto o uso como pr\'e9-incremento quanto como p\'f3s-incremento, cada fun\'e7\'e3o operador sobrecarregado deve ter uma assinatura distinta, de forma que o compilador seja capaz de determinar qual vers\'e3o de ++ \'e9 pretendida. As vers\'f5es de prefixo s\'e3o sobrecarregadas exatamente como seria qualquer outro operador de prefixo un\'e1rio. \par
CAP\'cdTULO 8 - SOORECARGA DE OPERADORES 547 \line Suponha, por exemplo, que queremos somar 1 ao dia no objeto dl do tipo Date. Quando o compilador \line encontra a express\'e3o de pr\'e9-incremento \line o compilador gera a chamada da fun\'e7\'e3o membro \line dl operator-H- () \line cujo prot\'f3tipo seria \line Date &operator++ \line Se o pr\'e9-incremento \'e9 implementado como uma fun\'e7\'e3o n\'e3o-membro, quando o compilador encontra a express\'e3o ++dl \line o compilador gera a chamada de fun\'e7\'e3o \line operator++( dl \line cujo prot\'f3tipo seria declarado na classe Date como \line friend Date &operator++ ( Date & ); \line Sobrecarregar o operador de p\'f3s-incremento apresenta um desafio um pouco maior, porque o compilador deve ser capaz de distinguir entre as assinaturas das fun\'e7\'f5es operador sobrecarregadas pr\'e9-incremento e p\'f3s-incremento. A conven\'e7\'e3o que foi adotada em C++ \'e9 que quando o compilador encontra a express\'e3o p\'f3s-incrementada \line dl++ \line ele gera a chamada de fun\'e7\'e3o membro \line dl.operator++( O \line cujo prot\'f3tipo \'e9 \line Date operator++( int \line O O \'e9 estritamente um \ldblquote valor fantasma\rdblquote  para tornar a lista de argumentos de operator++ usada para p\'f3s-incremento diferente da lista de argumentos de operator++ usada para pr\'e9-incremento. \line Se o p\'f3s-incremento \'e9 implementado como uma fun\'e7\'e3o n\'e3o-membro, quando o compilador encontra a express\'e3o \line dl ++ \line o compilador gera a chamada de fun\'e7\'e3o \line operator++( dl, O \line cujo prot\'f3tipo seria \line friend Date operator++( Date &, int ); \line Mais uma vez, o argumento O \'e9 usado pelo compilador apenas para que a lista de argumentos de operator-t-+ usada para p\'f3s-incrementar seja diferente da lista de argumentos para pr\'e9-incrementar \par
548 C\'f7\'f7 COMO PROGRAMAR \par
Tudo que foi afirmado nesta se\'e7\'e3o para sobrecarga de operadores de pr\'e9-incremento e p\'f3s-incremento se aplica \'e0 sobrecarga de operadores de pr\'e9-decremento e p\'f3s-decremento. A seguir, examinamos uma classe Date com operadores sobrecarregados de pr\'e9-incremento e p\'f3s-incremento. \line A Fig. 8.6 ilustra uma classe Date. A classe usa operadores sobrecarregados de pr\'e9-incremento e p\'f3s-incremento para somar 1 ao dia em um objeto do tipo Date, ao mesmo tempo que incrementa apropriadamente o m\'eas e o ano, se necess\'e1rio. \par
1 II Fig. 8.6: datel.h \line 2 II Defini\'e7\'e3o da classe Date \line 3 #ifndef DATE1H \line 4 #define DATE1_H \line 5 #include <iostream> \par
6 \par
7 using std::ostream; \par
8 \par
class Date \line friend ostream &operator\'ab( ostream \line public: \line Date( int m = 1, int d = 1, int y void setDate( int, int, int ); Date &operator++O; \line Date operator++ ( int ); \line const Date &operator+=( int ); bool leapYear( int ) const; \line bool endOfMonth( int ) const; \line private: \line int month; \line int day; \line int year; \par
\}; \par
static const int days[]; void helplncrementO; \par
30 #endif \par
&, const Date & ); \line = 1900 ); // construtor \line 1/ inicializa a data \line II operador de pr\'e9-incremento \line II operador de p\'f3s-incremento \line II soma dias, modifica objeto \line // este \'e9 um ano bissexto? \line II este dia \'e9 um fim de m\'eas? \line II array de dias por m\'eas // fun\'e7\'e3o utilit\'e1ria \par
47 \line 48 \line 49 \line 50 \line 51 \line 52 \line 53 \line 54 \line 55 \line 56 \line 57 \line 58 \line 59 \line 60 \line 61 \line 62 \line 63 \par
94 \par
95 \line 96 \line 97 \line 98 \line 99 \par
8.12 Estudo de caso: uma classe Date \par
Date: :D \par
42 \line 43 \line 44 \line 45 \par
// Inic \line void Da \line 46 \par
mont year \line II t if \par
d \line ei se \line d \par
II Oper Date &D \par
9 \line 10 \line 11 \line 12 \line 13 \line 14 \line 15 \line 16 \line 17 \line 18 \line 19 \line 20 \line 21 \line 22 \line 23 \line 24 \line 25 \line 26 \line 27 \line 28 \line 29 \par
heip \line re tu \par
II Oper \line II Obse \line II n\'e3o \line Date Da \par
Date heip \par
II 2 \line re tu \par
\} \par
Fig. 8.6 Date com operadores de incremento sobrecarregados - datei . h. \par
for \par
retu. \par
64 \line 65 \line 66 \line 67 \line 68 \line 69 \line 70 \line 71 \line 72 \line 73 \line 74 \line 75 \line 76 // Soma \line 77 const D \line 78 \{ \line 79 \line 80 \line 81 \line 82 \line 83 \} \line 84 \line 85 //Seo \line 86 // caso \line 87 bool Da \line 88 \{ \line 89 if( \line 90 ri \line 91 else \line 92 ri \line 93 \} \line // Dete. bool Da \line if \line ri \line 100 else \line Fig. 8.6 Date \par
Fig. 8.6 Date com operadores de incremento sobrecarregados - datei . cpp (parte 1 de 3). \par
\pard\par
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx301\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4299\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx5284\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx5789\pard\intbl 31 \cell II Fig. 8.6: datel.cpp \cell\cell\cell\row
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx301\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4299\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx5789\pard\intbl 32 \cell // Defini\'e7\'f5es de fun\'e7\'f5es membro para a \cell classe Date \cell\row
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx301\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4299\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx5284\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx5789\pard\intbl 33 \cell #include <iostream> \cell\cell\cell\row
\intbl 34 \cell #include \lquote datel.h\rdblquote  \cell\cell\cell\row
\intbl 35 \cell\cell\cell\cell\row
\intbl 36 \cell II Inicializa membro static em escopo de \cell arquivo; \cell\cell\row
\intbl 37 \cell II uma c\'f3pia com \'e2mbito em toda a classe. \cell\cell\cell\row
\intbl 38 \cell const int Date: :days[] = \{ 0, 31, 28, 31, \cell 30, 31, \cell 30, \cell\row
\intbl 39 \cell 31, 31, 30, 31, \cell 30, 31 \cell\}; \cell\row
\intbl 40 \cell\cell\cell\cell\row
\intbl 41 \cell // Construtor de Date \cell\cell\cell\row
\pard\sb100\sa240 CAP\'cdTULO 8 - SOBRECARGA DE OPERADORES 549 \line 42 Date::Date( int m, int d, int y ) \{ setDate( m, d, y ); \} \line 43 \line 44 II Inicializa a data \line 45 void Date::setDate( int mm, int dd, int yy \line 46 \line 47 month = ( mm > 1 && mm <= 12 ) ? mm : 1; \line 48 year = ( yy >= 1900 && yy <= 2100 ) ? yy : 1900; \line 49 \line 50 II testa ano bissexto \line 51 if ( month == 2 && ieapYear( year \line 52 day = ( dd >= 1 && dd <= 29 ) ? dd 1; \line 53 else \line 54 day = ( dd >= 1 && dd <= days[ month J ) ? dd : 1; \line 55 \} \line 56 \line 57 II Operador de pr\'e9-incremento sobrecarregado como fun\'e7\'e3o membro. \line 58 Date &Date::operator++() \line 59 \line 60 helplncrementO; \line 61 return *this; II retorno de refer\'eancia para criar um ivalue \line 62 \} \line 63 \line 64 II Operador de p\'f3s-incremento sobrecarregado como fun\'e7\'e3o membro. \line 65 II Observe que o par\'e2metro fantasma inteiro \line 66 II n\'e3o tem um nome de par\'e2metro. \line 67 Date Date::operator++( int \line 68 \{ \line 69 Date temp = *this; \line 70 helplncrementO; \line 71 \line 72 II retorna objeto tempor\'e1rio, n\'e3o-incrementado, salvo \line 73 return temp; II retorno de valor; n\'e3o \'e9 um retorno de refer\'eancia \line 74 \line 75 \line 76 II Soma um n\'famero espec\'edfico de dias a uma data \line 77 const Date &Date::operator+=( int additionalDays \line 78 \line 79 for ( int i = 0; i < additionalDays; i++ \line 80 helpIncrement \line 81 \line 82 return *this; II possibilita encadeamento \line 83 \line 84 \line 85 /1 Se o ano \'e9 bissexto, retorna true; \line 86 1/ caso contr\'e1rio, retorna false \line 87 bool Date::leapYear( int y ) const \line 88 \{ \line 89 if ( y % 400 == O II ( y % 100 != O && y % 4 == O \line 90 return true; 1/ ano bissexto \line 91 else \line 92 return false; 1/ ano n\'e3o-bissexto \line 93 \} \line 94 \line 95 /1 Determina se o dia \'e9 o \'faltimo do m\'eas \line 96 bool Date: :endOfMonth( int d ) const \line 97 \line 98 if ( month == 2 && leapYear( year \line 99 return d == 29; /1 \'faltimo dia de fevereiro em ano bissexto \line 100 else \line Fig. 8.6 Date com operadores de incremento sobrecarregados - datei . cpp (parte 2 de 3). \par
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx301\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4299\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx5284\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx5789\pard\intbl\cell\cell\cell\cell\row
\intbl\cell\cell\cell\cell\row
\pard\sb100\sa240 550 C++ COMO PROGRAMAR \line 101 return d == days[ month ]; \line 102 \line 103 \line 104 II Fun\'e7\'e3o para ajudar a incrementar a data \line 105 void Date: :helplncrement() t \line 106 \line 107 if ( endOfMonth( day ) && month == 12 ) \{ II fim de ano \line 108 day = 1; \line 109 month = 1; \line 110 ++year; \line 111 \line 112 else if ( endOfMonth( day ) ) \{ II fim de m\'eas \line 113 day = 1; \line 114 ++month; \line 115 \line 116 else // n\'e3o \'e9 fim de m\'eas nem fim de ano; incrementa dia \line 117 ++day; \line 118 \line 119 \line 120 // Operador de sa\'edda sobrecarregado \line 121 ostream &operator\'ab( ostream &output, const Date &d \line 122 \line 123 static char *monthName[ 13 ] = \{ \ldblquote , \ldblquote Janeiro\rdblquote , \line 124 \lquote Fevereiro\rdblquote , \lquote Mar\'e7o\rdblquote , \ldblquote Abril\rdblquote , \ldblquote Maio\rdblquote , \ldblquote Junho\rdblquote , \line 125 \ldblquote Julho\rdblquote , \lquote Agosto\rdblquote , \ldblquote Setembro\rdblquote , \ldblquote Outubro\rdblquote , \line 126 \ldblquote Novembro\rdblquote , \ldblquote Dezembro\rdblquote  ); \line 127 \line 128 output \'ab monthName[ d.month ] \'ab \line 129 \'ab d.day \'ab \ldblquote , \ldblquote  \'ab d.year; \line 130 \line 131 return output; II possibilita encadeamento \line 132 \line Fig. 8.6 Date com operadores de incremento sobrecarregados - datei . cpp (parte 3 de 3). \line A interface public de Date inclui um operador de inser\'e7\'e3o em stream sobrecarregado, um construtor default, uma fun\'e7\'e3o setDate. um operador de pr\'e9-incremento sobrecarregado, um operador de p\'f3s-incremento sobrecarregado, um operador de adi\'e7\'e3o com atribui\'e7\'e3o (+=) sobrecarregado, uma fun\'e7\'e3o para testar se o ano \'e9 bissexto e uma fun\'e7\'e3o para deteminar se um dia \'e9 o \'faftimo dia do m\'eas. \line 133 II Fig. 8.6: figO8O6.cpp \line 134 // Programa para testar a classe Date \line 135 #include <iostream> \line 136 \line 137 using std::cout; \line 138 using std: :endl; \line 139 \line 140 #include \ldblquote datei.h\rdblquote  \line 141 \line 142 int main() \line 143 \line 144 Date dl, d2( 12, 27, 1992 ), d3( 0, 99, 8045 ); \line 145 cout \'ab \ldblquote dl \'e9 \ldblquote  \'ab di \line 146 \'ab \ldblquote\\nd2 \'e9 \ldblquote  \'ab d2 \line 147 \'ab \ldblquote\\nd3 \'e9 \ldblquote  \'ab d3 \'ab \ldblquote\\n\\n\rdblquote ; \line 148 \line 149 cout \'ab \ldblquote d2 += 7 \'e9 \ldblquote  \'ab ( d2 += 7 ) \'ab \ldblquote\\n\\n\rdblquote ; \line Fig. 8.6 Date com operadores de incremento sobrecarregados - figo8 06. cpp (parte 1 de 2). \par
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx301\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4299\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx5284\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx5789\pard\intbl\cell\cell\cell\cell\row
\intbl\cell\cell\cell\cell\row
\pard\par
\pard\sb100\sa240 CAP\'cdTULO 8 - SOBRECARGA DE OPERADORES 551 \par
150 \line 151 d3.setDate( 2, 28, 1992 ); \line 152 cout \'ab \ldblquote  d3 \'e9 \ldblquote  \'ab d3; \line 153 cout \'ab \ldblquote\\n++d3 \'e9 \ldblquote  \'ab ++d3 \'ab \ldblquote\\n\\n\rdblquote ; \line 154 \line 155 Date d4( 3, 18, 1969 ); \line 156 \line 157 cout \'ab Testando o operador de pr\'e9-incremento:\\n\rdblquote  \line 158 \'ab \ldblquote  d4 \'e9 \ldblquote  \'ab d4 \'ab \lquote\\n\rquote ; \line 159 cout \'ab \ldblquote ++d4 \'e9 \ldblquote  \'ab ++d4 \'ab \lquote\\n\rquote ; \line 160 cout \'ab \ldblquote  d4 \'e9 \ldblquote  \'ab d4 \'ab \ldblquote\\n\\n\rdblquote ; \line 161 \line 162 cout \'ab \ldblquote Testando o operador de p\'f3s-incremento:\\n\rdblquote  \line 163 \ldblquote  d4 \'e9 \ldblquote  \'ab d4 \'ab \lquote\\n\rquote ; \line 164 cout \'ab \ldblquote d4++ \'e9 \ldblquote  \'ab d4++ \'ab \lquote\\n\rquote ; \line 165 cout \'ab \ldblquote  d4 \'e9 \ldblquote  \'ab d4 \'ab endi; \line 166 \line 167 return 0; \line 168 \line dl \'e9 Janeiro 1, 1900 \line d2 \'e9 Dezembro 27, 1992 \line d3 \'e9 Janeiro 1, 1900 \line d2 + 7 \'e9 Janeiro 3, 1993 \line d3 \'e9 Fevereiro 28, 1992 \line ++d3 \'e9 Fevereiro 29, 1992 \line Testando o operador de pr\'e9-incremento: \line d4 \'e9 Mar\'e7o 18, 1969 \line ++d4 \'e9 Mar\'e7o 19, 1969 \line d4 \'e9 Mar\'e7o 19, 1969 \line Testando o operador de p\'f3s-incremento: \line d4 \'e9 Mar\'e7o 19, 1969 \line d4++ \'e9 Mar\'e7o 19, 1969 \line d4 \'e9 Mar\'e7o 20, 1969 \line Fig. 8.6 Date com operadores de incremento sobrecarregados - fig08_06 . cpp (parte 2 de 2). \line O programa deteste em main cria os objetos Date dl, que \'e9 inicializado por default com 1 de janeiro de 1900, \line d2, que \'e9 inicializado com 27 de dezembro de 1992 e d3, que o programa tenta inicializar com uma data inv\'e1lida. \line O construtor de Date chama setOate para validar o m\'eas, dia e ano especificados. Se o m\'eas \'e9 inv\'e1lido, \'e9 inicializado \line com 1. Um ano inv\'e1lido \'e9 inicializado com 1900. Um dia inv\'e1lido \'e9 inicializado com 1. \line O programa de teste exibe cada um dos objetos Date constru\'eddos usando o operador de inser\'e7\'e3o em stream sobrecarregado. O operador sobrecarregado += \'e9 usado para somar 7 dias a d2. Ent\'e3o a fun\'e7\'e3o setDate \'e9 usada para inicializar d3 com 28 de fevereiro de 1992. Em seguida, um novo objeto do tipo Date, d4, \'e9 inicializado com 8 de mar\'e7o de 1969. Ent\'e3o, d4 \'e9 incrementado por 1 com o operador de pr\'e9-incremento sobrecarregado. A data \'e9 impressa antes e depois do pr\'e9-incremento, para confirmar que ele funcionou corretamente. Finalmente, d4 \'e9 incrementado com o operador de p\'f3s-incremento sobrecarregado. A data \'e9 impressa antes e depois do p\'f3s-incremento, para confirmar que ele funcionou corretamente. \line Sobrecarregar o operador de pr\'e9-incremento \'e9 simples. O operador de pr\'e9-incremento chama a fun\'e7\'e3o utilit\'e1na private helplncrement para incrementar a data. Esta fun\'e7\'e3o lida com \ldblquote voltas para o primeiro \ldblquote  ou \ldblquote vai um\rdblquote  que acontecem quando incrementamos o \'faltimo dia do m\'eas. Estes \ldblquote vai um\rdblquote  exigem incrementar o m\'eas. Se o m\'eas j\'e1 \'e9 12, ent\'e3o o ano tamb\'e9m deve ser incrementado. A fun\'e7\'e3o helplncrement usa as fun\'e7\'f5es leapYear e endOfMonth para incrementar o dia corretamente. \par
\par
552 C++ COMO PROGRAMAR \line O operador de pr\'e9-incremento sobrecarregado retoma uma refer\'eancia para o objeto de tipo Date corrente (i.e., o que acabou de ser incrementado). Isto acontece porque o objeto corrente, *thjs, \'e9 retomado como um Date &. \line Sobrecarregar o operador de p\'f3s-incremento requer um pouco mais de ast\'facia. Para emular o efeito do p\'f3s- incremento, devemos retomar uma c\'f3pia n\'e3o-incrementada do objeto Date. Na entrada para operator++, salvamos o objeto corrente (*this) em temp. Em seguida, chamamos helplncrement para incrementar o objeto Date corrente. Ent\'e3o, retomamos a c\'f3pia n\'e3o-incrementada do objeto previamente armazenado em temp. Note que esta fun\'e7\'e3o n\'e3o pode retornar uma refer\'eancia ao objeto local temp do tipo Date, porque vari\'e1veis locais s\'e3o destru\'eddas quando a fun\'e7\'e3o em que elas s\'e3o declaradas terminam. Deste modo, declarar o tipo de retorno desta fun\'e7\'e3o como Date retornaria uma refer\'eancia para um objeto que n\'e3o existe mais. Retomar uma refer\'eancia para uma vari\'e1vel local \'e9 um erro comum para o qual alguns compiladores emitem uma mensagem de advert\'eancia. \line Resumo \line\bullet  O operador \'ab \'e9 usado para m\'faltiplas finalidades em - como o operador de inser\'e7\'e3o em streams e como o operador de deslocamento \'e0 esquerda. Este \'e9 um exemplo de sobrecarga de operadores. De modo semelhante, \'bb \'e9 tamb\'e9m sobrecarregado; \'e9 usado tanto como o operador de extra\'e7\'e3o de streams e como o operador de deslocamento \'e0 direita. \line\bullet  C++ possibilita que o programador sobrecarregue a maioria dos operadores sens\'edveis ao contexto em que s\'e3o usados. O compilador gera o c\'f3digo apropriado baseado no uso do operador. \line\bullet  A sobrecarga de operadores contribui para a extensibilidade de C++. \line\bullet  Para sobrecarregar um operador, escreva uma defini\'e7\'e3o de fun\'e7\'e3o; o nome da fun\'e7\'e3o deve ser a palavra-chave operator seguida pelo s\'edmbolo do operador que est\'e1 sendo sobrecarregado. \line\bullet  Para usar um operador com objetos de classes, aquele operador deve ser sobrecarregado - com duas exce\'e7\'f5es. O operador de atribui\'e7\'e3o (=) pode ser usado com dois objetos da mesma classe para executar uma c\'f3pia default, membro a membro, sem sobrecarga. O operador de endere\'e7o (&) tamb\'e9m pode ser usado com objetos de qualquer classe sem sobrecarga; ele retoma o endere\'e7o do objeto na mem\'f3ria. \line\bullet  A sobrecarga de operadores fornece as mesmas express\'f5es concisas para tipos definidos pelo usu\'e1rio que C++ fornece com sua rica cole\'e7\'e3o de operadores que funcionam com tipos primitivos. \line\bullet  A preced\'eancia e associatividade de um operador n\'e3o podem ser mudadas com a sobrecarga. \line\bullet  N\'e3o \'e9 poss\'edvel mudar o n\'famero de operandos que um operador aceita: os operadores un\'e1rios sobrecarregados permanecem como operadores un\'e1rios; os operadores bin\'e1rios sobrecarregados permanecem como operadores bin\'e1rios, O \'fanico operador tern\'e1rio de C++, ? :, n\'e3o pode ser sobrecarregado. \line\bullet  N\'e3o \'e9 poss\'edvel criar s\'edmbolos para novos operadores; somente os operadores existentes podem ser sobrecarregados. \line\bullet  O significado de como um operador funciona com objetos de tipos primitivos n\'e3o-pode ser mudado com a sobrecarga. \line\bullet  Ao sobrecarregar o, [ ], -> ou qualquer operador de atribui\'e7\'e3o, a fun\'e7\'e3o de sobrecarga do operador dever ser declarada como um membro de classe. \line\bullet  Fun\'e7\'f5es operadores podem ser fun\'e7\'f5es membro ou fun\'e7\'f5es n\'e3o-membro. \line\bullet  Quando uma fun\'e7\'e3o de operador \'e9 implementada como uma fun\'e7\'e3o membro, o operando mais \'e0 esquerda deve ser um objeto de classe (ou uma refer\'eancia para um objeto de classe) da classe do operador. \line\bullet  Se o operando esquerdo precisa ser um objeto de uma ctasse diferente, esta fun\'e7\'e3o operador deve ser implementada como uma fun\'e7\'e3o n\'e3o-membro. \line\bullet  Fun\'e7\'f5es operador membro s\'e3o chamadas somente quando o operando esquerdo de um operador bin\'e1rio \'e9 um objeto daquela classe ou quando o \'fanico operando de um operador un\'e1rio \'e9 um objeto daquela classe. \line\bullet  Um programador poderia escolher uma fun\'e7\'e3o n\'e3o-membro para sobrecarregar um operador, a fim de possibilitar que o operador seja comutativo (i.e., dadas defini\'e7\'f5es apropriadas do operador sobrecarregado, o argumento esquerdo de um operador pode ser um objeto de outro tipo de dados). \line\bullet  Um operador un\'e1rio pode ser sobrecarregado como uma fun\'e7\'e3o membro n\'e3o-static sem argumentos ou como uma fun\'e7\'e3o n\'e3o-membro com um argumento; esse argumento deve ser ou um objeto de um tipo definido pelo usu\'e1rio ou uma refer\'eancia para um objeto de um tipo definido pelo usu\'e1rio. \par
CAP\'cdTULO 8 - SOBRECARGA DE OPERADORES 553 \par
\bullet  Um operador bin\'e1rio pode ser sobrecarregado como uma fun\'e7\'e3o membro n\'e3o-static com um argumento, ou como uma fun\'e7\'e3o n\'e3o-membro com dois argumentos (um desses argumentos deve ser ou um objeto da classe ou uma refer\'eancia para um objeto da classe). \line\bullet  O operador subscrito de array [3 n\'e3o tem seu uso restrito somente a arrays; pode ser usado para selecionar elementos de outros tipos de classes cont\'eainer ordenadas, tais como listas encadeadas, strings, dicion\'e1rios, etc. Al\'e9m disso, os subscritos n\'e3o precisam mais ser inteiros; por exemplo, podem ser usados caracteres ou strings. \line\bullet  Um construtor de c\'f3pia \'e9 usado para inicializar um objeto com outro objeto da mesma classe. Os construtores de c\'f3pia s\'e3o tamb\'e9m invocados sempre que uma c\'f3pia de um objeto \'e9 necess\'e1ria, tal como em chamadas por valor, e ao se retomar um valor de uma fun\'e7\'e3o chamada. Em um construtor de c\'f3pia, o objeto para o qual est\'e1 sendo feita a c\'f3pia deve ser passado por refer\'eancia. \line\bullet  O compilador n\'e3o sabe como fazer convers\'f5es entre tipos definidos pelo usu\'e1rio e tipos primitivos - o programador deve explicitamente especificar como devem ser feitas tais convers\'f5es. Tais convers\'f5es podem ser executadas com construtores de convers\'e3o (i.e., construtores de argumento \'fanico) que simplesmente tranformam objetos de outros tipos em objetos de uma classe particular. \line\bullet  Um operador de convers\'e3o (ou operador de coer\'e7\'e3o) pode ser usado para converter um objeto de uma classe em um objeto de outra classe ou em um objeto de um tipo primitivo. Tal operador de convers\'e3o deve ser uma fun\'e7\'e3o membro n\'e3o-stat\'ed este tipo de operador de convers\'e3o n\'e3o pode ser uma fun\'e7\'e3o friend. \line\bullet  Um construtor de convers\'e3o \'e9 um construtor de argumento \'fanico usado para converter o argumento em um objeto da classe do construtor. O compilador pode chamar tal construtor implicitamente. \line\bullet  O operador de atribui\'e7\'e3o \'e9o operador mais freq\'fcentemente sobrecarregado. Ele \'e9 normalmente usado para atribuir um objeto a outro objeto da mesma classe, mas atrav\'e9s do uso de construtores de convers\'e3o ele tamb\'e9m pode ser usado para atribui\'e7\'e3o entre classes diferentes. \line\bullet  Se um operador de atribui\'e7\'e3o sobrecarregado n\'e3o \'e9 definido, ainda assim a atribui\'e7\'e3o \'e9 permitida, mas ela se torna, por default, uma c\'f3pia membro a membro de cada membro de dados. Em alguns casos, isto \'e9 aceit\'e1vel. Para objetos que cont\'eam ponteiros para mem\'f3ria alocada dinamicamente, a c\'f3pia membro a membro resulta em dois objetos diferentes apontando para a mesma mem\'f3ria alocada dinamicamente. Quando o destruidor para qualquer um destes objetos \'e9 chamado, a mem\'f3ria alocada dinamicamente \'e9 liberada. Se o outro objeto, ent\'e3o, fizer refer\'eancia \'e0quela mem\'f3ria, o resultado \'e9 indefinido. \line\bullet  Para sobrecarregar o operador de incremento para permitir tanto o uso como pr\'e9-incremento e p\'f3s-incremento, cada fun\'e7\'e3o operador sobrecarregado deve ter uma assinatura distinta, de maneira que o compilador seja capaz de determinar qual vers\'e3o de ++ o programador deseja. As vers\'f5es de prefixo s\'e3o sobrecarregadas exatamente como qualquer outro operador de prefixo un\'e1rio. Para fornecer uma assinatura distinta para o p\'f3s-incremento, a fun\'e7\'e3o operador recebe um segundo argumento - que deve ser do tipo int. Na realidade, o usu\'e1rio n\'e3o fornece um valor para este argumento especial do tipo inteiro. Ele est\'e1 l\'e1 simplesmente para ajudar o compilador a distinguir entre as vers\'f5es prefixo e p\'f3s-fixo dos operadores de incremento e decremento. \line Terminologia \line auto-atribui\'e7\'e3o c\'f3pia default membro a membro \line classe Array fun\'e7\'e3o de convers\'e3o \line classe Date fun\'e7\'e3o operador coer\'e7\'e3o \line classe Hugelnteger fun\'e7\'e3o operador sobrecarregado friend \line classe PhoneNumber operador [3 sobrecarregado \line classe string operador chamada de fun\'e7\'e3o \line concatena\'e7\'e3o de strings operador de atribui\'e7\'e3o (=) sobrecarregado \line construtor de argumento \'fanico operador de convers\'e3o \line construtor de convers\'e3o operador sobrecarregado - \line construtor de c\'f3pia operador sobrecarregado - - \line convers\'e3o definida pelo usu\'e1rio operador sobrecarregado \line convers\'f5es de tipo de expl\'edcitas (com coer\'e7\'e3o) operador sobrecarregado + \line convers\'f5es de tipo impl\'edcitas operador sobrecarregado ++ \line convers\'f5es entre tipos de classe operador sobrecarregado += \line convers\'f5es entre tipos primitivos e classesaz operador sobrecarregado \'ab \par
cout \'ab \lquote Testando \'ab d4 \'e9 \line cout \'ab \ldblquote ++d4 \'e9 \line cout \'ab \ldblquote  d4 \'e9 \par
o operador de pr\'e9-incremento:\\n\rdblquote  \line\'ab d4 \'ab \lquote\\n\rquote ; \line\'ab ++d4 \'ab \lquote\\n\rquote ; \line\'ab d4 \'ab \ldblquote\\n\\n\rdblquote ; \par
o operador de p\'f3s-incremento:\\n\rdblquote  \line\'ab d4 \'ab \lquote\\n\rquote ; \line\'ab d4++ \'ab \lquote\\n\rquote ; \line\'ab d4 \'ab endi; \par
d2 += 7 \'e9 Janeiro 3, 1993 \par
d3 \'e9 Fevereiro 28, 1992 \line ++d3 \'e9 Fevereiro 29, 1992 \par
Testando o operador de d4 \'e9 Mar\'e7o 18, 1969 \line ++d4 \'e9 Mar\'e7o 19, 1969 d4 \'e9 Mar\'e7o 19, 1969 \par
Testando o operador de d4 \'e9 Mar\'e7o 19, 1969 \line d4++ \'e9 Mar\'e7o 19, 1969 d4 \'e9 Mar\'e7o 20, 1969 \par
pr\'e9-incremento: \par
p\'f3s-incremento: \par
Fig. 8.6 Date com operadores de incremento sobrecarregados - fig08 06. cpp (parte 2 de 2). \par
O programa de teste em main cria os objetos Date dl. que \'e9 inicializado por default com 1 de janeiro de 1900, \line d2. que \'e9 inicializado com 27 de dezembro de 1992 e d3, que o programa tenta inicial izar com uma data inv\'e1lida. \line O construtor de Date chama setDate para validar o m\'eas, dia e ano especificados. Se o m\'eas \'e9 inv\'e1lido, \'e9 inicializado \line com 1. Um ano inv\'e1lido \'e9 inicializado com 1900. Um dia inv\'e1lido \'e9 inicializado com 1. \line O programa de teste exibe cada um dos objetos Date constru\'eddos usando o operador de inser\'e7\'e3o em stream sobrecarregado. O operador sobrecarregado += \'e9 usado para somar 7 dias a d2. Ent\'e3o a fun\'e7\'e3o setDate \'e9 usada para inicializar d3 com 28 de fevereiro de 1992. Em seguida, um novo objeto do tipo Date, d4, \'e9 inicializado com 18 de mar\'e7o de 1969. Ent\'e3o, d4 \'e9 incrementado por 1 com o operador de pr\'e9-incremento sobrecarregado. A data \'e9 impressa antes e depois do pr\'e9-incremento, para confirmar que ele funcionou corretamente. Finalmente, d4 \'e9 incrementado com o operador de p\'f3s-incremento sobrecarregado. A data \'e9 impressa antes e depois do p\'f3s-incremento, para confirmar que ele funcionou corretamente. \line Sobrecarregar o operador de pr\'e9-incremento \'e9 simples. O operador de pr\'e9-incremento chama a fun\'e7\'e3o utilit\'e1ria private helplncrement para incrementar a data. Esta fun\'e7\'e3o lida com \ldblquote voltas para o primeiro \ldblquote  ou \ldblquote vai um\rdblquote  que acontecem quando incrementamos o \'faltimo dia do m\'eas. Estes \ldblquote vai um\rdblquote  exigem incrementar o m\'eas. Se o m\'eas j\'e1 \'e9 12, ent\'e3o o ano tamb\'e9m deve ser incrementado. A fun\'e7\'e3o helplncrement usa as fun\'e7\'f5es leapYear e endOfMonth para incrementar o dia corretamente. \par
d3.setDate( 2, 28, 1992 ); \line cout \'ab \ldblquote  d3 \'e9 \ldblquote  \'ab d3; \line cout \'ab \ldblquote\\n++d3 \'e9 \ldblquote  \'ab ++d3 \'ab \ldblquote\\n\\n\rdblquote ; \line 155 Date d4( 3, 18, 1969 ); \par
156 \line 157 \line 158 \line 159 \line 160 \line 161 \line 162 \line 163 \line 164 \line 165 \line 166 \line 167 \line 168 \par
cout \'ab \ldblquote Testando \'ab \ldblquote  d4 \'e9 \line cout \'ab \ldblquote d4++ \'e9 cout \'ab \ldblquote  d4 \'e9 \line return 0; \par
dl \'e9 \line d2 \'e9 \line d3 \'e9 \par
Janeiro 1, 1900 \line Dezembro 27, 1992 \line Janeiro 1, 1900 \par
\par
554 C++ COMO PROGRAMAR \line operador sobrecarregado = operator++ ( int \line operador sobrecarregado == operator+= \line operador sobrecarregado> operator< \line operador sobrecarregado >= operator\'ab \line operador sobrecarregado\'bb operator<= \line operador sobrecarregado por fun\'e7\'e3o membro operator= \line operador sobrecarregado< operator== \line operador sobrecarregado<= operator> \line operadores implementados como fun\'e7\'f5es operator>= \line operadores n\'e3o-sobrecarreg\'e1veis operator\'bb \line operadores sobrecarregados encadeados palavra-chave operator \line operadores sobrecarreg\'e1veis perda de mem\'f3ria \line operator -- ponteiro indefinido \line operator char * sobrecarga \line operator int sobrecarga de operador \line operator! sobrecarga de operador un\'e1rio p\'f3s-fixo \line operator ! = sobrecarga de operador un\'e1rio prefixo \line operator () sobrecarregando um operador bin\'e1rio \line operator [ ] sobrecarregando um operador un\'e1rio \line operator+ substring \line operator++ tipo definido pelo usu\'e1rio \line Erros comuns de programa\'e7\'e3o \line 8.1 Tentar sobrecarregar um operador n\'e3o-sobrecarreg\'e1vel \'e9 um erro de sintaxe. \line 8.2 Tentar criar novos operadores atrav\'e9s da sobrecarga de operadores \'e9 um erro de sintaxe. \line 8.3 Tentar modificar como um operador funciona com objetos de tipos primitivos \'e9 um erro de sintaxe. \line 8.4 Assumir que sobrecarregar um operador tal como + sobrecarrega operadores relacionados, tais como +=, ou que sobrecarregar == sobrecarrega um operador relacionado como ! =. Operadores podem ser sobrecarregados somente explicitamente; n\'e3o existe sobrecarga impl\'edcita. \line 8.5 Tentar mudar a aridade\rdblquote  de um operador atrav\'e9s da sobrecarga de operadores \'e9 um erro de sintaxe. \line 8.6 Note que o construtor de c\'f3pia deve usar chamada por refer\'eancia, e n\'e3o chamada por valor. Caso contr\'e1rio, a chamada ao construtor de c\'f3pia resulta em uma recurs\'e3o infinita (um erro de l\'f3gica fatal) porque, para uma chamada por valor, deve ser feita uma c\'f3pia do objeto passado para o construtor de c\'f3pia, o que resulta no construtor de c\'f3pia sendo chamado recursivamente! \line 8.7 Se o construtor de c\'f3pia simplesmente copiasse o ponteiro no objeto de origem para o ponteiro no objeto de destino, ent\'e3o ambos os objetos apontariam para a mesma mem\'f3ria alocada dinamicamente. O primeiro destruidor a ser executado iria, ent\'e3o, apagar a mem\'f3ria alocada dinamicamente e o ptr do outro objeto ficaria indefinido, uma situa\'e7\'e3o chamada de \ldblquote ponteiro indefinido\rdblquote , que provavelmente resultaria em um erro s\'e9rio durante a execu\'e7\'e3o. \line 8.8 N\'e3o fornecer um operador de atribui\'e7\'e3o sobrecarregado e um construtor de c\'f3pia a uma classe, quando objetos daquela classe cont\'eam ponteiros para mem\'f3ria alocada dinamicamente. \'e9 um erro de l\'f3gica. \line Boas pr\'e1ticas de programa\'e7\'e3o \line 8.1 Use a sobrecarga de operadores quando ela tomar um programa mais claro do que realizar as mesmas opera\'e7\'f5es com chamadas expl\'edcitas de fun\'e7\'e3o. \line 8.2 Evite o uso excessivo ou incompat\'edvel da sobrecarga de operadores, pois isto pode tornar um programa cr\'edptico e dif\'edcil de ler. \line 8.3 Sobrecarregue operadores para executar a mesma fun\'e7\'e3o ou fun\'e7\'f5es semelhantes com objetos de classes da mesma maneira como os operadores s\'e3o executados com objetos de tipos primitivos. Evite usos n\'e3o intuitivos de operadores. \line 8.4 Antes de escrever programas em C++ com operadores sobrecarregados, consulte os manuais de seu compilador para se tomar ciente de restri\'e7\'f5es e requisitos especiais aplic\'e1veis a operadores particulares. \line 8.5 Para garantir a consist\'eancia entre operadores relacionados, use um operador para implementar os outros (i.e., use um operador + sobrecarregado para implementar um operador + sobrecarregado). \line 8.6 Ao se sobrecarregar operadores un\'e1rios, \'e9 prefer\'edvel tornar as fun\'e7\'f5es operador membros da classe, em vez de fun\'e7\'f5es friend n\'e3o-membro. As fun\'e7\'f5es e classes friend devem ser evitadas, a menos que sejam absolutamente necess\'e1rias. \line O uso de friends viola o encapsulamento de uma classe. \par
\par
CAP\'cdTULO 8 - SOBRECARGA DE OPERADORES 555 \line Dicas de desempenho \line 8.1 \'c9 poss\'edvel sobrecarregar um operador como uma fun\'e7\'e3o n\'e3o-membro, n\'e3o-friend, mas se tal fun\'e7\'e3o necessita de acesso a dados private ou protected de uma classe precisaria usar fun\'e7\'f5es set ou ger fornecidas na interface public daquela classe. O overhead de chamar estas fun\'e7\'f5es pode causar um desempenho ruim, de modo que estas fun\'e7\'f5es podem ser definidas mime para melhorar o desempenho. \line 8.2 Ter o operador de concatena\'e7\'e3o += sobrecarregado, que recebe um \'fanico argumento do tipo const char \lquote , torna a execu\'e7\'e3o mais eficiente do que ter que fazer primeiro a convers\'e3o impl\'edcita e, ent\'e3o, a concatena\'e7\'e3o. Convers\'f5es impl\'edcitas exigem menos c\'f3digo e causam menos erros. \line Observa\'e7\'f5es de engenharia de software \line 8.1 A sobrecarga de operadores contribui para a extensibilidade de C++, um dos atributos mais atraentes da linguagem. \line 8.2 Pelo menos um dos argumentos de uma fun\'e7\'e3o operador deve ser um objeto de classe ou uma refer\'eancia a um objeto de classe. Isto impede que os programadores mudem a maneira como os operadores funcionam sobre tipos primitivos. \line 8.3 Novos recursos de entrada/sa\'edda para tipos definidos pelo usu\'e1rio podem ser acrescentados a C++ sem modificar as declara\'e7\'f5es ou os membros de dados private para a classe ostreani ou para a classe istreani. Este \'e9 outro exemplo de extensibilidade da linguagem de programa\'e7\'e3o C+-i-. \line 8.4 Um construtor, um destruidor, um operador de atribui\'e7\'e3o sobrecarregado e um construtor de c\'f3pia s\'e3o normalmente fornecidos como um grupo para qualquer classe que usa mem\'f3ria alocada dinamicamente. \line 8.5 \'c9 poss\'edvel se evitar que um objeto de uma classe seja atribu\'eddo a outro. Isto \'e9 feito declarando-se o operador de atribui\'e7\'e3o como um membro private da classe. \line 8.6 \'c9 poss\'edvel se evitar que objetos de classes sejam copiados; para fazer isto, simplesmente torne private tanto o operador de atribui\'e7\'e3o sobrecarregado como o construtor de c\'f3pia. \line 8.7 Quando \'e9 usado um construtor de convers\'e3o para executar uma convers\'e3o impl\'edcita, C++ pode aplicar somente uma \'fanica chamada impl\'edcita de construtor para tentar atender \'e0s necessidades de um outro operador sobrecarregado. N\'e3o \'e9 poss\'edvel atender \'e0s necessidades de um operador sobrecarregado executando urna s\'e9rie de convers\'f5es impl\'edcitas, definidas pelo usu\'e1rio. \line 8.8 Ao implementar fun\'e7\'f5es membro usando fun\'e7\'f5es membro definidas anteriormente, o programador reutiliza c\'f3digo para reduzir a quantidade de c\'f3digo que deve ser escrito. \line Dica de teste e depura \'e7\'e3o \line 8.1 Retomar uma refer\'eancia char de um operador subscrito sobrecarregado em uma classe String \'e9 perigoso. Por exemplo, o cliente poderia usar esta refer\'eancia para inserir um nulo (\lquote  \\O\rquote ) em qualquer posi\'e7\'e3o no string. \line Exerc\'edcios de auto-revis\'e3o \line 8.1 Preencha os espa\'e7os em branco em cada um dos seguintes itens: \line a) Suponha que a e b sejam vari\'e1veis do tipo inteiro e formamos a soma a + b. Agora, suponha que e e d sejam vari\'e1veis de ponto flutuante e formamos a soma a + d. Os dois operadores + aqui est\'e3o sendo claramente usados \line para finalidades diferentes. Este \'e9 um exemplo de ___________ \line b) A palavra-chave introduz uma defini\'e7\'e3o de fun\'e7\'e3o operador sobrecarregado. \line c) Para usar operadores com objetos de classes, eles devem ser sobrecarregados, com exce\'e7\'e3o dos operadores de ________ ede ________ \line d) O/A , e _______ de um operador n\'e3o podem ser mudados por sobrecarga do operador. \line 8.2 Explique os significados m\'faltiplos dos operadores \'ab e \'bb em C++. \line 8.3 Em que contexto poderia ser usado em C++ o nome operator/? \line 8.4 (Verdadeiro/Falso) Em C++, somente operadores existentes podem ser sobrecarregados. \line 8.5 Como se compara a preced\'eancia de um operador sobrecarregado em C++ com a preced\'eancia do operador original? \par
\par
\par
556 C++ COMO PROGRAMAR \line Respostas aos exerc\'edcios de auto-revis\'e3o \line 8.1 a) sobrecarga de operador. b) operator. c) atribui\'e7\'e3o (=), endere\'e7o(&). d) preced\'eancia, associatividade e \ldblquote aridade.\rdblquote  \line 8.2 O operador \'bb \'e9 tanto o operador de deslocamento \'e0 direita como o operador de extra\'e7\'e3o de streams, dependendo do seu contexto. O operador \'ab \'e9 tanto o operador de deslocamento \'e0 esquerda como o operador de inser\'e7\'e3o em streams, \line dependendo do seu contexto. \line 8.3 Para sobrecarga de operador: seria o nome de uma fun\'e7\'e3o que forneceria uma vers\'e3o sobrecarregada do operador /. \line 8.4 Verdadeiro. \line 8.5 Id\'eantica. \line Exerc\'edcios \line 8.6 D\'ea tantos exemplos quanto puder de sobrecarga impl\'edcita de operadores em C++. D\'ea um exemplo razo\'e1vel de uma \line situa\'e7\'e3o em que voc\'ea possa querer sobrecarregar explicitamente um operador em C++. \line 8.7 Os operadores em C++ que n\'e3o podem ser sobrecarregados s\'e3o .............._, , e \line 8.8 A concatena\'e7\'e3o de strings exige dois operandos - os dois strings que ser\'e3o concatenados. No texto, mostramos como implementar um operador de concatena\'e7\'e3o, sobrecarregado que concatena o segundo objeto do tipo String \'e0 direita do primeiro objeto do tipo String, modificando deste modo o primeiro objeto do tipo String. Em alguns aplica\'e7\'f5es, \'e9 desejavel produzir um objeto do tipo String concatenado, sem modificar os argumentos do tipo String. Implemente operator+ para permitir opera\'e7\'f5es tais como \line stringl = string2 + string3; \line 8.9 (O exerc\'edcio definitivo sobre sobrecarga de operadores) Para apreciar o cuidado que deveria se tomar na sele\'e7\'e3o de operadores para sobrecarga, liste cada um dos operadores sobrecarreg\'e1veis de C++ e, para cada um deles, liste um significado poss\'edvel (ou v\'e1rios, se for o caso) para cada uma das v\'e1rias classes que voc\'ea estudou neste curso. Sugerimos que voc\'ea tente com: \line a) Array \line b) Stack \line c) String \line Depois de fazer isto, comente quais os operadores que parecem ter significado para uma ampla variedade de classes. Quais operadores parecem ter pouco valor para sobrecarregar? Quais operadores parecem amb\'edguos? \line 8.10 Agora, efetue o processo descrito no problema anterior ao contr\'e1rio. Liste cada um dos operadores sobrecarreg\'e1veis de C++. Para cada um, liste o que voc\'ea sente que talvez seja a \ldblquote melhor opera\'e7\'e3o\rdblquote  que o operador deve ser usado para representar. Se existirem v\'e1rias opera\'e7\'f5es excelentes, liste todas elas. \line 8.11 (Projeto) C++ \'e9 uma linguagem em evolu\'e7\'e3o e novas linguagens est\'e3o sempre sendo desenvolvidas. Quais operadores adicionais voc\'ea recomendaria acrescentar a C++ ou a uma linguagem nova semelhante a C++, que suportaria tanto a programa\'e7\'e3o procedural como a programa\'e7\'e3o orientada a objetos ? Escreva uma justificativa cuidadosa. Voc\'ea pode considerar enviar as suas sugest\'f5es ao Comit\'ea do ANSI para C++ ou ao grupo de news comp. std. c++. \line 8.12 Um exemplo agrad\'e1vel de sobrecarga do operador chamada de fun\'e7\'e3o O \'e9 permitir a forma mais comum de array duplamente subscrito. Em vez de dizer \line tabuleiroDeXadrez[ linha )[ coluna \line para um array de objetos, sobrecarregue o operador chamada de fun\'e7\'e3o para permitir a forma alternativa \line tabuleiroDeXadrez( linha, coluna \line 8.13 Crie uma classe ArrayBidimensional que tem recursos semelhantes aos da classe Array na Fig. 8.4. Durante a \line constru\'e7\'e3o, a classe deve ser capaz de criar um array com qualquer n\'famero de linhas e qualquer n\'famero de colunas. A classe deve \line oferecer o operador () para executar opera\'e7\'f5es com subscritos duplos. Por exemplo, em um ArrayBidirnensional de 3 por \line 5 chamado a, o usu\'e1rio poderia escrever a ( 1, 3 ) para acessar o elemento na linha 1 e coluna 3. Lembre-se de que operador \line O pode receber qualquer n\'famero de argumentos (veja a classe String na Fig. 18.5 para um exemplo do operador O). A representa\'e7\'e3o subjacente do array bidimensional deve ser um array de inteiros unidimensional com um n\'famero de elementos \par
CAP\'cdTULO 8 - SOBRECARGA DE OPERADORES 557 \line igual a colunas * linhas. A fun\'e7\'e3o operator () deve executar a aritm\'e9tica de ponteiros apropriada para acessar cada elemento do array. Devem existir duas vers\'f5es do operador () - uma que retorna int &, para que um elemento de um ArrayBidimensionaJ. possa ser usado como um Ivalue, e uma que retoma const int &, para que um elemento de um const ArrayBidimensional possa ser usado como um rvalue. A classe deve tamb\'e9m fomecer os seguintes operadores: \line ==, ! =, =, \'ab(para exibir/imprimir no array em formato de linhas e colunas) e \'bb (para receber como entrada o conte\'fado de todo o array). \line 8.14 Sobrecarregue o operador subscrito para retomar o maior elemento de uma cole\'e7\'e3o, o segundo maior, o terceiro maio, etc. \line 8.15 Considere a classe Complex mostrada na Fig. 8.7. A classe possibilita opera\'e7\'f5es sobre os chamados n\'fameros complexos. Estes s\'e3o n\'fameros na forma parteReal + partelmaginaria * i, onde i tem o valor: \line a) Modifique a classe para possibilitar a entrada e sa\'edda de n\'fameros complexos atrav\'e9s dos operadores sobrecarregados \'bb e \'ab, respectivamente (voc\'ea deve remover a fun\'e7\'e3o print da classe). \line b) Sobrecarregue o operador de multiplica\'e7\'e3o para possibilitar a multiplica\'e7\'e3o de dois n\'fameros complexos. como em \'e1lgebra. \line e) Sobrecarregue os operadores == e = para permitir compara\'e7\'f5es de n\'fameros complexos. \line 1 // Fig. 8.7: complexl.h \line 2 // Defini\'e7\'e3o da classe Complex \line 3 #ifndef COMPLEX1H \line 4 #define COMPLEX1H \line 5 \line 6 class Complex \{ \line 7 public: \line 8 Complex( double = 0.0, double = 0.0 ); II construtor \line 9 Complex operator+( const Complex & ) const; II adi\'e7\'e3o \line 10 Complex operator-( const Complex & ) const; II subtra\'e7\'e3o \line 11 const Complex &operator=( const Complex & ); // atribui\'e7\'e3o \line 12 void print() const; II sa\'edda \line 13 private: \line 14 double real; II parte real \line 15 double imaginary; II parte imagin\'e1ria \line 16 \}; \line 17 \line 18 #endif \line Fig. 8.7 Uma classe de n\'fameros complexos - complexi . h. \line 19 II Fig. 8.7: complexl.cpp \line 20 II Defini\'e7\'f5es de fun\'e7\'f5es membro para a classe Complex \line 21 #include <iostream> \line 22 \line 23 using std::cout; \line 24 \line 25 #include complexl.h\rdblquote  \line 26 \line 27 /1 Construtor \line 28 Complex::Complex( double r, double i \line 29 : real( r ), imaginary( i ) \line 30 \line 31 II Operador de adi\'e7\'e3o sobrecarregado \line 32 Complex Complex: :operator+( const Complex &operand2 ) const \line 33 \{ \line Fig. 8.7 Uma classe de n\'fameros complexos - complexl .h (parte 1 de 2). \par
(par\par
\par
558 C++ COMO PROGRAMAR \par
34 \line 35 \line 36 \line 37 \line 38 \line 39 \line 40 \line 41 \line 42 \line 43 \line 44 \line 45 \line 46 \line 47 \line 48 \line 49 \line 50 \line 51 \line 52 \line 53 \line 54 \line 55 \par
return Complex( real + operand2.real, \line imaginary + operand2 imaginary ); \line II Operador de subtra\'e7\'e3o sobrecarregado \line Complex Complex: : operator- ( const Complex &operand2 ) const \line return Complex( real - operand2.real, \line imaginary - operand2 imaginary ); \line II Operador de atribui\'e7\'e3o (=) sobrecarregado \line const Complex& Complex: :operator=( const Complex &right \line real = right.real; \line imaginary = right.imaginary; \line return *this; II possibilita encadeamento \line // Exibe um objeto Complex no formato: (a, b) \line void Complex: :print() const \line cout \'ab \lquote (\lquote  \'abreal \'ab \lquote , \'abimagin\'e1ria \'ab \lquote )\lquote ; \par
4 \line 4 \par
Fig. 8.7 Uma classe de n\'fameros complexos - figo8_07 . cpp (parte 1 de 2). \par
\pard\par
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx602\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx5051\pard\intbl Fig. 8.7 \cell Uma classe de n\'fameros complexos - complexi . cpp (parte 2 de 2). \cell\row
\intbl 56 \cell II Fig. 8.7: figO8O7.cpp \cell\row
\intbl 57 \cell II Programa de teste para a classe Complex \cell\row
\intbl 58 \cell #include <iostream> \cell\row
\intbl 59 \cell\cell\row
\intbl 60 \cell using std::cout; \cell\row
\intbl 61 \cell using std: :endl; \cell\row
\intbl 62 \cell\cell\row
\intbl 63 \cell #include \ldblquote complexl.h\rdblquote  \cell\row
\intbl 64 \cell\cell\row
\intbl 65 \cell int main() \cell\row
\intbl 66 \cell ( \cell\row
\intbl 67 \cell Complex x, y( 4.3, 8.2 ), z( 3.3, 1.1 ); \cell\row
\intbl 68 \cell\cell\row
\intbl 69 \cell cout \'ab x: \cell\row
\intbl 70 \cell x.printQ; \cell\row
\intbl 71 \cell cout \'ab \lquote\\ny: \ldblquote ; \cell\row
\intbl 72 \cell y.printO; \cell\row
\intbl 73 \cell cout \'ab \ldblquote\\nz: \ldblquote ; \cell\row
\intbl 74 \cell z.print \cell\row
\intbl 75 \cell\cell\row
\intbl 76 \cell x=y+z; \cell\row
\intbl 77 \cell cout \'ab \\n\\nx = y + z:\\n\rquote ; \cell\row
\intbl 78 \cell x.printQ; \cell\row
\intbl 79 \cell cout \'ab = \cell\row
\intbl 80 \cell y.print(); \cell\row
\intbl 81 \cell cout \'ab + \cell\row
\intbl 82 \cell z.print(); \cell\row
\intbl 83 \cell\cell\row
\intbl 84 \cell x=y-z; \cell\row
\intbl 85 \cell cout \'ab \lquote\\n\\nx = y - z:\\n\rquote ; \cell\row
\pard\par
\pard\sb100\sa240\par
CAP\'cdTULO 8 - SOBRECARGA DE OPERADORES 559 \line 86 x.printO; \line 87 cout \'ab \ldblquote  = \line 88 y.print \line 89 cout \'ab - \line 90 z.printO; \line 91 cout \'ab endi; \line 92 \line 93 return 0; \line 94 ) \line x: (0, 0) \line y: (4.3, 8.2) \line z: (3.3, 1.1) \line x = y + z: \line (7.6, 9.3) = (4.3, 8.2) + (3.3, 1.1) \line x = y - z: \line (1, 7.1) (4.3, 8.2) - (3.3, 1.1) \line Fig. 8.7 Uma classe de n\'fameros complexos - fig08 07 . cpp (parte 2 de 2). \line 8.16 Uma m\'e1quina com inteiros de 32 bits pode representar ints no intervalo de aproximadamente -2 bilh\'f5es a +2 bilh\'f5es. \line Esta restri\'e7\'e3o de tamanho fixo raramente \'e9 problem\'e1tica. Mas existem aplicativos em que gostar\'edamos de ser capazes de usar \line inteiros em um intervalo muito maior. E para fazer isto que C++foi constru\'edda, ou seja, criar novos tipos de dados poderosos. \line Considere a classe Hugelnt da Fig. 8.8. Estude a classe cuidadosamente e, ent\'e3o \line a) Descreva precisamente como ela funciona. \line b) Que restri\'e7\'f5es tem a classe? \line e) Sobrecarregue o operador de multiplica\'e7\'e3o*. \line d) Sobrecarregue o operador de divis\'e3o 1. \line e) Sobrecarregue todos os operadores relacionais e de igualdade. \line 1 II Fig. 8.8: hugeintl.h \line 2 II Defini\'e7\'e3o da classe Hugelnt \line 3 #ifndef HUGEIt4T1H \line 4 #define HUGEINT1H \line 5 \line 6 #include <iostream> \line 7 \line 8 using std::ostream; \line 9 \line 10 class Hugelnt \line 11 friend ostreaxn &operator\'ab( ostream &, const Hugelnt & ); \line 12 public: \line 13 Hugelnt( long = O ); /1 construtor de convers\'e3o/default \line 14 Hugelnt( const char * ) ; II construtor de convers\'e3o \line 15 Hugelnt operator+( const Hugelnt & ); II soma outro Hugelnt \line 16 Hugelnt operator+( int ); II soma um int \line 17 Hugelnt operator+( const char * ); 1/ soma um int em um char * \line 18 private: \line 19 short integer[ 30 ]; \line 20 \line 21 \line 22 #endif \line Fig. 8.8 Uma classe de inteiros enormes - huge\'edntl . h. \par
\par
\i\f1\fs20 560 \i0 C++ CoMo \b\fs12 PROGRAMAR \line\b0\f2\fs16 23 \i\f1\fs20 /1 \i0\f2\fs16 Fig. 8.8: hugeintl.cpp \line 24 \i\f1\fs20 // \i0\f2\fs16 Defini\'e7\'f5es de fun\'e7\'f5es membro e friends para a classe Hugelnt \line 25 #inciude <cstring> \line 26 #inciude \ldblquote hugeintl.h\rdblquote  \line 27 \line 28 \i\f1\fs20 /1 \i0\f2\fs16 Construtor de convers\'e3o \line 29 Hugelnt: :Hugelnt( iong vai \line 30 \line 31 int i; \line 32 \line 33 for \i\f1\fs20 ( \i0\f2\fs16 i \f1\fs12 = \f2\fs16 0; i \b\f1\fs12 < \b0\f2\fs16 29; i++ \line 34 integer[ i \i\f1\fs20 1 \b\i0\fs12 = \b0\f2\fs16 0; \i\f1\fs20 II \i0\f2\fs16 iniciaiiza array com zero \line 35 \line 36 for \i\f1\fs20 ( \i0\f2\fs16 i \b\f1\fs12 = \b0\f2\fs16 29; vai \b\f1\fs12 1= \b0\f2\fs16 O && i \b\f1\fs12 >= \b0\f2\fs16 0; i- \line 37 integer[ i \i\f1\fs20 1 \b\i0\fs12 = \b0\f2\fs16 vai % 10; \line 38 vai \i\f1\fs20 1= \i0\f2\fs16 10; \line 39 \i\f1\fs20\} \line\i0\f2\fs16 40 \i\f1\fs20 ) \line\i0\f2\fs16 41 \line 42 Hugelnt::Hugelnt( const char *string \line 43 \i\f1\fs20\{ \line\i0\f2\fs16 44 int i, \f1\fs20 j; \line\f2\fs16 45 \line 46 for \i\f1\fs20 ( \i0\f2\fs16 i \b\f1\fs12 = \b0\f2\fs16 0; i \b\f1\fs12 < \b0\f2\fs16 29; i++ \line 47 integer[ i \i\f1\fs20 ] \b\i0\fs12 = \b0\f2\fs16 0; \line 48 \line 49 for \i\f1\fs20 ( \i0\f2\fs16 i \b\f1\fs12 = \b0\f2\fs16 30 \f1\fs8 - \f2\fs16 strien( string \i\f1\fs20 ), \i0 j \b\fs12 = \b0\f2\fs16 0; i \b\f1\fs12 <= \b0\f2\fs16 29; i++, ++ \line 50 if \i\f1\fs20 ( \i0\f2\fs16 isdigit( string[ \f1\fs20 j ] \line\f2\fs16 51 integer[ i \i\f1\fs20 ) \b\i0\fs12 = \b0\f2\fs16 string[ \f1\fs20 j ] \fs8 - \f2\fs16\lquote 0; \line 52 \line 53 \line 54 \i\f1\fs20 II \i0\f2\fs16 Adi\'e7\'e3o \line 55 Hugelnt Hugelnt: :operator+( const Hugelnt &op2 \line 56 \f1\fs20\{ \line\f2\fs16 57 Hugelnt temp; \line 58 int carry \b\f1\fs12 = \b0\f2\fs16 0; \line 59 \line 60 for \f1\fs20 ( \f2\fs16 int i 29; i \b\f1\fs12 > \b0\f2\fs16 0; i- \line 61 temp.integer[ i \f1\fs20 1 \b\fs12 = \b0\f2\fs16 integer[ i \f1\fs20 ] \f2\fs16 + \line 62 op2.integer[ i \f1\fs20 1 \f2\fs16 + carry; \line 63 \line 64 if \f1\fs20 ( \f2\fs16 temp.integer[ i \f1\fs20 ] \f2\fs16 > 9 \f1\fs20 ) \{ \line\f2\fs16 65 temp.integer[ i \f1\fs20 1 \b\fs12 % \b0\f2\fs16 iO; \line 66 carry \b\f1\fs12 = \b0\f2\fs16 1; \line 67 \f1\fs20\} \line\f2\fs16 68 eise \line 69 carry \b\f1\fs12 = \b0\f2\fs16 0; \line 70 \line 71 \line 72 return temp; \line 73 \f1\fs20\} \line\f2\fs16 74 \line 75 \i\f1\fs22 II \i0\f2\fs16 Adi\'e7\'e3o \line 76 Hugelnt Hugelnt::operator+( int op2 \line 77 \f1\fs20\{ \f2\fs16 return *this + Bugelnt( op2 ); \f1\fs20\} \line\f2\fs16 78 \line\f1\fs20 Fig. 8.8 Uma classe de inteiros enormes \fs8 - \f3\fs16 hugeinti cpp \f1\fs20 (parte 1 de 2). \f3\fs24\par
\fs14 CAP\'cdTULO \f1\fs20 8 \fs8 - \f3\fs14 SOBRECARGA DE OPERADORES \f1\fs20 561 \line\f3\fs14 79 \f1\fs20 // \f3\fs14 Adi\'e7\'e3o \line\f2\fs16 80 Hugelnt Hugelnt::operator+( const char *op2 \line 81 \f1\fs20\{ \f2\fs16 return *this + Hugelnt( op2 ); \f1\fs20\} \line\f2\fs16 82 \line 83 ostreaxn& operator\'ab( ostream &output, const Hugelnt &num \line 84 \f1\fs20\{ \line\f2\fs16 85 int i; \line 86 \line 87 for \f1\fs20 ( \f2\fs16 i \f3\fs14 = \f2\fs16 0; \f1\fs20 ( \f2\fs16 num.integer[ i \f1\fs20 ] \f3\fs14 == \f2\fs16 O \f1\fs20 ) \f3\fs14 && \f1\fs20 ( \f2\fs16 i \f3\fs14 <= \f2\fs16 29 ); i++ \line 88 ; \f1\fs20 // \f2\fs16 salta zeros iniciais (n\'e3o significativos) \line 89 \line 90 if(i==30) \line 91 output \'ab 0; \line 92 else \line 93 for \f1\fs20 ( \f3\fs14 ; i < \f2\fs16 29; i++ \line 94 output \'ab nuxn.integer[ i ); \line\f3\fs14 95 \line 96 \f2\fs16 return output; \line\ul\f3\fs14 97 \ulnone\line\f1\fs18 Fig. 8.8 Uma classe de inteiros enormes \fs8 - \f3\fs14 hugeintl \f1\fs8 . \f3\fs14 cpp \f1\fs20 (parte 2 de 2). \line\f3\fs14 98 \i\f1\fs20 II \i0\f3\fs14 Fig. 8.8: figO8O8.cpp \line\f2\fs16 99 \i\f1\fs22 1/ \i0\f2\fs16 Programa de teste para a classe Hugelnt \line 100 #include <iostream> \line\f3\fs14 101 \line\f2\fs16 102 using std: :cout; \line 103 using std::endl; \line\f3\fs14 104 \line\f2\fs16 105 #include \ldblquote hugeintl.h\rdblquote  \line 106 \line 107 int mamo \line\f3\fs14 108 \f1\fs20\{ \line\f2\fs16 109 Hugelnt ni \f1\fs20 ( \f2\fs16 7654321 \f1\fs20 ) \fs8 , \f2\fs16 n2 \f1\fs20 ( \f2\fs16 7891234 \line\f3\fs14 110 \f2\fs16 n3( \f3\fs14\ldblquote 99999999999999999999999999999\rdblquote  \f1\fs20 ), \line\f3\fs14 111 \f2\fs16 n4( \ldblquote 1\rdblquote  \f1\fs20 ), \f2\fs16 n5; \line\f3\fs14 112 \line 113 \f2\fs16 cout \'ab \ldblquote ni \'e9 \f1\fs8\ldblquote  \f3\fs14\'ab \f2\fs16 ni \'ab \ldblquote\\nn2 \'e9 \f1\fs8\ldblquote  \f3\fs14\'ab n2 \line 114 \f1\fs20\'ab \f3\fs14\ldblquote\\nn3 \'e9 \f1\fs8\ldblquote  \f3\fs14\'ab n3 \'ab \ldblquote\\nn4 \'e9 \f1\fs8\ldblquote  \f3\fs14\'ab n4 \line 115 \f1\fs20\'ab \f2\fs16\ldblquote\\nn5 \'e9 \f1\fs8\ldblquote  \f3\fs14\'ab n5 \'ab \ldblquote\\n\\n\rdblquote ; \line 116 \line\f2\fs16 117 n5n1+n2; \line\f3\fs14 118 cout \'ab nl \'ab \f1\fs8\ldblquote  \f3\fs14 + \f1\fs8\ldblquote  \f3\fs14\'ab n2 \'ab \f1\fs8\ldblquote  \ldblquote  \f3\fs14\'ab n5 \'ab \ldblquote\\n\\n\rdblquote ; \line 119 \line 120 cout \'ab n3 \'ab \f1\fs8\ldblquote  \f3\fs14 + \f1\fs8\ldblquote  \f3\fs14\'ab n4 \'ab \ldblquote\\n= \f1\fs8\ldblquote  \f3\fs14\'ab \f1\fs20 ( \f3\fs14 n3 + n4 \line 121 \'ab \ldblquote\\n\\n\rdblquote ; \line 122 \line 123 n5 = ni + 9; \line 124 cout \'ab nl \'ab \f1\fs8\ldblquote  \f3\fs14 + \f1\fs8\ldblquote  \f3\fs14\'ab 9 \'ab \f1\fs8\ldblquote  \f3\fs14 = \f1\fs8\ldblquote  \f3\fs14\'ab n5 \'ab \ldblquote\\n\\n\rdblquote ; \line 125 \line 126 n5 = n2 + \ldblquote 10000\rdblquote ; \line 127 cout \'ab n2 \'ab \f1\fs8\ldblquote  \f3\fs14 + \f1\fs8\ldblquote  \f3\fs14\'ab \ldblquote 10000\rdblquote  \'ab \f1\fs8\ldblquote  \f3\fs14 = \f1\fs8\ldblquote  \f3\fs14\'ab n5 \'ab endi; \line 128 \line\f2\fs16 129 return 0; \line\f3\fs14 130 \f1\fs20 ) \line Fig. 8.8 Uma classe de inteiros enormes \fs8 - \fs20 figo8 08 \fs8 . \fs20 cpp (parte 1 de 2). \f3\fs24\par
\pard\par
\pard\sb100\sa240\b\i\f1\fs18 562 \i0 C++ \f3\fs16 COMO \b0 PROGRAMAR \line\f2 ni \'e9 7654321 \line\f3 n2 \f2\'e9 7891234 \line\f3 n3 \'e9 99999999999999999999999999999 \line n4 \'e9 1 \line ri5 \f2\'e9 O \line\f1\fs18 7654321 \b\f3\fs16 + 7891234 \b0\f1\fs12 = \b\f3\fs16 15545555 \line 99999999999999999999999999999 + 1 \line\b0\f1\fs12 = \b\f3\fs16 100000000000000000000000000000 \line 7654321 \b0 + \b 9 \b0\f1\fs12 = \b\f3\fs16 7654330 \line 7891234 + 10000 \b0\f1\fs12 = \b\f3\fs16 7901234 \line\b0\f1\fs18 Fig. 8.8 Uma classe de inteiros enormes \fs8 - \fs18 fig08 08 cpp (parte 2 de 2). \line\f3\fs16 8.17 Crie uma classe NumeroRacional (fra\'e7\'f5es) com os seguintes recursos: \line a) Crie um construtor que impe\'e7a um O como denominador em uma fra\'e7\'e3o, reduza ou simplifique fra\'e7\'f5es que n\'e3o est\'e3o na forma reduzida e evite denominadores negativos. \line b) Sobrecarregue os operadores de adi\'e7\'e3o, subtra\'e7\'e3o, multiplica\'e7\'e3o e divis\'e3o para esta classe. \line c) Sobrecarregue os operadores relacionais e de igualdade para esta classe. \line\b\f1\fs18 8.18 \b0\f3\fs16 Estude as fun\'e7\'f5es da biblioteca C++ de manipula\'e7\'e3o de \i strings \i0 e implemente cada uma das fun\'e7\'f5es como parte da classe String. Ent\'e3o, use estas fun\'e7\'f5es para executar manipula\'e7\'f5es de texto. \line\b 8.19 \b0 Desenvolva a classe Polinomio. A representa\'e7\'e3o interna de um Polinomio \'e9 um array de termos. Cada termo cont\'e9m um coeficiente e um expoente. \b O \b0 termo \line 2x4 \line tem um coeficiente 2 e um expoente 4. Desenvolva uma classe completa, contendo fun\'e7\'f5es construtor e destruidor apropriadas, bem como fun\'e7\'f5es \i set \i0 e \i get. \i0 A classe deve tamb\'e9m fornecer os seguintes recursos de operadores sobrecarregados: \line a) Sobrecarregue o operador adi\'e7\'e3o \b (+) \b0 para somar dois Polinomios. \line b) Sobrecarregue o operador de subtra\'e7\'e3o \b\i\f1\fs18 (-) \b0\i0\f3\fs16 para subtrair dois Polinomios. \line e) Sobrecarregue o operador de atribui\'e7\'e3o para atribuir um Polinomio a outro. \line d) Sobrecarregue o operador de multiplica\'e7\'e3o \b (*) \b0 para multiplicar dois Polinomios. \line e) Sobrecarregue o operador de adi\'e7\'e3o com atribui\'e7\'e3o \b (+=), \b0 o operador de subtra\'e7\'e3o com atribui\'e7\'e3o \b\i\f1\fs18 (-) \b0\i0\f3\fs16 e o operador de multiplica\'e7\'e3o com atribui\'e7\'e3o (*=). \line 8.20 O programa da Fig. 8.3 cont\'e9m o coment\'e1rio \line\b\i\f1\fs18 II \b0\i0\f2\fs16 Operador de inser\'e7\'e3o em stream sobrecarregado (n\'e3o pode \line\i\f1\fs20 II \i0\f2\fs16 ser \f3 urna \f2 fun\'e7\'e3o membro se quisermos invoc\'e1-la com \line\f3 II \f2 cout \f1\fs20\'ab \f2\fs16 somePhoneNurnber;). \line Na verdade, n\'e3o pode ser uma fun\'e7\'e3o \f3 membro da classe ostreaiti. mas ele pode ser uma fun\'e7\'e3o membro da classe PhoneNumber \f2 se estivermos dispostos a invoc\'e1-lo de qualquer um dos modos seguintes: \line somePhoneNumber.operator\'ab( cout \f3 ) \line\f2 ou \line somePhoneNuxnber \f1\fs20\'ab \f2\fs16 cout; \line Rescreva o programa da Fig. 8.3 com o operator\'ab de inser\'e7\'e3o em \i\f3 streams \i0\f2 sobrecarregado como uma fun\'e7\'e3o \f3 membro e teste \f2 os dois comandos precedentes no programa para provar que eles funcionam. \par
\f0\fs24\par
\par
}
 