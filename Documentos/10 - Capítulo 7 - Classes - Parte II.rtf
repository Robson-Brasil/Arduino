{\rtf1\ansi\ansicpg1252\deff0\deflang1033{\fonttbl{\f0\froman\fprq2\fcharset0 Times New Roman;}{\f1\froman\fcharset0 Helvetica Narrow;}{\f2\froman\fcharset0 Helvetica, sans-serif;}{\f3\fmodern\fprq1\fcharset0 Courier;}{\f4\froman\fcharset0 Times New Roman;}}
\viewkind4\uc1\pard\sb100\sa240\lang2070\f0\fs16\par
\fs24\par
\ul\b\f1\fs140 7 \ulnone\line\f0\fs70 Classes: parte II \line\f2\fs22 Objetivos \line\b0\f0\fs20\bullet  Ser capaz de criar e destruir objetos dinamicamente. \line\bullet  Ser capaz de especificar objetos const (constantes) e fun- \f2\fs8 * \f0\fs20\'e7\'f5es membro const. \line\bullet  Entender a finalidade das fun\'e7\'f5es e classes friend. \line\bullet  Entender como usar membros de dados e fun\'e7\'f5es membro static. \line\bullet  Entender o conceito de uma classe cont\'eainer. \line\bullet  Entender a no\'e7\'e3o de classes de iteradores que percorrem os elementos de classes cont\'eaineres. \line\bullet  Entender o uso do ponteiro this. \line\i\fs18 But what, to serve ourpri vate ends, \line Forbids the cheating ofourfriends? \line\i0\fs20 Charles Churchili \line\i\fs18 Em vez dessa divis\'e3o absurda de sexos, deveriam \line classificar as pessoas como est\'e1ticas e din\'e2micas. \line\i0\fs20 Evelyn Waugh \line\i\fs18 E sobretudo isso: s\'ea fiel a ti mesmo. \line\i0\fs20 William Shakespeare, Hamlet \fs24\par
\i\fs18 N\'e3o tenha amigos iguais a voc\'ea. \line\i0\fs20 Conf\'facio \fs24\par
\i\f2\fs22 452 \b\i0\f0\fs20 C++ \fs14 COMO PROGRAMAR \line\ul\f2\fs30 Vis\'e3o geral \ulnone\line\b0\f3\fs18 7.1 \b\f2\fs20 Introdu\'e7\'e3o \line 7.2 Objetos \b0\f0\fs18 const \b\f2\fs20 (constantes) e fun\'e7\'f5es membro \f0\fs16 const \line\f2\fs20 7.3 Composi\'e7\'e3o: objetos como membros de classes \line 7.4 Fun\'e7\'f5es \f0\fs16 friend \f2\fs20 e classes \f0\fs16 friend \line\f2\fs20 7.5 Usando o ponteiro \f0\fs16 this \line\f2\fs20 7.6 Aloca\'e7\'e3o din\'e2mica de mem\'f3ria com os operadores \f0\fs16 new \f2\fs20 e delete \line 7.7 Membros de classe static \line 7.8 Abstra\'e7\'e3o de dados e oculta\'e7\'e3o de informa\'e7\'f5es \line 7.8.1 Exemplo: tipo de dado abstrato array \line 7.8.2 Exemplo: tipo de dado abstrato \i string \line\i0 7.8.3 Exemplo: tipo de dado abstrato fila \line 7.9 Classes cont\'eainer e iteradores \line 7.10 Classes proxy \line 7.11 (Estudo de caso opcional) Pensando em objetos: programando as classes para o simulador de elevador \line\b0\i\f0\fs18 Resumo \i0\f2\fs12 . \i\f0\fs18 Terminologia \i0\f2\fs12 . \i\f0\fs18 Erros comuns de programa\'e7\'e3o \i0\f2\fs12\bullet  \i\f0\fs18 Boas pr\'e1ticas de programa\'e7\'e3o Dicas de desempenho\bullet  Observa\'e7\'f5es de engenharia de software Dicas de teste e depura \'e7\'e3o Exerc\'edcios de auto-revis\'e3o\bullet  Respostas aos exerc\'edcios de auto-revis\'e3o \i0\f2\fs12\bullet  \i\f0\fs18 Exerc\'edcios \line\b\i0\f2\fs26 7.1 Introdu\'e7\'e3o \line\b0\f0\fs18 Neste cap\'edtulo, continuamos o nosso estudo de abstra\'e7\'e3o de dados e classes. Discutimos muitos t\'f3picos mais avan\'e7ados e assentamos a base para a discuss\'e3o de classes e sobrecarga de operadores no Cap\'edtulo 8. A discuss\'e3o nos Cap\'edtulos 6 a 8 encoraja que os programadores usem objetos, o que chamamos \i de programa\'e7\'e3o baseada em objetos (OBP object-based programming). \i0 A seguir, os Cap\'edtulos 9 e 10 introduzem heran\'e7a e polimorfismo \f2\fs8 - \f0\fs18 as t\'e9cnicas da verdadeira \i programa\'e7\'e3o orientada a objetos (OOP). \i0 Nestes e em v\'e1rios cap\'edtulos subseq\'fcentes, usamos \i strings \i0 ao estilo de programa\'e7\'e3o em C que introduzimos no Cap\'edtulo 5. Isto ajudar\'e1 o leitor a dominar o complexo t\'f3pico de ponteiros em C e prepar\'e1-lo para o mundo profissional, no qual o leitor ver\'e1 muito c\'f3digo legado em C, desenvolvido durante as \'faltimas duas d\'e9cadas. No Cap\'edtulo 19, discutimos o novo estilo de \i strings, \i0 isto \'e9, \i strings \i0 como objetos de classes no sentido pleno da palavra. Deste modo, o leitor familiarizar-se-\'e1 com os dois m\'e9todos mais comuns de criar e manipular \i strings \i0 em C++. \line\b\f2\fs26 7.2 Objetos \b0\f0\fs24 const \b\f2\fs26 (constantes) e fun\'e7\'f5es membro \fs20 const \line\b0\f0\fs18 Ternos enfatizado o \i princ\'edpio do m\'ednimo privil\'e9gio \i0 como um dos princ\'edpios mais fundamentais da boa engenharia de software. Iremos ver como esse princ\'edpio se aplica a objetos. \line Alguns objetos necessitam ser modific\'e1veis e outros n\'e3o. O programador pode usar a palavra-chave const para especificar que um objeto n\'e3o \'e9 modific\'e1vel e que qualquer tentativa de modificar o objeto deve ser considerada um erro de sintaxe. Por exemplo, \line\f3 const Time noon ( \b\f0\fs14 12, O, O ); \line\b0\f3\fs18 declara um objeto const noon da \f0 classe Time e o inicializa \'e0s 12 horas. \fs24\par
\i\fs18 II \i0\f3\fs16 Fig. 7.1: time5.h \line\f0\fs20 // \f3\fs16 Declara\'e7\'e3o da classe Time. \line\f0\fs20 // \f3\fs16 Fun\'e7\'f5es membro definidas em time5.cpp \line #ifndef TIME5H \line #define TIME5H \line 7 class Time \f0\fs20\{ \f3\fs16 60 \line public: \line Time( int \f2\fs10 = \f3\fs16 0, int \f2\fs10 = \f3\fs16 0, int =0); \f0\fs20 // \f3\fs16 construtor default \line\i\f0\fs18 II \i0\f3\fs16 fun\'e7\'f5es de inicializa\'e7\'e3o \line void setTime( int, int, int \line void setHour( int ); \line void setMinute \f0\fs20 ( \f3\fs16 int ); \line void setSecond( int ); \line\i\f0\fs18 II \i0\f3\fs16 fun\'e7\'f5es obter (normalmente declaradas const) \line int getHour() const; \i\f0\fs18 II \i0\f3\fs16 retorna hour \line int getNinute() const; \i\f0\fs18 II \i0\f3\fs16 retorna minute \line int getSecond() const; \i\f0\fs18 II \i0\f3\fs16 retorna second \line\i\f0\fs18 II \i0\f3\fs16 fun\'e7\'f5es de impress\'e3o (normalmente declaradas const) \line void printMilitary() const; \f0\fs20 // \f3\fs16 imprime hora militar \line void printStandard \i\f0\fs18 II \i0\f3\fs16 imprime hora padr\'e3o \line private: \line int hour; \line int minute; \line int second; \line 83 \line 84 \line 85 \line\b\f2\fs18 Fig. \b0\fs20 7.1 Usando uma classe Time com objetos const e fun\'e7\'f5es membro \f0\fs16 const \f2\fs8 - \fs20 time5 .h. 86 \f0\fs24\par
\i\f2\fs22 454 \b\i0\fs18 C++ \b0\fs14 COMO PROGRAMAR \line\f0\fs18 (na linha 108). O programa tamb\'e9m ilustra as tr\'eas outras combina\'e7\'f5es de chamadas de fun\'e7\'f5es membro a objetos \f2\fs8 - \f0\fs18 uma fun\'e7\'e3o membro n\'e3o-const a um objeto n\'e3o-const (linha 100), uma fun\'e7\'e3o membro const a um objeto n\'e3o const (linha 104) e uma fun\'e7\'e3o membro const a um objeto const (linhas 106 e 107). As mensagens geradas por dois compiladores populares para fun\'e7\'f5es membros n\'e3o-const que chamam um objeto const s\'e3o mostradas na janela de sa\'edda. \line\i Boa pr\'e1tica de programa\'e7\'e3o 7.1 \line Declare como \i0 cons \b\fs16 t \b0\i\fs18 todas as fun\'e7\'f5es membro que n\'e3o necessitam modificar o objeto corrente, deforma que voc\'ea possa us\'e1-las sobre um objeto \i0 const \i se necessitar \i0\fs24\par
\f3\fs16 1 \line\b\f2\fs18 2 \line\b0\f3\fs16 3 \line 4 \line 5 \line\f2\fs20 6 \f0\fs24\par
\f3\fs16 41 \line 42 \line 43 \line 44 \line 45 \line 46 \line 47 \line 48 \line 49 \line 50 \line 51 \line 52 \line 53 \line 54 \line 55 \line 56 \line 57 \line\b\f0 58 \line\b0\f3 59 \f0\fs24\par
\f3\fs16 8 \line 9 \line 10 \line 11 \line 12 \line 13 \line 14 \line 15 \line 16 \line 17 \line 18 \line 19 \line 20 \line 21 \line 22 \line 23 \line 24 \line 25 \line 26 \line 27 \line 28 \line 29 \line 30 \line 31 \f0\fs24\par
\fs20 // \f3\fs16 inicializa time \f0\fs20 // \f3\fs16 inicializa hour \line\f0\fs20 // \f3\fs16 inicializa minute \line\i\f0\fs18 II \i0\f3\fs16 inicializa second \f0\fs24\par
\b\f2\fs18 61 \line\b0\f3\fs16 62 \line\b\f0 63 \line 64 \line\b0\f3 65 \line\f2\fs20 66 \line\f3\fs16 67 \line 68 \line 69 \line 70 \line 71 \line 72 \line 73 \line 74 \line 75 \line\b\f0 76 \line\b0\f3 77 \line 78 \line 79 \line 80 \line 81 \line 82 \f0\fs24\par
\i\f2\fs22 II \i0\f3\fs16 O -23 \line\i\f2\fs22 II \i0\fs18 O \f3\fs16 -59 \line\i\f2\fs22 II \i0\fs18 O \f3\fs16 -59 \f0\fs24\par
\fs18 #endif \fs24\par
\f3\fs16 87 \line 88 \f0\fs24\par
\f2\fs18 Fig. \line\f3\fs16 2 \f2\fs18 de \f0\fs24\par
\f3\fs16 89 \line 90 \line\b\f0 91 \b0\fs24\par
\b\fs16 92 \line\f2 Fig. \line (part \b0\f0\fs24\par
\b\f2\fs18 Fig. \b0 7.1 Usando uma classe Time com objetos const e fun\'e7\'f5es membro \f0 const \f2\fs8 - \fs18 time5 \fs8 . \fs18 h (parte 1 de 2). \f0\fs24\par
\pard\par
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx301\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4711\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx6050\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx8235\pard\intbl\f3\fs16 32  33  34 \f0\fs24\cell\i\fs18 II \i0\f3\fs16 Fig. 7.1: time5.cpp  \f0\fs20 // \f3\fs16 Defini\'e7\'f5es das fun\'e7\'f5es #include <iostream> \f0\fs24\cell\f3\fs16 membro \f0\fs24\cell\f3\fs16 para a classe Time. \f0\fs24\cell\fs20\row
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx301\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4711\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx6050\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx6560\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx8235\pard\intbl\f3\fs16 35 \f0\fs24\cell\cell\cell\cell\cell\fs20\row
\f3\fs16\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx301\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4711\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx6050\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx6560\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx8235\intbl 36 \f0\fs24\cell\f3\fs16 using std::cout; \f0\fs24\cell\cell\cell\cell\fs20\row
\b\fs16\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx301\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4711\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx6050\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx6560\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx8235\intbl 37 \b0\fs24\cell\cell\cell\cell\cell\fs20\row
\f3\fs16\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx301\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4711\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx6050\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx6560\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx8235\intbl 38 \f0\fs24\cell\f3\fs16 #include \ldblquote time5.h\rdblquote  \f0\fs24\cell\cell\cell\cell\fs20\row
\f3\fs16\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx301\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4711\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx6050\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx6560\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx8235\intbl 39 \f0\fs24\cell\cell\cell\cell\cell\fs20\row
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx301\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4711\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx6560\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx8235\pard\intbl\f3\fs16 40 \f0\fs24\cell\i\fs18 II \i0\f3\fs16 Fun\'e7\'e3o construtor para \f0\fs24\cell\f3\fs16 inicializar dados \f0\fs24\cell\f3\fs16 privados. \f0\fs24\cell\fs20\row
\pard\fs24\par
\pard\sb100\sa240\fs16 CAP\'cdTULO 7 \f2\fs8 - \f0\fs16 CLASSES: PARTE II \i\f2\fs20 455 \line\i0\f0\fs16 os- 41 \i\f2\fs20 /1 \i0\f0\fs16 Valores default s\'e3o O (ver defini\'e7\'e3o da classe). \line\f3 jeto 42 Time::Time( int hr, int mm, int sec \i\f2\fs20 ) \line\i0\f3\fs16 ens 43 \i\f2\fs20\{ \i0\f3\fs16 setTime( hr, mm, sec ); \i\f2\fs20\} \line\i0\f3\fs16 sao 45 \i\f2\fs20 /1 \i0\f3\fs16 Inicializa os valores \f0 de hour, minute e second. \line\f3 46 void Time::setTime( int h, int m, int s \line 47 \line 48 setHour( h ); \line 49 setMinute( m ); \line 50 setSecond( s ); \line 51 \line 52 \line 53 \i\f2\fs20 II \i0\f3\fs16 Inicializa o valor de hour \line 54 void Time::setHour( int h \line 55 \{hour=(h>=0&&h<24)?h:0;\} \line 56 \line 57 \i\f2\fs20 /1 \i0\f3\fs16 Inicializa o valor de minute \line 58 void Time: :setMinute( int m \line 59 \{minute= (m>=0 &&m< 60) ?m :0;) \line 60 \line 61 \i\f2\fs20 II \i0\f3\fs16 Inicializa o valor de second \line 62 void Time::setSecond( int s \line 63 \i\f2\fs20 ( \i0\f3\fs16 second \b\f0\fs12 = \b0\i\f2\fs20 ( \i0\f3\fs16 s \b\f0\fs12 >= O \b0\f3\fs16 && s < 60 \i\f2\fs20 ) \i0\f3\fs16 ? s : 0; \i\f2\fs20\} \line\i0\f3\fs16 64 \line 65 \i\f2\fs20 /1 \i0\f0\fs16 Obt\'e9m o valor \f3 de hour \line 66 int Time: :getHour() const \i\f2\fs20\{ \i0\f3\fs16 return hour; \line 67 \line 68 \i\f2\fs20 II \i0\f3\fs16 Obt\'e9m o valor de minute \line 69 \f0 irit \f3 Time: :getMinute() const \i\f2\fs20\{ \i0\f3\fs16 return minute; \line 70 \line 71 \i\f2\fs20 II \i0\f3\fs16 Obt\'e9m o valor de second \line 72 int Time: :getSecond() const \i\f2\fs20\{ \i0\f3\fs16 return second; \line 73 \line 74 \i\f2\fs20 II \i0\f3\fs16 Exibe o tempo no formato militar: HH:MM \line 75 void Time: :printMilitary() const \line 76 \line\f0 77 cout \'ab \i\f2\fs20 ( \i0\f0\fs16 hour < \f3 10 ? \lquote 0\rdblquote  : \f2\fs8\ldblquote\ldblquote  \i\fs20 ) \i0\f0\fs16\'ab hour \'ab \line 78 \'ab \i\f2\fs20 ( \i0\f3\fs16 minute < 10 ? \ldblquote 0\rquote  : \f2\fs8\ldblquote  \i\fs20 ) \i0\f0\fs16\'ab \f3 minute; \line 79 \i\f2\fs20\} \line\i0\f3\fs16 80 \line 81 \i\f2\fs20 /1 \i0\f3\fs16 Exibe o tempo no formato padr\'e3o: HH:MM:SS da manh\'e3 (ou tarde) \line 82 void Time::printStandard() \i\f2\fs20 II \i0\f3\fs16 deveria ser const \line 83 \line 84 cout \'ab \i\f2\fs20 ( ( \i0\f0\fs16 hour \b\fs12 == \b0\f3\fs16 12 \i\f2\fs20 ) \i0\f0\fs16 ? 12 : hour % 12 \i\f2\fs20 ) \i0\f0\fs16\'ab \line\f3 85 \'ab \i\f2\fs20 ( \i0\f3\fs16 minute < 10 \f0 ? \ldblquote 0\rdblquote  : \f2\fs8\ldblquote  \i\fs20 ) \i0\f0\fs16\'ab minute \'ab \line\f3 86 \'ab \i\f2\fs20 ( \i0\f3\fs16 second < 10 ? \ldblquote 0\rquote  : \f2\fs8\ldblquote  \i\fs20 ) \i0\f0\fs16\'ab \f3 second \line 87 \'ab \i\f2\fs20 ( \i0\f3\fs16 hour \f0 < \f3 12 ? \f2\fs8\ldblquote  \f3\fs16 da manh\'e3\rdblquote  : \f2\fs8\ldblquote  \f3\fs16 da tarde\rdblquote ); \line 88 \i\f2\fs20 ) \line\i0 Fig. 7.1 Usando uma classe Time com objetos const e fun\'e7\'f5es membro \f0\fs16 const \f2\fs8 - \fs20 time5 \fs8 . \fs20 cpp (parte 2 de 2). \line\f3\fs16 89 \i\f2\fs20 1/ \i0\f3\fs16 Fig. 7.1: figo7_01.cpp \line 90 \i\f2\fs20 // \i0\f3\fs16 Tentando acessar um objeto const \line 91 \i\f2\fs20 II \i0\f3\fs16 com fun\'e7\'f5es membro n\'e3o-const. \line 92 #include \ldblquote time5.h\rdblquote  \line\f2\fs20 Fig. 7.1 Usando uma classe Time com objetos const e fun\'e7\'f5es membro const \fs8 - \fs20 figo7_01 \fs8 . \fs20 cpp (parte 1 de 2). \f0\fs24\par
\i\f2\fs22 456 \i0\fs18 C++ COMO PROGRAMAR \line\f3\fs16 93 \line 94 int main() \line 95 \f2\fs30 o \line\f3\fs16 96 Time wakeUp( 6, 45, O ); \i\f2\fs22 II \i0\f3\fs16 objeto n\'e3o-constante \line 97 const Time noon( 12, 0, O ); \i\f2\fs22 II \i0\f3\fs16 objeto constante \line 98 \line 99 \i\f2\fs20 II \i0\f3\fs16 FUN\'c7\'c3O \f0\fs14 MEMBRO OBJETO \line\f3\fs16 100 wakeUp.setHour( 18 ); \i\f2\fs22 II \i0\f3\fs16 n\'e3o-const n\'e3o-const \line 101 \line 102 noon.setHour( 12 ); \f0\fs20 // \f3\fs16 n\'e3o-const const \line 103 \line 104 wakeUp.getHourf); \i\f2\fs22 II \i0\f3\fs16 const n\'e3o-const \line 105 \line 106 noon.getMinuteO; \i\f2\fs20 II \i0\f3\fs16 const const \line 107 noon.printMi1itary \i\f2\fs22 II \i0\f3\fs16 const const \line 108 noon.printStandardO); \f0\fs20 // \f3\fs16 n\'e3o-const const \line 109 return 0; \line 110 \i\f0\} \line Mensagens de erro do compilador Borland C++ com linha de comando \line\i0\f3 FigO7Ol \f2\fs8 . \f3\fs16 cpp: \line Warning W8037 FigO7 01.cpp 14: Non-const function Time::setHour(int) called for const object in function main() \line Warning W8037 FigO7 01.cpp 20: Non-const function Time: :printStandard(int) called for const object in function main() \line Turbo Incremental Link 5.00 Copyright (c) 1997, 2000 Borland \line\i\f0 Mensagens de erro do compilador Microsoft Visual C+ \i0\fs14 + \line\f3\fs16 Compiling... \line\f0\fs18 FigO 7_Ol \f2\fs8 . \f0\fs18 cpp \line\f3\fs16 d:figo7_01.cpp(14): error C2662: \lquote setHour\rquote  : cannot convert \lquote this\rquote  pointer from\rquote const class Time\rquote  to \lquote class Time \f0\fs14 & \line\f3\fs16 Conversion loses qualifiers \line d:\\fig07_01.cpp(20): error C2662: \lquote printStandard : cannot convert \lquote this\rquote  pointer from \lquote const class Time\rquote  to \lquote class Time \f2\fs12 &\lquote  \line\f3\fs16 Conversion loses qualifiers \line time 5 \f2\fs8 . \f3\fs16 cpp \line Error executing cl.exe. \line test.exe \f2\fs8 - \f3\fs16 2 error(s), O warning(s) \line\f2\fs18 Fig. 7.1 Usando uma classe Time com objetos const e fun\'e7\'f5es membro \f0\fs16 const \f2\fs8 - \fs18 fig07 01 \fs8 . \f0\fs18 cpp \f2 (parte 2 de 2). \line\f0\fs20 Note que, muito embora um construtor deva ser uma fun\'e7\'e3o membro n\'e3o-const, ainda assim ele pode ser chamado para um objeto const. A defini\'e7\'e3o do construtor de Time nas linhas 42 e 43 \line\f3\fs16 Time::Time( int hr, int mm, int sec \line\i\f0\{ \i0\f3 setTime( hr, mm, sec); \f0\fs20\} \line mostra que o construtor de Time chama outra fun\'e7\'e3o membro n\'e3o-const -setTime \f2\fs8 - \f0\fs20 para executar a inicializa\'e7\'e3o de um objeto de tipo Time. Invocar uma fun\'e7\'e3o membro n\'e3o-const a partir de uma chamada para o construtor de um objeto const \'e9 permitido. A caracter\'edstica de ser const de um objeto \'e9 assegurada a partir do momento em que o construtor completa a inicializa\'e7\'e3o do objeto e at\'e9 que o destruidor daquele objeto seja chamado. \fs24\par
\b\fs14 CAP\'cdTULO \b0\fs18 7 \f2\fs8 - \b\f0\fs14 CLASSES: PARTE II \b0\i\fs20 457 \line Observa\'e7\'e3o de engenharia de software 7.4 \line\i0\f2\fs12 ______ \i\f0\fs18 Um objeto \i0 cons \b t \b0\i n\'e3o pode ser modificado por atribui\'e7\'e3o; por isso ele deve ser inicializado. Quando um membro de dados de uma classe \'e9 declarado \b\i0 const, \b0\i um \i0 inicializador de membro \i deve ser usado para \line fornecer ao construtor o valor inicial do membro de dados de um objeto \i0 da \i classe. \line\i0 Note tamb\'e9m que a linha 108 (linha 20 no arquivo-fonte) \line noon.printStandard O; \i\fs20 II \i0\fs18 non-const const \line gera um erro de compila\'e7\'e3o, embora a fun\'e7\'e3o membro printStandard da classe Time n\'e3o modifique o objeto sobre o qual \'e9 invocada. N\'e3o modificar um objeto n\'e3o \'e9 suficiente para indicar um m\'e9todo const. O m\'e9todo tamb\'e9m precisa ser explicitamente declarado const. \line A Fig. 7.2 demonstra o uso de um inicializador de membro para inicializar o membro de dados const \line increment da classe Increment. O construtor para Increment \'e9 modificado, como segue: \line Increment::Increment( \f3 int a, int \b\f0 i \line\b0\f3 increment( \b\f0 i \line\b0\i\fs20\{ \i0\fs18 count \f2\fs10 = \b\f0\fs18 a; \b0\i\fs20\} \line\i0\fs18 A nota\'e7\'e3o : increment ( i ) inicializa increment com o valor i. Se s\'e3o necess\'e1rios v\'e1rios inicializadores de membros, simplesmente inclua-os em uma lista separada por v\'edrgulas depois dos dois-pontos. Todos os membros de dados \i podem \i0 ser inicializados usando sintaxe de inicializador de membro, mas consts e refer\'eancias \i devem \i0 ser inicializados desta maneira. Mais tarde, neste cap\'edtulo, veremos que objetos membro devem ser inicializados deste modo. No Cap\'edtulo 9, quando estudarmos heran\'e7a, veremos que as partes da classe base, em classes derivadas, tamb\'e9m devem ser inicializadas deste modo. \line\f1\fs80\'ae \i\f0\fs20 Dica de teste e depura \'e7\'e3o 7.1 \line Sempre declare fun\'e7\'f5es membro como \i0\fs18 const \i se elas n\'e3o modificarem o objeto. Isso pode ajudar a \line eliminar muitos bugs. \line\b\i0\f3\fs16 1 \b0\i\f0\fs20 II \b\i0\f3\fs16 Fig. \f0\fs18 7.2: figO7_02.cpp \line\f3\fs16 2 \b0\i\f0\fs20 II \b\i0\f3\fs16 Usando um inicializador de membro para inicializar \line\f0\fs18 3 \b0\i\fs20 II \i0\fs18 urna \b\f3\fs16 constante de um tipo de dado primitivo. \line 4 #include <iostrearn> \line 5 \line 6 using std: :cout; \line 7 using std: :endl; \line 8 \line 9 class Increment \line 10 public: \line 11 Increment( int c \b0\f2\fs10 = \b\f0\fs18 O, \f3\fs16 int i \b0\f2\fs10 = \b\f0\fs18 1 ); \line\f3\fs16 12 void addlncrement() \b0\i\f0\fs20\{ \b\i0\f3\fs16 count \f0\fs14 += \f3\fs16 increment; \line 13 void print() const; \line 14 \line 15 private: \line 16 int count; \line 17 const int increment; \b0\i\f0\fs20 II \b\i0\f3\fs16 membro de dados const \line\f0\fs18 18 \}; \line 19 \line\f3\fs16 20 \b0\i\f0\fs20 II \b\i0\f3\fs16 Construtor para a classe Increment \line 21 Increment: :Increment( int c, int i \line\b0\f2\fs20 Fig. 7.2 Usando um inicializador de membro para inicializar uma \f0\fs18 constante \f2\fs20 de um tipo de dado primitivo (parte 1 de 2). \f0\fs24\par
\i\f2\fs22 458 \i0\f3\fs16 C++ \f2\fs14 COMO \f0 PROGRAMAR \line\f3\fs16 22 : increment( i \f0\fs20 ) \i\f2\fs22 II \i0\f3\fs16 inicializador para \f0 membro \f3 const \line 23 \f0\fs20\{ \f3\fs16 count \f2\fs12 = \f3\fs16 e; \line 24 \line 25 \i\f2\fs20 II \i0\f3\fs16 Imprime os dados \line 26 void Increment: :print() const \line 27 \line 28 cout \'ab \ldblquote count \f2\fs12 = \f0\ldblquote  \fs20\'ab \f3\fs16 count \line 29 \'ab \f0\fs12\ldblquote , \f3\fs16 increment \f2\fs12 = \f0\ldblquote  \f3\fs16\'ab increment \'ab endi; \line 30 \i\f2\fs22\} \line\i0\f3\fs16 31 \line 32 int main \f0\fs20 O \line\f3\fs16 33 \line 34 Increment value( 10, 5 ); \line 35 \line 36 cout \'ab \lquote Antes de incrementar: \f2\fs10\ldblquote ; \line\f3\fs16 37 value.printO; \line 38 \line 39 for(intj=0;j<3;j++)\{ \line 40 value.addlncrementO; \line 41 cout \'ab \ldblquote Ap\'f3s incrementar \f0\fs12\ldblquote  \fs20\'ab \fs14 + 1 \fs20\'ab \fs12\ldblquote : \line\f3\fs16 42 value.printQ; \line 43 \line 44 \line 45 return 0; \line 46 \line Antes de incrementar: count \f2\fs12 = \f3\fs16 10, increment \f2\fs12 = \f3\fs16 5 \line Ap\'f3s incrementar 1: count \f2\fs12 = \f3\fs16 15, increment \f2\fs12 = \f3\fs16 5 \line Ap\'f3s incrementar 2: count \f2\fs12 = \f3\fs16 20, increment \f2\fs12 = \f3\fs16 5 \line Ap\'f3s incrementar 3: count \f2\fs12 = \f3\fs16 25, increment \f2\fs12 = \line\fs20 Fig. \b\f3\fs18 7.2 \b0\f2\fs20 Usando um inicializador de membro para inicializar \f3\fs16 uma constante de um tipo de dado primitivo \f2\fs20 (parte 2 de 2). \line\f0 A Fig. 7.3 ilustra as mensagens de erros de compila\'e7\'e3o emitidas por dois compiladores populares de C++ para \fs12 um \fs20 programa que tenta inicializar increment com um comando de atribui\'e7\'e3o em vez de com um inicializador de membro. \line\f3\fs16 1 \i\f2\fs20 II \i0\f0\fs16 Fig. \f3 7.3: \f0\fs20 figO7O3.cpp \line 2 // Tentando inicializar uma constante de uni \line\f3\fs16 3 \f0\fs20 // tipo de dado primitivo com \fs12 uma atribui\'e7\'e3o. \line\f3\fs16 4 \f0 #include <iostreani> \line\f3 5 \line 6 using std: :cout; \line 7 using std: :endl; \line 8 \line 9 class Increment \f0\fs20\{ \line\f3\fs16 10 public: \line 11 Increment( int c \f2\fs12 = \f3\fs16 0, int i \f2\fs12 = \f3\fs16 1 ); \line 12 void addlncrement() \f0\fs20\{ \f3\fs16 count \f0\fs14 + \f3\fs16 increment; \f0\fs20\} \line\f3\fs16 13 void print() const; \line 14 private: \line 15 int count; \line\b\f2\fs18 Fig. 7.3 \b0\f3\fs16 Tentativa err\'f4nea \f2\fs20 de inicializar uma constante de um tipo de dado primitivo por atribui\'e7\'e3o (parte 1 de 2). \f0\fs24\par
\f3\fs16 CAP\'cdTULO \i\f0 7 \i0\f2\fs8 - \f0\fs14 CLASSES: PARTE \fs20 II 459 \line\f3\fs16 16 const int increment; \line 17 \line 18 \line 19 \f0\fs20 // \f3\fs16 Construtor para a classe Increment \line 20 Increment: :Increment( int c, int i \line 21 \f0\fs20\{ // \f3\fs16 Membro constante \lquote increment\rquote  n\'e3o est\'e1 inicializado \line 22 count \f2\fs10 = \line\f3\fs16 23 increment \f2\fs10 = \f3\fs16 i; \f0\fs20 // \f3\fs16 ERRO: n\'e3o se pode modificar um objeto const \line 24 \f2\fs20 ) \line\f3\fs16 25 \line 26 \i\f2\fs20 II \i0\f3\fs16 Imprime os dados \line 27 void Increment: :print() const \line 28 \f0\fs20\{ \line\f3\fs16 29 cout\'ab \ldblquote count \f2\fs10 = \ldblquote  \f3\fs16\'ab count \line 30 \'ab \f2\fs8\ldblquote , \f3\fs16 increment \f2\fs10 = \lquote  \f3\fs16\'ab increment \'ab endl; \line 31 \line 32 \line 33 int main() \line 34 \i\f0\{ \line\i0\f3 35 Increment value( 10, 5 ); \line 36 \line 37 cout \'ab \lquote Antes de incrementar: \line 38 value.printO; \line 39 \line 40 for(mntj=0;j<3;j++)\{ \line 41 value.addlncrementQ; \line 42 cout \'ab \ldblquote Ap\'f3s incrementar \f2\fs10\ldblquote  \f3\fs16\'ab \f0\fs20 j \f3\fs16\'ab \line 43 value.printO); \line 44 \i\f0 ) \line\i0\f3 45 \line 46 return 0; \line\f0\fs14 47 \fs20 ) \line\i\fs16 Mensagens de erro do compilador Borland C++ com linha de comando \line\i0\f3 Fig0703.cpp: \line de Warning W8038 FigO7 03.cpp 21: Constant member \lquote Increment: :increment\rquote  is not initialized in function Increment: :Increment(int,int) \line Error E2024 FigO7 03.cpp 23: Cannot modify a const object in function \line Increment: : Increment (int, int) \line Warning W8057 FigO7 03.cpp 24: Parameter \lquote i\rquote  is never used in function \line Increment: : Increment(int,int) \line\f2\fs12 *** \f3\fs16 1 errors in Compile \f2\fs12 *** \line\i\f0\fs16 Mensagens de erro do compilador Microsoft Visual C+ \i0\fs14 + \line\f3\fs16 Compiling... \line Fig0703 cpp \line D:\\Fig0703.cpp(21) : error C2758: \lquote increment\rquote  : must be initialized in \line constructor base/member initializer list \line D:\\Fig0703.cpp(16) : see declaration of \lquote increment\rquote  \line D:\\Fig0703.cpp(23) : error C2166: 1-value specifies const object \line Error executing cl.exe. \line\f2\fs8 - \f3\fs16 test.exe \f2\fs8 - \f3\fs16 2 error(s), O warning(s) \line rte \line\f2\fs18 Fig. 7.3 Tentativa erronea de inicializar uma constante de um tipo de dado primitivo por atribui\'e7ao (parte 2 de 2). \f0\fs24\par
\b\f2\fs22 460 C++ \fs14 COMO PROGRAMAR \line\b0\i\f0\fs20 Erro comum de programa\'e7\'e3o 7.5 \line N\'e3o definir um inicializador de membro para um membro de dados \b\i0\fs18 const \b0\i\fs20\'e9 um erro de sintaxe. \line Observa\'e7\'e3o de engenharia de software 7.5 \line\i0\f2\fs12 ______ \i\f0\fs18 Membros de classe constantes (objetos \i0 const \i e \ldblquote vari\'e1veis\rdblquote  \i0 const) \i devem ser inicializados com a sintaxe de inicializador de membro; n\'e3o s\'e3o permitidas atribui\'e7\'f5es. \line\i0 Note que a fun\'e7\'e3o print na linha 27 \'e9 declarada const. \f1\fs26\'c9 \f0\fs18 razo\'e1vel, embora estranho, rotular essa fun\'e7\'e3o como const, porque, provavelmente, nunca teremos um objeto Increment const. \line\i\fs20 Observa\'e7\'e3o de engenharia de software 7.6 \line\i0\f1\fs26\'c9 \i\f0\fs18 uma boa pr\'e1tica declarar como \i0 const \i todas as fun\'e7\'f5es membro de uma classe que n\'e3o modficam o objeto sobre o qual elas operam. Ocasionalmente, isto ser\'e1 uma anomalia, porque voc\'ea n\'e3o tem nenhuma inten\'e7\'e3o de criar objetos \b\i0 const \b0\i daquela classe. Entretanto, declarar como \b\i0 const \b0\i tais fun\'e7\'f5es membro oferece um benefi\rquote cio: se voc\'ea, inadvertidamente, modificar o objeto naquela fun\'e7\'e3o membro, o compilador emitir\'e1 uma mensagem de erro de sintaxe. \line\i0\f2\fs12\'ae \i\f0\fs18 Dica de teste e depura \'e7\'e3o 7.2 \line As linguagens como C+ \b\i0\f3\fs16 + \b0\i\f0\fs18 s\'e3o como \ldblquote alvos m\'f3veis \i0\f2\fs8\ldblquote , \i\f0\fs18 pois evoluem. \f1\fs26\'c9 \f0\fs18 prov\'e1vel que mais palavras-chave sejam incorporadas \'e0 linguagem. Evite usar palavras muito importantes, tais como \ldblquote objeci \i0\f2\fs8\ldblquote , \i\f0\fs18 como identificadores. Embora \ldblquote object\rdblquote  n\'e3o seja atualmente uma palavra-chave em C++, no futuro ela o poder\'e1 ser Assim, futuros compiladores poderiam tornar inoperante o c\'f3digo existente. \line\i0 C++ fornece uma palavra-chave chamada mutable que afeta o tratamento de objetos const em um programa. Discutiremos a palavra-chave mutable no Cap\'edtulo 21. \line\b\f2\fs26 7.3 Composi\'e7\'e3o: objetos como membros de classes \line\b0\f0\fs18 Um objeto da classe RelogioDespertador necessita saber quando ele deve soar seu alarme; assim, por que n\'e3o incluir um objeto do tipo Time como membro do objeto RelogioDespertador? Tal recurso \'e9 chamado de \i composi\'e7\'e3o. \i0 Uma classe pode ter objetos de outras classes como membros. \line\i Observa\'e7\'e3o de engenharia de software 7.7 \line\i0\f2\fs12 ______ \i\f0\fs18 A forma mais comum de reutiliza\'e7\'e3o de software \'e9 a composi\'e7\'e3o, na qual uma classe tem objetos de outras classes como membros. \line\i0 Quando um objeto \'e9 criado, seu construtor \'e9 chamado automaticamente, de modo que necessitamos especificar como os argumentos s\'e3o passados para construtores de objetos membro. Os objetos membro s\'e3o constru\'eddos na ordem em que s\'e3o declarados (n\'e3o na ordem em que s\'e3o listados na lista de inicializadores de membros do construtor) e antes de os objetos de classe que os incluem (\'e0s vezes denominados \i objetos hospedeiros) \i0 serem constru\'eddos. \line A Fig. 7.4 usa a classe Employee e a classe Date para demonstrar objetos como membros de outros objetos. A classe Eniployee cont\'e9m membros de dados privados firstName. lastName. birthDate e hireDate. Os membros birthDate e hireDate s\'e3o objetos const da classe Date, que cont\'e9m os membros de dados privados month, day e year. O programa instancia um objeto Employee e inicializa e exibe seus membros de dados. Note a sintaxe do cabe\'e7alho da fun\'e7\'e3o, na defini\'e7\'e3o do construtor de Employee: \line Employee: \b\f3\fs16 :Employee( char *fne, char *1ne, \line int bmonth, int bday, int byear, \line int hmonth, int hday, int hyear \line birthDate( bmonth, bday, byear \b0\f0\fs18 ), \line\b\f3\fs16 hireDate( hmonth, hday, hyear \b0\f0\fs24\par
\fs18 CAP\'cdTULO 7 \f2\fs8 - \f0\fs18 CLASSES: PARTE II \b\f2\fs22 461 \line\b0\f0\fs18 O construtor recebe oito argumentos (fnaine. mame, bmonth. bday. byear. hmonth, hday e hyear). Os dois-pontos \b\f2\fs22 (:) \b0\f0\fs18 no cabe\'e7alho separa os inicializadores de membros da lista de par\'e2metros. Os inicializadores de membros especificam os argumentos de Employee que est\'e3o sendo passados para os construtores dos objetos membro Date. Os argumentos bmonth, bday e byear s\'e3o passados para o construtor do objeto birthDate e os argumentos hmonth. hday e hyear s\'e3o passados para o construtor do objeto hireDate. Inicializadores de membros m\'faltiplos s\'e3o separados por v\'edrgulas. \line\f3\fs16 1 \i\fs20 II \i0\fs16 Fig. 7.4: \f0\fs18 datel.h \line\f3\fs16 2 \i\fs20 1/ \i0\fs16 Declara\'e7\'e3o da classe Date. \line 3 \i\fs20 II \i0\fs16 Fun\'e7\'f5es membro definidas em datel.cpp \line 4 #ifndef DATE1_H \line 5 #define DATE1_H \line 6 \line 7 class Date \line\i\fs20 na \i0\fs16 8 public: \line 9 Date( int \b\f0\fs12 = \b0\fs18 1, \f3\fs16 int \b\f0\fs12 = \b0\f3\fs16 1, int \b\f0\fs12 = \b0\f3\fs16 1900 ); \b\f2\fs22 // \b0\f3\fs16 construtor default \line la- 10 void print() const; \i\fs20 II \i0\fs16 imprime a data no formato m\'eas/dia/ano \line 11 \lquote DateO; \b\f2\fs22 // \b0\f3\fs16 fornecido para confirmar a ordem de destrui\'e7\'e3o \line 12 private: \line 13 int month; \b\f2\fs22 // \b0\f3\fs16 1-12 \line\f2\fs8 - \f3\fs16 14 int day; \i\fs20 II \i0\fs16 1-31 dependendo do m\'eas \line\i\fs20 ive \i0\fs16 15 int year; \b\f2\fs22 // \b0\f3\fs16 qualquer ano \line\i\f2\lquote nO \i0\f3 16 \line\i\f2\fs18\lquote r\'e1 \i0\f3\fs16 17 \b\f2\fs22 // \b0\f3\fs16 fun\'e7\'e3o utilit\'e1ria para testar validade do dia para m\'eas e ano \line 18 int checkDay(int); \line\f0\fs18 19 \line\f3\fs16 20 \line 21 #endif \line\b\f2\fs18 Fig. \b0\fs20 7.4 Usando inicializadores para objetos membro \fs8 - \f0\fs18 datel \f2\fs8 . \fs20 h. \line\f3\fs16 22 \b\f2\fs22 // \b0\f3\fs16 Fig. 7.4: datel.cpp \line\f0\fs18 n\'e3o \f3\fs16 23 \i\f2\fs22 /1 \i0\f3\fs16 Defini\'e7\'f5es de fun\'e7\'f5es membro para a classe Date. \line\f0\fs18 de \f3\fs16 24 #include <iostream> \line 25 \line 26 using std::cout; \line 27 using std: :endl; \line\f2\fs8 - \f3\fs16 28 \line\i\fs20 de \i0\fs16 29 #include \ldblquote datel.h\rdblquote  \line 30 \line 31 \i\f2\fs22 1/ \i0\f3\fs16 Construtor: confirma valor adequado para month \line 32 \b\f2\fs22 // \b0\f3\fs16 chama a fun\'e7\'e3o utilit\'e1ria checkDay para \line 33 \b\f2\fs22 // \b0\f3\fs16 confirmar valor adequado para day. \line\f0\fs18 ,na \f2\fs8 . \line\f3\fs16 34 Date: :Date( int mn, int dy, int yr \line 35 \line dOs. 36 if \f0\fs18 ( mn > \f3\fs16 O && \f0 mn \b\fs12 < 12 \f2\fs22 ) // \b0\f3\fs16 valida o m\'eas \line bje- 37 month \b\f0\fs12 = \b0\fs16 mn; \line\fs14 te. \f3\fs16 38 else \f0\fs18\{ \line\f3\fs16 idos 39 month \b\f0\fs12 = 1; \line\b0\f3\fs16 sde 40 cout \'ab \ldblquote M\'eas \'ab mn \'ab inv\'e1lido. Inicializa m\'eas com 1.\\n\rdblquote ; \line\b\f0\fs12 41 \b0\fs18\} \line\b\fs12 42 \line\b0\f3\fs16 43 year yr; \i\f2\fs22 1/ \i0\f3\fs16 deveria validar yr \line 44 day \b\f0\fs12 = \b0\f3\fs16 checkDay( dy ); \i\f2\fs22 /1 \i0\f3\fs16 valida o dia \line 45 \line\f2\fs20 Fig. 7.4 Usando inicializadores para objetos membro \fs8 - \fs20 datei \fs8 . \fs20 cpp (parte 1 de 2). \f0\fs24\par
\b\fs20 462 C++ \b0\fs14 COMO PROGRAMAR \line\b\f3\fs16 46 cout \'ab Construtor do objeto Date para a data \b0\f2\fs10\ldblquote ; \line\b\f3\fs16 47 print(); \b0\i\f2\fs22 II \b\i0\f3\fs16 interessante: \b0\f0 uma \b\f3 fun\'e7\'e3o print sem argumentos \line 48 cout \'ab endi; \line 49 \f0\fs20\} \line\f3\fs16 50 \line 51 \b0\i\f2\fs22 II \b\i0\f3\fs16 Imprime o objeto Date no formato m\'eas/dia/ano \line 52 void Date::print() const \line 53 \f0\fs20\{ \f3\fs16 cout \'ab month \b0\f0\fs20\'ab \i\f2\fs22\lquote 1\rquote  \b\i0\f3\fs16\'ab day \'ab \b0\i\f2\fs22\lquote 1\rquote  \i0\f0\fs20\'ab \b\f3\fs16 year; \line 54 \line 55 \b0\i\f2\fs22 II \b\i0\f3\fs16 Destruidor: fornecido para confirmar a ordem de destrui\'e7\'e3o \line 56 Date::-Date() \line 57 \line 58 cout \b0\f0\fs20\'ab \b\f3\fs16\ldblquote Destruidor do objeto Date para a data \b0\f2\fs10\ldblquote ; \line\b\f3\fs16 59 print(); \line 60 cout \'ab endi; \line 61 \line 62 \line 63 \f0\fs20 // \f3\fs16 Fun\'e7\'e3o utilit\'e1ria para confirmar o valor apropriado \line 64 \f0\fs20 // \f3\fs16 do dia, com base no m\'eas e no ano. \line 65 \b0\i\f2\fs22 II \b\i0\f3\fs16 O ano 2000 \'e9 um ano bissexto? \line 66 int Date::checkDay( int testDay \line 67 \f0\fs20\{ \line\f3\fs16 68 static const int daysPerMonth[ 13 \f0\fs20 ] \b0\f2\fs12 = \line\b\f3\fs16 69 \{0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31\}; \line 70 \line 71 if \f0\fs20 ( \f3\fs16 testDay > O && testDay \b0\f0\fs14 <= \b\f3\fs16 daysPerMonth[ month \line 72 return testDay; \line 73 \line 74 if \f0\fs20 ( \f3\fs16 month \b0\f0\fs14 == 2 && \b\fs20 // \f3\fs16 Fevereiro: testa se \'e9 ano bissexto \line 75 testDay \b0\f0\fs14 == \b\f3\fs16 29 && \line 76 (year % 400 \b0\f0\fs14 == \fs24 011 \b\f3\fs16 1/ano 2000? \line 77 \f0\fs20 ( \f3\fs16 year % 4 \b0\f0\fs14 == \b\f3\fs16 O && year %100 \b0\f0\fs14 ! O \b\fs20 ) ) ) \b0\i\f2\fs22 1/ \b\i0\f3\fs16 ano 2000 ? \line 78 return testDay; \line 79 \line 80 cout \'ab \ldblquote Dia \b0\f2\fs8\ldblquote  \b\f3\fs16\'ab testDay \'ab \b0\f2\fs8\ldblquote  \b\f3\fs16 inv\'e1lido. Inicializa dia com \line 81 \line 82 return 1; \f0\fs20 // \f3\fs16 deixa o objeto em estado consistente se o valor for inadequa& \line 83 \f0\fs20\} \line\f2\fs18 Fig. \b0\fs20 7.4 Usando inicializadores para objetos membro \fs8 - \fs20 datei \fs8 . \b\fs18 cpp. \line\b0\f0\fs20 Lembre-se de que membros e refer\'eancias const tamb\'e9m s\'e3o inicializados na lista de inicializadores de membro (no Cap\'edtulo 9, veremos que as partes da classe base de classes derivadas tamb\'e9m s\'e3o inicializadas deste modo). classe Date e a classe Empioyee incluem uma fun\'e7\'e3o destruidor que imprime uma mensagem quando um objet do tipo Date ou um objeto do tipo Empioyee \'e9 destru\'eddo, respectivamente. Isto nos permite confirmar na sa\'edda d programa que os objetos s\'e3o constru\'eddos de dentro para fora e destru\'eddos na ordem inversa, de fora para dentro (i.e. os objetos membro de Date s\'e3o destru\'eddos depois do objeto Empioyee que os cont\'e9m). \line Um objeto membro n\'e3o necessita ser inicializado explicitamente atrav\'e9s de um inicializador de membro. S um inicializador de membro n\'e3o \'e9 fornecido, o construtor default do objeto membro ser\'e1 chamado implicitamente Os valores, se houver algum, estabelecidos pelo construtor default podem ser substitu\'eddos por fun\'e7\'f5es \i\f2\fs18 set. \i0\f0\fs20 Entretan to, para inicializa\'e7\'e3o complexa, essa abordagem pode exigir trabalho e tempo adicionais significativos. \line\b\f3\fs16 84 \b0\i\f2\fs22 II \b\i0\f3\fs16 Fig. 7.4: empiyi.h \line 85 \b0\i\f2\fs22 II \b\i0\f3\fs16 Declara\'e7\'e3o da classe Employee. \line 86 \b0\i\f2\fs22 /1 \b\i0\f3\fs16 Fun\'e7\'f5es membro definidas em emplyl.cpp \line Fig. 7.4 \b0\f2\fs20 Usando inicializadores para objetos membro \fs8 - \b\f3\fs16 emplyi \b0\f2\fs8 . \b\f3\fs16 h \b0\f2\fs20 (parte 1 de 2). \f0\fs24\par
\fs16 CAP\'cdTULO \i\fs20 7 \i0\f2\fs8 - \f0\fs16 CLASSES: PARTE 11 463 \line\f3 87 #ifndef EMPLY1H \line 88 #define EMPLY1H \line 89 \line 90 #include \ldblquote datel.h\rdblquote  \line 91 \line 92 class Employee \line 93 public: \line 94 Employee( char \f2\fs8 , \f3\fs16 char \f2\fs8 , \f3\fs16 int, int, int, int, int, int ); \line 95 void print() const; \line 96 \lquote .-EmployeeO; \i\f0\fs20 II \i0\f3\fs16 fornecido para confirmar a ordem de destrui\'e7\'e3o \line 97 private: \line 98 char firstName[ 25 ); \line 99 char lastName[ 25 \f0\fs20 J; \line\f3\fs16 100 const Date birthDate; \line 101 const Date hireDate; \line 102 \}; \line 103 \line 104 #endif \line\f2\fs18 Fig. 7.4 Usando inicializadores para objetos membro \fs8 - \fs18 emplyl \fs8 . \fs18 h (parte 2 de 2). \line\i\f0\fs20 Erro comum de programa\'e7\'e3o 7.6 \line N\'e3o definir um construtor default para a classe de um objeto membro, quando nenhum inicializador de \line membro \'e9fornecido para aquele objeto membro, \'e9 um erro de sintaxe. \line\i0\f3\fs16 105 //Fig. 7.4: emplyl.cpp \line 106 //Defini\'e7\'f5es das fun\'e7\'f5es membro para a classe Employee. \line 107 #include <iostream> \line 108 \line 109 using std::cout; \line 110 using std::endl; \line 111 \line 112 #include <cstring> \line iado 113 #include \ldblquote emplyl.h\rdblquote  \line 114 #include \lquote datel.h\rdblquote  \line 115 \line 116 Employee::Employee( char *fname, char *lname, \line 117 int bmonth, int bday, int byear, \line 118 int hxnonth, int hday, int hyear) \line -ibros 119 : birthDate( bmonth, bday, byear \f0\fs20 ), \line\f3\fs16 o).A 120 hireDate( \f0 hmonth, \f3 hday, hyear \line bjeto 121 \line dado. 122 \i\f0\fs20 /1 \i0\f3\fs16 copia fname para firstName e assegura \f0\fs18 que \f3\fs16 ele cabe \line (i.e. 123 int length strlen( fname ); \line 124 length \f2\fs12 = \f0\fs20 ( \f3\fs16 length \f0 < \f3 25 \f0 ? \f3 length : 24 ); \line\f0 o \f3 Se 125 strncpy( firstName, fname, length ); \line\bullet  126 firstName[ length \f0\fs20 ] \f2\fs12 = \line\f0\fs16 ente. \f3 127 \line\lquote etan- 128 \i\f0\fs20 II \i0\f3\fs16 copia \f0 lname \f3 para lastNaxne e assegura \f0\fs18 que \f3\fs16 ele cabe \line 129 length \f2\fs12 = \f3\fs16 strlen( \f0 lname ); \line\f3 130 length \f2\fs12 = \f0\fs20 ( \f3\fs16 length < 25 ? length : 24 ); \line 131 strncpy( lastName, lname, length ); \line 132 lastName[ length \f0\fs20 ] \f2\fs12 = \line\f3\fs16 133 \line 134 cout \'ab \ldblquote Construtor do objeto Employee: \line 135 \'ab firstName \'ab \f0\fs20 , \f2\fs8\lquote  \f0\fs16\'ab lastName \'ab endi; \line\f2\fs18 Fig. 7.4 Usando inicializadores para objetos membro \fs8 - \fs18 emplyl \fs8 . \f3\fs16 cpp \f2\fs18 (parte 1 de 2). \f0\fs24\par
\f2\fs20 464 \f0\fs16 C++ \f2\fs14 COMO PROGRAMAR \line\f0\fs16 136 \f2\fs20\} \line\f3\fs16 137 \line 138 void Employee: :print() const \line 139 \line 140 cout \'ab lastNaxne \'ab \f2\fs8\lquote , \lquote  \f3\fs16\'ab firstName \'ab \ldblquote\\nContratado: \line 141 hireDate.print \line 142 cout \'ab \f2\fs8\ldblquote  \f3\fs16 Data de nascimento: \f2\fs10\ldblquote ; \line\f3\fs16 143 birthDate.printO; \line 144 cout \'ab endl; \line 145 \line 146 \line 147 1/Destruidor: fornecido para confirmar a ordem de destrui\'e7\'e3o \line 148 Employee: :-Employee() \line 149 \line 150 cout \'ab \ldblquote Destruidor do objeto Employee: \line 151 \'ab lastName \'ab \f2\fs8\ldblquote , \ldblquote  \f3\fs16\'ab firstName \'ab endi; \line 152 \line\f0 Fig. 7.4 Usando inicializadores para objetos membro \f2\fs8 - \f0\fs16 emplyl \f2\fs8 . \fs20 cpp (parte 2 de 2). \line\i\f0 Dica de desempenho 7.2 \line\i0\f2\fs8 ______ \i\f0\fs18 Inicialize explicitamente objetos membro atrav\'e9s de inicializadores de membros. Isto elimina o \i0\fs16 overhead \i\fs18 da \ldblquote dupla inicializa\'e7\'e3o\rdblquote  de objetos membro \i0\f2\fs8 - \i\f0\fs18 uma vez quando o construtor default do objeto membro for \line chamado e novamente quando fun\'e7\'f5es set forem usadas para inicializar o objeto membro. \line\i0\fs16 153 //Fig. 7.4: figO7O4.cpp \line 154 //Demonstrando a composi\'e7\'e3o: um objeto com objetos membro. \line 155 #include <iostream> \line 156 \line\f3 157 using std::cout; \line 158 using std: :endl; \line\f0 159 \line\f3 160 #include \ldblquote emplyl.h\rdblquote  \line\f0 161 \line 162 int main \f2\fs20 () \line\f0\fs16 163 \line\f3 164 Employee e( \ldblquote Jos\'e9\rdblquote , \ldblquote Silva\rdblquote , \f0 7, 24, 1949, 3, 12, 1988 ); \line 165 \line 166 cout \f3\'ab \f0\lquote\\n\rquote ; \line 167 e.printO; \line 168 \line 169 cout \'ab \ldblquote\\nTesta o construtor de Date com valores inv\'e1lidos:\\n\rdblquote ; \line 170 Date d( 14, 35, 1994 ); \i\fs20 1/ \i0\f3\fs16 valores inv\'e1lidos de Date \line\f0 171 cout \'ab endl; \line 172 return 0; \line 173 \f2\fs20\} \f0\fs24\par
\f2\fs18 Fig. 7.4 Usando inicializadores para objetos membro \fs8 - \f0\fs18 figo7 04 \f2\fs8 . \fs18 cpp (parte 1 de 2). \f0\fs24\par
\pard\par
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1165\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1574\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2367\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx3448\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx5681\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx6186\pard\intbl\f3\fs16 Construtor \f0\fs24\cell\f3\fs16 do \f0\fs24\cell\f3\fs16 objeto \f0\fs24\cell\f3\fs16 Date para \f0\fs24\cell\f3\fs16 a data 7/24/1949 \f0\fs24\cell\cell\fs20\row
\f3\fs16\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1165\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1574\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2367\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx3448\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx5681\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx6186\intbl Construtor \f0\fs24\cell\f3\fs16 do \f0\fs24\cell\f3\fs16 objeto \f0\fs24\cell\f3\fs16 Date para \f0\fs24\cell\f3\fs16 a data 3/12/1988 \f0\fs24\cell\cell\fs20\row
\f3\fs16\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1165\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1574\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2367\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx3448\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx5681\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx6186\intbl Construtor \f0\fs24\cell\f3\fs16 do \f0\fs24\cell\f3\fs16 objeto \f0\fs24\cell\f3\fs16 Employee: \f0\fs24\cell\f3\fs16 Jos\'e9 Silva \f0\fs24\cell\cell\fs20\row
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1165\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2367\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx3448\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx5681\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx6186\pard\intbl\f3\fs16 Silva, Jos\'e9  Contratado: \f0\fs24\cell\f3\fs16 3/12/1988 \f0\fs24\cell\f3\fs16 Data de \f0\fs24\cell\f3\fs16 nascimento: 7/24/1949 \f0\fs24\cell\f3\fs48 J \f0\fs24\cell\fs20\row
\pard\fs24\par
\pard\sb100\sa240\b\fs16 CAP\'cdTULO \b0\i\fs18 7 \i0\f2\fs8 - \b\f0\fs16 CLASSES: PARTE \b0\fs20 II \b\i\f2\fs22 465 \b0\i0\f0\fs24\par
\f2\fs20 Fig. 7.4 Usando inicializadores para objetos membro \fs8 - \fs20 figO7 04 \fs8 . \fs20 cpp (parte 2 de 2). \line\i\f0\fs18 Observa\'e7\'e3o de engenharia de software 7.8 \line\i0\f2\fs8 ______ \i\f0\fs18 Se uma classe tem como membro um objeto de outra classe, tornar esse objeto membro \i0 public \i n\'e3o viola o encapsulamento e a oculta\'e7\'e3o dos membros \b\i0\fs16 private \b0\i\fs18 daquele objeto membro. \line\i0 Note a chamada para a fun\'e7\'e3o membro print de Date na linha 52. Muitas fun\'e7\'f5es membro de classes em C++ n\'e3o exigem nenhum argumento. Isso ocorre porque cada fun\'e7\'e3o membro cont\'e9m um \i handie \i0 impl\'edcito (na forma de um \line\f2\fs8 - \f0\fs18 ponteiro) \f2\fs8 - \f0\fs18 para o objeto sobre o qual ela opera. Discutiremos o ponteiro impl\'edcito \f2\fs8 - \f0\fs18 chamado this \f2\fs8 - \f0\fs18 na Se\'e7\'e3o 7.5. head Nesta primeira vers\'e3o de nossa classe Employee (por facilidade de programa\'e7\'e3o), usamos dois arrays de 25 \i ofor \i0 caracteres (firstName e lastName) para representar o primeiro e o \'faltimo nomes do Employee. Esses arrays \line podem ser um desperd\'edcio de espa\'e7o para nomes mais curtos que 24 caracteres (lembre-se de que um caractere em cada array est\'e1 destinado para o caractere nulo terminal, \lquote\\O \lquote ,do \i string). \i0 Fora isso, nomes maiores que 24 caracteres devem ser truncados para caber nestes arrays de caracteres. Mais \'e0 frente neste cap\'edtulo, apresentaremos outra vers\'e3o da classe Employee que cria dinamicamente a quantidade exata de espa\'e7o para manter o primeiro e o \'faltimo nome. Tamb\'e9m poder\'edamos usar dois objetos string para representar os nomes. A classe string da biblioteca padr\'e3o \'e9 apresentada em detalhes no Cap\'edtulo 19. \line\b\f2\fs26 7.4 Fun\'e7\'f5es \f0\fs24 friend \f2\fs26 e classes \b0\fs20 friend \line\i\f0\fs18 Um fun\'e7\'e3o \b\i0\f3 friend de uma classe \b0\f0\'e9 definida fora do escopo daquela classe, mas ainda tem o direito de acessar membros private da classe (e protected. como veremos no Cap\'edtulo 9, \ldblquote Heran\'e7a\rdblquote ). Uma fun\'e7\'e3o ou uma classe inteira podem ser declaradas como friends de outra classe. \line Usar fun\'e7\'f5es friend melhora o desempenho. Aqui \'e9 mostrado um exemplo mec\'e2nico de como funciona uma fun\'e7\'e3o friend. Mais \'e0 frente no livro, fun\'e7\'f5es friend ser\'e3o usadas para sobrecarregar operadores para uso com objetos de classes e para criar classes de iteradores. Os objetos de uma classe de iteradores s\'e3o usados sucessivamente para selecionar itens ou executar uma opera\'e7\'e3o sobre os itens em um objeto de uma classe cont\'eainer (ver Se\'e7\'e3o 7.9). Os objetos de classes cont\'eaineres s\'e3o capazes de armazenar itens. O uso de friends freq\'fcentemente \'e9 apropriado quando uma fun\'e7\'e3o membro n\'e3o puder ser usada para certas opera\'e7\'f5es, como veremos no Cap\'edtulo 8, \ldblquote Sobrecarga de operadores\rdblquote . \line Para declarar uma fun\'e7\'e3o como um friend de uma classe, preceda o prot\'f3tipo da fun\'e7\'e3o na defini\'e7\'e3o da \line classe com a palavra-chave friend. Para declarar a classe ClassTwo como um friend da classe ClassOne. coloque uma declara\'e7\'e3o da forma \line friend class ClassTwo; \line na defini\'e7\'e3o da classe ClassOne. \line\i Observa\'e7\'e3o de engenharia de software 7.9 \line\i0\f2\fs8 ______ \i\f0\fs18 Embora os prot\'f3tipos para fun\'e7\'f5es \b\i0\fs16 friend \b0\i\fs18 apare\'e7am na defini\'e7\'e3o da classe, ainda assim \b\i0\fs16 friends \b0\i\fs18 n\'e3o s\'e3o fun\'e7\'f5es membro. \i0\fs24\par
\f1\fs38 LI \f0\fs24\par
\pard\par
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx3457\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4430\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx5727\pard\intbl\b\f3\fs18 Testa o construtor de Date com \b0\f0\fs24\cell\b\f3\fs18 valores \b0\f0\fs24\cell\b\f3\fs18 inv\'e1lidos: \b0\f0\fs24\cell\fs20\row
\b\f3\fs18\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx3457\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4430\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx5727\intbl M\'eas 14 inv\'e1lido. Inicializa m\'eas \b0\f0\fs24\cell\b\f3\fs18 com 1. \b0\f0\fs24\cell\cell\fs20\row
\b\f3\fs18\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx3457\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4430\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx5727\intbl Dia 35 inv\'e1lido. Inicializa dia \b0\f0\fs24\cell\b\f3\fs18 com 1. \b0\f0\fs24\cell\cell\fs20\row
\b\f3\fs18\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx3457\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4430\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx5727\intbl Construtor do objeto Date para \b0\f0\fs24\cell\b\f3\fs18 a data \b0\f0\fs24\cell\b\f3\fs18 1/1/1994 \b0\f0\fs24\cell\fs20\row
\b\f3\fs18\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx3457\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4430\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx5727\intbl Destruidor do objeto Date para \b0\f0\fs24\cell\b\f3\fs18 a data \b0\f0\fs24\cell\b\f3\fs18 1/1/1994 \b0\f0\fs24\cell\fs20\row
\b\f3\fs18\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx3457\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4430\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx5727\intbl Destruidor do objeto Employee: \b0\f0\fs24\cell\b\f3\fs18 Silva, \b0\f0\fs24\cell\b\f3\fs18 Jos\'e9 \b0\f0\fs24\cell\fs20\row
\b\f3\fs18\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx3457\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4430\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx5727\intbl Destruidor do objeto Date para \b0\f0\fs24\cell\b\f3\fs18 a data \b0\f0\fs24\cell\b\f3\fs18 3/12/1988 \b0\f0\fs24\cell\fs20\row
\b\f3\fs18\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx3457\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4430\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx5727\intbl Destruidor do objeto Date para \b0\f0\fs24\cell\b\f3\fs18 a data \b0\f0\fs24\cell\b\f3\fs18 7/24/1949 \b0\f0\fs24\cell\fs20\row
\pard\fs24\par
\pard\sb100\sa240\b\f2\fs22 466 \b0\f0\fs18 C++ \b\fs14 COMO \f2 PROGRAMAR \line\b0\i\f0\fs20 Observa\'e7\'e3o de engenharia de software 7.10 \line\i0\f2\fs8 ______ \i\f0\fs18 As no\'e7\'f5es de acesso a membros \i0 private, protected \i e \i0\f2 public \i\f0 n\'e3o s\'e3o relevantes para as declara\'e7\'f5es de rela\'e7\'f5es \i0 friend, \i de modo que as declara\'e7\'f5es de rela\'e7\'f5es \i0 friend \i podem ser colocadas em \line qualquer lugar na defini\'e7\'e3o da classe. \line Boa pr\'e1tica de programa\'e7\'e3o 7.2 \line Coloque todas as declara\'e7\'f5es \i0 friend \i no in\'edcio da classe, logo depois do cabe\'e7alho da classe, e n\'e3o as \line preceda com quaisquer especificadores de acesso a membros. \line\i0 A condi\'e7\'e3o de friend \'e9 concedida, n\'e3o tomada; i.e., para a classe B ser friend da classe A, a classe A deve \line declarar explicitamente a classe B como sua friend. Al\'e9m disso, a condi\'e7\'e3o de friend n\'e3o \'e9 nem sim\'e9trica nem \line transitiva: i.e., se a classe A \'e9 friend da classe B e a classe B \'e9 friend da classe C, voc\'ea n\'e3o pode deduzir que \line a classe B \'e9 friend da classe A (repetindo, a condi\'e7\'e3o friend n\'e3o \'e9 sim\'e9trica), que a classe C \'e9 friend da \line classe B, ou que a classe A \'e9 friend da classe C (repetindo, friend n\'e3o \'e9 transitiva). \line\i\fs20 Observa\'e7\'e3o de engenharia de software 7.11 \line Algumas pessoas na comunidade de OOP consideram que a no\'e7\'e3o de \i0\fs18 friend \i corrompe a oculta\'e7\'e3o de \line informa\'e7\'f5es e enfraquece o valor da abordagem de projeto orientado a objetos. \line\i0 A Fig. 7.5 demonstra a declara\'e7\'e3o e uso da fun\'e7\'e3o friend setx para inicializa\'e7\'e3o do membro de dados private x da classe count. Note que a declara\'e7\'e3o de friend aparece primeiro (por conven\'e7\'e3o) na declara\'e7\'e3o da classe, mesmo antes de as fun\'e7\'f5es membro public serem declaradas, O programa da Fig. 7.6 demonstra as mensagens produzidas pelo compilador quando a fun\'e7\'e3o n\'e3o-friend cannotSetX \'e9 chamada para modificar o membro de dados private x. As Figs. \i 7.5 \i0 e 7.6 t\'eam por objetivo apresentar a \ldblquote mec\'e2nica\rdblquote  do uso de fun\'e7\'f5es friend \line exemplos pr\'e1ticos do uso de fun\'e7\'f5es friend aparecer\'e3o nos cap\'edtulos mais \'e0 frente. \line\b\f3\fs16 1 \b0\i\f0\fs20 II \b\i0\f3\fs16 Fig. 7.5: \b0\f0\fs18 figO7O5.cpp \line\b\f3\fs16 2 //Friends podem acessar membros private de \b0\f0\fs18 uma \b\f3\fs16 classe. \line 3 #include <iostream> \line 4 \line 5 using std: :cout; \line 6 using std::endl; \line 7 \line 8 \b0\i\f0\fs20 /1 \b\i0\f3\fs16 Classe Count modificada \line 9 class Count \line 10 friend void setX( Count \f0\fs14 &, \f3\fs16 int ); \b0\i\f0\fs20 /1 \b\i0\f3\fs16 Declara\'e7\'e3o de friend \line 11 public: \line 12 Count() \b0\i\f0\fs20\{ x \i0\f2\fs10 = \b\f3\fs16 0; \b0\i\f0\fs20\} II \b\i0\f3\fs16 Construtor \line 13 void print() const \b0\i\f0\fs20\{ \b\i0\f3\fs16 cout \'ab x \'ab eridl; \b0\i\f0\fs20\} II \b\i0\f3\fs16 sa\'edda \line 14 private: \line 15 int x; \b0\i\f0\fs20 II \b\i0\f3\fs16 membro de dados \line 16 \line 17 \line 18 \b0\i\f0\fs20 II \b\i0\f3\fs16 Pode modificar dados private de Count porque \line 19 \b0\i\f0\fs20 /1 \b\i0\f3\fs16 setX \'e9 declarada como \b0\f0\fs18 unia \b\f3\fs16 fun\'e7\'e3o friend de Count \line 20 void setX \b0\i\f0\fs20 ( \b\i0\f3\fs16 Count &c, int val \line 21 \line 22 c.x \b0\f2\fs10 = \b\f3\fs16 val; \b0\i\f0\fs20 II \b\i0\f3\fs16 v\'e1lido: setX \'e9 fun\'e7\'e3o friend de Count \line 23 \line 24 \line 25 int main \b0\i\f0\fs20 Q \line\b\i0\f3\fs16 26 \line\b0\f2\fs20 Fig. 7.5 friendS podem acessar membros private de uma classe (parte 1 de 2). \f0\fs24\par
\fs16 CAP\'cdTULO \i\fs20 7 \i0\f2\fs8 - \f0\fs16 CLASSES: PARTE II \i\f2\fs22 467 \line\i0\f0\fs16 27 Count counter; \line 28 \line\f3 29 cout \'ab \lquote counter.x ap\'f3s instancia\'e7\'e3o: \line 30 counter.print \i\f2\fs22 O; \line\i0\f3\fs16 31 cout \f0\'ab \f3\ldblquote counter.x ap\'f3s chamada \'e0 fun\'e7\'e3o friend setX: \line 32 setX( counter, 8 ); \i\f0\fs18 II \i0\f3\fs16 inicializa x com \f0\fs20 urna \f3\fs16 fun\'e7\'e3o friend \line 33 counter.printO; \line 34 return 0; \line 35 \i\f2\fs22\} \i0\f0\fs24\par
\f2\fs20 Fig. 7.5 \f0\fs18 friendS \f2\fs20 podem acessar membros private de uma classe (parte 2 de 2). \line\f0\fs18 Note que a fun\'e7\'e3o setX (linha \f2\fs20 20) \i\f0\'e9 \i0\fs18 uma fun\'e7\'e3o ao estilo da programa\'e7\'e3o em C, uma fun\'e7\'e3o isolada \f2\fs8 - \f0\fs18 ela n\'e3o \'e9 \line uma fun\'e7\'e3o membro da classe Count. Por essa raz\'e3o, quando setX \'e9 invocada para o objeto counter, usamos o \line comando na linha 32 \line setX( counter, 8 ); \i II \i0 setX com uma fun\'e7\'e3o friend \line que recebe counter como um argumento em vez de usar um \i\fs20 handle \i0\fs18 (tal como o nome do objeto) para chamar a fun\'e7\'e3o, como em \line\f3 counter.setX( 8 ); \line Como mencionamos, a Fig. \f0 7.5 \'e9 um exemplo mec\'e2nico da constru\'e7\'e3o \f3 friend. Normalmente, seria apropriado \f0 definir a fun\'e7\'e3o \b\f2 setX \b0\f0 como uma fun\'e7\'e3o membro da classe Count. \line\i\fs20 Observa\'e7\'e3o de engenharia de software 7.12 \line\i0\f2\fs8 ______ \i\f0\fs18 Como C++ \'e9 uma linguagem h\'edbrida, \'e9 comum ter-se uma mistura de dois tipos de chamadas de fun\'e7\'e3o em um programa efreq\'fcentemente lado a lado \i0\f2\fs8 - \i\f0\fs18 chamadas ao estilo de C, que passam dados primitivos ou objetos para fun\'e7\'f5es, e chamadas no estilo pr\'f3prio de C+ \i0 +, \i que passam fun\'e7\'f5es (ou mensagens) para objetos. \line\i0\f3 1 \i\f2\fs22 II \i0\f3\fs18 Fig. 7.6: figO7_06.cpp \line 2 \i\f2\fs24 II \i0\f3\fs18 Fun\'e7\'f5es n\'e3o-friend \i\f2\fs24 / \i0\f3\fs18 n\'e3o-membro n\'e3o podem \line 3 \i\f2\fs24 II \i0\f3\fs18 acessar dados private de \f0 urna \f3 classe. \line 4 #include <iostream> \line 5 \line 6 using std::cout; \line 7 using std: :endl; \line 8 \line 9 \i\f2\fs24 II \i0\f3\fs18 Classe Count modificada \line 10 class Count \f0\{ \line\f3 11 \f0 public: \line\f3 12 Count() \f0\{ x \f2\fs12 = \f3\fs18 O; \f0\} \i\f2\fs24 II \i0\f3\fs18 construtor \line 13 void print() const \f0\{ \f3 cout \f2\fs24\'ab \f3\fs18 x \'ab endl; \f0\} \i\f2\fs24 II \i0\f3\fs18 sa\'edda \line 14 private: \line 15 int x; \i\f0\fs20 II \i0\f3\fs18 membro de dados \line\f2\fs20 Fig. \b\fs18 7.6 \b0\f3 Fun\'e7\'f5es n\'e3o-friend \i\f2\fs22 / \i0\fs20 n\'e3o-membro n\'e3o podem acessar membros de classe private (parte 1 de 2). \f0\fs24\par
\pard\par
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1081\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1730\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx5295\pard\intbl\f3\fs18 counter.x \f0\fs24\cell\f3\fs18 ap\'f3s \f0\fs24\cell\f3\fs18 instancia\'e7\'e3o: O \f0\fs24\cell\fs20\row
\f3\fs18\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1081\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1730\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx5295\intbl counter.x \f0\fs24\cell\f3\fs18 ap\'f3s \f0\fs24\cell\f3\fs18 chamada \'e0 fun\'e7\'e3o friend setX: 8 \f0\fs24\cell\fs20\row
\pard\fs24\par
\pard\sb100\sa240\b\f2\fs22 468 \b0\fs20 C++ \b\f0\fs14 COMO \f2 PROGRAMAR \line\f0\fs18 16 \line\b0\f3 17 \line 18 \i\f2\fs24 II \i0\f3\fs18 Fun\'e7\'e3o tenta modificar dados private de Count, \line 19 \i\f2\fs24 II \i0\f3\fs18 mas n\'e3o pode porque n\'e3o \'e9 \f0 uma \f3 fun\'e7\'e3o friend de Count. \line 20 void cannotSetX( Count &c, int vai \line 21 \line 22 \b c.x \b0\f2\fs12 = \f3\fs18 vai; \i\f2\fs24 II \i0\f3\fs18 ERRO: \lquote Count: :x\rquote  n\'e3o \'e9 acess\'edvel \line\f0 23 \b\f2\fs22\} \line\b0\f3\fs18 24 \line 25 int main \b\f2\fs22 Q \line\b0\f3\fs18 26 \line 27 Count counter; \line 28 \line 29 cannotSetX( counter, 3 ); \i\f2\fs24 II \i0\f3\fs18 cannotSetx n\'e3o \'e9 \f0 uma \f3 fun\'e7\'e3o friend \line 30 return 0; \line 31 \line\i\f0\fs16 Mensagens de erro do compilador Borland C+ \b\i0\fs14 + \b0\i\fs16 com linha de comando \line\i0\f3\fs18 Borland C++ 5.5 \f0 for \f3 Win32 Copyright (c) 1993, 2000 Borland \line Fig0706 \f2\fs8 . \f3\fs18 cpp: \line Error E2247 FigO7_06.cpp 22: Count::x\rquote  is not acessibie in \line function cannotSetX(Count &,int) \line\f2\fs10 *** \f3\fs18 1 errors in Compile \f2\fs10 *** \line\i\f0\fs16 Mensagens de erro do compilador Microsofi Visual C+ \b\i0\fs14 + \line\b0\fs18 Compiiing... \line\f3 FigO 7_06 \f2\fs8 . \f3\fs18 cpp \line D: \\books\\2000\\cpphtp3\\exampies\\Ch07\\FigO7 06\\FigO7 06. cpp (22) error C2248: \lquote x\rquote  : cannot access private member deciared in \line class Count \line D: \\books\\2000\\cpphtp3\\examples\\Ch07\\Fig0706\\ \line Fig0706.cpp(15) : see deciaration of \b\lquote x \line\b0 Error executing cl.exe. \line test.exe \f2\fs8 - \f0\fs18 1 error(s), O warning(s) \line\b Fig. 7.6 \b0\f2\fs20 Fun\'e7\'f5es \f0\fs18 n\'e3o-friend \f2\fs20 / n\'e3o-membro n\'e3o podem acessar membros de classe \b\f0\fs18 private \b0\f2\fs20 (parte 2 de \b\f0\fs18 2). \line\b0\f1\fs26\'c9 \f0\fs18 poss\'edvel especificar fun\'e7\'f5es sobrecarregadas como friends de uma classe. Cada fun\'e7\'e3o sobrecarregada com inten\'e7\'e3o de ser um friend deve ser explicitamente declarada na defini\'e7\'e3o da classe como um friend da classe. \line\b\f2\fs26 7.5 Usando o ponteiro this \line\b0\f1\fs50 4 \f0\fs18 Todo objeto tem acesso ao seu pr\'f3prio endere\'e7o atrav\'e9s de um ponteiro chamado this. O ponteiro this de um objeto n\'e3o faz parte do objeto propriamente dito \f2\fs8 - \f0\fs18 exemplo: o tamanho do ponteiro this n\'e3o \'e9 computado no resultado de uma opera\'e7\'e3o sizeof sobre o objeto. Em vez disso, o ponteiro this \'e9 passado para o objeto (pelo compilador) como primeiro par\'e2metro impl\'edcito em toda chamada de fun\'e7\'e3o membro n\'e3o-static para o objeto (membros static s\'e3o discutidos na Se\'e7\'e3o 7.7). \line O ponteiro this \'e9 implicitamente usado para prover refer\'eancia tanto para os membros de dados como para as fun\'e7\'f5es membro de um objeto; tamb\'e9m pode ser usado explicitamente. O tipo do ponteiro this depende do tipo do \fs24\par
\fs18 CAP\'cdTULO \i\fs20 7 \i0\f2\fs8 - \f0\fs18 CLASSES: PARTE II \b\f2\fs22 469 \line\b0\f0\fs18 objeto e de se a fun\'e7\'e3o membro em que this \'e9 usado \'e9 declarada const ou n\'e3o. Em uma fun\'e7\'e3o membro n\'e3o- constante da classe Employee, o ponteiro this tem o tipo Employee \f2\fs12 * \f0\fs18 const (um ponteiro constante para um um objeto de Employee). Em uma fun\'e7\'e3o membro constante da classe Employee. o ponteiro this tem o tipo de dado const Employee \f2\fs12 * \f0\fs18 const (um ponteiro constante para um objeto Employee que \'e9 constante). \line No momento, mostraremos um exemplo simples do uso expl\'edcito do ponteiro this: mais tarde, neste cap\'edtulo e no Cap\'edtulo 8, mostraremos alguns exemplos significativos e sutis de uso de this. Toda fun\'e7\'e3o membro n\'e3ostatic tem acesso ao ponteiro this para o objeto para o qual o membro est\'e1 sendo invocado. \line\i\fs20 Dica de desempenho 7.3 \line\i0\f2\fs8 ______ \i\f0\fs20 Por motivos de economia de mem\'f3ria e armazenamento, existe s\'f3 uma c\'f3pia de cada fun\'e7\'e3o membro por classe e essa fun\'e7\'e3o membro \'e9 invocada para todos os objetos daquela classe. Cada objeto, por outro \line lado, tem sua pr\'f3pria c\'f3pia dos membros de dados da classe. \line\i0\fs18 A Fig. 7.7 demonstra o uso expl\'edcito do ponteiro this para habilitar uma fun\'e7\'e3o membro da classe Test a imprimir o dado privado x de um objeto de Test. \line\b\f3\fs16 1 \b0\i\f0\fs20 II \b\i0\f3\fs16 Fig. 7.7: figO7O7.cpp \line 2 \b0\f0\fs18 // \b\f3\fs16 Usando o ponteiro this para referenciar membros de objetos. \line 3 #include <iostreain> \line\b0\f2\fs20 4 \line\b\f3\fs16 5 using std::cout; \line 6 using std::endl; \line 7 \line 8 class Test \line 9 \b0\f0\fs18 public: \line\b\f3\fs16 10 Test( int \b0\f2\fs12 = \b\f3\fs16 O ); \b0\f0\fs18 // \b\f3\fs16 construtor default \line 11 void print() const; \line 12 private: \line 13 int x; \line 14 \}; \line 15 \line 16 Test::Test( int a \b0\f0\fs18 ) \{ \b\f3\fs16 x= a; \b0\f0\fs18\} \i\fs20 II \b\i0\f3\fs16 construtor \line 17 \line 18 void Test: :print() const \b0\i\f0\fs20 II () \b\i0\f3\fs16 em volta de *this obrigat\'f3rios \line 19 \line 20 cout \'ab \b0\f2\fs8\ldblquote  \b\f3\fs16 x \b0\f2\fs12 = \f0\fs18\'ab x \line\b\f3\fs16 21 \'ab \\n this->x \b0\f2\fs12 = \f0\fs18\'ab \b\f3\fs16 this->x \line 22 \'ab \\n(*this) .x \b0\f2\fs12 = \ldblquote  \f0\fs18\'ab ( \b\f3\fs16 *this \b0\f0\fs18 ) .x \'ab \b\f3\fs16 endl; \line 23 \line 24 \line 25 int ntain() \line 26 \b0\f0\fs18\{ \line\b\f3\fs16 27 Test test0bject( 12 ); \line 28 \line 29 testobject.printO; \line 30 \line 31 return 0; \line 32 \b0\f0\fs18 ) \fs24\par
\f2\fs20 Fig. 7.7 Usando o ponteiro this. \f0\fs24\par
\pard\par
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx781\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1515\pard\intbl\cell\b\f2\fs14 x \b0\fs12 = \b\f3\fs16 12 \b0\f0\fs24\cell\fs20\row
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1515\pard\intbl\b\f3\fs16 this->x 12 \b0\f0\fs24\cell\fs20\row
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx781\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1515\pard\intbl\b\f3\fs16 (*this) \b0\f0\fs24\cell\b\f3\fs14 .x \b0\f2\fs12 = \b\f3\fs14 12 \b0\f0\fs24\cell\fs20\row
\pard\fs24\par
\pard\sb100\sa240\b\fs14 470 C++ \b0\fs16 COMO PROGRAMAR \line Para fins de ilustra\'e7\'e3o, a fun\'e7\'e3o membro print na Fig. 7.7 primeiro imprime x diretamente. A seguir, print usa 2 \line duas nota\'e7\'f5es diferentes para acessar x atrav\'e9s do ponteiro this \f2\fs8 - \f0\fs16 o operador seta \b\fs14 (->) \b0\fs16 do ponteiro this e o 2 \line operador ponto \b\i\f2\fs14 (.) \b0\i0\f0\fs16 do ponteiro this derreferenciado. \line Note os par\'eanteses ao redor de *this quando ele \'e9 usado com o operador de sele\'e7\'e3o de membro ponto \b\i\f2\fs14 (.). \b0\i0\f0\fs16 3( \line Os par\'eanteses s\'e3o necess\'e1rios porque o operador ponto tem preced\'eancia mais alta que o operador \b\fs14 . \b0\fs16 Sem os par\'ean- 3 \line teses, a express\'e3o 3\bullet  \line 3 \line\b\f3 *thjsx \b0\f2\fs8 - \line\fs20 Fi \line\f0\fs16 seria avaliada como se estivesse entre par\'eanteses, como segue: \line *( this.x \line o que \'e9 um erro de sintaxe, pois o operador ponto n\'e3o pode ser usado com um ponteiro. \line\i\fs18 Erro com um de programa\'e7\'e3o 7.7 \line Tentar usar o operador de sele\'e7\'e3o de membro ( \b\f2\fs14 .) \b0\f0\fs18 com um ponteiro para um objeto \'e9 um erro de sintaxe \i0\f2\fs8 - \i\f0\fs18 o operador de sele\'e7\'e3o de membro ponto s\'f3 pode ser usado com um objeto ou com uma refer\'eancia para um objeto. \line\i0\fs16 Um uso interessante do ponteiro this \'e9 evitar que um objeto seja atribu\'eddo a si pr\'f3prio. Como veremos no Cap\'edtulo 8, \ldblquote Sobrecarga de operadores\rdblquote , a atribui\'e7\'e3o a si pr\'f3prio pode produzir erros s\'e9rios quando os objetos contiverem ponteiros para mem\'f3ria alocada dinamicamente. \line Outro uso do ponteiro this \'e9 habilitar chamadas a fun\'e7\'f5es membro em cascata. A Fig. 7.8 ilustra retornar uma refer\'eancia para um objeto Time para habilitar chamadas em cascata de fun\'e7\'f5es membro da classe Time. Cada uma das fun\'e7\'f5es membro setTime. setHour, setMinute e setSecond retorna *this com um tipo de retorno Time \b\fs14 &. \line\f3\fs16 1 \b0\i\f0\fs18 II \b\i0\f3\fs16 Fig. 7.8: time6.h \line 2 \b0\f0 // \b\f3 Encadeando chamadas a fun\'e7\'f5es membro. \line\b0\f0 3 \line\b\f3 4 \b0\f0 // Declara\'e7\'e3o da classe \b\f3 Time. \line 5 \b0\i\f0\fs18 II \b\i0\f3\fs16 Fun\'e7\'f5es membro definidas em time6.cpp \line\b0\f0 6 #ifndef TIME6H \line 7 #define TIME6H \line 8 \line\b\f3 9 class Time \line\b0\f0 10 public: \line\b\f3 11 Time( int \b0\f2\fs10 = \b\f3\fs16 O, int \b0\f2\fs10 = \b\f3\fs16 O, int \b0\f2\fs10 = \b\f3\fs16 O ); \b0\i\f0\fs18 II \b\i0\f3\fs16 construtor default \line 12 \line 13 \b0\i\f0\fs18 II \b\i0\f3\fs16 fun\'e7\'f5es de inicializa\'e7\'e3o \line 14 Time &setTime( int, int, int ); \b0\i\f0\fs18 1/ \b\i0\f3\fs16 inicializa hour, minute, second \line 15 Time &setHour( int \b0\f0 ); \i\fs18 II \b\i0\f3\fs16 inicializa hour \line 16 Time &setMinute( int \b0\f0 ); \i\fs18 II \b\i0\f3\fs16 inicializa minute \line 17 Time &setSecond( int \b0\f0 ); \i\fs18 II \b\i0\f3\fs16 inicializa second \line 18 \line 19 \b0\f0 // \b\f3 fun\'e7\'f5es para obter dados (normalmente declaradas const) \line 20 int getHour() const; \b0\i\f0\fs18 II \b\i0\f3\fs16 retorna hour \line 21 \b0\f0 int \b\f3 getMinute() const; \b0\i\f0\fs18 II \b\i0\f3\fs16 retorna minute \line 22 int getSecond() const; \b0\i\f0\fs18 II \b\i0\f3\fs16 retorna second \line\b0\f0 23 \line\b\f3 24 \i\f2\fs14 II \i0\f3\fs16 fun\'e7\'f5es print (normalmente declaradas const) \line 25 void printMilitary() const; \b0\i\f0\fs18 II \b\i0\f3\fs16 imprime o tempo militar \b0\f0\fs24\par
\b\f2\fs18 Fig. 7.8 \b0 Encadeando chamadas a fun\'e7\'f5es membro \fs8 - \fs18 time6 \b\i\fs14 . \b0\i0\fs18 h (parte 1 de 2). \f0\fs24\par
\fs16 CAP\'cdTULO 7 \f2\fs8 - \f0\fs16 CLASSES: PARTE II \b\f2\fs18 471 \line\b0\f0\fs16 void printStandard() const; \i\f2\fs22 II \i0\f0\fs16 imprime o tempo padr\'e3o \line\b\f3 private: \line int hour; \b0\f0 // O \f2\fs8 - \b\f3\fs16 23 \line int minute; \b0\i\f2\fs20 II \b\i0\f3\fs16 O \b0\f2\fs8 - \b\f3\fs16 59 \line int second; \b0\f0 // O \f2\fs8 - \b\f3\fs16 59 \line\f2\fs20 Fig. \b0 7.8 Encadeando chamadas a fun\'e7\'f5es membro \fs8 - \f0\fs16 time \f2\fs20 6. h (parte 2 de 2). \line\f0\fs16 Por que a t\'e9cnica de retornar *this como uma refer\'eancia funciona? O operador ponto \b\f2\fs18 (.) \b0\f0\fs16 se associa da esquelua para a direita, de modo que a express\'e3o \line t.setHour( 18 ) .setNinute( 30 ) .setSecond( 22 ); \line primeiro avalia t. setHour \b\f2\fs18 ( \b0\f0\fs16 18 \b\f2\fs18 ) \b0\f0\fs16 e ent\'e3o retorna uma refer\'eancia para o objeto t como o valor desta chamada da fun\'e7\'e3o. A express\'e3o restante \fs20\'e9 \fs16 ent\'e3o interpretada como \line t.setNinute( 30) .setSecond( 22); \line A chamada t. setMinute \b\f2\fs18 ( \b0\f0\fs16 30 \'e9 executada e retorna o equivalente de t. A express\'e3o restante \'e9 interpretada como \line t.setSecond( 22) \line Note que as chamadas \line t.setTime(20, 20, 20) .printStandardO; \line tamb\'e9m usam o recurso de cascateamento. Essas chamadas devem aparecer nesta express\'e3o nessa ordem, porque printStandard. como definida na classe, n\'e3o retorna uma refer\'eancia para t. Colocar a chamada para \b\f3 printStandard, \b0\f0 no comando precedente, antes da chamada para setTime. resulta em um erro de sintaxe. \line\i\f2\fs20 II \b\i0\f3\fs16 Fig. 7.8: time6.cpp \line\b0\f0 // Defini\'e7\'f5es de fun\'e7\'f5es membro para a classe Time. \line\b\f3 #include <iostream> \line 38 using std: :cout; \line 39 \line 40 #include \ldblquote time6.h\rdblquote  \line\b0\f0 // \b\f3 Fun\'e7\'e3o construtor para inicializar dados private. \line\b0\i\f2\fs22 II \i0\f0\fs16 Chama fun\'e7\'e3o membro setTime para inicializar vari\'e1veis. \line // Valores default s\'e3o O (ver defini\'e7\'e3o da classe) \line\b\f3 Time::Time( int hr, int mm, int sec \line\f2\fs20\{ \f3\fs16 setTime( hr, mi sec ); \b0\f0\} \line 48 // Inicializa os valores de hour, minute e second. \line\b\f3 49 Time &Time::setTime( int h, int m, int s \line\b0\f0 setHour ( \b\f3 h ); \line\b0\f0 setMinute ( \b\f3 m ); \line setSecond( s ); \b0\f0\fs24\par
\fs16 b usa 3 eo \fs24\par
\pard\sb100\sa100\fs18 ar\'ean 26 \fs24\par
\pard\sb100\sa240\b\f3\fs16 27 \line 28 \line 29 \line 30 \line\b0\f0\fs18 31 \}; \line\b\f3\fs16 32 \line 33 #endif \b0\f0\fs24\par
\i\f2\fs18 xe \i0\fs12 - \f0\fs24\par
\fs14 i \i\f2\fs18 um \i0\f0\fs24\par
\fs16\'edtulo \line Tem \fs24\par
\fs18 mar ada \fs24\par
\fs18 a de \fs24\par
\b\f3\fs16 34 \line 35 \line 36 \line 37 \b0\f0\fs24\par
\b\f3\fs16 41 \line 42 \line 43 \line 44 \line 45 \line 46 \line 47 \b0\f0\fs24\par
\f2\fs20 50 \{ \line\b\f3\fs16 51 \line 52 \line 53 \b0\f0\fs24\par
\b\f2\fs20 Fig. 7.8 \b0\fs18 Encadeando chamadas a fun\'e7\'f5es membro \fs8 - \fs18 time6 \b . \b0 cpp (parte 1 de 2). \f0\fs24\par
\f2\fs20 472 C\'f7+ \f0\fs16 COMO PROGRAMAR \line\f3 54 return *thjs; \f2\fs20 // \f0\fs16 habilita o encadeamento 1C \line 55 \f2\fs20\} \f0\fs16 1C \line 56 li \line\f3 57 \f2\fs20 // \f3\fs16 Inicializa o valor de hour \f0 1 \line\f3 58 Time &Time::setHour( int h \f2\fs20 ) \f0\fs16 1] \line 59 \f2\fs20\{ \f0\fs16 1] \line\f3 60 hour=(h>=0&&h<24)?h:0; 11 \line 61 1] \line 62 return *this; \i\f2\fs22 II \i0\f3\fs16 habilita o encadeamento 1] \line 63 \f2\fs20\} \f0\fs16 1 \line 64 \line 65 \f2\fs20 // \f3\fs16 Inicializa o valor de minute \f2\fs12 11 \line\f3\fs16 66 Time &Time: :setMinute( int m \line\f0 67 \line\f3 68 minute \f2\fs12 = \fs20 ( \f3\fs16 m \f2\fs12 >= \f0\fs16 O \f3 && m < 60 \f2\fs20 ) \f3\fs16 ? m : 0; \line 69 \line 70 return *this; \f2\fs20 // \f3\fs16 habilita o encadeamento \line 71 \line 72 \line 73 \f2\fs20 // \f3\fs16 Inicializa o valor de second \line 74 Time &Time::setSecond( int s \line\f0 75 \f2\fs20\{ \line\f3\fs16 76 second \f2\fs12 = \fs20 ( \b\f0\fs10 s \b0\f2\fs12 >= \f0\fs16 O \f3 && s \f0 < \f3 60 \f2\fs20 ) \f0\fs16 ? \f3 s : 0; \line\f0 77 \line\f3 78 return *this; \i\f2\fs22 1/ \i0\f3\fs16 habilita o encadeamento \line\f0 79 \f2\fs20\} \line\f0\fs16 80 \line\f3 81 \f2\fs20 // \f3\fs16 Obt\'e9m o valor de hour \line 82 int Time; :getHour() const \f2\fs20\{ \f3\fs16 return hour; \line 83 \line 84 \f2\fs20 // \f3\fs16 Obt\'e9m o valor de minute \line 85 int Time::getMinute() const return minute; \line 86 \line\f0 87 \f2\fs20 // \f3\fs16 Obt\'e9m o valor de second \i\f2\fs22 7 \line\i0\f3\fs16 88 int Time: :getSecond() const \f2\fs20\{ \f3\fs16 return second; \line\f0 89 \line 90 \f2\fs20 // \f3\fs16 Exibe o tempo no formato militar: HH:MM \line 91 void Time: :printMilitary() const (p \line 92 \f2\fs20\{ C \line\f0\fs16 93 cout \'ab \f2\fs20 ( \f0\fs16 hour < 10 ? \ldblquote 0\rdblquote  : \f2\fs8\ldblquote  \ldblquote  \fs20 ) \f0\fs16\'ab hour \'ab \line 94 \'ab \f2\fs20 ( \f0\fs16 minute < 10 ? \ldblquote 0\rdblquote  : \f2\fs8\ldblquote  \ldblquote  \fs20 ) \f0\fs16\'ab minute; \line 95 \f2\fs20\} \line\f0\fs16 96 \line\f3 97 \f2\fs20 // \f3\fs16 Exibe o tempo no formato padr\'e3o: HH:4:SS da manh\'e3 (ou tarde) \line 98 void Time: :printStandard() const \line\f0 99 \f2\fs20\{ \line\f3\fs16 100 cout\'ab \f2\fs20 ( ( \f3\fs16 hour \f2\fs12 == \f3\fs16 O hour \f2\fs12 == \f3\fs16 12 \f2\fs20 ) \f0\fs16 ? \f3 12 : hour % 12 \line\f0 101 \'ab \b\fs10\ldblquote :\ldblquote  \b0\fs16\'ab \f2\fs20 ( \f3\fs16 minute < 10 ? \ldblquote 0\rdblquote  : \b\f0\fs10\ldblquote  \ldblquote  \b0\f2\fs20 ) \f0\fs16\'ab minute \line 102 \b\fs10\ldblquote :\ldblquote  \b0\fs16\'ab \f2\fs20 ( \f0\fs16 second < 10 ? \ldblquote 0\rdblquote  : \b\fs10\ldblquote  \b0\f2\fs20 ) \f0\fs16\'ab second \f2\fs8 - \line\f0\fs16 103 \'ab \f2\fs20 ( \f0\fs16 hour < 12 ? \b\fs10\ldblquote  \b0\fs16 da manh\'e3\rdblquote  \f2\fs12 ; \lquote  \f0\fs16 da tarde\rdblquote  ); fu \line 104\} m \line\f2\fs20 Fig. 7.8 Encadeando chamadas a fun\'e7\'f5es membro \fs8 - \b\f0\fs10 time \b0\f2\fs20 6 \fs8 . \fs20 cpp (parte 2 de 2). \line\f0\fs16 105 \i\f2\fs22 II \i0\f0\fs16 Fig. 7.8: figO7OB.cpp \f2\fs20 O \line\f0\fs16 106 \f2\fs20 // \f3\fs16 Encadeando chamadas a fun\'e7\'f5es membro \f0 P( \line 107 \i\f2\fs22 1/ \i0\f0\fs16 em conjunto com o ponteiro this ar \line\b\f2\fs18 Fig. \b0\fs20 7.8 Encadeando chamadas a fun\'e7\'f5es membro \fs8 - \f0\fs16 time 6 \f2\fs8 . \fs20 cpp (parte 1 de 2). te, \f0\fs24\par
\fs16 CAP\'cdTULO 7 \f2\fs8 - \f0\fs16 CLASSES: PARTE \fs22 11 473 \fs24\par
\b\f3\fs16 108 #include <iostream> \line 109 \line 110 using std::cout; \line 111 using std::endl; \line 112 \line 113 #include \ldblquote time6.h\rdblquote  \line 114 \line 115 int main \b0\f0\fs22 O \line\b\f3\fs16 116 \b0\f0\fs22\{ \line\b\f3\fs16 117 Time t; \line 118 \line 119 t.setHour( 18 \b0\f0\fs22 ) \b\f3\fs16 .setMinute( 30 \b0\f0\fs22 ) \b\f3\fs16 .setSecond( 22 ); \line 120 cout \'ab \ldblquote Hora militar: \b0\f2\fs10\ldblquote ; \line\b\f3\fs16 121 t.printNilitaryO; \line 122 cout \'ab \ldblquote\\nHora padr\'e3o: \line 123 t.printStandard \line 124 \line 125 cout \'ab \ldblquote\\n\\nNova hora padr\'e3o: \line 126 t.setTime( 16, 20, 20 ).printStandardO; \line 127 cout \'ab endl; \line 128 \line 129 return 0; \line 130 \b0\f0\fs22\} \line\b\f3\fs16 Hora militar: 18:30 \line Hora padr\'e3o: 6:30:22 da tarde \line Nova hora padr\'e3o: 4:20:20 da tarde \line\f2\fs18 Fig. \f3 7.8 \b0\f2\fs20 Encadeando chamadas a fun\'e7\'f5es membro \fs8 - \fs20 figo7 08 \fs8 . \f3\fs18 cpp (parte \f2\fs20 2 de 2). \line\b\fs26 7.6 Aloca\'e7\'e3o din\'e2mica de mem\'f3ria com os operadores \f0\fs22 new \f2\fs26 e \b0\f0\fs22 delete \line Os operadores new e delete fornecem um meio mais agrad\'e1vel de executar a aloca\'e7\'e3o din\'e2mica de mem\'f3ria \line (para qualquer tipo primitivo ou definido pelo usu\'e1rio) do que com as chamadas das fun\'e7\'f5es malloc e free de C. \line Considere o seguinte c\'f3digo \line\fs16 TypeName \f2\fs10 * \f0\fs16 typeNamePtr; \line Em ANSI/C, para criar dinamicamente um objeto do tipo TypeName, voc\'ea faria \line typeNamePtr \f2\fs10 = \f0\fs16 malloc( sizeof( TypeName \fs22 ) ); \line Isso exige uma chamada da fun\'e7\'e3o malloc e o uso expl\'edcito do operador sizeof. Em vers\'f5es de C anteriores ao ANSI/C, voc\'ea tamb\'e9m teria que fazer uma coer\'e7\'e3o do ponteiro retornado por malloc com (TypeName *) \f2\fs8 . \f0\fs16 A fun\'e7\'e3o malloc n\'e3o fornece qualquer m\'e9todo para inicializar o bloco de mem\'f3ria alocado. Em C++, voc\'ea simplesmente escreve \line typeNaxnePtr \f2\fs10 = \b\f0\fs18 new TypeName; \line\b0\fs22 O operador new cria automaticamente um objeto do tamanho apropriado, chama o construtor do objeto e retorna um ponteiro do tipo correto. Se new n\'e3o conseguiu encontrar espa\'e7o, ele retorna um ponteiro O em vers\'f5es de C++ anteriores ao padr\'e3o ANSI/ISO. [Nota: no Cap\'edtulo 13, mostramos-lhe como lidar com insucessos de \b\fs18 new \b0\fs16 no contexto do padr\'e3o ANSI/ISO para C++. Em particular, mostraremos como \b\fs18 new \b0\fs16\ldblquote dispara\rdblquote  uma \ldblquote exce\'e7\'e3o\rdblquote  e mostrare \fs24\par
\b\f2\fs22 474 \b0\fs28 c++ \b\fs14 COMO PROGRAMAR \line\b0\f0\fs18 mos como \ldblquote capturar\rdblquote  aquela exce\'e7\'e3o e trat\'e1-la]. Para destruir o objeto e liberar o espa\'e7o usado para este objeto em C++, voc\'ea deve usar o operador delete. como segue: \line delete typeNamePtr; \line C++ permite que voc\'ea forne\'e7a um \i\fs20 inicializador \i0\fs18 para um objeto criado por new, como em: \line\f3 double *thingptr \f2\fs10 = \f3\fs18 riew double ( 3.14159 ); \line que inicializa \f0 um objeto double rec\'e9m-criado com 3 \f2\fs8 . \f3\fs18 14159. \line\f0 Um array inteiro de \f3 10 elementos pode ser criado e atribu\'eddo a arrayPtr como segue: \line int *arrayptr \f2\fs10 = \b\f3\fs16 new int[ 10 ]; \line\b0\fs18 Este array pode ser deletado com o comando \line delete [ ] \b\fs16 arrayPtr; \line\b0\fs18 Como veremos, usar new e delete, em vez de malloc e free. oferece tamb\'e9m outros benef\'edcios. \f0 Em particular, \b new \b0\f3 invoca \f0 o construtor e delete invoca o destruidor da classe. \line\i Erro comum de programa\'e7\'e3o 7.8 \line Misturar o estilo \b\i0\f3\fs16 new \b0\i\f0\fs18 e \b\i0\f3\fs16 delete \b0\i\f0\fs18 com o estilo \i0 malJ.oc \i e \b\i0 free \b0\i de aloca\'e7\'e3o din\'e2mica de mem\'f3ria din\'e2mica \'e9 um erro de l\'f3gica: o espa\'e7o criado por \i0 malloc \i n\'e3o pode ser liberado por \b\i0 delete: \b0\i os objetos criados por \b\i0 new \b0\i n\'e3o podem ser deletados por \b\i0 free. \line\b0\i Erro comum de programa\'e7\'e3o 7.9 \line Usar \b\i0 delete \b0\i em vez de \b\i0 delete \f2\fs22 [ ) \b0\i\f0\fs18 para arrays pode levar a erros de l\'f3gica durante a execu\'e7\'e3o. Para evitar problemas, o espa\'e7o criado como um array deveria ser apagado com o operador \b\i0 delete \f2\fs22 [1 \b0\i\f0\fs18 e o espa\'e7o criado como um elemento individual deveria ser apagado com o operador \b\i0 delete. \line\b0\i Boa pr\'e1tica de programa\'e7\'e3o 7.3 \line Como C++ inclui C, programas em C++ podem conter mem\'f3ria criada por \b\i0 malloc \b0\i e liberada por \line\b\i0 free \b0\i e objetos criados por \b\i0 new \b0\i e deletados por \i0 delete. \i E melhor usar somente \b\i0 new \b0\i e \b\i0 delete. \line\f2\fs26 7.7 Membros de classe \b0\fs24 static \line\f0\fs18 Cada objeto de uma classe tem sua pr\'f3pria c\'f3pia de todos os membros de dados da classe. Em certos casos, todos os objetos de uma classe deveriam compartilhar s\'f3 uma c\'f3pia de uma vari\'e1vel. Uma vari\'e1vel de classe static \'e9 usada por essa e outras raz\'f5es. Uma vari\'e1vel de classe static representa informa\'e7\'f5es \ldblquote de \'e2mbito de toda a classe\rdblquote  (i.e., uma propriedade da classe, n\'e3o de um objeto espec\'edfico da classe). A declara\'e7\'e3o de um membro static come\'e7a com a palavra-chave static. \line Para motivar a necessidade de termos dados static \f2\fs8 - \f0\fs18 v\'e1lidos para toda a classe \f2\fs8 - \f0\fs18 usaremos um exemplo de videogame. Suponhamos que temos um videogame com Marcianos e outras criaturas do espa\'e7o. Cada Marciano tende a ser valente e disposto a atacar outras criaturas do espa\'e7o quando o Marciano sabe que existem pelo menos cinco Marcianos presentes. Se menos de cinco Marcianos estiverem presentes, cada Marciano se torna covarde. Assim, cada Marciano necessita saber o numeroDeMarcianos. Poder\'edamos dotar cada inst\'e2ncia da classe Marciano com numeroDeMarcianos como um membro de dados. Se assim fizermos, ent\'e3o todo Marciano ter\'e1 uma c\'f3pia separada do membro de dados e toda vez que criarmos um novo Marciano teremos que atualizar o membro de dados numeroDeMarcianos em todos os objetos Marciano. Isso desperdi\'e7a espa\'e7o com as c\'f3pias redundantes e desperdi\'e7a tempo para atualizar as c\'f3pias separadas. Em vez disso, declaramos numeroDeMarcianos como static. Isso torna numeroDeMarcianos um dado conhecido por toda a das \fs24\par
\fs16 CAP\'cdTULO \i\fs20 7 \i0\f2\fs8 - \f0\fs16 CLASSES: PARTE \f3\fs18 II \i\f0\fs20 475 \i0\fs24\par
\fs16 to em se. Todo Marciano pode ver o nuineroDeMarcianos como se ele fosse um membro de dados de Marciano. mas s\'f3 uma c\'f3pia do membro est\'e1tico numeroDeMarcianos \'e9 mantida por C++. Economiza espa\'e7o. Economizamos tempo fazendo com que o construtor de Marciano incremente o numeroDeMarcianos est\'e1tico. Como s\'f3 existe uma c\'f3pia, n\'e3o temos que incrementar c\'f3pias separadas de numeroDeMarcianos para cada objeto Marciano. \line\ul\i\fs20 jDica \ulnone de desempenho 7.4 \line\i0\f2\fs8 ______ \i\f0\fs18 Use membros de dados \i0\f3 s tati c \i\f0 para economizar mem\'f3ria quando uma \'fanica c\'f3pia dos dados \'e9 suficiente. \line\i0\fs16 Embora membros de dados static possam se parecer com vari\'e1veis globais, membros de dados static t\'eam escopo de classe. Membros static podem ser public, private ou protected. Membros de dados static \i\fs18 devem \i0\fs16 ser inicializados \i\fs18 uma vez \i0\fs16 (e s\'f3 uma vez) em escopo de arquivo. Os membros de dados public static de uma classe podem ser acessados por qualquer objeto daquela classe, ou ent\'e3o eles podem ser acessados atrav\'e9s do nome da classe usando o operador de resolu\'e7\'e3o de escopo bin\'e1rio. Os membros private e protected static de uma classe devem ser acessados atrav\'e9s de fun\'e7\'f5es membro public da classe ou atrav\'e9s de friends da classe. Os membros static de uma classe existem mesmo quando n\'e3o existem objetos daquela classe. Para acessar um membro public static de uma classe, quando n\'e3o existem objetos daquela classe, simplesmente prefixe o \line\fs18 Lrticu- \fs16 nome do membro de dados da classe com o nome da classe e o operador bin\'e1rio de resolu\'e7\'e3o de escopo \i\fs20 (: \b\i0\f2\fs16 :). \b0\f0 Para \line acessar um membro de classe public ou private quando n\'e3o existem objetos daquela classe, deve ser providen ciad uma fun\'e7\'e3o membro static e a fun\'e7\'e3o deve ser chamada prefixando-se o seu nome com o nome da classe e o operador de resolu\'e7\'e3o de escopo bin\'e1rio. \line\f2\fs8 - \f0\fs16 O programa da Fig. \b\f2 7.9 \b0\f0 demonstra o uso de um membro de dados private static e de uma fun\'e7\'e3o \i\fs18 din\'f4- \i0\fs16 membro public static. O membro de dados count \f3\fs18\'e9 \f0\fs16 inicializado com zero no escopo de arquivo com o \i\fs18 jetos \i0\fs16 comando \line\f3\fs18 int Employee: :count \b\f2\fs16 = \f3 O; \line\b0\fs18 O membro de dados count \f0\fs16 mant\'e9m uma contagem \f3\fs18 do \f0\fs16 n\'famero de objetos da classe Employee que foram \line\i\fs18 e \i0\f3 instanciados. Quando existem objetos da classe Employee, o membro count pode ser referenciado por qualquer \line fun\'e7\'e3o membro de um objeto Employee \f2\fs8 - \f3\fs18 neste exemplo, count \'e9 referenciado tanto pelo \f0\fs16 construtor como pelo \line destruidor. \line\f2\fs8 - \i\f0\fs18 Erro comum de programa\'e7\'e3o 7.10 \line ipor \f1\fs24\'c9 \f0\fs18 um erro de sintaxe incluir a palavra-chave \i0\f3 static \i\f0 na defini\'e7\'e3o de uma vari\'e1vel de classe \i0\f3 static \i\f0 em escopo de arquivo. \i0\fs24\par
\f2\fs18 Fig. 7.9 \f0\fs20 Usando um membro \f2\fs18 de dados \b\f0\fs16 static \b0\f2\fs18 para manter uma contagem do n\'famero de objetos de uma classe \fs8 - \b\f0\fs16 employl \b0\f2\fs8 . \fs18 h (parte 1 de 2). \f0\fs24\par
\fs18 osos ic \'e9 asse\rdblquote  \line\b\fs16 Ltic \line\b0\fs18 lo de .cipelo D se st\'e2ntudo mos pa\'e7o mos das \fs24\par
\pard\par
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx325\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4430\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4780\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx7481\pard\intbl\f3\fs18 1 \f0\fs24\cell\i\fs20 II \i0\f3\fs18 Fig. 7.9: employl.h \f0\fs24\cell\cell\cell\fs20\row
\f3\fs18\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx325\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4430\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4780\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx7481\intbl 2 \f0\fs24\cell\f3\fs18 // Uma classe Employee \f0\fs24\cell\cell\cell\fs20\row
\f3\fs18\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx325\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4430\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4780\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx7481\intbl 3 \f0\fs24\cell\f3\fs16 #ifndef \b EMPLOY1H \b0\f0\fs24\cell\cell\cell\fs20\row
\b\f3\fs16\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx325\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4430\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4780\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx7481\intbl 4 \b0\f0\fs24\cell\b\f3\fs16 #define EMPLOY1H \b0\f0\fs24\cell\cell\cell\fs20\row
\b\f3\fs16\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx325\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4430\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4780\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx7481\intbl 5 \b0\f0\fs24\cell\cell\cell\cell\fs20\row
\b\f3\fs16\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx325\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4430\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4780\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx7481\intbl 6 \b0\f0\fs24\cell\b\f3\fs16 class Employee \b0\i\f0\fs20\{ \i0\fs24\cell\cell\cell\fs20\row
\b\f3\fs16\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx325\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4430\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4780\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx7481\intbl 7 \b0\f0\fs24\cell\fs18 public: \fs24\cell\cell\cell\fs20\row
\f3\fs18\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx325\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4430\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4780\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx7481\intbl 8 \f0\fs24\cell\f3\fs18 Employee( const char*, const char* ) \f0\fs24\cell\i\fs20 II \i0\fs24\cell\f3\fs18 construtor \f0\fs24\cell\fs20\row
\b\f3\fs16\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx325\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4430\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4780\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx7481\intbl 9 \b0\f0\fs24\cell\b\f3\fs16 -EmployeeO; \b0\f0\fs24\cell\i\fs20 II \i0\fs24\cell\b\f3\fs16 destruidor \b0\f0\fs24\cell\fs20\row
\f3\fs18\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx325\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4430\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4780\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx7481\intbl 10 \f0\fs24\cell\f3\fs18 const char *getFirstNe() const; \f0\fs24\cell\i\fs20 II \i0\fs24\cell\f3\fs18 retorna o primeiro nome \f0\fs24\cell\fs20\row
\f3\fs18\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx325\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4430\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4780\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx7481\intbl 11 \f0\fs24\cell\f3\fs18 const char *getTastNaxp.e() const; \f0\fs24\cell\i\fs20 II \i0\fs24\cell\f3\fs18 retorna o \f0\'faltimo nome \fs24\cell\fs20\row
\b\f3\fs16\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx325\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4430\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4780\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx7481\intbl 12 \b0\f0\fs24\cell\cell\cell\cell\fs20\row
\f3\fs18\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx325\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4430\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4780\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx7481\intbl 13 \f0\fs24\cell\i\fs20 II \i0\f3\fs18 fun\'e7\'e3o membro static \f0\fs24\cell\cell\cell\fs20\row
\pard\fs24\par
\pard\sb100\sa240\fs20 476 C++ COMO \f2\fs14 PROGRAMAR \line\f3\fs16 14 static int getCount(); \i\f2\fs22 II \i0\f0\fs16 retorna # \f3 de objetos instanciados \line 15 \line 16 private: \line 17 char *fjrstName; \line 18 char *lastName; \line 19 \line 20 \i\f2\fs22 II \i0\f3\fs16 membro de dados static \line 21 static int count; \i\f2\fs22 II \i0\f3\fs16 n\'famero de objetos instanciados \line 22 \}; \line 23 \line 24 #endif \line\f2\fs20 Fig. 7.9 Usando um membro de dados \f0\fs16 static \f2\fs20 para manter uma contagem do numero ae orjetos cie uma classe \fs8 - \f0\fs16 employl \f2\fs8 . \fs20 h (parte 2 de 2). \line\f3\fs16 25 \i\f2\fs20 II \i0\f0\fs16 Fig. \f3 7.9: employl.cpp \line\f0 26 1/ Defini\'e7\'f5es de fun\'e7\'f5es membro para a classe Employee \line 27 #include <iostream> \line\f3 28 \line 29 using std: :cout; \line 30 using std::endl; \line 31 \line 32 #include <cstring> \line 33 #include <cassert> \line 34 #include \ldblquote employl.h\rdblquote  \line 35 \line 36 \i\f2\fs20 II \i0\f3\fs16 Inicializa o membro de dados static \line 37 int Employee::count \b\f2\fs12 = \b0\f3\fs16 0; \line 38 \line 39 \f0\fs20 // \f3\fs16 Define a fun\'e7\'e3o membro static \f0 que \f3 retorna \line 40 \f0\fs20 II \f3\fs16 o n\'famero de objetos Employee instanciados. \line 41 int Employee::getCount() \f0\fs20\{ \f3\fs16 return count; \line 42 \line\f0 43 II Construtor aloca dinamicamente o espa\'e7o para \line\f3 44 \i\f2\fs20 II \i0\f3\fs16 o primeiro e o \'faltimo nomes e usa strcpy para copiar \line 45 \i\f2\fs20 II \i0\f3\fs16 o primeiro e o \'faltimo nomes para o objeto \line 46 Employee: :Employee( const char *fjrst, const char *last \line 47 \f0\fs20\{ \line\f3\fs16 48 firstName \b\f2\fs12 = \b0\f3\fs16 new char[ strlen( first \f0\fs20 ) + 1 ]; \line\f3\fs16 49 assert( firstName \b\f2\fs12 != O \b0\f0\fs20 ) ; \i\f2 1/ \i0\f3\fs16 assegura-se de \f0 que \f3 a mem\'f3ria foi alocada \line 50 strcpy( firstName, first ); \line 51 \line 52 lastName \f0\fs14 = \f3\fs16 new char[ strlen( last \f0\fs20 ) \f2\'f7 \f3\fs16 1 ]; \line 53 assert( lastName \f0\fs14 != O ); \i\f2\fs20 II \i0\f3\fs16 assegura-se de \f0 que \f3 a mem\'f3ria foi alocada \line 54 strcpy( lastName, last ); \line 55 \line 56 ++count; \i\f2\fs20 II \i0\f3\fs16 incrementa contador de empregados static \line 57 cout \'ab Construtor para Employee \'ab firstName \line 58 \'ab \f2\fs8\lquote  \f0\fs16\'ab lastName \'ab \f2\fs8\ldblquote  \f0\fs16 chamado.\rdblquote  \'ab endl; \line\f3 59 \f0\fs20\} \line\f3\fs16 60 \line 61 \f0\fs20 II \f3\fs16 Destruidor desaloca a mem\'f3ria alocada dinamicamente \line 62 Employee: :-.Employee() \line 63 \f0\fs20\{ \line\f3\fs16 64 cout\'ab \ldblquote -.Employee() chamado para \f2\fs8\ldblquote  \f0\fs16\'ab firstName \line\f3 65 \'ab \f2\fs8\lquote  \f3\fs16\'ab lastName \'ab endl; \line\f2\fs20 Fig. 7.9 Usando um membro de dados \f0\fs18 static \f2\fs20 para manter uma contagem do n\'famero de objetos de uma classe \fs8 - \f0\fs16 employl \f2\fs8 . \fs20 cpp (parte 1 de 2). \f0\fs24\par
\fs16 CAP\'cdTULO 7 \f2\fs8 - \f0\fs16 CLASSES: PARTE II 477 \line\f3 66 delete \f0\fs20 [] firstName; \i\f2 II \i0\f0\fs16 recupera a mem\'f3ria \line\f3 67 delete \f0\fs20 [) \f3\fs16 lastName; \i\f2\fs20 II \i0\f3\fs16 recupera a mem\'f3ria \line 68 --count; \i\f2\fs22 II \i0\f3\fs16 decrementa contador de empregados static \line 69 \line 70 \line 71 \i\f2\fs22 II \i0\f3\fs16 Retorna primeiro nome de Employee \line 72 const char *Employee::getFirstName() const \line 73 \line 74 \i\f2\fs22 II \i0\f3\fs16 Const antes do tipo de retorno evita \f0\fs18 que \f3\fs16 o cliente modifique \line 75 \i\f2\fs22 II \i0\f3\fs16 dados private. Os clientes devem copiar o string retornado antes \f0\fs18 que o \line\f3\fs16 76 \f0\fs20 // \f3\fs16 destruidor delete a mem\'f3ria para evitar um ponteiro indefinido. \line 77 return firstName; \line 78 \line 79 \line 80 \i\f2\fs20 II \i0\f3\fs16 Retorna \'faltimo nome de Employee \line 81 const char *Employee::getLastName() const \line 82 \line 83 \i\f2\fs22 II \i0\f3\fs16 Const antes do tipo de retorno evita \f0\fs18 que \f3\fs16 o cliente modifique \line 84 \i\f2\fs20 II \i0\f3\fs16 dados private. Os clientes devem copiar o string retornado antes \f0\fs18 que o \line\f3\fs16 85 \i\f2\fs22 II \i0\f3\fs16 destruidor delete a mem\'f3ria para evitar um ponteiro indefinido. \line 86 return lastName; \line 87 \line\f2\fs20 Fig. 7.9 Usando um membro de dados \f0\fs18 static \f2\fs20 para manter uma contagem do n\'famero de objetos de uma classe \fs8 - \f3\fs16 employl \f2\fs8 . \fs20 cpp (parte 2 de 2). \line\f3\fs16 88 \i\f2\fs22 II \i0\f3\fs16 Fig. 7.9: figO7O9.cpp \line 89 \i\f2\fs20 II \i0\f3\fs16 Programa para testar a classe Employee \line 90 #include <iostream> \line 91 \line 92 using std::cout; \line 93 using std:endl; \line 94 \line 95 #include \ldblquote employl.h\rdblquote  \line 96 \line 97 int main() \line 98 \line 99 cout \'ab N\'famero de Employees antes da instancia\'e7\'e3o \'e9 \line 100 \'ab Employee::getCountO) \'ab endl; \f0\fs20 // \f3\fs16 usa nome da classe \line\f0 101 \line\f3 102 Employee *elPtr \f2\fs10 = \f3\fs16 new Employee( \ldblquote Simone\rquote , \ldblquote Bianchi\rdblquote  \line 103 Employee *e2ptr \f2\fs10 = \f3\fs16 new Employee( \ldblquote Roberto\rdblquote , \lquote Schmidt\rdblquote  ); \line 104 \line 105 cout \'ab \ldblquote N\'famero de Employees ap\'f3s a instancia\'e7\'e3o \'e9 \line 106 \'ab elPtr->getCountO; \line 107 \line 108 cout\'ab \lquote\\n\\nEmployee 1: \line 109 \'ab e1Ptr->getFirstName \line 110 \'ab \f2\fs8\ldblquote  \f0\fs16\'ab \f3 elPtr->getLastName() \line\f0 111 \'ab \f3\ldblquote\\nEmployee 2: \line 112 \'ab e2Ptr->getFirstName() \line 113 \f2\fs8\ldblquote  \f3\fs16\'ab e2Ptr->getLastName() \'ab \ldblquote\\n\\n\rdblquote ; \line 114 \line 115 delete elPtr; \i\f2\fs22 II \i0\f3\fs16 recupera a mem\'f3ria \line 116 elPtr \f2\fs10 = \f3\fs16 0; \line 117 delete e2Ptr; \i\f2\fs20 II \i0\f3\fs16 recupera a mem\'f3ria \line 118 e2Ptr \f2\fs10 = \f3\fs16 0; \line\f2\fs20 Fig. 7.9 Usando um membro de dados \f0 static \f2 para manter uma contagem do n\'famero de objetos de \f0 uma \f2 classe \fs8 - \f0\fs20 figo7 \f3\fs16 09. \f0\fs20 cpp (parte 1 de 2). \fs24\par
\b\f2\fs18 478 \b0\f1\fs30 c++ \b\f0\fs16 COMO PROGRAMAR \line 119 \b0\f3\fs18 As \line\b\fs16 120 cout \b0\fs18\'ab \b\fs16\lquote N\'famero de Employees ap\'f3s dele\'e7\'e3o \'e9 \b0\f2\fs8\'b0 \b\f3\fs16 Em] \line 121 \'ab Employee::getCount() \'ab endi; \b0\fs24 dei \line\b\f0\fs16 122 \line\f3 123 return O; \line 124) \line N\'famero de Employees antes da instancia\'e7\'e3o \'e9 O \line Construtor para Employee Simone Bianchi chamado. \line Construtor para Entployee Roberto Schmidt chamado. \line N\'famero de Employees ap\'f3s a instancia\'e7\'e3o \b0\fs18\'e9 2 No \line\b\fs16 Employee 1: Simone Bianchi ca \line Employee 2: Roberto Schmidt um \line -Employee() chamado para Simone Bianchi pai \line -Emp1oyee() chamado para Roberto Schmidt um \line N\'famero de Employees ap\'f3s dele\'e7\'e3o \'e9 O de \line\f2\fs18 Fig. 7.9 \b0 Usando um membro de dados \f0 static \f2 para manter uma contagem do n\'famero de objetos de me uma classe \fs8 - \fs18 figO7 09. cpp (parte 2 de 2). \line Quando n\'e3o existem objetos da classe Employee, o membro count ainda pode ser referenciado, mas somente tes \line atrav\'e9s de uma chamada para a fun\'e7\'e3o membro static getCount, como segue: \line\b\f3\fs16 Employee: :getCount() \line\b0\f2\fs18 Nesse exemplo, a fun\'e7\'e3o getCount \'e9 usada para determinar o n\'famero de objetos de Employee atualmente err instanciados. Note que, quando n\'e3o existir nenhum objeto instanciado no programa, \'e9 usada a chamada \'e0 fun\'e7\'e3o ex Employee: : getCount \f1\fs30 o. \f2\fs18 Por\'e9m, quando existirem objetos instanciados, a fun\'e7\'e3o getCount pode ser chamada atrav\'e9s de um dos objetos, como mostrado no comando nas linhas 105 e 106 \line\b\f3\fs16 cout \'ab \b0\f0\fs18\ldblquote N\'famero \b\f3\fs16 de Employees ap\'f3s a instancia\'e7\'e3o \'e9 \line\f0\'ab elPtr->getCountO); \line\f3 ei \line\b0\f2\fs18 Note que as chamadas e2Ptr->getCount O e Employee: : getCount () produzem o mesmo resultado. coi \line\i\f0\fs20 Observa\'e7\'e3o de engenharia de software 7.13 \i0\f3\fs18 m \f2\fs8 ______ \i\f0\fs18 Algumas organiza\'e7\'f5es t\'eam em seus padr\'f5es de engenharia de software a norma de que todas as chamadas \line afun\'e7\'f5es membro \b\i0\f3\fs16 static \b0\i\f0\fs18 sejam feitas usando o nome da classe e n\'e3o o \i0\f3 handle \i\f0 do objeto. \i0 ou \line dei \line\f2 Uma fun\'e7\'e3o membro pode ser declarada static se ela n\'e3o acessa membros de dados e fun\'e7\'f5es membro n\'e3o- ge \line static da classe. Diferentemente de fun\'e7\'f5es membros n\'e3o-static, uma fun\'e7\'e3o membro static n\'e3o tem um ari \line ponteiro this porque membros de dados static e fun\'e7\'f5es membros static existem independentemente de foi \line quaisquer objetos de uma classe, de \line\i\f0\fs20 Erro comum de programa\'e7\'e3o 7.11 \line Referir-se ao ponteiro \b\i0\f3\fs16 this \b0\i\f0\fs18 dentro de uma fun\'e7\'e3o membro \b\i0\f3\fs16 static \b0\i\f0\fs20\'e9 um erro de sintaxe. \b\i0\f2\fs18 7. \line\b0\i\f0\fs20 Erro comum de programa\'e7\'e3o 7.12 \i0\f3\fs24 cl \line\i\f0\fs18 Declarar uma fun\'e7\'e3o membro \b\i0\f3\fs16 static \b0\i\f0\fs18 como \b\i0\f3\fs16 const \b0\i\f0\fs18\'e9 um erro de sintaxe, de \line pil \line Observa\'e7\'e3o de engenharia de soflware 7.14 \line\i0\f2\fs8 ______ \i\f0\fs18 Os membros de dados \i0\fs20 static \i\fs18 e as fun\'e7\'f5es membro \i0 static \i de uma classe existem e podem ser usados \line ainda que nenhum objeto daquela classe tenha sido instanciado. \i0\fs20 sai \fs24\par
\fs18\bullet e-LLs) soiuqn p oapnd oqqi,, \fs28\lquote o \line\fs18 OIniid3 ou opd Doqq!q P PS SSID sowaitpnis ,,so1uqB,, \lquote J oIn1Jd3 ou (iq1id) ps ssp rnd\'e7ud issou sowiu so5!Ms sns soiisqi sopip p sodji 1uwsi3Jd swm jniumjdwi i.rnd sssp sn opiwioid o \lquote ++D Wj IpTUIJpUJ OA!WU OJiUJ Um p pupnnb zini iin.iix p o3ido i sw \lquote sowp os sopp p sonjdo sfn, \lquote SoAUuu soJui p o5ou oidwx on u3t\'cdqns JopndwoD op JAflh1d tp oxij \f2\fs20 oqunwii o owo situ \f0\fs18 iuinbui ip soiwjd PAJSUS flJ!uuj p \lquote ouod ou w \lquote sprnnx \f2\fs20 ops \f0\fs18 Sflp!TTUUd so5ijdo SWT piUJJpUT ojz iod O1STAJp sm \lquote oInp9uJ O1STATp \lquote OP5fl3JId!flflUl \lquote o5tiqns \lquote o5!p P so5ido uijp ++3 u u\'e7 p o5ou n \lquote o1dwx JOd SOj31p SSS qos spiitwd os nb \i\fs14 SdQ5 \line -vJ?do \i0\fs18 sn \i sopvp p ovvjusaida, \i0 umn :tfs no \lquote soou snp nqou iuuq oiuisqi sopnp p odu \fs28 wn \fs18 JopulndwoD wn W \lquote osT3Jd p ou\'e7wjsis 1A;U wnp opunw \line op sQou p sopow os sp \lquote niuss w soiusq sopp p sodn p sojdwx sopoi os sojno 1t.p eqnop uT 0W03 sodii JP!SU03 n flAiJDdSJd ou mn w DOA \lquote flJO \i\f2\fs8\lquote SJI%J \i0\f0\fs18 souwnuonsnb ws u-r SouJiD \lquote inb y .I1aI opunw op sowuwjJodwo3 SOPDUO3 p \lquote SOppoUT no \lquote SQ5lWiXOJdU 9S OS 1UW \line -IPaI ++J OwOD o5wnoid p sunnuj od sopiiuoj soAjliwud sopup p sodj so nb oisnb \fs28 v \line\fs18\bullet saJ1DnJD p snqJm nb \lquote suap o suodif \line o omo s!lfl sunnuq niud opnbpnu uwioi osj sujip sinun p SIOfA J 3UJO siq s p \fs28 iijsv \fs18 saiPi p ounFuoD O opunw ou p wn \'c7 sopiudwoD sopiuuj uisq \line os \lquote sJop1ndwoD sop in.ioTw u \lquote xtp odu op SaIOI1A 1UTp od uussi (\'e7) oip wn \lquote ($) Jj\'e7p p tun \lquote oInsnujw z um \lquote oInDsnww wn omo \lquote wniusjdj sp nb sw.rnc so wo npnu w w3arnd s o\'e7u sgpd \f2\fs20 s1s spq \f0\fs18 oio wo soz sun p sgipud os nuwjuwiou iwt.p SIO\{1A owixoid mim wt.p \f2\fs16 p\rquote  \line\f0\fs18\bullet e-[qnop tuid oJ!p1pJA owsw .pai opuntu op oiiui wn p oou up \line oi5ntuixojd iwn os iuwi sJopindwoD tu \i\fs14 W\'c7 mil p \i0\fs18 on5ou n \lquote wiss\rquote  iwjqoid w ou sonwiuw \line SOJT3U! SJ \bullet 0IaUODUT opninsi 11111 iiznpojd p pipijiqissod i opuinput \lquote iujnbw p upudp \line opotu wnp p puods I?u!nb?w \i (Mofiaio) \i0 oinois p wn \lquote oiiui sp oj n ojnc wn \line\i p \i0 OPtfflSJ o \fs28 s \fs18 sgqiq + I sQqIq \f2\fs8 - \f0\fs18 0IAJ1U! o oprn!w!I is pod siiq p iuinbpw mim \line w ;u \lquote oidWx JOd tU SOpflitUtj utnsiq iuwjmiuou os sJopnrndmoD w su-\'e7 \lquote njn3iund w \line\bullet 3!Ww11w w O.llTU! Wfl nb o uwtinx ou Jopndwo3 tun ui smii \lquote t3fltuWw w wiiui oJwpu wn p op5ou uui \'e7 UJA nb O \bullet ;u OATITtUUd odij o pisuo ojuijsq opnp p odn wn nb O \line s\'efwmojd p O1UtU!AIOAUSp p ossod \line o iuioqpw pod nb 1uoT3!p OP5flZ!IflWJoJ mn wuioj \lquote usqo ON npmJnnJ1s tunuisqns \line ou \bullet stpmp sirnp swil s uiunp ipmunnis onwioid n ounnb mp m \'cdoq o5uw miuri \line siUv (sIuv) sopisq sopp p sodt \fs28 r \fs18 ousou i ipmpisuo sou od omuzquwoj \fs28 v \fs18 sopip iqos so \line -ou snwni mz!I1imuJoJ nosiDaid on5iwtuojd p sumnuiI P pupiunmo n \lquote OJip BSu .tUqU!UJU3 \line sodj spnbip \line sop\'edqo iu sg5iui s (sssp \lquote i) sopip p sodi sOAOu niJc ++J w mJwud pnp!AJin \fs28 v \fs18 sopp sop mDu1JOdUJi n nutunn ++3 so\'cdqo u opniuuo p opjs o ++ woc tpnw oS!A iss \line SOAOU sopp p sodij soud\'e7ud sns ucm saopw \line -uojd so iuid 1!\rquote J!P soAfliwud sopp 3p sodii sunii 95 w31s1x] SflJ3,, oS sopip 50 \i\fs14 S3Q0 \i0\fs18 su nb op suus \line -s.I3uJ souw,, opus OwoD so)siA os sopnp so \lquote opow J3nb1unb \f2\fs16 j \f0\fs18 1innx3 wusjoad sumuioid so 3nb so3n su jiwodns u.rud WSIX sopup so suunui \i\fs14 SflSS3 \i0\fs18 sou uziuJuo o5numu.mojd 3p suunuq snp uuoiuw \fs28 v \line\fs18 n oSJA uuin uu3s31dn ++3 t113 so\'edqo n upuu3uo o5nwniod \line\fs28 v \fs18 o5uwn.mojd 3p suunui suiuni wsix inb od ozmu nmn uss \f2\fs8 - \f0\fs18 uin oipud OSIA !u9 uwn 31s1x3 ON waiusn siopuwuioid so niud 3111TU3AUO3 OSIA utun ITIIJD J3AU Ofli 3p WunUII uuin 3j3 Ounj V \line pnw ou ssup upnbup u3Jqpd \line 3uJJ31ui \f2\fs20 nb \f0\fs18 psp \lquote uwisis op osam o iujn umas upniisqns no upu.m3Tu .is 3pod \i (npvina \i0 3 \b\i\f2\fs16 Op5d2su \b0\i0\f0\fs18 3 \i\fs14 S3Q5 \line\i0\fs18 -ul3do suns uwn uTu3woldwT 3nb utun owo Iu) .mujnDTiud ssp mim p o5uu3w31dwT u 3nb u3!J!11!s osi \f2\fs20 sqpnp ssp \f0\fs18 upu3d3p 3nb o!p\'e7)3 l3AaIDs3 W3A3 Oi!U sounsn so \lquote upuu3w3jdwi 3SS uwn 011103 3 squip so J3UOD 1313nb uiussod soijnnsn 50 uioqtu \i (sadj rnvu pvJJsq\rquote I \i0\f2\fs8 - \f0\fs18 sjuv) \i sowisqo sopvp ap soda \i0 sopuulwou3p sopup p sodii w3up ++D w sssup 3 \i\lquote sopvp 2p op5vjsqv p \i0 opumuq o3u1u3w3IdwJ \line uns p 3u3w31uopu3d3pui 3ssuj3 nwn 3 3pupquUO!DuflJ u J3A3JDS3Q nus u oJi3umud \lquote .ImIu3 o oJi3wud w3plo ou sopnuzowio wo\'cd3s sopop 3p su3li so ou sopop p suii sopnoio waioj opuunb \lquote 3nb J3nb \line -u3ws31dwls 3u3ip \fs28 o \fs18 opou3w31dwi uII1!d o otuo iqns olTss3D3u ou nq1id ssop otun p 31U31P w (sopop p suannjs,, \lquote\'e7j olnlldoD J3A SOO3fl3U3 suisij no) suuo wo suporn3w3ldw! ms 31u3m1130J w3pod soqid s\rquote i ows3w op o5ow3w3Idtu! O S3TU3!13 SII3S Op J3U0DS3 oqjid 35SO nwn 10113 3pod opnwnoid \fs28 o \line\fs18 IVNV1DOdd O14O3 ++3 \b\f1\fs22 OXt\rquote  \b0\f0\fs24\par
\fs18 CAP\'cdTULO 7 \f2\fs8 - \f0\fs18 CLASSES: PARTE \b\fs20 II 481 \line 7.8.1 \f2\fs22 Exemplo: tipo de dado abstrato array \line\b0\f0\fs18 nen- Discutimos arrays no Cap\'edtulo 4. Um array n\'e3o \'e9 muito mais que um ponteiro e algum espa\'e7o na mem\'f3ria. Este dem recurso primitivo para executar opera\'e7\'f5es com arrays aceit\'e1vel se o programador for cauteloso e pouco exigente. sua Existem muitas opera\'e7\'f5es que seriam interessantes de se executar com arrays, mas que n\'e3o est\'e3o dispon\'edveis em \i ipos \i0 C++. Com as classes de C++, o programador pode desenvolver um ADT array que seja melhor do que \ldblquote arrays crus\rdblquote . s de A classe array pode fornecer muitos recursos novos e \'fateis, tais como \line era- \f2\fs10 . \f0\fs18 Verifica\'e7\'e3o de intervalo de validade de subscritos. \line face \line\f2\fs10 . \f0\fs18 Um intervalo arbitr\'e1rio de subscritos em vez de ter que come\'e7ar com O. \line N\'e3o \f2\fs8 . . \line\f0\fs18 o A \f2\fs10 . \f0\fs18 Atribui\'e7ao de arrays. \line\f2\fs10 . \f0\fs18 Compara\'e7\'e3o de arrays. \line )rtar \line res- \f2\fs10 . \f0\fs18 Opera\'e7\'f5es de entradalsa\'edda para arrays. \line gra- \f2\fs10 . \f0\fs18 Arrays que conhecem seus tamanhos. \line dos \f2\fs10 . \f0\fs18 Arrays que se expandem dinamicamente para acomodar mais elementos. \line etos \line Criamos nossa pr\'f3pria classe array no Cap\'edtulo 8, \ldblquote Sobrecarga de operadores\rdblquote , e estudamos a classe equivalente da \line ; no- biblioteca padr\'e3o (chamada vector) no Cap\'edtulo 20. \line bem C++ tem um conjunto pequeno de tipos primitivos. As classes estendem a linguagem de programa\'e7\'e3o b\'e1sica. \line n\'e3o \line ar o \i Observa\'e7\'e3o de engenharia de software 7. 15 \line\i0 um \f2\fs8 ______ \i\f0\fs18 O programador pode criar novos tipos atrav\'e9s do mecanismo de classes. Esses novos tipos podem ser \line\i0 tica \i projetados para serem usados t\'e3o convenientemente quanto os tipos primitivos. Deste modo, C+ \b\i0\fs14 + \b0\i\fs18\'e9 uma \line\i0 : em linguagem extens\'edvel. \i Embora a linguagem seja f\'e1cil de estender com estes novos tipos, a linguagem \line\i0 o de \i b\'e1sica propriamente dita n\'e3o \'e9 mut\'e1vel. \line\i0 iodo \line irs Novas classes criadas em ambientes C++ podem ser propriedades individuais, de grupos pequenos ou de empre \'e7a sas. As classes tamb\'e9m podem ser colocadas em bibliotecas de classe padr\'e3o, dirigidas para uma distribui\'e7\'e3o em \line larga escala. Isto n\'e3o promove padr\'f5es necessariamente, embora de fato estejam surgindo padr\'f5es \f2\fs8 . \f0\fs18 O verdadeiro \line stes valor de C++ pode ser percebido somente quando s\'e3o usadas bibliotecas de classe substanciais e padronizadas \line ulo, para desenvolver novas aplica\'e7\'f5es. O ANSI (American National Standards Institute) e a \fs24 ISO \fs18 (Intemational Standards \line s\'e3o Organization) desenvolveram uma vers\'e3o padr\'e3o de C++ que inclui uma biblioteca de classes padr\'e3o. O leitor \line bits que aprende C++ e a programa\'e7\'e3o orientada a objetos estar\'e1 preparado para tirar proveito dos novos tipos de \line 110 \b\fs14 O \b0\fs18 desenvolvimento de software r\'e1pido e orientado a componentes, tornados poss\'edveis com bibliotecas cada vez \line mais abundantes e ricas. \line eal int \line har \line do \b\f2\fs22 7.8.2 Exemplo: tipo de dado abstrato \i string \line\b0\f0\fs18 era- \i0 C++ \'e9 uma linguagem intencionalmente sucinta, que fornece aos programadores somente os recursos crus neces\'e7\'e3o, s\'e1rios para construir uma ampla gama de sistemas (considere-a uma ferramenta para fabricar ferramentas). A s\'e3o linguagem foi projetada para minimizar sobrecargas que comprometem o desempenho. C++ \'e9 apropriada tanto a do para a programa\'e7\'e3o de aplicativos como para a programa\'e7\'e3o de sistemas \f2\fs8 - \f0\fs18 esta \'faltima imp\'f5e aos programas idos exig\'eancias extraordin\'e1rias de desempenho. Certamente, teria sido poss\'edvel incluir um tipo de dado primitivo ador \i string \i0 entre os tipos primitivos oferecidos por C++. Em vez disso, a linguagem foi projetada para incluir mecanispria mos para criar e implementar tipos de dados abstratos \i string \i0 atrav\'e9s de classes. Desenvolveremos nosso pr\'f3prio tulo ADT \i string \i0 no Cap\'edtulo 8. O padr\'e3o ANSI/ISO inclui uma classe string que discutiremos em detalhes no \line Cap\'edtulo 19. \fs24\par
\b\f2\fs14 CAP\'cdTULO \b0\f0\fs20 7 \f2\fs8 - \b\fs14 CLASSES: PARTE \b0\f0\fs20 II \b\f2\fs22 483 \line\b0\f0\fs20 Implementar uma classe \i\f2 proxy \i0\f0 exige v\'e1rios passos (Fig. 7. 10). Primeiro, criamos a defini\'e7\'e3o da classe e os \line arquivos de implementa\'e7\'e3o para a classe cujos dados private queremos esconder. Nossa classe exemplo, que \line\i\f2 queue. \i0\f0 chamaremos de Implementation. \'e9 mostrada na Fig. 7. 10, linhas 1 a 12. A classeproxy Interface \'e9 mostra- \line la para da na Fig. 7. 10, linhas 1 3 a 41 \f2\fs8 , \f0\fs20 e o programa de teste e sua sa\'edda s\'e3o mostrados na Fig. 7. 1 O, linhas 42 a 61. \line e todos A classe de Implementation fornece um \'fanico membro de dados private. chamado value (este \'e9 o \line )utador dado que queremos esconder do cliente), um construtor para inicializar value e as fun\'e7\'f5es setValue e getValue. \line o que \line\f3\fs18 ompre- \f0\fs20 1 \i\f3 II \i0\fs18 Fig. 7.10: implementation.h \line\i\fs20 -nafila \i0\f0\fs18 2 \i\f3\fs20 II \b\i0\f0\fs16 Arquivo \b0\fs18 de cabe\'e7alho \f3 para a classe Implementation \line\i\fs20 retirar \line\i0\f2\fs8 - \b\f0\fs16 4 class Implementation \b0\fs20\{ \line\f3\fs18 ns sao \line 5 public: \line iliaeo 6 Implementation( int v \f0\fs20 ) \{ \f3\fs18 value \f2\fs10 = \line\f3\fs18 7 void setValue( int v \f0\fs20 ) \{ \f3\fs18 value \f2\fs10 = \line\f3\fs18 ns que 8 int getValue() const \f0\fs20\{ \f3\fs18 return value; \f0\fs20\} \line\i\f2 na fila \i0\f3\fs18 9 \line querem 10 private: \line\f0\fs20 aquele \f3\fs18 11 int value; \line\f0\fs20 primei- 12 \} \line nta\'e7\'e3o \b\fs18 Fig. 7.10 \b0\fs20 Implemeritando \f2 uma classe \i proxy- \i0\f3\fs18 implementation.h \line\f0\fs20 esteve \line\f3\fs18 lar esta 13 \i\f2\fs20 II \i0\f3\fs18 Fig. 7.10: interface.h \line clientes 14 \f0\fs20 // \f3\fs18 Arquivo de cabe\'e7alho para interface.cpp \line era\'e7\'f5es 15 class Implementation; \i\f2\fs20 II \i0\f3\fs18 declara\'e7\'e3o antecipada da classe \line nificar 16 \line 17 class Interface \line\f0\fs14 10. \f3\fs18 18 public: \line\f0\fs20 oCapi- \f3\fs18 19 Interface( int ); \line 20 void setValue( int ); \i\f2\fs20 II \i0\f3\fs18 mesma interface p\'fablica \f0 que a \line\f3 21 int getValue() const; \i\f2\fs20 II \i0\f3\fs18 classe Implementation \line 22 -InterfaceO; \line 23 private: \line 24 Implementation *ptr; \i\f2\fs20 II \i0\f3\fs18 requer a declara\'e7\'e3o \line 25 \i\f2\fs20 II \i0\f3\fs18 antecipada acima \line\'f5esde 26 \}; \line\f0\fs12 OffiO \b\fs18 Fig. 7.10 \b0\f2\fs20 Implementando uma classe \i proxy- \b\i0\f0\fs18 interface.h \line\b0\fs20 p\'edtulo \f2 4 \line\b\f0\fs18 27 \b0\i\f3\fs20 II \i0\fs18 Fig. 7.10: interface.cpp \line ier.Um 28 \i\f2\fs20 II \i0\f3\fs18 Defini\'e7\'e3o da classe Interface \line itemde 29 #include \ldblquote interface.h \line sepode 30 #include \ldblquote implementation.h\rdblquote  \line pessoas \b\f0\fs16 31 \line\b0\f3\fs18 )erando 32 Interface::Interface( int v \line\f0 t\'eaineres \f3 33 : ptr \f0\fs20 ( \f3\fs18 new Implementation( v \f0\fs20 ) ) \{ \} \line\f3\fs18 35 \i\f2\fs20 II \i0\f3\fs18 chama a fun\'e7\'e3o setValue de Implementation \line 36 void Interface::setValue( int v \f0\fs20 ) \{ \f3\fs18 ptr->setValue( v ); \line 37 \line 38 \i\f2\fs20 II \i0\f3\fs18 chama a fun\'e7\'e3o getValue de Implementation \line 39 int Interface::getValue() const \f0\fs20\{ \f3\fs18 return ptr->getValueO; \f0\fs20\} \line\f3\fs18 40 \line iet\'e1nas 41 Interface: :Interface() \f0\fs20\{ \f3\fs18 delete ptr; \f0\fs20\} \line\f3\fs18 a classe \line sda sua Fig. 7.10 Implementando uma classe \i\f2\fs20 proxy- \i0\f3\fs18 interface.cpp \f0\fs24\par
\f2\fs20 484 \fs28 c++ \f0\fs18 COMO \b\fs14 PROGRAMAR \line\b0\fs18 Criamos uma defini\'e7\'e3o de classe \i proxy \i0 com uma interface public id\'eantica \'e0 da classe Implementation. O \'fanico membro private da classe \i proxy \i0\f2\fs20\'e9 \f0\fs18 um ponteiro para um objeto da classe Implementation. Usar um ponteiro desta maneira permite que n\'f3s escondamos do cliente os detalhes de implementa\'e7\'e3o da classe \line\b\f3\fs16 Implementation. \line 42 \b0\f2\fs20 /1 \b\f3\fs16 Fig. 7.10: figO7lO.cpp \line 43 \b0\i\fs20 II \b\i0\fs16 Ocultando os dados private de \b0\fs18 urna \b\fs16 classe com \b0\fs18 uma \b\fs16 classe proxy. \line 44 #include <iostream> \line 45 \line 46 using std::cout; \line 47 using std::endl; \line 48 \line 49 #include \ldblquote interface.h\rdblquote  \line 50 \line 51 int main \b0\fs20 O \line\b\fs16 52 \b0\f2\fs20\{ \line\b\f3\fs16 53 Interface i \b0\f2\fs20 ( \b\f3\fs16 5 ); \line 54 \line 55 cout\'ab \ldblquote Interface cont\'e9m: \'ab i.getValue() \line 56 \'ab \b0\f2\fs10 o \b\f3\fs16 antes de setValue \'ab endl; \line 57 i.setValue( 10 ); \line 58 cout\'ab \ldblquote Interface cont\'e9m: \b0\f2\fs8\ldblquote  \f0\fs18\'ab \b\f3\fs16 i.getValue() \line 59 \'ab \b0\f2\fs8 ,, \b\f3\fs16 ap\'f3s setValue\rdblquote  \'ab endl; \line 60 return 0; \line 61 \b0\f2\fs20\} \line\b\f3\fs16 Interface cont\'e9m: 5 antes de setValue \line Interface cont\'e9m: 10 ap\'f3s setValue \line\b0\f2\fs20 Fig. 7.10 Implementando uma classe \i proxy- \i0\f0\fs18 figo7_l0 .cpp. \line A classe Interface. na parte 2 da Fig.7.lO, \'e9 a classeproxy para a classe Implementation. Note que a \'fanica men\'e7\'e3o \'e0 classe propriet\'e1ria Impleinentation na classe Interface \'e9 na declara\'e7\'e3o de ponteiro (linha 24). Quando uma defini\'e7\'e3o de classe (tal como a da classe Interface) usa s\'f3 um ponteiro para outra classe (tal como para a classe Implementation), o arquivo de cabe\'e7alho de classe para aquela outra classe (que normalmente revelaria os dados private daquela classe) n\'e3o precisa ser obrigatoriamente inclu\'eddo com #include. Voc\'ea pode simplesmente declarar aquela outra classe como um tipo de dados, usando uma \i declara\'e7\'e3o de classe antecipada \i0\f2\fs8 - \i\fs26 f \f0\fs18 orward \i0 (linha \i 15), \i0 antes de o tipo ser usado no arquivo. \line O arquivo de implementa\'e7\'e3o contendo as fun\'e7\'f5es membro para a classeproxv Interface (Fig.7.lO, parte 3) \'e9 o \'fanico arquivo que inclui o arquivo de cabe\'e7alho implementation h, que cont\'e9m a classe \b\f3\fs16 Implementation. \b0\f0\fs18 O arquivo interface cpp (Fig. 7.10, parte 3) \'e9 fornecido ao cliente como um arquivo objeto pr\'e9-compilado, junto com o arquivo de cabe\'e7alho interface h, que inclui os prot\'f3tipos de fun\'e7\'f5es dos servi\'e7os fornecidos pela classe \i\f2\fs20 proxy. \i0\f0\fs18 Como o arquivo interface cpp toma-se dispon\'edvel para o cliente somente como o c\'f3digo objeto compilado, o cliente n\'e3o pode ver as intera\'e7\'f5es entre a classe \i\f2\fs20 proxy \i0\f0\fs18 e a classe propriet\'e1ria. \line O programa na parte 4 da Fig. 7.10 testa a classe Interface. Note que s\'f3 o arquivo de cabe\'e7alho para a classe Interface \'e9 inclu\'eddo em main \f2\fs8 - \f0\fs18 n\'e3o existe nenhuma men\'e7\'e3o \'e0 exist\'eancia de uma classe separada denominada Implementation. Deste modo, o cliente nunca v\'ea os dados private da classe Implementation, nem o c\'f3digo cliente pode se tornar dependente do c\'f3digo de Implementation. \line\b\f2\fs26 7.11 (Estudo de caso opcional) Pensando em objetos: programando as classes para o simulador de elevador \line\b0\f0\fs18 Nas se\'e7\'f5es \ldblquote Pensando em objetos\rdblquote , nos finais dos Cap\'edtulos 2 a \i 5, \i0 projetamos nosso simulador de elevador e, no Cap\'edtulo 6, come\'e7amos a programar o simulador em C++. No corpo do Cap\'edtulo 7, discutimos os recursos restantes \fs24\par
\b\fs14 CAP\'cdTULO \b0\fs18 7 \f2\fs8 - \b\f0\fs14 CLASSES: PARTE \b0\fs18 11 \b\i\fs22 485 \line\b0\i0\fs18 de C++ de que necessitamos para implementar um simulador de elevador completo e que funcione. Discutimos t\'e9cnicas de administra\'e7\'e3o din\'e2mica de objetos, usando new e delete para criar e destruir objetos, respectivamente. Tamb\'e9m discutimos a composi\'e7\'e3o, um recurso que nos permite criar classes que cont\'eam objetos de outras classes como membros de dados. A composi\'e7\'e3o nos habilita a criar uma classe Building que cont\'e9m um objeto Scheduler, um objeto Clock. um objeto Elevator e dois objetos Floor; uma classe Elevator que contem um objeto de cada uma das classes ElevatorButton, Door e Be].1; e uma classe Floor que cont\'e9m objetos FloorButton e Light. Tamb\'e9m discutimos como usar membros de classes static, membros de classes const e a sintaxe de inicializa\'e7\'e3o de membros em construtores. Nesta se\'e7\'e3o, continuamos a implementar nosso sistema de elevador em C++ usando estas t\'e9cnicas. No fim desta se\'e7\'e3o, apresentamos um programa simulador de elevador completo em C++ (aproximadamente 1000 linhas de c\'f3digo) e um \i walkthrough \i0 detalhado do c\'f3digo. Na se\'e7\'e3o \ldblquote Pensando em objetos\rdblquote  no fim do Cap\'edtulo 9, completamos nosso estudo de caso do simulador de elevador incorporando heran\'e7a ao simulador de elevador; naquele ponto, apresentamos somente o c\'f3digo C++ adicional necess\'e1rio para implementarmos a heran\'e7a. \line\b\i\fs22 Uma i\rquote is\'e3o geral da implementa\'e7\'e3o da simula\'e7\'e3o de elevador \line\b0\i0\fs18 Nossa simula\'e7\'e3o de elevador \'e9 controlada por um objeto da classe Building, que cont\'e9m dois objetos da classe Floor e um objeto de cada uma das classes Elevator, Clock e Scheduler. Este relacionamento composto foi mostrado no diagrama de classes da UML (Fig. 2.44) apresentado na se\'e7\'e3o \ldblquote Pensando em objetos\rdblquote  no fim do Cap\'edtulo \f2\fs20 2. \f0\fs18 O rel\'f3gio simplesmente registra a hora atual em segundos e \'e9 incrementado uma vez por segundo pelo pr\'e9dio. O \i scheduler \i0\'e9 respons\'e1vel por escalonar a chegada de pessoas a cada andar. \line Ap\'f3s cada tiquetaqueada do rel\'f3gio, o pr\'e9dio atualiza o \i scheduler \i0 com a hora atual (atrav\'e9s da fun\'e7\'e3o membro processTime da classe Scheduler). O \i scheduler \i0 compara esta hora com a pr\'f3xima hora de chega- da escalonada para pessoas em cada andar. Se est\'e1 escalonada a chegada de uma pessoa a um andar, o \i scheduler \i0 verifica se o andar est\'e1 ou n\'e3o ocupado chamando a fun\'e7\'e3o membro isOccupied da classe Floor. Se esta chamada retorna true. existe uma pessoa no andar naquele momento, de modo que o \i scheduler \i0 invoca sua fun\'e7\'e3o delayArrival para retardar em um segundo a pr\'f3xima hora de chegada de uma pessoa para aquele andar. \line Se o andar est\'e1 vazio (i.e., a chamada retorna false), o \i scheduler \i0 cria um novo objeto da classe Person e \line aquela pessoa entra no andar apropriado. A pessoa ent\'e3o invoca a fun\'e7\'e3o membro pressButton da classe FloorButton. O bot\'e3o do andar, por sua vez, invoca o m\'e9todo suninionElevator da classe Elevator. \line\f2\fs8 . \fs28 o \f0\fs18 pr\'e9dio tamb\'e9m atualiza o elevador com a hora atual em segundos ap\'f3s cada tiquetaqueada do rel\'f3gio. \line Quando recebe a hora atualizada, o elevador primeiro verifica seu estado atual (se est\'e1 \ldblquote se movendo\rdblquote  ou \ldblquote para- \line\f2\fs8 - ). \f0\fs18 do\rdblquote ). Se o elevador est\'e1 se movimendo entre os andares, mas n\'e3o est\'e1 escalonado para chegar em um andar .flo naquela hora, o elevador simplesmente exibe na tela a dire\'e7\'e3o em que est\'e1 se movendo. Se o elevador est\'e1 se \line ne movendo e a hora atual coincide com a pr\'f3xima hora de chegada escalonada, o elevador p\'e1ra, desliga o bot\'e3o do \line e elevador, toca a campainha e avisa ao andar que chegou (atrav\'e9s da fun\'e7\'e3o membro elevatorArrived da \line\b\i\fs22 a \b0\i0\f2\fs8 - \f0\fs18 classe Floor). Em resposta, o andar desliga o bot\'e3o de andar e liga a luz. O elevador ent\'e3o abre a porta, o que \line rte permite que a pessoa no elevador saia e a pessoa no andar entre. O elevador ent\'e3o fecha a porta e determina se o \line outro andar necessita de atendimento. Se o outro andar precisa de atendimento, o elevador come\'e7a a se mover \line\fs20 sse \line\f2\fs8 . \f0\fs18 para aquele andar. \line vo Se o elevador n\'e3o est\'e1 se movendo quando recebe a hora atualizada do pr\'e9dio, o elevador determina qual \line\f1\fs66 : \f0\fs18 andar precisa ser atendido. Se o andar atual precisa ser atendido (i.e., uma pessoa pressionou o bot\'e3o no andar atual \line em que o elevador est\'e1), o elevador toca a campainha, avisa o andar que o elevador chegou e abre a porta \f2\fs8 . \f0\fs18 A pessoa \line na. que est\'e1 no andar entra no elevador e aperta o bot\'e3o para come\'e7ar a movimentar o elevador para o outro andar. Se o \line a a outro andar necessita de atendimento (i.e., uma pessoa apertou o bot\'e3o no outro andar), o elevador come\'e7a a se \line mover para aquele andar. \line\b\i\fs22 A implementa\'e7\'e3o da simula\'e7\'e3o de elevador \line\b0\i0\fs18 Nas se\'e7\'f5es \ldblquote Pensando em objetos\rdblquote  anteriores, reunimos muitas informa\'e7\'f5es sobre nosso sistema. Usamos estas informa\'e7\'f5es para criar um projeto orientado a objetos para nossa simula\'e7\'e3o de elevador e representamos este projeto usando a UML. Agora, \fs22 j\'e1 \fs18 discutimos toda a tecnologia de programa\'e7\'e3o orientada a objetos em C++ que \'e9 necess\'e1ria para implementar uma simula\'e7\'e3o que funcione. O restante desta se\'e7\'e3o cont\'e9m nossa implementa\'e7\'e3o em C++ e um \i walkthrough \i0 detalhado do c\'f3digo. \line\fs20 fies \fs24\par
\b\f2\fs22 486 \b0\fs28 c++ \fs16 COMO \f0\fs18 PROGRAMAR \line Nosso programa acionador (Fig. 7. 1 1) inicialmente pede ao usu\'e1rio que digite o per\'edodo de tempo para o qual \line a simula\'e7\'e3o deve ser executada (linhas 15 e 16). A chamada para cm \f2\fs8 . \f0\fs18 ignore na linha 17 instrui o \i stream \i0 cm a \line ignorar o caractere de retorno do carro \i (return) \i0 que o usu\'e1rio digitar ap\'f3s o inteiro durante a execu\'e7\'e3o. Isto remove \line o caractere \i return \i0 do \i stream \i0 de entrada. O acionador cria, ent\'e3o, o objeto bui lding (linha 1 9) e invoca sua fun\'e7\'e3o \line membro runSimulation, passando como par\'e2metro a dura\'e7\'e3o especificada pelo usu\'e1rio (linha 23). O acionador \line tamb\'e9m exibe na tela mensagens indicando ao usu\'e1rio quando a simula\'e7\'e3o inicia (linha 21) e termina (linha 24). \line\b\f3\fs16 1 \b0\i\fs22 II \b\i0\fs16 Figure 7.11 \line 2 \b0\i\fs22 II \b\i0\fs16 Acionador para a simula\'e7\'e3o \line 3 #include <iostream> \line 4 \line 5 using std: :cout; \line 6 using std: :cin; \line 7 \line 8 using std::endl; \line\b0\f2 9 \line\b\f3 10 #include \ldblquote building.h\rdblquote  \line 11 \line 12 int main() \line 13 \line 14 int duration; \b0\i\fs20 II \b\i0\fs16 dura\'e7\'e3o da simula\'e7\'e3o em segundos \line 15 \line 16 cout \'ab \ldblquote Digite o tempo de simula\'e7\'e3o: \b0\f0\fs18 ; \line\b\f3\fs16 17 cm \'bb duration; \line 18 cin.ignore(); \b0\i\f2\fs22 II \b\i0\f3\fs16 ignora caractere \i return \line\i0 19 Building building; \b0\i\f2\fs22 II \b\i0\f3\fs16 cria o pr\'e9dio \line 20 \line 21 cout \'ab endl \'ab \b0\f2\fs8\ldblquote\lquote  \b\f3\fs16 IN\'cdCIO DA SIMULA\'c7\'c3O DO ELEVADOR \line 22 \'ab endl \'ab endl; \line 23 building.runSimulation( duration ); \b0\i\f2\fs22 II \b\i0\f3\fs16 come\'e7a a simula\'e7\'e3o \line 24 cout \'ab FIM DA SIMULA\'c7\'c3O DO ELEVADOR \b0\f2\fs10 *,\ldblquote  \f0\fs18\'ab \b\f3\fs16 endl; \line 25 \line 26 return 0; \line 27 \line\b0\f2\fs20 Fig. 7.11 Acionador para a simula\'e7\'e3o do elevador. \line\f0\fs18 De acordo com nosso diagrama de classes (Fig. 2.44), a classe Building \'e9 composta por objetos de diversas outras classes. O arquivo de cabe\'e7alho de Building, apresentado na Fig. 7.12, reflete esta composi\'e7\'e3o (linhas 46 a 50). A classe Building \'e9 composta de dois objetos Floor (floori e floor2), um objeto Elevator (elevator), um objeto Clock (clock) e um objeto Scheduler (scheduler). \line\b\f3\fs16 28 \b0\i\f2\fs22 II \b\i0\f3\fs16 building.h \line 29 \b0\i\f2\fs22 II \b\i0\f3\fs16 Defini\'e7\'e3o da classe Building. \line 30 #ifndef BUILDINGH \line 31 #define BUILDINGH \line 32 \line 33 #include \ldblquote elevator.h\rdblquote  \line 34 #include \ldblquote floor.h\rdblquote  \line 35 #include clock.h\rdblquote  \line 36 #include \ldblquote scheduler.h\rdblquote  \line 37 \line 38 class Building \f2\fs22\{ \line\f3\fs16 Fig. 7.12 \b0\f2\fs20 Arquivo de cabe\'e7alho da classe \b\f3\fs16 Building \b0\f2\fs20 (parte 1 \b\f3\fs16 de \b0\f2\fs20 2). \f0\fs24\par
\fs16 CAP\'cdTULO 7 \f2\fs8 - \f0\fs16 CLASSES: PARTE II \b\f2 487 \line\b0\f0\fs20 ual 39 \line na 40 public: \line\f3\fs16 ve 41 Building() ; \i\fs22 II \i0\fs16 construtor \line io 42 -Building() ; \i\fs22 II \i0\fs16 destruidor \line dor 43 void runSimulation( int \f0\fs20 );// \f3\fs16 executa simula\'e7\'e3o pelo tempo especificado \line 44 \line\b\f2 ). \b0\f3 45 private: \line 46 Floor floori; \i\fs22 /1 \i0\fs16 objeto floori \line 47 Floor floor2; \i\fs22 II \i0\fs16 objeto floor2 \line 48 Elevator elevator; \f0\fs20 // \f3\fs16 objeto elevator \line 49 Clock clock; \i\fs20 II \i0\fs16 objeto clock \line 50 Scheduler scheduler; \i\fs22 1/ \i0\fs16 objeto scheduler \line 51 \}; \line\f0 52 \line\f3 53 #endif \i\fs22 II \i0\fs16 BUILDINGH \line\b\f2\fs18 Fig. 7.12 \b0 Arquivo de cabe\'e7alho da classe Building (parte 2 de 2). \line\fs28 o \f0\fs18 arquivo de implementa\'e7\'e3o para a classe Building \'e9 mostrado na Fig. 7. 13. O construtor est\'e1 nas linhas 64 a 69. \line Na lista de inicializa\'e7\'e3o de membros (linhas 65 a 68), s\'e3o chamados construtores para muitos dos objetos dos quais \line a classe Building \'e9 composta, com os argumentos apropriados. FLOOR1 e FLOOR2 (mencionados nas linhas 65 \line e 66) s\'e3o constantes definidas na classe Floor (linhas 821 e 822). \line\f3\fs16 54 \i\fs22 II \i0\fs16 building.cpp \line 55 \f0\fs20 // \f3\fs16 Defini\'e7\'f5es de fun\'e7\'f5es membro para a classe Building. \line 56 #include <iostream> \line 57 \line 58 using std::cout; \line 59 using std::cin; \line 60 using std::endl; \line 61 \line 62 #include \lquote building.h\rdblquote  \line 63 \line 64 Building::Building() \i\f2\fs22 II \i0\f3\fs16 construtor \line 65 : floorl( Floor::FLOOR1, elevator \f0\fs20 ), \line\f3\fs16 66 floor2( Floor::FLOOR2, elevator \f0\fs20 ), \line\f3\fs16 67 elevator( floori, floor2 \f0\fs20 ), \line\f3\fs16 68 scheduler( floori, floor2 \line sas 69 \f0\fs20\{ \f3\fs16 cout \'ab \ldblquote pr\'e9dio criado\rdblquote  \'ab endi; \line\f0\fs18 46 \f3\fs16 70 \line or 71 Building::Building() \i\f2\fs22 II \i0\f3\fs16 destruidor \line 72 \f0\fs20\{ \f3\fs16 cout \'ab \ldblquote pr\'e9dio destruido\rdblquote  \'ab endl; \line 73 \line 74 \f0\fs20 // \f3\fs16 controla a simula\'e7\'e3o \line 75 void Building: :runSimulation( int totalTime \line 76 \f0\fs20\{ \line\f3\fs16 77 int currentTime \f2\fs10 = \f3\fs16 0; \line 79 while \f0\fs20 ( \f3\fs16 currentTime < totalTime \line 80 clock.tickO; \line 81 currentTime \f2\fs10 = \f3\fs16 clock.getTime(); \line 82 cout \'ab \ldblquote HORA: \f2\fs8\ldblquote  \f0\fs16\'ab currentTime \'ab endl; \line\f3 83 scheduler.processTime( currentTime ); \line 84 elevator.processTime( currentTime ); \line 85 cin.getO; \f0\fs20 // \f3\fs16 p\'e1ra a cada segundo para usu\'e1rio ler informa\'e7\'f5es \line 86 \f0\fs20\} \line\f3\fs16 87 \f0\fs20\} \line\b\f2\fs18 Fig. 7.13 \b0 Arquivo de implementa\'e7\'e3o da classe Building. \f0\fs24\par
\fs18 488 \fs28 c++ \f2\fs14 COMO PROGRAMAR \line\f0\fs18 A principal funcionalidade da classe Building est\'e1 em sua fun\'e7\'e3o membro runSixnulation (linhas 87), que executa um la\'e7o at\'e9 que a quantidade de tempo especificada tenha decorrido. Em cada itera\'e7\'e3 building instrui o clock a incrementar sua hora em um segundo, enviando a mensagem tick para c].c (linha 80). A seguir, o building obt\'e9m a hora de clock chamando a fun\'e7\'e3o membro getTime (linha 81 currentTime \'e9 ent\'e3o enviado atrav\'e9s de mensagens processTiine para o scheduler e para o elevat nas linhas 83 e 84, respectivamente. Finalmente, adicionamos uma chamada a \fs28 cm \f2\fs8 . \f0\fs18 get (linha 85) para qi. usu\'e1rio suspenda temporariamente a rolagem dos dados de sa\'edda na tela, a fim de visualizar a sa\'edda da simula para o pr\'f3ximo segundo de tempo simulado, antes de pressionar a tecla \i enter \i0 para retomar a rolagem dos dado sa\'edda na tela. \line Clock \'e9 uma classe simples que n\'e3o \'e9 composta por qualquer outro objeto. O arquivo de cabe\'e7alho pa classe Clock \'e9 mostrado na Fig. 7. 14 e sua implementa\'e7\'e3o na Fig. 7. 1 5. Um objeto da classe Clock pode rece mensagens para incrementar time atrav\'e9s da fun\'e7\'e3o membro tick, que est\'e1 prototipada na linha 98 e implement nas linhas 1 \f2\fs20 22 \f0\fs18 e 123. A hora atual torna-se dispon\'edvel para outros objetos atrav\'e9s da fun\'e7\'e3o membro getTime. linhas 99, 125 e 126. Observe que getTime \'e9 const. \line 88 \i\f2\fs22 II \i0\f0\fs18 clock.h \line\b\f3\fs16 89 \b0\f0\fs18 // \b\f3\fs16 Defini\'e7\'e3o da classe Clock. \line 90 #ifndef CLOCKH \line 91 #define CLOCKH \line 92 \line 93 class Clock \line 94 \line\b0\f0\fs18 95 public: \line\b\f3\fs16 96 ClockO; \b0\f0\fs18 // \b\f3\fs16 construtor \line 97 \lquote -ClockO; \b0\f0\fs18 // \b\f3\fs16 destruidor \line 98 voidtick \b0\i\f2\fs22 II \b\i0\f3\fs16 incrementa rel\'f3gio em um segundo \line 99 int getTime() const; \b0\i\f2\fs22 II \b\i0\f3\fs16 retorna hora atual do rel\'f3gio \line 100 \line 101 private: \line 102 int time; \b0\i\f2\fs20 II \b\i0\f3\fs16 hora do rel\'f3gio \line 103 \line 104 \line 105 #endif \b0\i\f2\fs22 II \b\i0\f3\fs16 CLOCKH \line\f2\fs20 Fig. \b0 7.14 Arquivo de cabe\'e7alho da classe Clock. \line\b\f3\fs16 106 \b0\i\f2\fs22 II \b\i0\f3\fs16 clock.cpp \line 107 \b0\f0\fs18 // \b\f3\fs16 Defini\'e7\'e3o de fun\'e7\'f5es membro para a classe Clock. \line 108 #include <iostream> \line 109 \line 110 using std::cout; \line 111 using std: :endl; \line 112 \line 113 #include \ldblquote clock.h\rdblquote  \line 114 \line 115 Clock::Clock() \b0\i\f2\fs22 II \b\i0\f3\fs16 construtor \line 116 : time( O \line 117 \b0\f0\fs18\{ \b\f3\fs16 cout \'ab \ldblquote rel\'f3gio criado\rdblquote  \'ab endl; \line 118 \line 119 Clock: :-Clock() \b0\i\f2\fs22 II \b\i0\f3\fs16 destruidor \line 120 \b0\f0\fs18\{ \b\f3\fs16 cout \'ab \ldblquote rel\'f3gio destru\'eddo\rdblquote  \'ab endl; \b0\f0\fs18 1 \line\b\f3\fs16 121 \line 122 void Clock::tick() \b0\i\f2\fs22 II \b\i0\f3\fs16 incrementa hora em 1 \b0\f0\fs24\par
\b\f2\fs20 Fig. \b0 7.15 Arquivo de implementa\'e7\'e3o da classe Clock (parte 1 de 2). \f0\fs24\par
\fs18 CAP\'cdTULO 7 \f2\fs8 - \f0\fs18 CLASSES: PARTE II \b\f2\fs20 489 \line\b0\f3\fs16 74a \b 123 \b0\f0\fs20\{ \b\f3\fs16 time++; \b0\f0\fs20\} \line jo, o 124 \line\b\f3\fs16 ock 125 int Clock::getTirne() const \b0\i\fs22 II \b\i0\fs16 retorna hora atual \line\b0 [).O \b 126 \b0\f0\fs20\{ \b\f3\fs16 return time; \line\b0\f0\fs18 tor \line ue o \b\f2\fs20 Fig. 7.15 \b0 Arquivo de implementa\'e7\'e3o da classe Clock (parte 2 de 2). \line\b\f3\fs16 a\'e7\'e3o \line\b0\f1\fs14 )S \f0\fs20 de A classe Scheduler (Fig. 7. 16) \'e9 respons\'e1vel por criar objetos da classe Person em momentos gerados aleatoriamente e por colocar estes objetos nos andares apropriados. A interface public lista a fun\'e7\'e3o membro \line ara a processTime, que recebe como seu argumento a hora atual (linha 1 39). O arquivo de cabe\'e7alho tamb\'e9m lista \line eber diversas fun\'e7\'f5es utilit\'e1rias private (que discutimos em seguida) que executam as tarefas requeridas pela fun\'e7\'e3o \line itada membro processTime. \line\f2\fs8 , \f0\fs18 nas \line\b\f3\fs16 127 \b0\i\fs22 II \b\i0\fs16 scheduler.h \line 128 \b0\i\fs22 II \b\i0\fs16 Defini\'e7\'e3o da classe Scheduler \line 129 #ifndef SCHEDULERH \line 130 #define SCHEDULERH \line 131 \line 132 class Floor; \b0\i\fs22 II \b\i0\fs16 declara\'e7\'e3o antecipada \i (forward) \line\i0 133 \line 134 class Scheduler \b0\f0\fs20\{ \line\b\f3\fs16 135 \line 136 public: \line 137 Scheduler( Floor \b0\f1\fs14 &, \b\f3\fs16 Floor & \b0\f0\fs20 ) ; // \b\f3\fs16 construtor \line 138 -Scheduler() \b0\f1\fs14 ; \f0\fs20 // \b\f3\fs16 destruidor \line 139 void processTime( int ); \b0\i\fs22 II \b\i0\fs16 inicializa hora do scheduler \line\b0\f2\fs20 140 \line\b\f3\fs16 141 private: \line 142 \b0\i\fs22 II \b\i0\fs16 escalona chegada a um andar \line 143 void scheduleTime( const Floor & ); \line\b0\f2\fs20 144 \line\b\f3\fs16 145 \b0\i\fs22 II \b\i0\fs16 retarda chegada em um andar \line\b0 146 \b void delayTime( const Floor & ); \line\b0\f2\fs20 147 \line\f3\fs16 148 \i\fs22 II \b\i0\fs16 cria nova pessoa; coloca no andar \line 149 void createNewPerson( Floor & ); \line 150 \line 151 \b0\i\fs22 II \b\i0\fs16 processa chegada de \b0 uma \b pessoa a um andar \line 152 void handleArrivals( Floor \b0\f1\fs14 &, \b\f3\fs16 int ); \line 153 \line 154 int currentClockTime; \line 155 \line 156 Floor &floorlRef; \line 157 Floor &floor2Ref; \line 158 \line 159 int floorlArrivalTime; \line 160 int floor2ArrivalTime; \line 161 \line 162 \line 163 #endif \b0\f0\fs20 // \b\f3\fs16 SCHEDULERH \line\b0\f2\fs20 Fig. 7.16 Arquivo de cabe\'e7alho da classe Scheduler. \line\f0 A Fig. 7.17 lista o arquivo de implementa\'e7\'e3o para a classe Scheduler. A fun\'e7\'e3o membro processTime (linhas \line\f2 222 \f0 a 232) delega a maior parte de suas responsabilidades a fun\'e7\'f5es utilit\'e1rias menores dentro da classe, O construtor da classe Scheduler (linhas 178 a 189) primeiro \ldblquote semeia\rdblquote  o gerador de n\'fameros pseudo-aleat\'f3rios com um \fs24\par
\b\f2\fs20 490 \b0\fs28 c++ \fs14 COMO PROGRAMAR \line\f0\fs18 n\'famero baseado na hora atual do mundo real (linha 1 83). Isto faz com que o gerador de n\'fameros aleat\'f3rios produza uma s\'e9rie diferente de n\'fameros cada vez que o programa \'e9 executado. A classe Scheduler ent\'e3o chama a fun\'e7\'e3o utilit\'e1ria scheduleTime (linhas 194 a 207) uma vez para cada um dos dois andares (linhas 187 e 188). Esta fun\'e7\'e3o membro calcula uma hora de chegada pseudo-aleat\'f3ria (neste caso, um n\'famero aleat\'f3rio no intervalo de \i\f2\fs20 5 \i0\f0\fs18 a 20, inclusive) para o primeiro objeto Person em cada andar. \line\f3\fs16 164 \i\fs22 II \i0\fs16 scheduler.cpp \line 165 \i\fs22 II \i0\fs16 Defini\'e7\'f5es de fun\'e7\'f5es membro para a classe Scheduler. \line 166 #include <iostream> \line 167 \line 168 using std: :cout; \line 169 using std::endl; \line 170 \line 171 #include <cstdlib> \line 172 #include <ctime> \line 173 \line 174 #include scheduler.h\rquote  \line 175 #include \ldblquote floor.h\rdblquote  \line 176 #include \ldblquote person.h\rdblquote  \line 177 \line 178 \i\fs22 II \i0\fs16 construtor \line 179 Scheduler::Scheduler( Floor &firstFloor, Floor &secondFloor \line 180 : currentClockTime( O \b\f2\fs20 ), \b0\f3\fs16 floorlRef( firstFloor \b\f2\fs20 ), \line\b0\f3\fs16 181 floor2Ref( secondFloor \line 182 \b\f2\fs20\{ \line\b0\f3\fs16 183 srand( time( O \b\f2\fs20 ) \b0\f0\fs18 ); // \f3\fs16 semente p/gerador de n\'fameros aleat\'f3rios \line 184 cout \'ab scheduler criado\rdblquote  \'ab endi; \line 185 \line 186 \i\fs22 II \i0\fs16 escalona primeiras chegadas para andar 1 e andar 2 \line 187 scheduleTime \b\f2\fs20 ( \b0\f3\fs16 floorlRef ); \line 188 scheduleTime( floor2Ref ); \line\f0\fs18 189 \} \line\f3\fs16 190 \line 191 Scheduler: :Scheduler() \i\fs22 II \i0\fs16 destruidor \line 192 \b\f2\fs20\{ \b0\f3\fs16 cout \'ab \ldblquote scheduler destru\'eddo\rdblquote  \'ab endl; \line 193 \line 194 \i\fs22 II \i0\fs16 escalona chegada em um andar \line 195 void Scheduler::scheduleTime( const Floor &floor \line 196 \b\f2\fs20\{ \line\b0\f3\fs16 197 int floorNuinber floor.getNumber(); \line 198 int arrivalTime \f2\fs10 = \f3\fs16 currentClockTime + \b\f2\fs20 ( \b0\f3\fs16 5 + rand() % 16 ); \line 199 \line 200 floorNumber \f2\fs10 == \f3\fs16 Floor: :FLOOR1 ? \line 201 floorlArrivalTime \f2\fs10 = \f3\fs16 arrivalTime \line 202 floor2ArrivalTime \f2\fs10 = \f3\fs16 arrivalTime; \line 203 \line 204 cout \'ab \ldblquote (scheduler escalona pr\'f3xima pessoa para andar \line 205 \f0\fs18\'ab \f3\fs16 floorNuinber \'ab \f2\fs8\ldblquote  \f3\fs16 na hora \f2\fs8\ldblquote  \f3\fs16\'ab arrivalTime \f0\fs18\'ab \f2\fs12\lquote )\lquote  \line\f3\fs16 206 \'ab endl; \line 207 \b\f2\fs20\} \line\b0\f3\fs16 208 \line 209 \i\f2\fs20 II \i0\f3\fs16 reescalona chegada em um andar \line 210 void Scheduler::delayTime( const Floor &floor \line 211 \b\f2\fs20\{ \line\b0\f3\fs16 212 int floorNumber \f2\fs10 = \f3\fs16 floor.getNumberQ; \line\f2\fs20 Fig. 7.17 Arquivo de implementa\'e7\'e3o da classe Scheduler (parte 1 de 2). \f0\fs24\par
\fs14 CAP\'cdTULO \fs20 7 \f2\fs8 - \f0\fs14 CLASSES: PARTE \fs20 II \b\f2\fs22 491 \line\b0\f3\fs16 luza \f0\fs14 213 \line\f3\fs16 I\'e7\'e3o 214 int arrivalTime \f0\fs20 ( \f3\fs16 floorNumber \f2\fs10 == \f3\fs16 Floor: :FLOOR1 \f0\fs20 ) \fs14 ? \line\f3\fs16 Esta 215 ++floorlArrivalTinie : ++floor2ArrivalTime; \line 216 \line 217 cout \'ab \lquote (scheduler retarda pr\'f3xima pessoa para andar \line 218 \'ab floorNumber \'ab at\'e9 a hora \f2\fs8\ldblquote  \f3\fs16\'ab arrivalTime \'ab \f0\fs20 ) \line\f3\fs16 219 \'ab endi; \line 220 \f0\fs20 1 \line\f3\fs16 221 \line 222 \i\fs22 II \i0\fs16 fornece a hora para o scheduler \line 223 void Scheduler::processTime( int time \line 224 \line 225 currentClockTime \f2\fs10 = \f3\fs16 time; \f0\fs20 // \f3\fs16 record time \line 226 \line 227 \i\fs22 II \i0\fs16 processa chegadas no andar 1 \line 228 handleArrivals( floorlRef, currentClockTime ); \line 229 \line 230 \i\fs22 II \i0\fs16 processa chegadas no andar 2 \line 231 handleArrivals( floor2Ref, currentClockTime ); \line 232 \f0\fs20\} \line\f3\fs16 233 \line 234 \i\fs22 II \i0\fs16 cria nova pessoa e a coloca no andar especificado \line 235 void Scheduler: :createNewPerson( Floor &floor \line 236 \f0\fs20\{ \line\f3\fs16 237 int destinationFloor \f2\fs10 = \line\f3\fs16 238 floor.getNumber() Floor::FLOOR1 ? \line 239 Floor: :FLOOR2 : Floor: :FLOOR1; \line 240 \line 241 \i\fs22 II \i0\fs16 cria nova pessoa \line 242 Person *newpersonptr \f2\fs10 = \f3\fs16 new Person( destinationFloor \f0\fs20 ) \line\f3\fs16 243 \line 244 cout \'ab \ldblquote scheduler cria pessoa \line 245 \'ab newPersonPtr->getlD() \'ab endl; \line 246 \line 247 \i\fs22 II \i0\fs16 coloca pessoa no andar adequado \line 248 newPersonPtr->stepOntoFloor( floor ); \line 249 \line 250 scheduleTime( floor ); \i\fs22 1/ \i0\fs16 escalona pr\'f3xima chegada \line 251 \f0\fs20\} \line\f3\fs16 252 \line 253 \i\fs22 II \i0\fs16 processa chegadas em um andar espec\'edfico \line 254 void Scheduler::handleArrivals( Floor &floor, int time \line 255 \line 256 int floorNumber \f2\fs10 = \f3\fs16 floor.getNunibero; \line 257 \line 258 int arrivalTime \f2\fs10 = \f0\fs20 ( \f3\fs16 floorNumber \f2\fs10 == \f3\fs16 Floor: :FLOOR1 \f0\fs20 ) \fs14 ? \line\f3\fs16 259 floorlArrivalTime : floor2ArrivalTime; \line 260 \line 261 if \f0\fs20 ( \f3\fs16 arrivalTime \f2\fs10 == \f3\fs16 time \line 262 \line 263 if \f0\fs20 ( \f3\fs16 floor.isOccupied() \f0\fs20 ) // \f3\fs16 verifica se andar est\'e1 ocupado \line 264 delayTime( floor ); \line 265 else \line 266 createNewPerson( floor \line 267 \f0\fs20\} \line\f3\fs16 268 \line\f2\fs18 Fig. 7.17 Arquivo de implementa\'e7\'e3o da classe Scheduler (parte 2 de 2). \f0\fs24\par
\fs18 492 \f2\fs28 c++ \b\f0\fs16 COMO PROGRAMAR \line\b0\fs18 Em nossa simu1a\'e7o, o building informa a hora atual ao scheduler a cada segundo, atrav\'e9s da fun\'e7\'e3o mcm- bro de scheduler processTime (linhas \f2\fs20 222 \f0\fs18 a 232). O diagrama de seq\'fc\'eancia na Fig. 4.27 modelou a seq\'fc\'eancia de atividades que ocorre em resposta a esta mensagem e nossa implementa\'e7\'e3o reflete este modelo. Quando a fun\'e7\'e3o membro processTime \'e9 invocada, scheduler chama a fun\'e7\'e3o utilit\'e1ria handleArrivals para cada andar (linhas 228 a 231). Esta fun\'e7\'e3o utilit\'e1ria compara a hora atual (time, fornecida por building) com a pr\'f3xima hora de chegada escalonada para aquele andar (linha 261). Se a hora atual coincide com a hora de chegada para o andar e se o andar est\'e1 atualmente ocupado (linha 263), scheduler chama a fun\'e7\'e3o utilit\'e1ria delayTime para retardar a pr\'f3xima chegada escalonada em um segundo (linha 264). Se o andar est\'e1 desocupado, o scheduler invoca a fun\'e7\'e3o utilit\'e1ria createNewPerson (linha 266), que cria um novo objeto da classe Person usando o operador new (linha 242). O scheduler ent\'e3o envia a este novo objeto da classe Person a mensagem stepOntoFloor (linha 248). Assim que a pessoa tiver entrado no andar, o scheduler calcula a pr\'f3xima hora de chegada de uma pessoa \'e0quele andar chamando a fun\'e7\'e3o utilit\'e1ria scheduleTime (linha 250). \line Examinamos a implementa\'e7\'e3o de todas as classes que comp\'f5em a parte controladora da simula\'e7\'e3o; agora, examinemos as classes que comp\'f5em a parte \ldblquote mundo\rdblquote  da simula\'e7\'e3o. A classe Beil, como a classe Clock, n\'e3o \'e9 composta por outros objetos. A interface public da classe Beli, como definida em seu arquivo de cabe\'e7alho na Fig. \f2\fs20 7. \f0\fs18 18, consiste em um construtor, um destruidor e a fun\'e7\'e3o membro ringBell. As implementa\'e7\'f5es destas fun\'e7\'f5es (linhas 292 e 293, 295 e 296, e 298 e 299, respectivamente, na Fig. 7. 1 9) simplesmente enviam mensagens para a tela. \line\b\f3\fs16 269 \b0\i\fs22 II \b\i0\fs16 bell.h \line 270 \b0\i\fs22 II \b\i0\fs16 Defini\'e7\'e3o da classe Beli. \line 271 #ifndef BELLH \line 272 #define BELLH \line 273 \line 274 class Beil \b0\f0\fs18\{ \line\b\f3\fs16 275 \line 276 public: \line 277 BeilO; \b0\i\fs20 II \b\i0\fs16 construtor \line 278 Bell \b0\i\fs22 1/ \b\i0\fs16 destruidor \line 279 void ringBell() const; \b0\i\fs22 II \b\i0\fs16 toca a campainha \line 280 \line 281 \line 282 #endif \b0\i\fs22 II \b\i0\fs16 BELLH \line\b0\f2\fs20 Fig. 7.18 Arquivo de cabe\'e7alho da classe Beli. \line\b\f3\fs16 283 \b0\i\fs20 II \b\i0\fs16 bell.cpp \line 284 \b0\i\fs20 II \b\i0\fs16 Defini\'e7\'f5es de fun\'e7\'f5es membro para a classe Beil. \line 285 #include <iostreani> \line 286 \line 287 using std::cout; \line 288 using std::endl; \line 289 \line 290 #include bell.h\rdblquote  \line 291 \line 292 Bell::Bell() \b0\i\fs22 II \b\i0\fs16 construtor \line 293 \b0\f0\fs18\{ cout \b\fs16\'ab \lquote campainha criada\rdblquote  \'ab endl; \line\f3 294 \line 295 Bell::Bell() \b0\f0\fs18 // \b\f3\fs16 destruidor \line 296 \b0\f0\fs18\{ \b\f3\fs16 cout \f0\'ab \f3\ldblquote campainha destru\'edda\rdblquote  \'ab endi; \line 297 \line 298 void Bell::ringBell() const \b0\i\fs20 II \b\i0\fs16 toca campainha \line 299 \b0\f0\fs18\{ \b\f3\fs16 cout \'ab \ldblquote elevador toca a campainha\rdblquote  \'ab endl; \line\b0\f2\fs20 Fig. 7.19 Arquivo de implementa\'e7\'e3o da classe Beli. \f0\fs24\par
\fs14 CAP\'cdTULO \fs20 7 \f2\fs8 - \f0\fs14 CLASSES: PARTE \b\f2\fs20 11 493 \line\b0\f0\fs14 1- \fs20 A classe Light (Figs. 7.20 e 7.21) exp\'f5e duas fun\'e7\'f5es membro em sua interface public. al\'e9m do construtor e do n- destruidor. A fun\'e7\'e3o membro turnOn simplesmente liga a luz, ajustando o membro de dados on para true (linhas \line\fs14 ) \fs20 a 335 a 339). A fun\'e7\'e3o membro turnOff (linhas 341 a 345) desliga a luz, ajustando o membro de dados on para \line da false. \line a \line da \line\f3\fs16 e 300 \i\fs20 II \i0\fs16 light.h \line r 301 \i\fs20 II \i0\fs16 Defini\'e7\'e3o da classe Light. \line\f1\fs50 : \f3\fs16 302 #ifndef \line 303 #define LIGHT H \line\f0\fs20 m 304 \f2\fs8 - \line\f3\fs16 ra 305 class Light \f0\fs20\{ \line\f3\fs16 306 \line ra, 307 public: \line\i\fs20 )\'e9 \i0\fs16 308 Light( const char \f2\fs10 * \f0\fs20 ) \fs14 ; \fs20 // \f3\fs16 construtor \line ig. 309 -Light() ; \i\fs20 II \i0\fs16 destruidor \line es 310 void turnOn() ; \i\fs20 II \i0\fs16 liga a luz \line Ia. 311 void turnOffO; \i\fs22 II \i0\fs16 desliga a luz \line 312 \line 313 private: \line 314 bool on; \i\fs22 II \i0\fs16 true se ligada; false se desligada \line 315 const char *ne; \i\fs22 /1 \i0\fs16 em que andar a luz est\'e1 ligada \line 316 \}; \line 317 \line 318 #endif \i\fs22 II \i0\fs16 LIGHTH \line\f2\fs20 Fig. 7.20 Arquivo de cabe\'e7alho da classe Light. \line\f3\fs16 319 \i\fs20 II \i0\fs16 light.cpp \line 320 \i\fs22 II \i0\fs16 Defini\'e7\'f5es de fun\'e7\'f5es membro para a classe Light. \line\f0\fs20 321 #include <iostream> \line\f3\fs16 322 \line 323 using std: :cout; \line 324 using std: :endl; \line 325 \line 326 #include \lquote light.h\rdblquote  \line 327 \line 328 Light::Light( const char *string \f0\fs20 ) // \f3\fs16 construtor \line 329 : on( false ), name( string \line 330 \f0\fs20\{ \f3\fs16 cout \'ab name \'ab \f2\fs8\ldblquote  \f3\fs16 luz criada\rdblquote  \'ab endl; \line 331 \line 332 Light::-.Light() \i\fs20 II \i0\fs16 destruidor \line 333 \f0\fs20\{ \f3\fs16 cout \f0\fs20\'ab \f3\fs16 name \'ab \f2\fs8\ldblquote  \f3\fs16 luz destru\'edda\rdblquote  \'ab endl; \line 334 \line 335 void Light::turnOn() \i\fs20 II \i0\fs16 liga a luz \line 336 \line 337 on \f2\fs12 = \f3\fs16 true; \line 338 cout \'ab name \'ab \f2\fs8\lquote  \f3\fs16 liga a luz\rdblquote  \'ab endl; \line 339 \f0\fs20 1 \line\f3\fs16 340 \line 341 void Light::turnOff() \i\fs22 II \i0\fs16 desliga a luz \line 342 \f0\fs20\{ \line\f3\fs16 343 on \f2\fs8 = \f3\fs16 false; \line 344 cout \'ab name \'ab \f2\fs8\ldblquote  \f3\fs16 desliga a luz\rdblquote  \'ab endl; \line 345 \f0\fs20\} \line\f2 Fig. 7.21 Arquivo de implementa\'e7\'e3o da classe Light. \f0\fs24\par
\b\f2\fs20 494 \b0\fs28 c++ \b\f0\fs14 COMO PROGRAMAR \line\b0\fs18 A classe Door (Figs. 7.22 e 7.23) desempenha um papel importante em nossa simuIa\'e7o de elevador. \f1\fs26\'c9 \f0\fs18 o objeto \b\f2\fs20 door \b0\f0\fs18 que avisa ao passageiro do elevador para sair; door tamb\'e9m avisa \'e0 pessoa que est\'e1 esperando no andar que entre no elevador. Estas a\'e7\'f5es s\'e3o executadas pela fun\'e7\'e3o membro openDoor da classe Door. Voc\'ea vai notar que a fun\'e7\'e3o membro openDoor recebe quatro argumentos (linhas 361 a 362 e 390 a 392). O primeiro \'e9 um ponteiro para o objeto da classe Person que ocupa o elevador. O segundo argumento \'e9 um ponteiro para o objeto da classe Person que est\'e1 esperando no andar. Os dois argumentos restantes s\'e3o refer\'eancias para o objeto da classe Floor apropriado e para o objeto elevator. \line\b\f3\fs16 346 \b0\i\fs22 II \b\i0\fs16 door.h \line 347 \b0\i\fs22 II \b\i0\fs16 Defini\'e7\'e3o da classe Door. \line 348 #ifndef DOORH \line 349 #define DOORH \line 350 \line 351 class Person; \f2\fs20 // \f3\fs16 declara\'e7\'e3o antecipada \line 352 class Floor; \f2\fs20 // \f3\fs16 declara\'e7\'e3o antecipada \line 353 class Elevator; \b0\i\fs20 1/ \b\i0\fs16 declara\'e7\'e3o antecipada \line 354 \line 355 class Door \f2\fs20\{ \line\f3\fs16 356 \line 357 public: \line 358 DoorO; \b0\i\fs20 II \b\i0\fs16 construtor \line 359 -.Dooro; \b0\i\fs22 II \b\i0\fs16 destruidor \line 360 \line 361 void openDoor( Person \b0\f2\fs10 * \b\f3\fs16 const, Person \b0\f2\fs10 * \b\f3\fs16 const, \line 362 Floor \f0\fs14 &, \f3\fs16 Elevator & ); \line 363 void closeDoor( const Floor & ); \line 364 \line 365 private: \line 366 bool open; \b0\i\fs22 1/ \b\i0\fs16 aberta ou fechada \line 367 \line 368 \line 369 #endif \b0\i\fs22 II \b\i0\fs16 DOORH \line\f2\fs20 Fig. 7.22 \b0 Arquivo de cabe\'e7alho da classe Door. \line\f0\fs18 A classe Door \'e9 um objeto composto da classe Elevator para implementar esta composi\'e7\'e3o, o arquivo de \line cabe\'e7alho da classe Elevator precisa conter a linha \line\b\f3\fs16 #include \ldblquote door \b0\f2\fs8 . \b\f3\fs16 h\rdblquote  \line\b0\f0\fs18 A classe Door usa uma refer\'eancia a um objeto da classe Elevator (linha 362). Para declarar a classe Elevator. de modo a permitir que a classe Door use esta refer\'eancia, poder\'edamos colocar a seguinte linha no arquivo de cabe\'e7alho da classe Door: \line #include \ldblquote elevator \f2\fs8 . \b\f3\fs16 h\rdblquote  \line\b0\f0\fs18 Assim, o arquivo de cabe\'e7alho para a classe Elevator incluiria o arquivo de cabe\'e7alho para a classe Door. e vice- versa. O pr\'e9-processador n\'e3o seria capaz de resolver tais diretivas #include e geraria um erro fatal devido a este \i problema de inclus\'e3o circular. \line\i0 Para evitar este problema, colocamos uma declara\'e7\'e3o antecipada \i\fs20 (forward) \i0\fs18 da classe Elevator no arquivo de cabe\'e7alho da classe Door (linha 353). Esta declara\'e7\'e3o antecipada diz ao pr\'e9-processador que queremos fazer refer\'eancia a objetos da classe Elevator em nosso arquivo, mas que a defini\'e7\'e3o da classe Elevator est\'e1 fora do arquivo. Note que tamb\'e9m fazemos declara\'e7\'f5es antecipadas para as classes Person e Floor (linhas 351 e \i 352), \i0 de modo que podemos usar estas classes no prot\'f3tipo para a fun\'e7\'e3o membro openDoor. \fs24\par
\fs18 CAP\'cdTULO 7 \f2\fs8 - \f0\fs18 CLASSES: PARTE \b\fs16 II \i\f2\fs18 495 \line\b0\i0\f0 A Fig. 7.23 lista o arquivo de implementa\'e7\'e3o para a classe Door. Nas linhas 378 a 380, inclu\'edmos os arquivos de cabe\'e7alho para as classes Person. Floor e Elevator. Estas diretivas #include correspondem \'e0s nossas declara\'e7\'f5es antecipadas no cabe\'e7alho; e os arquivos de cabe\'e7alho que est\'e3o sendo inclu\'eddos cont\'eam os prot\'f3tipos de fun\'e7\'f5es obrigat\'f3rios de que necessitamos para sermos capazes de invocar as fun\'e7\'f5es membro apropriadas destas classes. \line Quando a fun\'e7\'e0o membro openDoor (linhas 389 a 409) \'e9 chamada, ela primeiro verifica se a portaj\'e1 n\'e3o est\'e1 aberta. A porta verifica se o ponteiro para a pessoa no elevador (passengerPtr) n\'e3o \'e9 zero (linha 400). Se este ponteiro n\'e3o \'e9 zero, existe uma pessoa no elevador que precisa sair. A pessoa \'e9 avisada para sair do elevador atrav\'e9s da mensagem exitElevator (linha 401 \b\i\f2 ). \b0\i0\f0 A porta elimina o objeto da classe Person que estava andando no elevador atrav\'e9s do operador delete (linha 402). \line\b\f3\fs16 370 \b0\i\fs22 II \b\i0\fs16 door.cpp \line 371 \b0\i\fs22 II \b\i0\fs16 Defini\'e7\'f5es de fun\'e7\'f5es membro para a classe Door. \line 372 #include <iostream> \line 373 \line 374 using std: :cout; \line 375 using std: :endl; \line 376 \line 377 #include \ldblquote door.h\rdblquote  \line 378 #include \ldblquote person.h\rdblquote  \line 379 #include \lquote floor.h\rdblquote  \line 380 #include \ldblquote elevator.h\rdblquote  \line 381 \line 382 Door: :Door() \b0\i\fs22 II \b\i0\fs16 construtor \line 383 : open( false \line 384 \b0\f0\fs18\{ \b\f3\fs16 cout \'ab \ldblquote porta criada\rdblquote  \b0\f0\fs18\'ab \b\f3\fs16 endl; \line 385 \line 386 Door::-Door() \b0\f0\fs18 // \b\f3\fs16 destruidor \line 387 \b0\f0\fs18\{ \b\f3\fs16 cout \'ab \ldblquote porta destru\'edda\rdblquote  \'ab endi; \line 388 \line 389 \b0\i\fs22 II \b\i0\fs16 abre a porta \line 390 void Door: :openDoor( Person \b0\f2\fs10 * \b\f3\fs16 const passengerPtr, \line 391 Person \b0\f2\fs10 * \b\f3\fs16 const nextPassengerPtr, \line 392 Floor &currentFloor, Elevator &elevator \line 393 \b0\f0\fs18\{ \line\b\f3\fs16 394 if \b0\f0\fs18 ( \b\f3\fs16 !open \b0\f0\fs18 ) \line\b\f3\fs16 395 open \b0\f2\fs12 = \b\f3\fs16 true; \line 396 \line 397 cout \'ab \ldblquote elevador abre a porta no andar \line 398 \'ab currentFloor.getNuiTlber() \'ab endl; \line 399 \line 400 if \b0\f0\fs18 ( \b\f3\fs16 passengerPtr ! O \b0\f0\fs18 ) \{ \line\b\f3\fs16 401 passengerPtr->exitElevator( currentFloor, elevator \b0\f0\fs18 ) \line\b\f3\fs16 402 delete passengerPtr; \b0\i\fs22 /1 \b\i0\fs16 passageiro sai da simula\'e7\'e3o \line 403 \b0\f0\fs18\} \line\b\f3\fs16 404 \line 405 if \b0\f0\fs18 ( \b\f3\fs16 nextPassengerPtr \f0 ! \f3 O \line 406 nextPassengerPtr->enterElevator \line 407 elevator, currentFloor \b0\f0\fs18 ) \line\b\f3\fs16 408 \b0\f0\fs18\} \line\b\f3\fs16 409 \b0\f0\fs18\} \line\b\f3\fs16 410 \line 411 \b0\i\fs22 II \b\i0\fs16 fecha a porta \line 412 void Door::closeDoor( const Floor &currentFloor \line 413 \b0\f0\fs18\{ \line\b\f2 Fig. 7.23 \b0\fs20 Arquivo de implementa\'e7\'e3o da classe Door (parte 1 de 2). \f0\fs24\par
\fs18 CAP\'cdTULO 7 \f2\fs8 - \f0\fs18 CLASSES: PARTE TI \b\i\f2\fs20 495 \line\b0\i0\f0 to \fs18 A Fig. 7.23 lista o arquivo de implementa\'e7\'e3o para a classe Door. Nas linhas 378 a 380, inclu\'edmos os arquivos ue de cabe\'e7alho para as classes Person, Floor e Elevator. Estas diretivas #include correspondem \'e0s nossas ue declara\'e7\'f5es antecipadas no cabe\'e7alho; e os arquivos de cabe\'e7alho que est\'e3o sendo inclu\'eddos cont\'eam os prot\'f3tipos de ro fun\'e7\'f5es obrigat\'f3rios de que necessitamos para sermos capazes de invocar as fun\'e7\'f5es membro apropriadas destas se classes. \line )r Quando a fun\'e7\'e3o membro openDoor (linhas 389 a 409) \'e9 chamada, ela primeiro verifica se a portaj\'e1 n\'e3o \line est\'e1 aberta. A porta verifica se o ponteiro para a pessoa no elevador (passengerPtr) n\'e3o \'e9 zero (linha 400). Se este ponteiro n\'e3o \'e9 zero, existe uma pessoa no elevador que precisa sair. A pessoa \'e9 avisada para sair do elevador atrav\'e9s da mensagem exitElevator (linha 40 1 \b\i\f2\fs20 ). \b0\i0\f0\fs18 A porta elimina o objeto da classe Person que estava andando no elevador atrav\'e9s do operador delete (linha 402). \line\b\f3\fs16 370 \b0\i\fs22 II \b\i0\fs16 door.cpp \line 371 \b0\i\fs22 II \b\i0\fs16 Defini\'e7\'f5es de fun\'e7\'f5es membro para a classe Door. \line 372 #include <iostream> \line 373 \line 374 using std: :cout; \line 375 using std::endl; \line 376 \line 377 #include \lquote door.h\rdblquote  \line 378 #include \ldblquote person.h\rquote  \line 379 #include \ldblquote floor.h\rdblquote  \line 380 #include \ldblquote elevator.h\rdblquote  \line\b0\f0\fs18 381 \line\b\f3\fs16 382 Door::Door() \b0\i\fs22 II \b\i0\fs16 construtor \line 383 : open( false \line 384 \b0\f0\fs18\{ cout \'ab \b\f3\fs16\ldblquote porta criada\rdblquote  \'ab endi; \line 385 \line 386 Door::Door() \b0\f0\fs18 // \b\f3\fs16 destruidor \line 387 \b0\f0\fs18\{ \b\f3\fs16 cout \'ab \ldblquote porta destru\'edda\rdblquote  \'ab endl; \line 388 \line 389 \b0\i\fs22 II \i0\fs16 abre a \b porta \line 390 void Door: :openDoor( Person \b0\f2\fs10 * \b\f3\fs16 const passengerPtr, \line 391 Person \b0\f2\fs10 * \b\f3\fs16 const nextPassengerPtr, \line 392 Floor &currentFloor, Elevator &elevator \line 393 \line 394 if \b0\f0\fs18 ( \b\f3\fs16 !open \b0\f0\fs18 ) \{ \line\b\f3\fs16 395 open \b0\f2\fs12 = \b\f3\fs16 true; \line 396 \line 397 cout \'ab \ldblquote elevador abre a porta no andar \line 398 \'ab currentFloor.getNumber() \'ab endl; \line 399 \line\b0 400 if \f0\fs18 ( \b\f3\fs16 passengerPtr \b0\f0\fs18 != \b\f3\fs16 O \b0\f0\fs18 ) \{ \line\b\f3\fs16 401 passengerPtr->exitElevator( currentFloor, elevator \b0\f0\fs18 ) \line\b\f3\fs16 402 delete passengerPtr; \b0\f0\fs18 // \b\f3\fs16 passageiro sai da simula\'e7\'e3o \line 403 \b0\f0\fs18\} \line\b\f3\fs16 404 \line 405 if \b0\f0\fs18 ( \b\f3\fs16 nextPassengerPtr \b0\f0\fs18 != \b\f3\fs16 O \line 406 nextPassengerPtr->enterElevator \line\b0\fs20 e- \b\fs16 407 elevator, currentFloor ); \line\b0\fs20 te \b\fs16 408 \b0\f0\fs18\} \line\b\f3\fs16 409 \b0\f0\fs18\} \line\fs20 vo \fs18 410 \line\f3\fs20 er \b\fs16 411 \b0\i\fs22 II \b\i0\fs16 fecha a porta \line\b0\fs20 io \b\fs16 412 void Door::closeDoor( const Floor &currentFloor \b0\f0\fs18 ) \line\b\i\f2\fs20 ), \b0\i0\f0\fs18 413 \{ \line\b\f2 Fig. 7.23 \b0\fs20 Arquivo de implementa\'e7\'e3o da classe Door (parte 1 de 2). \line\fs36 1 \f0\fs24\par
\f2\fs20 496 \fs28 c++ \fs16 COMO \f0 PROGRAMAR \line\f3 414 if \b (open) \b0\f2\fs20\{ \line\f3\fs16 415 \b open \b0\f2\fs12 = \b\f3\fs16 false; \line 416 cout \'ab elevador fecha a porta no andar \line\b0 417 \'ab currentFloor.getNuniber() \'ab endi; \line 418 \f2\fs20\} \line\f3\fs16 419 \f2\fs20\} \line Fig. 7.23 Arquivo de implementa\'e7\'e3o da classe Door (parte 2 de 2). \line\f0\fs16 Assim que o passageiro sai do elevador, a porta verifica o ponteiro para a pessoa que est\'e1 esperando no andar (nextPassengerPtr) para ver se aquele ponteiro n\'e3o \'e9 zero (linha 405). Se o ponteiro n\'e3o \'e9 zero (i.e., existe uma pessoa esperando para entrar no elevador), a pessoa \'e9 autorizada a entrar no elevador atrav\'e9s da fun\'e7\'e3o membro enterElevator da classe Person (linhas 406 e 407). A fun\'e7\'e3o membro closeDoor (linhas 412 a 419) simplesmente verifica se a porta est\'e1 aberta e, se estiver, a fecha. \line Algumas pessoas no sistema usam um objeto da classe ElevatorButton (Figs. 7.24 e 7.25) para fazer o elevador come\'e7ar a se mover para o outro andar. A fun\'e7\'e3o membro pressButton (linhas 460 a 466) primeiro ajusta o atributo pressed do bot\'e3o do elevador para true e ent\'e3o envia a mensagem prepareToLeave para o elevator. A fun\'e7\'e3o membro resetButton simplesmente ajusta o atributo pressed para false. \line\b\f3 420 \b0\i\fs22 II \i0\fs16 elevatorButton.h \line\b 421 \b0\i\fs22 II \i0\fs16 Defini\'e7\'e3o da classe ElevatorButton. \line\b 422 #ifndef ELEVATORBUTTONH \line 423 #define ELEVATORBUTTONH \line 424 \line 425 class Elevator; \b0\i\fs22 II \b\i0\fs16 declara\'e7\'e3o antecipada \line 426 \line 427 class ElevatorButton \b0\f0\{ \line\b\f3 428 \line 429 public: \line 430 ElevatorButton( Elevator & ); \b0\i\fs22 II \i0\fs16 construtor \line\b 431 -\lquote ElevatorButton() ; \b0\f0 // \b\f3 destruidor \line 432 \line\b0 433 void pressButtonQ; \i\fs22 II \b\i0\fs16 aperta o bot\'e3o \line\b0 434 void resetButtonO; \i\fs22 II \b\i0\fs16 desliga o bot\'e3o \line\b0 435 \line 436 private: \line\b 437 bool pressed; \b0\i\fs22 1/ \b\i0\fs16 estado do bot\'e3o \line 438 Elevator &elevatorRef; \b0\i\fs22 II \b\i0\fs16 refer\'eancia para o elevador do bot\'e3o \line 439 \line 440 \line\b0 441 #endif \i\fs20 II \i0\fs16 ELEVATORBUTTONH \line\f2\fs20 Fig. 7.24 Arquivo de cabe\'e7alho da classe ElevatorButton. \f0\fs24\par
\f2\fs20 Fig. 7.25 Arquivo de implementa\'e7\'e3o da classe ElevatorButton (parte 1 de 2). \f0\fs24\par
\pard\par
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx397\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx3062\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx6735\pard\intbl\b\f3\fs16 442 \b0\f0\fs24\cell\i\f3\fs22 II \i0\fs18 elevatorButton.cpp: \f0\fs24\cell\cell\fs20\row
\b\f3\fs16\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx397\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx3062\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx6735\intbl 443 \b0\f0\fs24\cell\i\f3\fs22 II \b\i0\fs16 Defini\'e7\'e3o de fun\'e7\'f5es \b0\f0\fs24\cell\b\f3\fs16 membro para a classe ElevatorButton. \b0\f0\fs24\cell\fs20\row
\b\f3\fs16\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx397\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx3062\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx6735\intbl 444 \b0\f0\fs24\cell\b\f3\fs16 4include <iostream> \b0\f0\fs24\cell\cell\fs20\row
\f3\fs16\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx397\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx3062\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx6735\intbl 445 \f0\fs24\cell\cell\cell\fs20\row
\f3\fs16\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx397\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx3062\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx6735\intbl 446 \f0\fs24\cell\f3\fs16 using std::cout; \f0\fs24\cell\cell\fs20\row
\b\f3\fs16\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx397\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx3062\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx6735\intbl 447 \b0\f0\fs24\cell\b\f3\fs16 using std: :endl; \b0\f0\fs24\cell\cell\fs20\row
\b\f3\fs16\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx397\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx3062\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx6735\intbl 448 \b0\f0\fs24\cell\cell\cell\fs20\row
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx397\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx6735\pard\intbl\b\f3\fs16 449 \b0\f0\fs24\cell\b\f3\fs16 #include \ldblquote elevatorButton.h\rdblquote  \b0\f0\fs24\cell\fs20\row
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx397\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx3062\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx6735\pard\intbl\b\f3\fs16 450 \b0\f0\fs24\cell\b\f3\fs16 #include \ldblquote elevator.h\rdblquote  \b0\f0\fs24\cell\cell\fs20\row
\pard\fs24\par
\pard\sb100\sa240\fs14 CAP\'cdTULO \fs20 7 \f2\fs8 - \f0\fs14 CLASSES: PARTE \fs20 II 497 \line\fs14 451 \line\f3\fs16 452 \i\fs20 II \i0\fs16 construtor \line 453 ElevatorButton: :ElevatorButton( Elevator &elevatorHandle \line 454 : pressed( false \f0\fs20 ), \f3\fs16 elevatorRef( elevatorHandle \line 455 \f0\fs20\{ \f3\fs16 cout \'ab \ldblquote bot\'e3o do elevador criado \'ab endl; \line 456 \line 457 ElevatorButton : : -ElevatorButton() \i\fs22 II \i0\fs16 destruidor \line 458 \f0\fs20\{ \f3\fs16 cout \'ab \ldblquote bot\'e3o do elevador destru\'eddo\rdblquote  \'ab endl; \line 459 \line 460 void ElevatorButton::pressButton() \i\fs20 II \i0\fs16 aperta o bot\'e3o \line 461 \line 462 pressed \f2\fs10 = \f3\fs16 true; \line 463 cout \'ab bot\'e3o do elevador avisa elevador que se prepare para sair\rquote  \line 464 \'ab endl; \line 465 elevatorRef.prepareToLeave( true ); \line 466 \f0\fs20\} \line\f3\fs16 467 \line 468 void ElevatorButton::resetButton() \i\fs22 II \i0\fs16 desliga o bot\'e3o \line 469 \f0\fs20\{ \f3\fs16 pressed \f2\fs10 = \f3\fs16 false; \f0\fs20\} \line\f2 Fig. 7.25 Arquivo de implementa\'e7\'e3o da classe ElevatorButton (parte 2 de 2). \line\f0 A classe FloorButton (Figs. 7.26 e 7.27), atrav\'e9s de sua interface public. exp\'f5e as mesmas fun\'e7\'f5es membro que a classe ElevatorButton. A fun\'e7\'e3o membro public pressButton chama o elevador atrav\'e9s da mensagem summonElevator. O bot\'e3o do andar \'e9 desligado atrav\'e9s de uma chamada para a fun\'e7\'e3o membro \line\f3\fs16 resetButton. \line 470 \i\fs22 II \i0\fs16 floorButton.h \line 471 \i\fs20 II \i0\fs16 Defini\'e7\'e3o da classe FloorButton. \line 472 #ifndef FLOORBUTTONH \line 473 #define FLOORBUTTONH \line 474 \line 475 class Elevator; \i\fs20 II \i0\fs16 declara\'e7\'e3o antecipada \line\f0\fs18 476 \line\f3\fs16 477 class FloorButton \line\f0\fs18 478 \line\f3\fs16 479 public: \line 480 FloorButton( const int, Elevator & ); \i\fs22 II \i0\fs16 construtor \line 481 FloorButton \i\fs22 II \i0\fs16 destruidor \line 482 \line 483 void pressButton() ; \f0\fs20 // \f3\fs16 aperta o bot\'e3o \line 484 void resetButton \f0\fs20 // \f3\fs16 desliga o bot\'e3o \line\f0\fs18 485 \line\f3\fs16 486 private: \line 487 const int floorNuinber; \f0\fs20 // \f3\fs16 n\'famero do andar do bot\'e3o \line 488 bool pressed; \i\fs22 II \i0\fs16 estado do bot\'e3o \line\f0\fs18 489 \line\f3\fs16 490 \i\fs22 II \i0\fs16 refer\'eancia ao elevador do bot\'e3o \line 491 Elevator &elevatorRef; \line 492 \line\f0\fs18 493 \line\f3\fs16 494 #endif \i\fs20 II \i0\fs16 FLOORBUTTONH \line\f2\fs20 Fig. 7.26 Arquivo de cabe\'e7alho da classe FloorButton. \f0\fs24\par
\b\f2\fs20 498 \b0\fs28 c++ \f0\fs18 COMO PROGRAMAR \line\b\f3\fs16 495 \b0\i\fs22 II \b\i0\fs16 floorButton.cpp \line 496 \b0\i\fs22 II \b\i0\fs16 Defini\'e7\'f5es de fun\'e7\'f5es membro para a classe FloorButton. \line 497 #include <iostream> \line 498 \line 499 using std::cout; \line 500 using std::endl; \line 501 \line 502 #include \ldblquote floorButton.h \line 503 #include \ldblquote elevator.h\rdblquote  \line 504 \line 505 \b0\i\fs22 II \b\i0\fs16 construtor \line 506 FloorButton: :FloorButton( const int numner, \line 507 Elevator &elevatorHandle \line 508 : floorNumber( nurnber \f2\fs20 ), \f3\fs16 pressed( false \f2\fs20 ), \line\f3\fs16 509 elevatorRef( elevatorHandle \line 510 \line 511 cout \b0\f0\fs18\'ab \b\f3\fs16\ldblquote bot\'e3o do andar \b0\f2\fs8\ldblquote  \f0\fs18\'ab \b\f3\fs16 floorNuniber \'ab \b0\f2\fs8\ldblquote  \b\f3\fs16 criado\rdblquote  \line 512 \'ab endl; \line 513 \f2\fs20\} \line\f3\fs16 514 \line 515 FloorButton : : FloorButton() \f2\fs20 // \f3\fs16 destruidor \line 516 \line 517 cout \'ab \ldblquote bot\'e3o do andar \b0\f2\fs8\ldblquote  \f0\fs18\'ab floorNumber \'ab \f2\fs8\ldblquote  \b\f3\fs16 destru\'eddo\rdblquote  \line 518 \'ab endl; \line 519 \f2\fs20 ) \line\f3\fs16 520 \line 521 \b0\i\fs22 II \b\i0\fs16 aperta o bot\'e3o \line 522 void FloorButton: :pressButton() \line 523 \line 524 pressed \b0\f2\fs10 = \b\f3\fs16 true; \line 525 cout \'ab \ldblquote bot\'e3o do andar \b0\f2\fs8\ldblquote  \f0\fs18\'ab floorNuniber \line\b\f3\fs16 526 \b0\f0\fs18\'ab \f2\fs8\ldblquote  \f0\fs18 chama o elevador\rdblquote  \'ab endl; \line\b\f3\fs16 527 elevatorRef.suinmonElevator( floorNumber ); \line 528 \f2\fs20\} \line\f3\fs16 529 \line 530 \b0\i\fs22 II \b\i0\fs16 desliga o bot\'e3o \line 531 void FloorButton: :resetButton() \line 532 \f2\fs20\{ \f3\fs16 pressed \b0\f2\fs10 = \b\f3\fs16 false; \f2\fs20 ) \line\b0 Fig. 7.27 Arquivo de mplementa\'e7\'e3o da classe FloorButton. \line\fs28 o \f0\fs18 arquivo de cabe\'e7alho para a classe Elevator (Fig. 7.28) \'e9 o mais complexo em nossa simula\'e7\'e3o. A classe Elevator exp\'f5e cinco fun\'e7\'f5es membro (al\'e9m de seu construtor e destruidor) em sua interface public. A fun\'e7\'e3o membro processTime permite que o edif\'edcio envie a hora atualizada do rel\'f3gio para o elevador. A fun\'e7\'e3o membro summonElevator permite que um objeto Person envie uma mensagem para o elevador para solicitar seu servi\'e7o. As fun\'e7\'f5es membro passengerEnters e passengerExits habilitam os passageiros a entrar e sair do elevador e a fun\'e7\'e3o membro prepareToLeave habilita o elevador a executar quaisquer tarefas necess\'e1rias, antes de come\'e7ar a se mover para um outro andar. Declaramos o objeto elevatorButton como public, de modo que um objeto da classe Person possa acessar diretamente o elevatorButton. Uma pessoa geralmente n\'e3o interage com a campainha ou com a porta (a menos que aquela pessoa seja um t\'e9cnico de manuten\'e7\'e3o do elevador). Portanto, declaramos os objetos beil e door na se\'e7\'e3o private da defini\'e7\'e3o da classe. \line Fun\'e7\'f5es utilit\'e1rias s\'e3o inclu\'eddas nas linhas 558 a 5\'f31. A classe Elevator tamb\'e9m define uma s\'e9rie de valores private static const (linhas 564 a \i\f2\fs20 566). \i0\f0\fs18 Estes valores s\'e3o declarados static porque cont\'eam informa\'e7\'e3o que \'e9 usada por todos os objetos da classe Elevator; estes valores n\'e3o devem ser modificados nunca, de modo que eles tamb\'e9m s\'e3o declarados como const. \fs24\par
\f3\fs16 541 \f0\fs24\par
\i\f3\fs22 II \i0\fs16 elevator.h \line\i\fs22 II \i0\fs16 Defini\'e7\'e3o da classe Elevator. #ifndef ELEVATORH \line #define ELEVATORH \line #include \ldblquote elevatorButton.h\rdblquote  \f0\fs24\par
\f3\fs14 #include \ldblquote door.h\rdblquote  #include \ldblquote bell \f2\fs8 . \f0\fs24\par
\f3\fs16 542 class Floor; \line 543 class Person; \f0\fs24\par
\f3\fs16 544 \f0\fs24\par
\f3\fs16 545 class Elevator \line 546 \f0\fs24\par
\f3\fs16 public: \line Elevator( Floor &, Floor & ); \line -Elevator(); \line void surninonElevator \f2\fs20 ( \f3\fs16 int ); oid prepareToLeave \f2\fs20 ( \f3\fs16 bool ); void processTime( int ); void passengerEnters( Person \f2\fs10 * \f3\fs16 void passengerExits(); \line ElevatorButton elevatorButton; \line private: \line void processPossibleArrival() void processPossibleDeparture(); void arriveAtFloor( Floor & ); void move(); \f0\fs24\par
\f3\fs16 int currentBuildingClockTime; bool moving; \line int direction; \line int currentFloor; \line int arrivalTime; \line bool floorlNeedsService; bool floor2NeedsService; \line Floor &floorlRef; \line Floor &floor2Ref; \line Person *passengerptr; \line Door door; \line Beil bell; \f0\fs24\par
\i\f3\fs22 II \i0\fs16 declara\'e7\'e3o antecipada \i\fs22 II \i0\fs16 declara\'e7\'e3o antecipada \line\i\fs22 II \i0\fs16 construtor \line\i\fs22 II \i0\fs16 destruidor \line\i\fs22 II \i0\fs16 pede atendimento para andar \line\i\fs22 II \i0\fs16 prepara para sair \i\fs22 II \i0\fs16 fornece hora ao elevador \f0\fs24\par
\f3\fs16 const \f2\fs20 ) ;// \f3\fs16 embarca um passageiro \i\fs22 II \i0\fs16 sai um passageiro \i\fs22 II \i0\fs16 note objeto public \f0\fs24\par
\i\f3\fs22 II \i0\fs16 dire\'e7\'e3o para cima \i\fs22 II \i0\fs16 dire\'e7\'e3o para baixo \f0\fs24\par
\i\f3\fs22 II \i0\fs16 estado do elevador \line\i\fs22 II \i0\fs16 dire\'e7\'e3o atual \line\i\fs22 II \i0\fs16 posi\'e7\'e3o atual \line\i\fs22 II \i0\fs16 hora de chegar a um andar \i\fs22 II \i0\fs16 indicador de atendimento de floori \i\fs22 II \i0\fs16 indicador de atendimento de floor2 \line\i\fs22 II \i0\fs16 refer\'eancia a floori \line\i\fs22 II \i0\fs16 refer\'eancia a floor2 \i\fs22 II \i0\fs16 ponteiro para passageiro atual \line\i\fs22 II \i0\fs16 objeto door \line\i\fs22 II \i0\fs16 objeto bell \f0\fs24\par
\f2\fs20 Fig. 7.28 Arquivo de cabe\'e7alho da classe Elevator. \line\f0 As linhas \i 568 \i0 a \i 58 \i0 1 do arquivo de cabe\'e7alho de Elevator cont\'eam membros de dados private adicionais. Note que para cada um dos objetos da classe Floor s\'e3o fornecidos \i handies \i0 de refer\'eancia (linhas 576 e \i 577), \i0 enquanto \fs24\par
\f3\fs16 533 \line 534 \line 535 \line 536 \line 537 \line 538 \line 539 \line 540 \f0\fs24\par
\fs16 CAP\'cdTULO \i\fs20 7 \i0\f2\fs8 - \f0\fs16 CLASSES: PARTE II \f2\fs22 499 \f0\fs24\par
\f3\fs16 547 \line 548 \line 549 \line 550 \line 551 \line 552 \line 553 \line 554 \line 555 \line 556 \line 557 \line 558 \line 559 \line 560 \line 561 \line 562 \line 563 \line 564 \line 565 \line 566 \line 567 \line 568 \line 569 \line 570 \line 571 \line 572 \line 573 \line 574 \line 575 \line 576 \line 577 \line 578 \line 579 \line 580 \line 581 \line 582 \line 583 \line 584 \f0\fs24\par
\i\f3\fs22 II \i0\fs16 hora de se mover entre andares static const int ELEVATOR TRAVEL TIME; static const int UP; \line static const int DOWN; \f0\fs24\par
\i\f3\fs22 II \i0\fs18 hora atual \f0\fs24\par
\fs20 A \line A \line ra \line\f2 ar \f0\fs24\par
\fs18 n \line 1. \line m \line la \fs24\par
\f3\fs18 #endif \i\fs22 II \i0\fs18 ELEVATORH \f0\fs24\par
\i\fs20 500 \i0\f2\fs28 c++ \f0\fs18 COMO PROGRAMAR \line um ponteiro \i\fs20\'e9 \i0\fs18 usado para o objeto passageiro (linha 578). Usamos um ponteiro para o passageiro porque este \i\fs20 handie \i0\fs18 vai precisar mudar sempre que um objeto da classe Person entra ou sai do elevador. Preferimos \i\fs20 handies \i0\fs18 de refer\'eancia para os objetos Floor. \line Usamos a UML para modelar muitas das atividades e colabora\'e7\'f5es associadas com a classe Elevator (ver Figs. 3.31, 3.32 e 5.37); nosso c\'f3digo para a classe Elevator (Fig. 7.29) implementa a informa\'e7\'e3o contida nestes modelos. O construtor de Elevator tem uma extensa lista de inicializadores de membros (linhas 602 a 607). Voc\'ea lembrar\'e1, de nossa defini\'e7\'e3o da classe ElevatorButton (Fig. 7.24), que um objeto daquela classe requer um \i\fs20 handie \i0\fs18 para um objeto da classe Elevator como um argumento para seu construtor. Providenciamos este \i\fs20 handie \i0\fs18 em nossa lista de inicializa\'e7\'e3o de membros derreferenciando o ponteiro this do objeto elevator (linha 602). Alguns compiladores geram um aviso nesta linha porque o objeto elevator ainda n\'e3o foi completamente inicializado. \line\b\f3\fs16 585 \b0\i\fs22 II \b\i0\fs16 elevator.cpp \line 586 \b0\i\fs22 II \b\i0\fs16 Defini\'e7\'f5es de fun\'e7\'f5es membro para a classe Elevator. \line 587 #include <iostream> \line 588 \line 589 using std: :cout; \line 590 using std: :endl; \line 591 \line 592 #include \lquote elevator.h \line 593 #include \lquote person.h\rdblquote  \line 594 #include \ldblquote floor.h\rdblquote  \line 595 \line 596 const int Elevator::ELEVATORTRAVELTINE \b0\f2\fs10 = \b\f3\fs16 5; \line 597 const int Elevator::UP \b0\f2\fs10 = \b\f3\fs16 O; \line 598 const int Elevator: :DOWN \b0\f2\fs10 = \b\f3\fs16 1; \line 599 \line 600 \b0\i\fs22 II \b\i0\fs16 construtor \line 601 Elevator: :Elevator( Floor &firstFloor, Floor &secondFloor \line 602 : elevatorButton( *this \b0\i\f0\fs20 ) \i0\f2\fs8 , \b\f3\fs16 currentBuildingClockTime( O \b0\i\f0\fs20 ) \line\b\i0\f3\fs16 603 moving( false \b0\i\f0\fs20 ) \i0\f2\fs8 , \b\f3\fs16 direction( UP \b0\i\f0\fs20 ), \line\b\i0\f3\fs16 604 currentFloor( Floor::FLOOR1 \b0\i\f0\fs20 ), \b\i0\f3\fs16 arrivalTime( O \b0\i\f0\fs20 ), \line\b\i0\f3\fs16 605 floorlNeedsService \b0\i\f0\fs20 ( \b\i0\f3\fs16 false \b0\i\f0\fs20 ) , \b\i0\f3\fs16 floor2NeedsService \b0\i\f0\fs20 ( \b\i0\f3\fs16 false \b0\i\f0\fs20 ), \line\b\i0\f3\fs16 606 floorlRef( firstFloor \b0\i\f0\fs20 ), \b\i0\f3\fs16 floor2Ref( secondFloor \b0\i\f0\fs20 ), \line\b\i0\f3\fs16 607 passengerPtr( O \line 608 \b0\i\f0\fs20\{ \b\i0\f3\fs16 cout \'ab elevador criado\rdblquote  \'ab endi; \line 609 \line 610 Elevator::-.Elevator() \b0\i\f0\fs20 // \b\i0\f3\fs16 destruidor \line 611 \b0\i\f0\fs20\{ \b\i0\f3\fs16 cout \'ab elevador destru\'eddo\rdblquote  \'ab endi; \line 612 \line 613 \b0\i\fs22 II \b\i0\fs16 fornece hora para o elevador \line 614 void Elevator::processTime( int time \line 615 \b0\i\f0\fs20\{ \line\b\i0\f3\fs16 616 currentBuildingClockTime \b0\f2\fs10 = \b\f3\fs16 time; \line 617 \line 618 if \b0\i\f0\fs20 ( \b\i0\f3\fs16 moving \line 619 processpossibleArrival \b0\fs30 o; \line\b\fs16 620 else \line 621 processPossibleDeparture(); \line 622 \line 623 if \b0\i\f0\fs20 ( \b\i0\f3\fs16 !moving \line 624 cout \'ab \ldblquote elevador parado no andar \line 625 \'ab currentFloor \'ab endi; \line 626 \b0\i\f0\fs20\} \line\b\i0\f3\fs16 627 \line\b0\f2\fs20 Fig. 7.29 Arquivo de implementa\'e7\'e3o da classe Elevator (parte 1 de 4). \f0\fs24\par
\fs14 CAP\'cdTULO \f2\fs20 7 \fs8 - \f0\fs14 CLASSES: PARTE \fs20 II 501 \line\f3\fs16 628 \i\fs20 II \i0\fs16 quando elevador est\'e1 se movendo, determina se ele deve parar \line 629 void Elevator: :processPossibleArrival() \line 630 \f2\fs20\{ \line\f3\fs16 631 \i\fs20 II \i0\fs16 se elevador chega ao andar de destino \line 632 if \f2\fs20 ( \f3\fs16 currentBuildingClockTime arrivalTime \f2\fs20 ) \line\f3\fs16 633 \line 634 currentFloor \f2\fs10 = \fs20 /1 \f3\fs16 atualiza andar atual \line 635 \f2\fs20 ( \f3\fs16 currentFloor \f2\fs10 == \f3\fs16 Floor: :FLOOR1 ? \line 636 Floor::FLOOR2 : Floor::FLOOR1 ); \line 637 \line 638 direction \f2\fs10 = \i\f3\fs20 II \i0\fs16 atualiza dire\'e7\'e3o \line 639 \f2\fs20 ( \f3\fs16 currentFloor \f2\fs10 == \f3\fs16 Floor: :FLOOR1 ? UP : DOWN ); \line 640 \line 641 cout \'ab elevador chega no andar \f2\fs8\ldblquote  \line\f3\fs16 642 \'ab currentFloor \'ab endl; \line 643 \line 644 arriveAtFloor( currentFloor \f2\fs10 == \f3\fs16 Floor: :FLOOR1 ? \line 645 floorlRef : floor2Ref ); \line 646 \line 647 return; \line 648 \f2\fs20\} \line\f3\fs16 649 \line 650 \i\fs20 II \i0\fs16 elevador est\'e1 se movendo \line 651 cout \'ab \lquote elevador se movendo \line 652 \'ab \f2\fs20 ( \f3\fs16 direction \f2\fs10 == \f3\fs16 UP ? para cima\rquote  : para baixo \f2\fs20 ) \'ab \f3\fs16 endl; \line 653 \f2\fs20 ) \line\f3\fs16 654 \line 655 \i\fs20 II \i0\fs16 determina se o elevador deve se mover \line 656 void Elevator: :processPossibleDeparture() \line 657 \line 658 \i\fs20 II \i0\fs16 este andar precisa ser atendido? \line 659 bool currentFloorNeedsService \line 660 currentFloor \f2\fs10 == \f3\fs16 Floor::FLOOR1 ? \line 661 floorlNeedsService : floor2NeedsService; \line 662 \line 663 \i\fs22 II \i0\fs16 outro andar precisa ser atendido? \line 664 bool otherFloorNeedsService \f2\fs10 = \line\f3\fs16 665 currentFloor \f2\fs10 == \f3\fs16 Floor::FLOOR1 ? \line 666 floor2NeedsService : floorlNeedsService; \line 667 \line 668 \i\fs22 II \i0\fs16 atende a este andar (se necess\'e1rio) \line 669 if \f2\fs20 ( \f3\fs16 currentFloorNeedsService \f2\fs20 ) \{ \line\f3\fs16 670 arriveAtFloor( currentFloor Floor::FLOOR1 ? \line 671 floorlRef : floor2Ref ); \line 672 \line 673 return; \line 674 \f2\fs20\} \line\f3\fs16 675 \line 676 \i\fs22 II \i0\fs16 atende a outro andar (se necess\'e1rio) \line 677 else prepareToLeave( otherFloorNeedsService ); \line 678 \f2\fs20\} \line\f3\fs16 679 \line 680 \i\fs22 II \i0\fs16 chega em um andar espec\'edfico \line 681 void Elevator: :arriveAtFloor( Floor& arrivaiFloor \line 682 \f2\fs20\{ \line\f3\fs16 683 moving \f2\fs10 = \f3\fs16 false; \i\fs22 II \i0\fs16 desliga estado \line 684 \line 685 cout \'ab \ldblquote elevador desliga o bot\'e3o\rdblquote  \'ab endl; \line\f2\fs18 Fig. 7.29 Arquivo de implementa\'e7\'e3o da classe Elevator (parte 2 de 4). \f0\fs24\par
\f2\fs20\bullet (17 ep e.rnd) \b\f0\fs12 2OAT \b0\f2\fs20 essI3 p o5iuewepdwi ep OA!flbJV 6L 6! \line\f3\fs14 opuTs SO epod op?AeTe o enb pu o stie \f2\fs20 // \line\f3\fs14 eooi; : ;etoou Iooi::1ooT \f2\fs10 == \f3\fs14 .2ooT.ueJnD IL \line\f2\fs10 = \f3\fs14 1oo.t.s-\'e7t. \i\fs16 OL \line\i0\f2\fs20\} \i\f3\fs16 6EL \line\i0\f2\fs20 ( \f3\fs14 5UTAe- ooq )eAe\rquote o1e1\'80ded: :oAe p-ro \i\fs16 8EL \line\f2\fs12 1?PU \i0\f3\fs14 op JTS es-xdeid \f2\fs20 // \i\f3\fs16 LEL \line 9EL \line\i0\f2\fs20\{ \f3\fs24 o \f2\fs10 = \f3\fs14 I:4d1e5uessd \f2\fs20 ) \f3\fs14 pio \i\fs16\'c7EL \line\i0\fs14 opuTs se oitefessd o nb iope-a o s-r \f2\fs20 // \i\f3\fs16 TEL \line\i0\f2\fs20\{ \i\f3\fs16 EL \line\i0\fs14 TPUe \'bb OOTUflD \i\f2\fs12 )> \f3\fs16 IEL \line\i0\f2\fs10\'ab \f3\fs14 pu ou .xopAee ou wua \f2\fs8 ,, \f3\fs14\'bb \i\fs16 OEL \line\i0\fs14 Oaiteb<-2aJe5uessd \'bb \f2\fs8 ,, \f3\fs14 ossed,, \'bb noz \i\fs16 6L \line\i0\fs14 8 \i\fs16 L \line\i0\fs14 1duosed \f2\fs10 = \f3\fs14 d15uesswd \i\fs16 LL \line\i0\fs14 oi-r5ssd \f2\fs20 // \i\f3\fs16 9L \line\i0\f2\fs20\} \i\f3\fs16 SL \line\i0\f2\fs20 ( \f3\fs14 juosad suo uosje ptoi \i\fs16 L \line\i0\fs14 oita5ssd um \b\f0\fs12 te \b0\f2\fs20 // \i\f3\fs16 EL \line\i0\f2\fs20\{ \i\f3\fs16 IL \line\i0\fs14 :anl; \f2\fs10 = \f3\fs14 eQTAJeSspeeM2oot; : en eDTIXeSSPeNT1OOT; \i\fs16 OL \line\i0\fs14\'e9 \fs24 Too\rquote i.: \fs14 :Joo \f2\fs10 == \f3\fs14 iooi; \i\fs16 6!L \line\i0\fs14 op-rxdod o;uuzpue ep ioptput eZ\'c7UT \f2\fs20 // \f3\fs14 8tL \line\f2\fs20\} \i\f3\fs16 LIL \line\i0\f2\fs20 ( \f3\fs14 too ut p-ro \i\fs16 91L \line\i0\fs14 :topaie OTad oueuxtpue TzTos \f2\fs20 // \f3\fs14 91L \line\i\fs16 IL \line\i0\f2\fs20\{ \i\f3\fs16 EIL \line\i0\fs14 esi \f2\fs10 = \f3\fs14 eDTAJeSSPeeN,IOOT :esTw \f2\fs10 = \f3\fs14 DTAIeSSP9NTOOI IL \line\f2\fs8 . \f3\fs14 nioo1.::oot. \f2\fs10 == \f3\fs14 JOOT.Ue1flD TIL \line o;uawTpUeE ep opiput -rsep \lquote otiuoo ose \f2\fs20 // \f3\fs14 eSte \i\fs16 OIL \line\i0\f2\fs20 ( \f3\fs14 eDTAeSSPeeN2OOTeT4O )aAeio1e1daJd \i\fs16 60L \i0\f2\fs20 ( \f3\fs14 TAeSSPeeN1OOI.U9IJflDI \f2\fs20 ) \b\f3\fs12 t \b0\i\fs16 80L \line\i0\fs14 1pu o2no o -\'e7s s-wdid \f2\fs20 // \f3\fs14 LOL \line o:uuITpue ep stDeJd ou ese as \f2\fs20 // \i\f3\fs16 90L \line\i0\fs14 OL \line !9DTAJeSSP9eNI,2001 : tA1Sp9JOOf \i\fs16 OL \line\b\i0\f0\fs12\lquote  \b0\f3\fs14 Ioo1::ooT. \f2\fs10 == \f3\fs14 1OOTU11flQ \i\fs16 LOL \line\i0\f2\fs10 = \f3\fs14 aDtAJeSSP9eNOOT2eT.O ooq OL o:uewTpue p stDazd ipu oi;no \f2\fs20 // \f3\fs14 TOL \line OOL \line !eDtAIeSSPeN1OOTJ : 9YtAeSSPeaNI2OOTJ 669 \line\b\f0\fs12 G \b0\f3\fs14 IOO\rquote I. :JooT \f2\fs10 == \f3\fs14 1ooT.ue11nD 869 \line\f2\fs10 = \f3\fs14 9DtAJeSSp9eNIOOIUe11fl T\'b0\'b0q L69 \line ouemTpue: ep swed pu e;se \f2\fs20 // \f3\fs14 969 \line 969 \line\f2\fs20 ( \f3\fs14 s-rt \lquote 1OOITAtI t69 \line\lquote duosed2ooTJ \lquote .x;dJa5uassd )oouedooop E69 \line 6 9 \line\i\f2\fs12 ! \i0\f3\fs14 IdUOS19dJOOI uosled 169 \line no5eT4D JOPA91e O 9flb ptrn o \b\f0\fs12 STA9 \b0\f2\fs20 // \f3\fs14 069 \line 689 \line\i\f2\fs12 ! \i0\f3\fs14 rre5u.x\rdblquote rTeq 889 \line L89 \line 989 \line\f2 IVNVIOOId OVOD \fs20 ++3 ZO \f0\fs24\par
\fs18 CAP\'cdTUIO \f2\fs20 7 \fs8 - \f0\fs18 CLASSES: PARTE II 503 \line\b\f3\fs16 744 thisFloor.elevatorLeaving(); \line 745 \line 746 door.closeDoor( thisFloor ); \line 747 \line 748 if \b0\f2\fs20 ( \b\f3\fs16 leaving \b0\f2\fs20 ) /1 \b\f3\fs16 sai, se necess\'e1rio \line 749 moveO; \line 750 \b0\f2\fs20 ) \line\b\f3\fs16 751 \line 752 void Elevator: :move() \b0\i\fs22 /1 \b\i0\fs16 vai para um andar espec\'edfico \line 753 \b0\f2\fs20\{ \line\b\f3\fs16 754 moving \b0\f2\fs10 = \b\f3\fs16 true; \b0\i\fs22 II \b\i0\fs16 muda estado \line 755 \line 756 \b0\i\fs22 II \b\i0\fs16 escalona hora de chegada \line 757 arrivalTime \b0\f2\fs10 = \b\f3\fs16 currentBuildingClockTime + \line 758 ELEVATORTRAVEL TIME; \line 759 \line 760 cout \'ab \ldblquote elevador come\'e7a a se mover \line 761 \'ab \b0\f2\fs20 ( \b\f3\fs16 direction \b0\f2\fs10 == \f3\fs16 DOWN ? \b\ldblquote para baixo \b0\f2\fs8\ldblquote  \b\f3\fs16 : para cima \b0\f2\fs20 ) \line\b\f3\fs16 762 \'ab \ldblquote para o andar \line 763 \'ab \b0\f2\fs20 ( \b\f3\fs16 direction \b0\f2\fs10 == \f3\fs16 DOWN ? \b\lquote 1\rquote  : \lquote 2\rquote  \line 764 \'ab \b0\f2\fs8 ,, \b\f3\fs16 (chega na hora \b0\f2\fs8\ldblquote  \f0\fs18\'ab arrivalTime \'ab )\lquote  \line\b\f3\fs16 765 \'ab endl; \line 766 \line\f2\fs18 Fig. 7.29 \b0\fs20 Arquivo de implementa\'e7\'e3o da classe Elevator (parte 4 de 4). \line\fs30 o \f0\fs18 building invoca a fun\'e7\'e3o membro processTime (linhas 613 a 626) da classe Elevator, passando como um par\'e2metro a hora atual da simula\'e7\'e3o time. Esta fun\'e7\'e3o membro atualiza o membro de dados currentBuiJ.dingClockTime com a hora atual da simula\'e7\'e3o (linha 616) e ent\'e3o verifica o valor do membro de dado motion (linha 618). Se o elevador est\'e1 se movendo, elevator invoca sua fun\'e7\'e3o utilit\'e1ria processPossibleArrival (linha 619). Se o elevador n\'e3o est\'e1 se movendo, elevator invoca sua fun\'e7\'e3o utilit\'e1riaprocessPossibleDeparture (linha 621). Se o elevador ainda n\'e3o est\'e1 se movendo depois de deter- minar se ele deveria chegar ao andar atual ou partir para o outro andar, elevator envia para a tela uma mensagem indicando que ele est\'e1 parado no currentFloor (linhas 623 a 625). \line A fun\'e7\'e3o processPossibleArrival determina se o elevador precisa parar de se mover comparando o \line currentBuildingClockTime ao arrivalTime calculado (linha 632). Se est\'e1 na hora do elevador chegar a \line um andar particular, elevator atualiza currentFloor (linhas 634 a 636) e direction (linhas 638 e 639). O \line elevator chama ent\'e3o sua fun\'e7\'e3o utilit\'e1ria arriveAtFloor para executar as tarefas necess\'e1rias na chegada. A fun\'e7\'e3o utilit\'e1ria processPossibleDeparture determina se o elevador precisa ou n\'e3o come\'e7ar a se \line mover para atender a um outro andar. O c\'f3digo determina se o andar atual ou o outro andar necessita do atendimento do elevador (linhas 658 a 666). Se o andar atual precisa ser atendido, o elevador chama sua fun\'e7\'e3o utilit\'e1ria arriveAtFloor para o andar atual (linhas 670 e 67 1 \f2\fs14 ). \f0\fs18 Caso contr\'e1rio, a fun\'e7\'e3o utilit\'e1ria prepareToLeave \'e9 chamada (linha 677) e o elevador vai se mover para o outro andar, se aquele andar necessita de atendimento. \line A fun\'e7\'e3o utilit\'e1ria arriveAtFloor executa as tarefas necess\'e1rias para o elevador chegar a um andar espec\'edfico. Esta fun\'e7\'e3o utilit\'e1ria primeiro p\'e1ra o elevador, ajustando a vari\'e1vel membro moving para false (linha 683), a seguir desliga o elevatorButton (linha 686) e toca a campainha (linha 688). Um ponteiro tempor\'e1rio para um objeto da classe \'e9 ent\'e3o declarado para guardar um \i\fs20 handie \i0\fs18 para um objeto Person que poderia estar esperando no andar. Este ponteiro recebe o valor de retorno da chamada \'e0 fun\'e7\'e3o membro elevatorArrived daquele andar (linha 691). \line O elevator abre a porta chamando a fun\'e7\'e3o membro openDoor da classe Door, passando como par\'e2metro um \i\fs20 handie \i0\fs18 para o passageiro atual, um \i\fs20 handie \i0\fs18 para a pessoa que est\'e1 esperando no andar, um \i\fs20 handie \i0\fs18 para o andar onde o elevador chegou e um \i\fs20 handie \i0\fs18 para o pr\'f3prio elevator (linhas 693 e 694). Elevator novamente determina se algum dos andares necessita de atendimento (linhas 696 a 704). Se o andar atual n\'e3o necessita de atendimento pelo elevador, elevator se prepara para sair para o outro andar (linha 709) e sai se o outro andar necessita de atendimento. Caso contr\'e1rio, elevator desliga o indicador de atendimento para o andar atual (linhas 71 1 e 712). \fs24\par
\b\i\f2\fs22 504 \b0\i0\fs28 c++ \f0\fs18 COMO PROGRAMAR \line A fun\'e7\'e3o membro summonElevator permite que outros objetos solicitem servi\'e7os do elevador. Quando \line invocada, a fun\'e7\'e3o membro summonElevator recebe um n\'famero de andar como argumento e ajusta o indicador de servi\'e7o para true (linhas 719 e 720). \line A fun\'e7\'e3o membro passengerEnters recebe um ponteiro para um objeto da classe Person como seu \'fanico argumento (linha 724) e atualiza o \i\fs20 handie \i0\fs18 passengerPtr de elevator, de modo que este aponte para o novo passageiro (linha 727). A fun\'e7\'e3o membro passengerExi ts simplesmente zera o \i\fs20 handie \i0\fs18 pas sengerPtr, indicando assim que o passageiro saiu do elevador (linha \i\fs20 735). \line\i0\fs18 A fun\'e7\'e3o membro prepareToLeave recebe um argumento do tipo bool que indica se o elevator deve sair do andar atual (linha 738). O elevador notifica o andar atual de que est\'e1 saindo enviando uma mensagem elevatorLeaving para o andar (linha 744). O elevador ent\'e3o fecha a porta (linha 748) e, se for o caso, come\'e7a a se mover chamando a fun\'e7\'e3o utilit\'e1ria move, que ajusta o membro de dados moving para true (linha 754). Ela ent\'e3o calcula a hora de chegada ao destino do elevator usando o valor static const ELEVATOR_TRAVEL_TI (linhas 757 e \i\fs20 758). \i0\fs18 Finalmente, ela escreve na sa\'edda a dire\'e7\'e3o na qual est\'e1 se movendo, o andar de destino e a hora de chegada (arrivalTime) prevista (linhas 760 a 765). \line Nossa defini\'e7\'e3o da classe Floor (Fig. 7.30) cont\'e9m uma mistura de maneiras de associar objetos de outras classes com objetos Floor. Primeiro, usamos uma refer\'eancia como um \i\fs20 handie \i0\fs18 para eJ.evator (linha 804) \f2\fs8 - \f0\fs18 isto \b\i\f2\fs22\'e9 \b0\i0\f0\fs18 apropriado porque este \i\fs20 handie \i0\fs18 sempre se refere ao mesmo elevator. Tamb\'e9m temos um ponteiro como um \i\fs20 handie \i0\fs18 para um objeto Person (linha 805) \f2\fs8 - \f0\fs18 este \i\fs20 handie \i0\fs18 vai mudar sempre que uma pessoa entra no andar ou sai do andar para entrar no elevador. Finalmente, temos objetos compostos, incluindo um objeto public floorButton (linha 800) e um objeto private light (linha 806). Declaramos o objeto floorButton como public para permitir que objetos da classe Person acessem o floorButton diretamente.\rquote  A defini\'e7\'e3o da classe Floor tamb\'e9m cont\'e9m os membros de dados static const FLOOR1 e FLOOR2 (linhas 798 e 799). Usamos estas constantes em lugar dos verdadeiros n\'fameros dos andares; inicializamos estes membros de dados const no arquivo de implementa\'e7\'e3o (linhas 821 e 822). Normalmente, membros de dados const de uma classe devem ser inicializados na lista de inicializa\'e7\'e3o de membros do construtor. No caso especial de membros de dados static const, eles s\'e3o inicializados em escopo de arquivo. \line\b\f3\fs16 767 \b0\i\fs22 II \b\i0\fs16 floor.h \line 768 \b0\i\fs22 II \b\i0\fs16 Defini\'e7\'e3o da classe Floor. \line 769 #ifndef FLOORH \line 770 #define FLOORH \line\b0\f0\fs18 771 \line\b\f3\fs16 772 #include \ldblquote floorButton.h\rdblquote  \line 773 #include \ldblquote light.h\rdblquote  \line 774 \line 775 class Elevator; \i\f2\fs22 /1 \i0\f3\fs16 declara\'e7\'e3o antecipada \line 776 class Person; \i\f2\fs22 /1 \i0\f3\fs16 declara\'e7\'e3o antecipada \line 777 \line 778 class Floor \i\f2\fs22\{ \line\i0\f3\fs16 779 \line 780 public: \line 781 Floor( int, Elevator & ); \b0\i\fs22 /1 \b\i0\fs16 construtor \line 782 -Floor \i\f2\fs22 1/ \i0\f3\fs16 destruidor \line 783 bool isOccupied() const; \b0\i\fs22 II \b\i0\fs16 retorna true se o andar est\'e1 ocupado \line 784 int getNumber() const; \i\f2\fs22 /1 \i0\f3\fs16 retorna n\'famero do andar \line 785 \line 786 \b0\i\fs22 II \b\i0\fs16 passa um handle para nova pessoa entrando no andar \line 787 void personArrives \i\f2\fs22 ( \i0\f3\fs16 Person \b0\f2\fs12 * \b\f3\fs16 const ); \line 788 \line\f2\fs18 Fig. 7.30 \b0\fs20 Arquivo de cabe\'e7alho da classe Floor (parte 1 de 2). \f0\fs24\par
\f2\fs12 , \f0\fs14 Uma pessoa normalmente n\'e3o tem permiss\'e3o para interagir com a luz em um andar (a menos que seja um t\'e9cnico de manuten\'e7\'e3o). Portanto, o \line objeto light \'e9 declarado na se\'e7\'e3o private da defini\'e7\'e3o da classe. \fs24\par
\f2\fs18 795 \line 796 \line 797 \f0\fs24\par
\i\f3\fs22 II \i0\fs16 avisa o andar que o elevador void elevatorLeaving(); \f0\fs24\par
\f3\fs16 static const int FLOOR1; static const int FLOOR2; FloorButton floorButton; \line private: \line const int floorNumber; \line Elevator &elevatorRef; \line Person *occupantptr; \line Light light; \line #endif \i\fs22 II \i0\fs16 FLOORH \f0\fs24\par
\i\f3\fs22 II \i0\fs16 objeto floorButton \line\i\fs22 II \i0\fs16 o nuuero do andar \line\i\fs22 II \i0\fs16 ponteiro para o elevador \line\i\fs22 II \i0\fs16 ponteiro para a pessoa no andar \line\i\fs22 II \i0\fs16 objeto light \f0\fs24\par
\f2\fs18 Fig. 7.30 Arquivo de cabe\'e7alho da classe Floor (parte 2 de 2). \line\f0 A Fig. 7.3 1 cont\'e9m o arquivo de implementa\'e7\'e3o para a classe Floor. A fun\'e7\'e3o membro isOccupied da classe Floor (linhas 836 a 838) retorna um valor bool que indica se existe ou n\'e3o uma pessoa esperando no andar. Para determinar se uma pessoa est\'e1 esperando, verificamos se o occupantPtr n\'e3o \'e9 zero (linha 838). Se o occupantPtr \'e9 zero, n\'e3o h\'e1 nenhuma pessoa esperando no andar. A fun\'e7\'e3o membro getNumber devolve o valor da vari\'e1vel membro floorNumber (linha 841). A fun\'e7\'e3o membro personArrives recebe um ponteiro para o objeto Person que est\'e1 entrando no andar. A este ponteiro \'e9 atribu\'eddo o membro de dados private \line\f3\fs16 occupantPtr. \f0\fs24\par
\i\f3\fs22 II \i0\fs16 floor.cpp \line\i\fs22 II \i0\fs16 Defini\'e7\'f5es de fun\'e7\'f5es membro para a classe Floor. #include <iostreain> \f0\fs24\par
\f3\fs16 using std::cout; \line using std::endl; \f0\fs24\par
\f3\fs12 #include \ldblquote floor \f2\fs8 . \line\f3\fs12 #include \ldblquote person \f2\fs8 . \f3\fs12 h\rdblquote  \line #include \ldblquote elevator \f2\fs8 . \f0\fs24\par
\f3\fs14 const int Floor: :FLOOR1 \f2\fs10 = \f3\fs14 1; \line const int Floor::FLOOR2 2; \f0\fs24\par
\i\f3\fs22 II \i0\fs16 construtor \line Floor: :Floor(int nuniber, Elevator &elevatorHandle : floorButton( nunber, elevatorHandle \f2\fs20 ), \line\f3\fs16 floorNumber( nunber \f0\fs20 ) \f2 , \f3\fs16 elevatorRef( elevatorHandle \f0\fs20 ) \line\f3\fs16 occupantPtr \f0\fs20 ( \f3\fs16 O \f2\fs20 ), \line\f3\fs16 light( floorNumber \f2\fs10 == \f3\fs16 1 ? \ldblquote floor 1\rdblquote  : \ldblquote floor 2\rdblquote  \i\fs22\{ \i0\fs16 cout \'ab \ldblquote andar \f2\fs8\ldblquote  \f3\fs16\'ab floorNutnber \'ab \f2\fs10\lquote  \f3\fs16 criado\rdblquote  \'ab endl; \f0\fs24\par
\ul\f1\fs156 1 \ulnone\f0\fs24\par
\f2\fs18 789 \line 790 \line 791 \line 792 \line 793 \line 794 \f0\fs24\par
\i\f3\fs22 II \i0\fs16 avisa o andar que o elevador chegou Person *elevatorArrived() \f0\fs24\par
\fs14 CAP\'cdTULO \f2\fs20 7 \fs8 - \f0\fs14 CLASSES: PARTE \fs20 II 505 \fs24\par
\f3\fs16 est\'e1 saindo \f0\fs24\par
\i\f3\fs22 II \i0\fs16 avisa o andar que a pessoa est\'e1 saindo do andar void personBoardingElevator(); \f0\fs24\par
\f2\fs18 798 \line 799 \line 800 \line 801 \line 802 \line 803 \line 804 \line 805 \line 806 \line 807 \line 808 \line 809 \f0\fs24\par
\f2\fs16 810 \line 811 \line\f3 812 \line\f2 813 \line 814 \line 815 \line 816 \line 817 \line 818 \line 819 \line 820 \line\f3 821 \line 0822 \line\f2 823 \line\f3 824 \line\f2 825 \line 826 \line 827 \line 828 \line 829 \line 830 \line 831 \line\f3 832 \f0\fs24\par
\i\f3\fs22 II \i0\fs18 destruidor \f0\fs24\par
\f2\fs18 Fig. 7.31 Arquivo de implementa\'e7\'e3o da classe Floor (parte 1 de 2). \f0\fs24\par
\i\f2\fs20 506 \i0\fs28 c++ \fs18 COMO PROGRAMAR \f0\fs24\par
\f3\fs16 833 Floor: :\lquote Floor() \line 834 \i\f2\fs20\{ \i0\f3\fs16 cout \'ab \ldblquote andar \'ab floorNuxnber \'ab \fs8\ldblquote  \fs16 destru\'eddo\rquote  \'ab endi; \line 835 \line 836 \i\fs22 II \i0\fs16 deterxnina se o andar est\'e1 ocupado \line 837 bool Floor: :isOccupied() const \line 838 \i\f2\fs20\{ \i0\f3\fs16 return \i\f2\fs20 ( \i0\f3\fs16 occupantPtr \b\fs14 != O \b0\i\f2\fs20 ) \i0\f3\fs16 ; \i\f2\fs20\} \line\i0\f3\fs16 839 \line 840 \i\fs22 II \i0\fs16 retorna o n\'famero deste andar \line 841 int Floor: :getNumber() const \i\f2\fs20\{ \i0\f3\fs16 return floorNumber; \i\f2\fs20\} \line\i0\f3\fs16 842 \line 843 \i\fs22 II \i0\fs16 passa pessoa para o andar \line 844 void Floor: :personArrives( Person \f2\fs10 * \f3\fs16 const personPtr \line 845 \i\f2\fs20\{ \i0\f3\fs16 occupantPtr \b\fs14 = \b0\fs16 personPtr; \i\f2\fs20\} \line\i0\f3\fs16 846 \line 847 \i\fs22 II \i0\fs16 avisa o andar que o elevador chegou \line 848 Person *Floor: :elevatorArrived() \line 849 \i\f2\fs20\{ \line\i0\f3\fs16 850 \i\fs22 II \i0\fs16 desliga o bot\'e3o no andar, se necess\'e1rio \line 851 cout \'ab \ldblquote andar \fs8\lquote  \fs16\'ab floorNumber \line 852 \'ab \fs8 o \fs16 desliga o bot\'e3o\rdblquote  \'ab endl; \line 853 floorButton.resetButton(); \line 854 \line 855 light.turnOn(); \line 856 \line 857 return occupantPtr; \line 858 \i\f2\fs20\} \line\i0\f3\fs16 859 \line 860 \i\fs22 II \i0\fs16 diz ao andar que o elevador est\'e1 saindo \line 861 void Floor: :elevatorLeaving() \i\f2\fs20\{ \i0\f3\fs16 light.turnOff() ; \i\f2\fs20\} \line\i0\f3\fs16 862 \line 863 \i\fs22 II \i0\fs16 notifica o andar que urna pessoa est\'e1 saindo dele \line 864 void Floor: :personBoardingElevator() \i\f2\fs20\{ \i0\f3\fs16 occupantPtr O; \i\f2\fs20\} \line\i0 Fig. 7.31 Arquivo de implementa\'e7\'e3o da classe Floor (parte 2 de 2). \line\f0\fs18 A \f2\fs20 fun\'e7\'e3o \f0\fs18 membro elevatorArrived (linhas 847 a 858) desliga o objeto floorButton do andar 1inha \line liga a luz e retoma o \i handie \i0 occupantPtr (linha 857). A fun\'e7\'e3o membro elevatorLeaving desliga a 1 \line (linha 861). Finalmente, a fun\'e7\'e3o membro personBoardingElevator zera o occupantPtr, indicando q \line a pessoa saiu do andar (linha 864). \line Os elementos do arquivo de cabe\'e7alho para a classe Person (Fig. 7.32) deveriam parecer familiares a e\rquote  altura. A fun\'e7\'e3o membro getlD retorna o ID \'fanico do objeto Person. As fun\'e7\'f5es membro stepontoFloo enterElevator e exitElevator formam o resto da interface publie de Person. Usamos uma vari\'e1vel classe private static personCount para registrar quantos objetos da classe Person foram criados. Tar b\'e9m declaramos os atributos ID e destinationFloor como membros de dados private const. \line\f3\fs16 865 \i\fs22 II \i0\fs16 person.h \line 866 \i\fs20 II \i0\fs16 Defini\'e7\'e3o da classe Person \line 867 #ifndef PERSONH \line 868 #define PERSONH \line 869 \line 870 class Floor; \i\fs22 /1 \i0\fs16 declara\'e7\'e3o antecipada \line 871 class Elevator; \i\fs22 /1 \i0\fs16 declara\'e7\'e3o antecipada \line 872 \line 873 class Person \line 874 \f0\fs24\par
\f2\fs20 Fig. 7.32 Arquivo de cabe\'e7alho da classe Person (parte 1 de 2). \f0\fs24\par
\fs14 CAP\'cdTULO \fs20 7 \f2\fs8 - \f0\fs14 CLASSES: PARTE \fs20 TI \i\f2\fs22 507 \line\i0\f3\fs16 875 public: \line 876 Person( const int ); \i\fs22 /1 \i0\fs16 construtor \line 877 -PersonQ; \i\fs22 1/ \i0\fs16 destruidor \line 878 int getlD() const; \i\fs22 II \i0\fs16 devolve o ID da pessoa \line 879 \line 880 void stepOntoFloor( Floor & ); \line 881 void enterElevator( Elevator \f0\fs14 &, \f3\fs16 Floor & ); \line 882 void exitElevator( const Floor \f0\fs14 &, \f3\fs16 Elevator & \f0\fs20 ) \f3\fs16 const; \line 883 \line 884 private: \line 885 static int personCount; \i\fs22 II \i0\fs16 n\'famero total de pessoas \line 886 const int ID; \i\fs22 /1 \i0\fs16 n\'famero de ID \'fanico da pessoa \line 887 const int destinationFloor; \i\fs22 II \i0\fs16 n\'famero do andar de destino \line 888 \}; \line 889 \line 890 #endif \i\fs22 II \i0\fs16 PERSONH \line\f2\fs20 Fig. 7.32 Arquivo de cabe\'e7alho da classe Person (parte 2 de 2). \line\f0 A imp1ementa\'e7o da classe Person (Fig. 7.33) come\'e7a com o construtor (linhas 905 a 907), que recebe um \'fanico const int como seu argumento. Este representa o andar de destino do objeto Person. Usamos este valor na sa\'edda de dados de nossa simula\'e7\'e3o. O destruidor (linhas 909 a 914) exibe uma mensagem indicando que uma pessoa saiu do elevator. \line\f3\fs16 891 \i\fs20 II \i0\fs16 person.cpp \line 892 \i\fs20 II \i0\fs16 Defini\'e7\'f5es de fun\'e7\'f5es membro para a classe Person. \line 893 #include <iostreani> \line 894 \line 895 using std::cout; \line 896 using std: :endl; \line 897 \line 898 #include \ldblquote person.h\rdblquote  \line 899 #include \ldblquote floor.h\rdblquote  \line 900 #include \ldblquote elevator.h\rdblquote  \line 901 \line 902 \i\fs20 II \i0\fs16 inicializa o membro static personCount \line 903 int Person: :personCount 0; \line 904 \line 905 Person: :Person( const int destFloor \f0\fs20 ) // \f3\fs16 construtor \line 906 : ID( ++personCount \i\f2\fs22 ), \i0\f3\fs16 destinationFloor( destFloor \line 907 \f0\fs20\{) \line\f3\fs16 908 \line 909 Person::Person() \f0\fs20 // \f3\fs16 destruidor \line 910 \f0\fs20\{ \line\f3\fs16 911 cout \'ab \ldblquote pessoa \f2\fs8\ldblquote  \f0\fs20\'ab \f3\fs16 ID \'ab \f2\fs8\ldblquote  \f3\fs16 sai da simula\'e7\'e3o no andar \line 912 \'ab destinationFloor \'ab \f2\fs8\ldblquote  \f3\fs16 (destruidor de pessoa invocado)\rdblquote  \line 913 \'ab endl; \line 914 \line 915 \line 916 int Person::getlD() const \f0\fs20\{ \f3\fs16 return ID; \f0\fs20\} \i\f3\fs22 II \i0\fs16 obt\'e9m o ID \line 917 \line 918 \i\fs22 II \i0\fs16 pessoa entra em um andar \line 919 void Person::stepontoFloor( Floor& floor \line 920 \f0\fs20\{ \line\f3\fs16 921 \i\fs22 II \i0\fs16 avisa o andar que urna pessoa est\'e1 chegando \line\f2\fs20 Fig. 7.33 Arquivo de implementa\'e7\'e3o da classe Person (parte 1 de 2). \f0\fs24\par
\f2\fs20 508 \fs28 c++ \b\fs14 COMO PROGRAMAR \line 922 \f3\fs16 cout \b0\f0\'ab \b\f3\ldblquote pessoa \b0\f2\fs8\ldblquote  \f0\fs16\'ab \f2\fs14 ID \f0\fs16\'ab \f2\fs8\ldblquote  \b\f3\fs16 entra no andar \line 923 \b0\f0\'ab \b\f3 floor.getNumber() \'ab endi; \line 924 floor.personArrives( this ); \line 925 \line 926 \b0\i\fs20 II \b\i0\fs16 aperta bot\'e3o no andar \line 927 cout \'ab pessoa \b0\f2\fs8\lquote  \b\f3\fs16\'ab ID \line 928 \'ab \b0\f2\fs8 ,, \b\f3\fs16 aperta o bot\'e3o de andar no andar \line 929 \'ab floor.getNumber() \'ab endi; \line 930 floor.floorButton.pressButton(); \line 931 \b0\f2\fs20\} \line\b\f3\fs16 932 \line 933 \b0\i\fs22 II \b\i0\fs16 pessoa entra no elevador \line 934 void Person: :enterElevator( Elevator &elevator, Floor &floor \line 935 \b0\f2\fs20\{ \line\b\f3\fs16 936 floor.personBoardingElevator() ; \b0\i\fs22 II \b\i0\fs16 pessoa sai do elevador \line 937 \line 938 elevator.passengerEnters( this ); \b0\i\fs22 1/ \b\i0\fs16 pessoa entra no elevador \line 939 \line 940 \b0\i\fs22 II \b\i0\fs16 aperta bot\'e3o no elevador \line 941 cout \'ab pessoa \b0\f2\fs8\lquote  \b\f3\fs16\'ab ID \line 942 \'ab \b0\f2\fs8\ldblquote  \b\f3\fs16 aperta o bot\'e3o do elevador\rdblquote  \'ab endi; \line 943 elevator.elevatorButton.pressButton(); \line 944 \b0\f2\fs20\} \line\b\f3\fs16 945 \line 946 \b0\i\fs22 II \b\i0\fs16 pessoa sai do elevador \line 947 void Person: :exitElevator( \line 948 const Floor &floor, Elevator &elevator \b0\f2\fs20 ) \b\f3\fs16 const \line 949 \line 950 cout \'ab \ldblquote pessoa \b0\f2\fs8\ldblquote  \b\f3\fs16\'ab ID \'ab \b0\f2\fs8\ldblquote  \b\f3\fs16 sai do elevador no andar \line 951 \'ab floor.getNumber() \'ab endl; \line 952 elevator.passengerExits(); \line 953 \b0\f2\fs20\} \line Fig. 7.33 Arquivo de implementa\'e7\'e3o da classe Person (parte 2 de 2). \line\f0\fs16 A fun\'e7\'e3o membro stepOntoFloor (linhas 918 a 931) primeiro notifica o andar de que a pessoa chegou, enviando ao andar uma mensagem personArrives (linha 924). A pessoa ent\'e3o chama o m\'e9todo pressButton de floorButton (linha 930), que chama o elevador. \line A fun\'e7\'e3o membro enterElevator primeiro avisa o andar que a pessoa est\'e1 embarcando no elevador, enviando a mensagem personBoardingElevator (linha 936). A pessoa envia a mensagem passengerEnters para avisar o elevador que a pessoa est\'e1 entrando (linha 938). A pessoa ent\'e3o envia a mensagem pressButton para o objeto elevatorButton, para que o elevador comece a se mover para o outro andar (linha 943). A fun\'e7\'e3o membro exitElevator envia para a sa\'edda uma mensagem, indicando que a pessoa est\'e1 saindo do elevador, e ent\'e3o envia a mensagem passengerExits para o elevator. \line Completamos agora a implementa\'e7\'e3o efetiva da simula\'e7\'e3o do elevador que apresentamos no Cap\'edtulo 2. O \line Cap\'edtulo 8 n\'e3o cont\'e9m uma se\'e7\'e3o \ldblquote Pensando em objetos\rdblquote . No Cap\'edtulo 9, discutimos heran\'e7a em C++ e a aplicamos ao nosso elevador. \line\b\i\f2\fs26 Resumo \line\b0\i0\fs8 . \f0\fs16 A palavra-chave const especifica que um objeto n\'e3o \'e9 modific\'e1vel. \line\f2\fs8 . \f0\fs16 O compilador em C++ n\'e3o permite chamadas de fun\'e7\'f5es membro n\'e3o-corist para objetos const. \line\f2\fs8 . \f0\fs16 Uma tentativa de uma fun\'e7\'e3o membro const de uma classe de modificar um objeto daquela classe \'e9 um erro de sintaxe. \line\f2\fs8 . \f0\fs16 Uma fun\'e7\'e3o \'e9 especificada como const tanto em sua declara\'e7\'e3o como em sua defini\'e7\'e3o. \fs24\par
\b\fs14 CAP\'cdTULO \b0 7 \f2\fs8 - \b\f0\fs14 CLASSES: PARTE \b0 II \b\i\f2\fs22 509 \b0\i0\f0\fs24\par
\fs16 Uma fun\'e7\'e3o membro const pode ser sobrecarregada com uma vers\'e3o n\'e3o-corist. A escolha de qual fun\'e7\'e3o membro sobrecarregada usar \'e9 feita pelo compilador verificando se o objeto foi declarado const ou n\'e3o. \line\f2\fs10 . \f0\fs16 Um objeto const deve ser inicializado \f2\fs8 - \f0\fs16 inicializadores de membros devem ser fornecidos no construtor de uma classe quando aquela classe cont\'e9m membros de dados const. \line\f2\fs10 . \f0\fs16 Classes podem ser compostas por objetos de outras classes. \line\f2\fs10 . \f0\fs16 Objetos membro s\'e3o constru\'eddos na ordem em que eles est\'e3o listados na defini\'e7\'e3o de classe e antes que sejam constru\'eddos os objetos da classe que os cont\'e9m. \line\f2\fs10 . \f0\fs16 Se um inicializador de membro n\'e3o \'e9 fornecido para um objeto membro, o construtor default do objeto membro \'e9 chamado. \line\f2\fs10 . \f0\fs16 Uma fun\'e7\'e3o friend de uma classe \'e9 uma fun\'e7\'e3o definida fora daquela classe e que tem o direito de acessar todos os membros da classe. \line\f2\fs10 . \f0\fs16 Declara\'e7\'f5es friend podem ser colocadas em qualquer lugar na defini\'e7\'e3o da classe. \line\f2\fs10 . \f0\fs16 O ponteiro this \'e9 usado implicitamente para fazer refer\'eancia tanto para as fun\'e7\'f5es membro n\'e3o-static como para os membros de dados n\'e3o-static do objeto. \line\f2\fs10 . \f0\fs16 Cada fun\'e7\'e3o membro n\'e3o-static tem acesso ao endere\'e7o de seu objeto usando a palavra-chave this. \line\f2\fs10 . \f0\fs16 O ponteiro this pode ser usado explicitamente. \line\f2\fs10 . \f0\fs16 O operador new aloca espa\'e7o para um objeto, executa o construtor do objeto e retorna um ponteiro do tipo correto. Para liberar o espa\'e7o para este objeto, use o operador delete. \line\f2\fs10 . \f0\fs16 Um array de objetos pode ser alocado dinamicamente com new, como em \line\b\f3 int *ptr \b0\f2\fs10 = \b\f3\fs16 new int[ 100 ]; \b0\f0\fs24\par
\fs16 que aloca um array de 100 inteiros e atribui a localiza\'e7\'e3o do come\'e7o do array a ptr. O array de inteiros precedente pode ser deletado com o comando \line\b\f3 delete \b0\f0 [3 \b\f3 ptr; \line\b0\f2\fs10 . \f0\fs16 Um membro de dados static representa informa\'e7\'f5es \ldblquote com \'e2mbito em toda a classe\rdblquote  (i.e., uma propriedade da classe, n\'e3o um objeto). A declara\'e7\'e3o de um membro static come\'e7a com a palavra-chave static. \line\f2\fs10 . \f0\fs16 Membros de dados static t\'eam escopo de classe. \line\f2\fs10 . \f0\fs16 Membros static de uma classe podem ser acessados atrav\'e9s de um objeto daquela classe ou atrav\'e9s do nome da classe, usando o operador de resolu\'e7\'e3o de escopo (se o membro for public). \line\f2\fs10 . \f0\fs16 Uma fun\'e7\'e3o membro pode ser declarada static se ela n\'e3o acessar membros n\'e3o-static da classe. Diferentemente de fun\'e7\'f5es membro n\'e3o-static, uma fun\'e7\'e3o membro static n\'e3o tem um ponteiro this. Isto acontece porque membros de dados static e fun\'e7\'f5es membro static existem independentemente de quaisquer objetos de uma classe. \line\f2\fs10 . \f0\fs16 Classes normalmente escondem seus detalhes de implementa\'e7\'e3o dos clientes das classes. Isto \'e9 chamado de oculta\'e7\'e3o de informa\'e7\'f5es. \line\f2\fs10 . \f0\fs16 As pilhas s\'e3o conhecidas como estruturas de dados \ldblquote\'faltimo a entrar, primeiro a sair\rdblquote  (LIFO) \f2\fs8 - \f0\fs16 o \'faltimo item inserido na pilha \'e9 o primeiro item retirado da pilha. \line\f2\fs10 . \f0\fs16 Descrever a funcionalidade de uma classe independentemente de sua implementa\'e7\'e3o \'e9 chamado de abstra\'e7\'e3o de dados e as classes em C++ definem os chamados tipos de dados abstratos (ADT5). \line\f2\fs10 . \f0\fs16 C++ aumenta a import\'e2ncia atribu\'edda aos dados. A atividade prim\'e1ria em C++ \'e9 criar novos tipos de dados (i.e., classes) e expressar as intera\'e7\'f5es entre objetos daqueles tipos de dados. \line\f2\fs10 . \f0\fs16 Tipos de dados abstratos s\'e3o maneiras de representar no\'e7\'f5es do mundo real, com algum n\'edvel satisfat\'f3rio de precis\'e3o, dentro de um sistema de computador. \line\f2\fs10 . \f0\fs16 Um tipo de dados abstrato na realidade captura duas no\'e7\'f5es, quais sejam: uma representa\'e7\'e3o de dados e as opera\'e7\'f5es que s\'e3o permitidas sobre esses dados. \fs24\par
\f1\fs156 1 \f0\fs24\par
\b\f2\fs16 510 \b0\fs26 c++ \b\f0\fs14 COMO PROGRAMAR \line\b0\f2\fs10 . \fs26 c++ \b\f0\fs18\'e9 \b0\fs16 uma linguagem extens\'edvel. Embora a linguagem seja f\'e1cil de estender com estes novos tipos, a linguagem b\'e1sica propriamente dita n\'e3o \'e9 mut\'e1vel. \line\f2\fs10 . \fs26 c++ \b\f0\fs18\'e9 \b0\fs16 uma linguagem intencionalmente sucinta, que fornece aos programadores somente os recursos b\'e1sicos necess\'e1rios para construir uma ampla gama de sistemas. A linguagem foi projetada para minimizar impactos negativos sobre o desempenho. \line\f2\fs10 . \f0\fs16 Itens s\'e3o retirados de uma fila na ordem \ldblquote primeiro a entrar, primeiro a sair\rdblquote  (FIFO) \f2\fs8 - \f0\fs16 o primeiro item inserido na fila \'e9 o 7.1 \line primeiro item retirado da fila. 7.2 \line\f2\fs10 . \f0\fs16 Classes cont\'eainer (tamb\'e9m chamadas de classes cole\'e7\'e3o) s\'e3o projetadas para manter cole\'e7\'f5es de objetos. Uma classe cont\'eainer normalmente fornece servi\'e7os tais como inser\'e7\'e3o, retirada, pesquisa, classifica\'e7\'e3o e verifica\'e7\'e3o de se um item pertence \'e0 classe e assim por diante. \line\f2\fs10 . \b\fs16\'c9 \b0\f0 comum se associar objetos iterador \f2\fs8 - \f0\fs16 ou simplesmente iteradores \f2\fs8 - \f0\fs16 com classes cont\'eainer. Um iterador \'e9 um objeto que retorna o pr\'f3ximo item de uma cole\'e7\'e3o (ou executa alguma a\'e7\'e3o sobre o pr\'f3ximo item de uma cole\'e7\'e3o). \line\f2\fs10 . \f0\fs16 Fornecer aos clientes de sua classe uma classe \i proxy, \i0 que conhece somente a interface public da sua classe, habilita os clientes a usar servi\'e7os da sua classe sem dar ao cliente acesso a detalhes de implementa\'e7\'e3o da sua classe. \line\f2\fs10 . \fs26 o \f0\fs16\'fanica membro \b\fs18 private da \b0\i\fs16 classeproxy \'e9 \i0 um ponteiro para um objeto da classe cujos dados private queremos ocultar. \line\f2\fs10 . \f0\fs16 Quando uma defini\'e7\'e3o de classe usa s\'f3 um ponteiro para outra classe, o arquivo de cabe\'e7alho da classe para aquela outra 79 classe (que normalmente revelaria os dados private daquela classe) n\'e3o precisa ser inclu\'eddo com #include. Voc\'ea pode \line simplesmente declarar aquela outra classe como um tipo de dados, usando uma declara\'e7\'e3o antecipada \i (forward) \i0 de classe antes de o tipo ser usado no arquivo. \line\f2\fs10 . \fs26 o \f0\fs16 arquivo de implementa\'e7\'e3o contendo as fun\'e7\'f5es membro para a classe \i proxy \'e9 \i0 o \'fanico arquivo que inclui o arquivo de cabe\'e7alho para a classe cujos dados private gostar\'edamos de ocultar. \line\f2\fs10 . \fs26 o \f0\fs16 arquivo de implementa\'e7\'e3o \'e9 fornecido para o cliente como um arquivo objeto pr\'e9-compilado, junto com o arquivo de cabe\'e7alho que inclui os prot\'f3tipos de fun\'e7\'f5es para os servi\'e7os fornecidos pela classe pro.sy. \line\b\i\f2\fs26 Terminologia \i0\f0\fs18 7.1 \b0\fs24\par
\fs16 classe friend \line classe \i proxy \line\i0 composi\'e7\'e3o \line construtor \line construtor de objeto membro \line construtor default \line cont\'eainer \line declara\'e7\'e3o antecipada \i (fonvard) \i0 de classe destruidor \line destruidor default \line encadeamento de chamadas a fun\'e7\'f5es membro escopo de classe \line especificadores de acesso a membro fun\'e7\'e3o friend \line fun\'e7\'e3o membro const \line fun\'e7\'e3o membro static \line inicializador de membro \line\i inserir \i0 (opera\'e7\'e3o de fila) \line\i inserir (push) \i0 (opera\'e7\'e3o de pilha) \line iterador \line linguagem extens\'edvel \line membro de dados static \fs24\par
\fs16 objeto const \line objeto hospedeiro \line objeto membro \line objetos din\'e2micos \line opera\'e7\'f5es de um ADT \line operador de resolu\'e7\'e3o de escopo bin\'e1rio ( : :) operador de sele\'e7\'e3o de membro \b\f2 (.) \b0\f0 operador delete \line operador delete [] \line operador new \line operador new [] \line operador ponteiro de sele\'e7\'e3o de membro \b\f2 (->) \b0\f0 ponteiro this \line primeiro a entrar, primeiro a sair (FIFO) programa\'e7\'e3o baseada em objetos representa\'e7\'f5es de dados \line\i retirar \i0 (opera\'e7\'e3o de fila) \line\i retirar (pop) \i0 (opera\'e7\'e3o de pilha) tipo de dados abstrato (ADT) tipo de dados abstrato queue (fila) tipo de dados abstrato stack (pilha) \'faltimo a entrar, primeiro a sair (LIFO) \fs24\par
\b\i\f2\fs22 Tem \line\b0\i0\f0\fs18 declar \fs24\par
\b\i\f2\fs26 Erri \b0\i0\f0\fs24\par
\fs18 7.3 \line\b 7.4 \line\b0 7.5 \line\b 7.6 \b0\fs24\par
\b\fs18 7.8 \b0\fs24\par
\b\fs18 7.10 \b0\fs24\par
\b\fs18 7.11 \line 7.12 \b0\fs24\par
\b\i\f2\fs26 Bo \b0\i0\f0\fs24\par
\fs18 7.2 \line\b 7.3 \line 7.4 \b0\fs24\par
\b\i\f2\fs26 Di \b0\i0\f0\fs24\par
\b\fs18 7.1 \line\b0 7.2 \line\b 7.3 \line 7.4 \b0\fs24\par
\b\i\f2\fs26 OL \b0\i0\f0\fs24\par
\b\fs18 7.1 \b0\fs24\par
\fs18 7.2 \fs24\par
\b\fs14 CAP\'cdTULO \f2\fs18 7 \b0\fs8 - \b\f0\fs14 CLASSES: PARTE \b0\fs18 II \b\f2\fs22 511 \b0\f0\fs24\par
\b\i\fs22 Terminologia de \ldblquote Pensando em objetos\rdblquote  \line\b0\i0\fs18 declara\'e7\'e3o antecipada \i\fs16 (forward) \i0\fs18 problema da inclus\'e3o circular \line\b\i\f2\fs24 Erros comuns de programa\'e7\'e3o \line\b0\i0\f0\fs18 7.1 Definir como const uma fun\'e7\'e3o membro que modifica um membro de dados de um objeto \'e9 um erro de sintaxe. \line 7.2 Definir como const uma fun\'e7\'e3o membro que chama uma fun\'e7\'e3o membro n\'e3o-corist da classe sobre a mesma inst\'e2ncia da classe \'e9 um erro de sintaxe. \line 7.3 Invocar uma fun\'e7\'e3o membro n\'e3o-const sobre um objeto const \'e9 um erro de sintaxe. \line 7.4 Tentar declarar um construtor ou destruidor como const \'e9 um erro de sintaxe. \line 7.5 N\'e3o definir um inicializador de membro para um membro de dados const \'e9 um erro de sintaxe. \line 7.6 N\'e3o definir um construtor default para a classe de um objeto membro, quando nenhum inicializador de membro \'e9 fornecido para aquele objeto membro, \'e9 um erro de sintaxe. \line 7.7 Tentar usar o operador de sele\'e7\'e3o de membro (.)com um ponteiro para um objeto \'e9 um erro de sintaxe \f2\fs8 - \f0\fs18 o operador de sele\'e7\'e3o de membro ponto \'f3 pode ser usado com um objeto ou com uma refer\'eancia para um objeto. \line 7.8 Misturar o estilo new e delete com o estilo malloc e free de aloca\'e7\'e3o din\'e2mica de mem\'f3ria din\'e2mica \'e9 um erro de l\'f3gica: o espa\'e7o criado por malloc n\'e3o pode ser liberado por \b\f2 delete: \b0\f0 os objetos criados por new n\'e3o podem ser deletados por free. \line 7.9 Usar delete em vez de delete [ ] para arrays pode levar a erros de l\'f3gica durante a execu\'e7\'e3o. Para evitar problemas, o espa\'e7o criado como um array deveria ser apagado com o operador dele te [J e o espa\'e7o criado como um elemento individual deveria ser apagado com o operador delete. \line 7.10 E um erro de sintaxe incluir a palavra-chave static na defini\'e7\'e3o de uma vari\'e1vel de classe static em escopo de arquivo. \line 7.11 Referir-se ao ponteiro this dentro de uma fun\'e7\'e3o membro s tatic \'e9 um erro de sintaxe. \line 7.12 Declarar uma fun\'e7\'e3o membro static como const \'e9 um erro de sintaxe. \line\b\i\f2\fs24 Boas pr\'e1ticas de programa\'e7\'e3o \line\b0\i0\f0\fs18 7.1 Declare como const todas as fun\'e7\'f5es membro que n\'e3o necessitam modificar o objeto corrente, de forma que voc\'ea possa us\'e1-las sobre um objeto const se necessitar. \line 7.2 Coloque todas as declara\'e7\'f5es friend no in\'edcio da classe, logo depois do cabe\'e7alho da classe, e n\'e3o as preceda com quaisquer especificadores de acesso a membros. \line 7.3 Como C++ inclui C, programas em C++ podem conter mem\'f3ria criada por malloc e liberada por free e objetos criados por new e deletados por delete. E melhor usar somente new e delete. \line 7.4 Depois de deletar mem\'f3ria dinamicamente alocada, reinicialize o ponteiro que referenciava aquela posi\'e7\'e3o de mem\'f3ria com O. Isso desconecta o ponteiro do espa\'e7o anteriormente alocado na mem\'f3ria livre dispon\'edvel para o programa. \line\b\i\f2\fs24 Dicas de desempenho \line\b0\i0\f0\fs18 7.1 A declara\'e7\'e3o de vari\'e1veis e objetos const n\'e3o s\'f3 \'e9 uma pr\'e1tica efetiva de engenharia de software \f2\fs8 - \f0\fs18 ela tamb\'e9m pode melhorar o desempenho porque os sofisticados compiladores otimizadores atuais podem executar certas otimiza\'e7\'f5es com constantes que n\'e3o podem ser executadas com vari\'e1veis. \line 7.2 Inicialize explicitamente objetos membro atrav\'e9s de inicializadores de membros. Isto elimina o \i\fs16 overhead \i0\fs18 da \ldblquote dupla inicializa\'e7\'e3o\rdblquote  de objetos membro \f2\fs8 - \f0\fs18 uma vez quando o construtor default do objeto membro for chamado e novamente quando fun\'e7\'f5es \i\f2\fs16 sei \i0\f0\fs18 forem usadas para inicializar o objeto membro. \line 7.3 Por motivos de economia de mem\'f3ria e armazenamento, existe s\'f3 uma c\'f3pia de cada fun\'e7\'e3o membro por classe e essa fun\'e7\'e3o membro \'e9 invocada para todos os objetos daquela classe. Cada objeto, por outro lado, tem sua pr\'f3pria c\'f3pia dos membros de dados da classe. \line 7.4 Use membros de dados static para economizar mem\'f3ria quando uma \'fanica c\'f3pia dos dados \'e9 suficiente. \line\b\i\f2\fs24 Observa\'e7\'f5es de engenharia de software \line\b0\i0\f0\fs18 7.1 Declarar um objeto como cons t ajuda a seguir o princ\'edpio do m\'ednimo privil\'e9gio. As tentativas de modificar o objeto s\'e3o detectadas durante a compila\'e7\'e3o, em vez de causar erros durante a execu\'e7\'e3o. \line 7.2 Usar const \'e9 crucial para o projeto de classes, o projeto de programas e a codifica\'e7\'e3o adequados. \fs24\par
\b\f2\fs22 512 \b0\fs30 c++ \b\fs16 COMO \f0\fs14 PROGRAMAR \line\b0\fs16 7.3 Uma fun\'e7\'e3o membro const pode ser sobrecarregada com uma vers\'e3o n\'e3o-const. A escolha de qual fun\'e7\'e3o membro sobrecarregada a ser usada \'e9 feita pelo compilador, baseado no fato de o objeto ser const ou n\'e3o. \line\b\f2 7.4 \b0\f0 Um objeto const n\'e3o pode ser modificado por atribui\'e7\'e3o; por isso, ele deve ser inicializado. Quando um membro de dados de uma classe \'e9 declarado const, um \i inicializador de membro \i0 deve ser usado para fornecer ao construtor o valor \line inicial do membro de dados de um objeto da classe. \line\i 7.5 \i0 Membros de classe constantes (objetos const e \ldblquote vari\'e1veis\rdblquote  const) devem ser inicializados com a sintaxe de inicializador de membro; n\'e3o s\'e3o permitidas atribui\'e7\'f5es. \line\i 7.6 \b\i0\f2 E \b0\f0 uma boa pr\'e1tica declarar como const todas as fun\'e7\'f5es membro de uma classe que n\'e3o modificam o objeto sobre o qual elas operam. Ocasionalmente, isto ser\'e1 uma anomalia porque voc\'ea n\'e3o tem nenhuma inten\'e7\'e3o de criar objetos const daquela classe. Entretanto, declarar como const tais fun\'e7\'f5es membro oferece um benef\'edcio: se voc\'ea, inadvertidamente, modificar o objeto naquela fun\'e7\'e3o membro, o compilador emitir\'e1 uma mensagem de erro de sintaxe. \line\i 7.7 \i0 A forma mais comum de reutiliza\'e7\'e3o de software \'e9 a \i composi\'e7\'e3o, \i0 na qual uma classe tem objetos de outras classes como membros. \line\b\f2 7.8 \b0\f0 Se uma classe tem como membro um objeto de outra classe, tornar esse objeto membro public n\'e3o viola o encapsulamento e a oculta\'e7\'e3o dos membros private daquele objeto membro. \line\b\f2 7.9 \b0\f0 Embora os prot\'f3tipos para fun\'e7\'f5es friend apare\'e7am na defini\'e7\'e3o da classe, ainda assim friends n\'e3o s\'e3o fun\'e7\'f5es membro. \line 7.10 As no\'e7\'f5es de acesso a membros private. protected e public n\'e3o s\'e3o relevantes para as declara\'e7\'f5es de rela\'e7\'f5es friend. de modo que as declara\'e7\'f5es de rela\'e7\'f5es friend podem ser colocadas em qualquer lugar na defini\'e7\'e3o da classe. \line 7.1 1 Algumas pessoas na comunidade de OOP consideram que a no\'e7\'e3o de friend corrompe a oculta\'e7\'e3o de informa\'e7\'f5es e enfraquece o valor da abordagem de projeto orientado a objetos. \line\b\f2 7.12 \b0\f0 Como C++ \'e9 uma linguagem h\'edbrida, \'e9 comum ter-se uma mistura de dois tipos de chamadas de fun\'e7\'e3o em um programa e freq\'fcentemente lado a lado \f2\fs8 - \f0\fs16 chamadas ao estilo de C, que passam dados primitivos ou objetos para fun\'e7\'f5es, e chama- \line das no estilo pr\'f3prio de C++, que passam fun\'e7\'f5es (ou mensagens) para objetos. \line\b\f2 7.13 \b0\f0 Algumas organiza\'e7\'f5es t\'eam em seus padr\'f5es de engenharia de software a norma de que todas as chamadas a fun\'e7\'f5es membro static sejam feitas usando-se o nome da classe e n\'e3o \i o handie \i0 do objeto. \line 7.14 Os membros de dados static e as fun\'e7\'f5es membro static de uma classe existem e podem ser usados ainda que nenhum objeto daquela classe tenha sido instanciado. \line 7.15 O programador pode criar novos tipos atrav\'e9s do mecanismo de classes. Esses novos tipos podem ser projetados para serem usados t\'e3o convenientemente quanto os tipos primitivos. Desse modo, C++ \'e9 uma linguagem extens\'edvel. Embora \line a linguagem seja f\'e1cil de estender com estes novos tipos, a linguagem b\'e1sica propriamente dita n\'e3o \'e9 mut\'e1vel. \line\b\i\f2\fs24 Dicas de teste e depura \'e7\'e3o \line\i0\fs16 7.1 \b0\f0 Sempre declare fun\'e7\'f5es membro como const se elas n\'e3o modificarem o objeto. Isso pode ajudar a eliminar muitos bugs. \line 7.2 As linguagens como C++ s\'e3o como \ldblquote alvos m\'f3veis\rdblquote , pois evoluem. E prov\'e1vel que mais palavras-chave sejam incorpora- das \'e0 linguagem. Evite usar palavras muito importantes, tais como \ldblquote object\rdblquote , como identificadores. Embora \ldblquote object\rdblquote  n\'e3o seja atualmente uma palavra-chave em C++, no futuro ela o poder\'e1 ser. Assim, futuros compiladores poderiam tornar inoperante o c\'f3digo existente. \line\b\i\f2\fs24 Exerc\'edcios de auto-revis\'e3o \line\i0\fs16 7.1 \b0\f0 Preencha os espa\'e7os em branco em cada um dos seguintes itens: \line a) A sintaxe de \f2\fs8 _______________ \f0\fs16\'e9 usada para inicializar membros constantes de uma classe. \line b) Uma fun\'e7\'e3o n\'e3o-membro deve ser declarada como um \f2\fs8 ___________ \f0\fs16 de uma classe para ter acesso aos membros de dados private daquela classe. \line e) O operador aloca dinamicamente mem\'f3ria para um objeto de um tipo especificado e retorna um \line daquele tipo. \line d) Um objeto constante deve ser \b\fs14 ; \b0\fs16 n\'e3o pode ser modificado depois de ser criado. \line e) Um membro de dados \f2\fs8 _________________ \f0\fs16 representa informa\'e7\'f5es \ldblquote de toda a classe\rdblquote . \line\f2\fs30 o \f0\fs16 Fun\'e7\'f5es membro de um objeto t\'eam acesso a um \ldblquote ponteiro para si mesmo\rdblquote  para o objeto, chamado de ponteiro \line g) A palavra-chave especifica que um objeto ou vari\'e1vel n\'e3o \'e9 modific\'e1vel depois de ser inicializado. \line h) Se um inicializador de membro n\'e3o for fornecido paraiim objeto membro de uma classe, \'e9 chamado de \f2\fs8 _____________ \f0\fs16 do objeto. \line i) Uma fun\'e7\'e3o membro pode ser declarada static se n\'e3o acessar membros da classe \f2\fs8 _______________ \line\f0\fs24 j) \fs16 Objetos membro s\'e3o constru\'eddos \f2\fs8 ______________ \f0\fs16 do objeto de classe que os inclui. \line k) O operador recupera mem\'f3ria previamente ameada por new. \fs24\par
\fs16 CAP\'cdTULO 7 \f2\fs8 - \f0\fs16 CLASSES: PARTE II 513 \line Ache o(s) erro(s) em cada um dos seguintes itens e explique como corrigi-lo(s). \line a) class Exemplo \line de public: \line\f3\fs18 or \b\fs16 Exemplo( int y 10 \b0\f0 ) \{ \b\f3 dado \b0\f2\fs12 = \b\f3\fs16 y; \line int obtemDadolncrementado() const \b0\f0\{ \b\f3 return ++dado; \line\b0\fs18 static int getCount() \line\b\fs16 o cout \'ab \ldblquote Dado \'e9 \b0\f2\fs8\ldblquote  \f0\fs16\'ab dado \'ab endl; \line\fs12 E5 \b\f3\fs16 return count; \line\b0\f0 r- \} \line\b\f3 private: \line int data; \line static int count; \line b) char *string; \line string \b0\f2\fs12 = \b\f3\fs16 new char[ 20 ]; \line free \b0\f0 ( \b\f3 string ); \line\i\f2\fs24 Respostas aos exerc\'edcios de auto-revis\'e3o \line\b0\i0\f0\fs16 7.1 a) inicializador de membro. b) friend. c)new, ponteiro. d) inicializado. e) static. O this. g) const. h) construtor default. i) n\'e3o-static. \f1\fs24 j) \f0\fs16 antes. k) delete. \line 7.2 a) Erro: a defini\'e7\'e3o de classe para Exemplo tem dois erros. O primeiro ocorre na fun\'e7\'e3o obtemDadolncrementado. \line e A fun\'e7\'e3o \'e9 declarada const, mas ela modifica o objeto. Corre\'e7\'e3o: para corrigir o primeiro erro, remova a palavra- \line chave const da defini\'e7\'e3o de obtemDadolncremeritado. \line a Erro: o segundo erro acontece na fun\'e7\'e3o getCount. Esta fun\'e7\'e3o \'e9 declarada static, assim n\'e3o \'e9 permitido \line a acessar qualquer membro n\'e3o-static da classe. \line Corre\'e7\'e3o: para corrigir o segundo erro, remova a linha de sa\'edda de dados da defini\'e7\'e3o de getCount. \line b) Erro: a mem\'f3ria alocada dinamicamente por new \'e9 liberada pela fun\'e7\'e3o free. da Biblioteca Padr\'e3o de C. Corre\'e7\'e3o: use o operador delete de C++ para liberar a mem\'f3ria. A aloca\'e7\'e3o din\'e2mica de mem\'f3ria ao estilo de C n\'e3o deve ser misturada com os operadores new e delete de C++. \line\b\i\f2\fs24 Exerc\'edcios \line\b0\i0\f0\fs16 7.3 Compare e contraste a aloca\'e7\'e3o din\'e2mica de mem\'f3ria com os operadores new e delete de C++ com a aloca\'e7\'e3o \line din\'e2mica de mem\'f3ria com as fun\'e7\'f5es malloc e free da Biblioteca Padr\'e3o de C. \line 7.4 Explique a no\'e7\'e3o de friend em C++. Explique os aspectos negativos de frierid conforme descritos no texto. \line 7.5 Uma defini\'e7\'e3o correta da classe Time pode incluir os dois construtores seguintes? Se n\'e3o, explique por qu\'ea. \line\b\f3 Time \b0\f0 ( \b\f3 int h O \b0\f2\fs8 , \b\f3\fs16 int m O \b0\f2\fs8 , \b\f3\fs16 int s O ); \line Time(); \line\b0\f0 7.6 O que acontece quando um tipo de retomo, mesmo void, \'e9 especificado para um construtor ou destruidor? \line 7.7 Crie uma classe Date com os seguintes recursos: \line a) Enviar a data para a sa\'edda em diversos formatos, tais como \line\b\f3 DDD YYYY \line\b0\f0 DD/MM/YY \line\b\f3 14 de junho de 1992 \line\b0\f0 b) Use construtores sobrecarregados para criar objetos Date inicializados com datas nos formatos especificados no item (a). \line e) Crie um construtor de Date que l\'ea a data do sistema usando as fun\'e7\'f5es do arquivo de cabe\'e7alho <ctime> da biblioteca padr\'e3o e inicializa os membros de Date. \line No Cap\'edtulo 8, seremos capazes de criar operadores para testar a igualdade de duas datas e para comparar datas para determinar se uma data \'e9 anterior ou posterior \'e0 outra. \fs24\par
\b\f2\fs20 514 \b0\fs28 c++ \f0\fs18 COMO PROGRAMAR \line 7.8 Crie uma classe ContaDePoupanca. Use um membro de dados static para conter a taxaDeJurosAnual para cada um dos poupadores. Cada membro da classe cont\'e9m um membro de dados private saldoDaPoupanca indicando a quantia que o poupador atualmente tem em dep\'f3sito. Forne\'e7a uma fun\'e7\'e3o membro calculeRendimentoMensal que calcula o rendimento mensal multiplicando o saldo pela taxaDeJurosAnual dividida por 1 \f2 2; \f0 este rendimento deve ser somado ao saldoDaPoupanca. Forne\'e7a uma fun\'e7\'e3o membro static modifiqueTaxaDeJuros que incializa a vari\'e1vel static taxaDeJurosAnual com um novo valor. Escreva um programa de teste para testar a classe ContaDePoupanca. Instancie dois objetos diferentes contaDePoupanca. poupadori e poupador2. com saldos de $2000.00 e $3000.00, respectiva- mente. Inicialize taxaDeJurosAnual com 6%, ent\'e3o calcule o rendimento mensal e imprima os novos saldos para cada um dos poupadores. Inicialize ent\'e3o a taxaDeJurosAnual com 8% e calcule o rendimento do pr\'f3ximo m\'eas e imprima o novo saldo para cada um dos poupadores. \line 7.9 Crie uma classe chamada ConjuntoDelnteiros. Cada objeto de classe ConjuntoDelnteiros pode manter \line inteiros no intervalo O a 100. Um conjunto \'e9 representado internamente como um array de uns e zeros. O elemento de array a \line\f2 i \b\fs20 ] \b0\f0\fs18\'e9 1 se o inteiro \i i \i0 est\'e1 no conjunto. O elemento de array a \b\f2\fs20 [ \b0\f1\fs22 j ] \i\f0\fs18\'e9 \i0 O se o inteiroj n\'e3o est\'e1 no conjunto. O construtor default \line inicializa o conjunto com o chamado \ldblquote conjunto vazio\rdblquote , i.e., um conjunto cuja representa\'e7\'e3o de array cont\'e9m toda ela zeros. \line Providencie fun\'e7\'f5es membro para as opera\'e7\'f5es comuns sobre conjuntos. Por exemplo, forne\'e7a uma fun\'e7\'e3o membro uniaoDeCojuntosDelnteiros que cria um terceiro conjunto que \'e9 a uni\'e3o te\'f3rica de dois conjuntos existentes (i.e., a um elernentu do array do terceiro conjunto \'e9 atribu\'eddo 1 se esse elemento \'e9 1 em um ou ambos os conjuntos existentes e a um elemento do array do terceiro conjunto \'e9 atribu\'eddo O se esse elemento \'e9 O em cada um dos conjuntos existentes). \line Forne\'e7a uma fun\'e7\'e3o membro intersecaoDeConjuntosDelnteiros que cria um terceiro conjunto que \'e9 a inter- \line se\'e7\'e3o te\'f3rica de dois conjuntos existentes (i.e., um elemento do terceiro array do conjunto \'e9 inicializado com O se esse elemento \line\'e9 \fs26 o \fs18 em um ou ambos os conjuntos existentes, e um elemento do array do terceiro conjunto \'e9 inicializado com 1 se esse elemento \line\'e9 1 em cada um dos conjuntos existentes). \line Forne\'e7a uma fun\'e7\'e3o membro insiraElemento que insere um novo inteiro \i k \i0 para um conjunto (inicializando a \b\f2\fs20 [ \b0\f0\fs18 k \line\b\f2\fs20 1 \b0\f0\fs18 com 1). Forne\'e7a uma fun\'e7\'e3o membro retiraElemento que exclui o inteiro \i\fs16 m \i0\fs18 (inicializando a \b\f2\fs20 [ \b0\f0\fs18 m \b\f2\fs20 ] \b0\f0\fs18 com 0). \line Forne\'e7a uma fun\'e7\'e3o membro imprimaConjurito que imprime um conjunto como uma lista de n\'fameros separados \line por espa\'e7os. Imprima somente aqueles elementos que est\'e3o presentes no conjunto (i.e., sua posi\'e7\'e3o no array tem um valor 1). Imprima \f2\fs8 --- \f0\fs18 para um conjunto vazio. \line Forne\'e7a uma fun\'e7\'e3o membro elgualA que determina se dois conjuntos s\'e3o iguais. \line Forne\'e7a um construtor adicional para receber cinco argumentos inteiros, que pode ser usado para inicializar um objeto \line conjunto. Se voc\'ea quiser fornecer menos de cinco elementos para o conjunto, usem argumentos default de \f2\fs8 - \f0\fs18 1 para os outros. \line Agora, escreva um programa de teste para testar sua classe ConjuntoDelnteiros. Instancie v\'e1rios objetos de \line ConjuntoDelnteiros. Certifique-se de que todas as suas fun\'e7\'f5es membro funcionem corretamente. \line 7.10 Seria perfeitamente razo\'e1vel para a classe Time da Fig. 7.8 representar o tempo internamente como o n\'famero de segundos desde a meia-noite, em vez dos tr\'eas valores inteiros hour. minute e second. Os clientes poderiam usar os mesmos m\'e9todos p\'fablicos e obter os mesmos resultados. Modifique a classe Time da Fig. 7.8 para implementar Time como o n\'famero de segundos decorridos desde a meia-noite e mostre que n\'e3o existe nenhuma mudan\'e7a vis\'edvel de funcionalidade para os clientes da classe. \par
\par
\par
\par
\pard\lang1033\f4\fs20\par
}
 