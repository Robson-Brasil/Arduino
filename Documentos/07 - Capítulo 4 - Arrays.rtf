{\rtf1\ansi\ansicpg1252\deff0\deflang1033{\fonttbl{\f0\fmodern\fprq1\fcharset0 Courier;}{\f1\froman\fprq2\fcharset0 Times New Roman;}{\f2\froman\fcharset0 Helvetica, sans-serif;}{\f3\froman\fcharset0 Helvetica Narrow;}{\f4\froman\fcharset0 Times New Roman;}}
\viewkind4\uc1\pard\sb100\sa240\lang2070\b\f0\fs16\par
\b0\f1\fs24\par
\b\fs70 Arrays \line\f2\fs22 Objetivos \line\b0\f1\fs18\bullet  Apresentar a estrutura de dados array. \line\bullet  Entender o uso de arrays para armazenar, classificar e pesquisar listas e tabelas de valores. \line\bullet  Entender como declarar um array, inicializar um array e fazer refer\'eancia aos elementos de um array. \line\bullet  Ser capaz de passar arrays a fun\'e7\'f5es. \line\bullet  Entender t\'e9cnicas b\'e1sicas de classifica\'e7\'e3o. \f2\fs8 ____ \bullet  \f1\fs18 Ser capaz de declarar e manipular arrays com v\'e1rios subscritos. \line\i Com solu\'e7os e l\'e1grimas ele selecionou \line Aquelas de maior tamanho \line\i0 Lewis Carroli \line\i Attempt the end, and never stand to doubt; \line Nothing \lquote s so hard, but search willfind it out. \line\i0 Robert Herrick \line\i Vai agora, escreve isso em uma t\'e1bua perante eles; vai e registra tudo em um livro \i0 Isa\'edas 30:8 \line\i Fechei vossas palavras na mem\'f3ria; \line a chave v\'f3s mesmo a guardareis. \line\i0 William Shakespeare \fs24\par
\b\f3\fs142 4 \b0\f1\fs24\par
\f2\fs22 262 C++ \b\fs16 COMO \f1\fs14 PROGRAMAR \line\ul\f2\fs30 Vis\'e3o Geral \ulnone\line\fs20 4.1 Introdu\'e7\'e3o \line 4.2 Arrays \line 4.3 Declarando arrays \line 4.4 Exemplos usando arrays \line 4.5 Passando arrays a fun\'e7\'f5es \line 4.6 Ordenando arrays \line 4.7 Estudo de caso: calculando m\'e9dia, mediana e moda usando arrays \line 4.8 Pesquisando arrays: pesquisa linear e pesquisa bin\'e1ria \line 4.9 Arrays multidimensionais \line 4.10 (Estudo de caso opcional) Pensando em objetos: identificando as opera\'e7\'f5es de uma classe \line\b0\i\f1\fs18 Resumo Terminologia Erros comuns de programa\'e7\'e3o Boas pr\'e1ticas de programa\'e7\'e3o \i0\f2\fs12\bullet  \i\f1\fs18 Dicas de desempenho Dicas de portabilidade. Observa\'e7\'f5es de engenharia de software \i0\f2\fs12\bullet  \i\f1\fs18 Dicas de teste e depura\'e7\'e3o \i0\f2\fs12 . \i\f1\fs18 Exerc\'edcios de auto-revis\'e3o \i0\f2\fs12 . \i\f1\fs18 Respostas dos exerc\'edcios de auto-revis\'e3o \i0\f2\fs12\bullet  \i\f1\fs18 Exerc\'edcios \i0\f2\fs12\bullet  \i\f1\fs18 Exerc\'edcios de recurs\'e3o \line\b\i0\f2\fs26 4.1 Introdu\'e7\'e3o \line\b0\f1\fs18 Este cap\'edtulo serve como uma introdu\'e7\'e3o para o importante t\'f3pico de estruturas de dados. Os \i arrays \i0 s\'e3o estruturas de dados que consistem em itens de dados do mesmo tipo, relacionados entre si. No Cap\'edtulo 6, discutimos a no\'e7\'e3o de \i estruturas \i0 e \i classes \i0\f2\fs8 - \f1\fs18 cada uma capaz de manter itens de dados relacionados entre si, provavelmente de tipos diferentes. Os arrays e as estruturas s\'e3o entidades \ldblquote est\'e1ticas\rdblquote , \b j\'e1 \b0 que permanecem do mesmo tamanho ao longo de toda a execu\'e7\'e3o do programa (obviamente, eles podem ser da classe de armazenamento autom\'e1tico e, assim, podem ser criados e destru\'eddos cada vez que o programa entra e sai dos blocos nos quais s\'e3o definidos). No Cap\'edtulo 15, apresentamos estruturas din\'e2micas de dados, tais como listas, filas, pilhas e \'e1rvores, que podem crescer ou reduzir de tamanho \'e0 medida que o programa \'e9 executado. O estilo de arrays que utilizamos neste cap\'edtulo \'e9 o de arrays baseados em ponteiros, ao estilo de C (estudaremos ponteiros no Cap\'edtulo 5). Mais \'e0 frente no livro, no Cap\'edtulo 8, sobre \ldblquote Sobrecarga de operadores\rdblquote , e no Cap\'edtulo 20, sobre \ldblquote A biblioteca padr\'e3o de gabaritos (STL)\rdblquote , cobriremos arrays como objetos no sentido pleno da palavra, usando as t\'e9cnicas da programa\'e7\'e3o orientada a objetos. Descobriremos que estes arrays baseados em objetos s\'e3o mais seguros e vers\'e1teis do que aqueles baseados em ponteiros, usados em C, que discutimos aqui no Cap\'edtulo 4. \line\b\f2\fs26 4.2 Arrays \line\b0\f1\fs18 Um array \'e9 um grupo de posi\'e7\'f5es de mem\'f3ria consecutivas, todas de mesmo nome e mesmo tipo. Para fazer refer\'eancia a uma posi\'e7\'e3o particular ou elemento no array, especificamos o nome do array e o \i n\'famero da posi\'e7\'e3o \i0 daquele elemento no array. \line A Fig. 4.1 mostra um array de valores inteiros chamado c. Esse array cont\'e9m 12 \i elementos. \i0 Qualquer um destes elementos pode ser referenciado fornecendo-se o nome do array seguido do n\'famero da posi\'e7\'e3o do elemento particular, entre colchetes \b ( [1 ). \b0 O primeiro elemento em qualquer array \'e9 o \i elemento zero. \i0 Dessa forma, o primeiro elemento do array c \'e9 referenciado como c [ O 1 \f2\fs8 , \f1\fs18 o segundo elemento do array e \'e9 referenciado como c [ 1 \line (1 elemento a partir do in\'edcio do array), o s\'e9timo elemento do array e \'e9 referenciado como e [ 6 ] (6 elementos a partir do in\'edcio do array) e, em geral, o elemento \i i \i0 do array e \'e9 referenciado como e [ i \f2\fs8 - \f1\fs18 1 1 \b . \b0 Os nomes de arrays seguem as mesmas conven\'e7\'f5es que os nomes de outras vari\'e1veis. \fs24\par
\b\fs16 CAP\'cdTULO 4 \b0\f2\fs8 - \b\f1\fs16 ARRAYS \f2\fs22 263 \line\b0\fs18 Nome do array (Observe que todos os \line elementos desse array possuem o mesmo \line nome, c) \line c[O] -45 \line c[1] 6 \line c[2] O \line c[3) 72 \line c[43 1543 \line c[5] -89 \line c[6] O \line c[7) 62 \line c[8] -3 \line c[9] 1 \line c[1O] 6453 \line c[11] 78 \line N\'famero de posi\'e7\'e3o do elemento dentro \line do array c \line Fig. 4.1 Um array com 12 elementos. \line O n\'famero da posi\'e7\'e3o contido entre colchetes \'e9 chamado mais formalmente de \i\f1 subscrito \i0\f2 (este n\'famero especifica a quantidade de elementos a partir do in\'edcio do array). Um subscrito deve ser um inteiro ou uma express\'e3o inteira (usando qualquer tipo integral). Se um programa usar uma express\'e3o inteira como subscrito, a express\'e3o ser\'e1 calculada para determinar o valor do subscrito. Por exemplo, se a \'e9 igual a 5 e b \'e9 igual a 6, o comando \line c[ a \b\f1\fs16 + b \f2\fs22 ] \b0\fs12 += \b\fs18 2; \line\b0 adiciona 2 ao elemento de array c [11] \fs8 . \fs18 Observe que o nome de um array com subscritos \'e9 um \i\f1 Ivalue \i0\f2\fs8 - \fs18 ele s\'f3 pode ser usado no lado esquerdo de uma atribui\'e7\'e3o. \line Vamos examinar o array c da Fig. 4.1 mais detalhadamente. O \i\f1 nome \i0\f2 do array em sua totalidade \'e9 c. Seus 12 elementos s\'e3o denominados c [0], c [1], c [2], \fs8 . . ., \fs18 c [11]. O \i\f1\fs20 valor \i0\f2\fs18 de c [0] \i\f1\fs20\'e9 \i0\f2\fs18 -45. o valor de c [1] \b 6,0 \b0 valor de c[2] \'e9 0,o valorde c[7] \'e9 62 e o valor de c [11] \'e9 78. Para imprimir a soma dos valores contidos nos tr\'eas primeiros elementos do array c, escrever\'edamos \line\b\f0 cout \'abc[ O \f2\fs22 ] \f1\fs16 + \f0\fs18 c[ 1 \f2\fs22 1 \f1\fs16 + \f0\fs18 c[ 2 \f2\fs22 1 \f1\fs16\'ab endi: \line\f0\fs18 Para \b0\f2 dividir por \b\f0 2 \b0\f2 o valor do s\'e9timo elemento do array e e atribuir o resultado \'e0 vari\'e1vel \b x. \b0 escrever\'edamos \line\b x \b0\fs12 = \b\f0\fs18 c[ \f2 6 1 / \f0 2; \line\i\f1 Erro comum de programa\'e7\'e3o 4.1 \line\b0\i0\f3\fs26\'c9 \i\f1\fs18 importante observar a diferen\'e7a entre o \ldblquote s\'e9timo elemento do \b array\rdblquote  e o \ldblquote elemento n\'famero sete do \line\b0 array\rdblquote . Como os subscritos dos arrays iniciam em O, o \ldblquote s\'e9timo elemento do array\rdblquote  tem subscrito 6, ao \i0\fs24\par
\b\f2\fs22 264 C++ \f1\fs14 COMO \f2 PROGRAMAR \line\b0\i\f1\fs18 passo que o \ldblquote elemento n\'famero sete do array\rdblquote  tem subscrito 7 e, na realidade, \'e9 o oitavo elemento do \line arra\rquote  Esse fato \'e9 uma fonte de \ldblquote erros por um\rdblquote . \line\i0\fs16 Na verdade, os colchetes usados para conter o subscrito de um array s\'e3o considerados um operador em C++. Eles possuem o mesmo n\'edvel de preced\'eancia que os par\'eanteses. A tabela da Fig. 4.2 mostra a preced\'eancia e a associatividade dos operadores apresentados at\'e9 agora no texto. Eles s\'e3o mostrados de cima para baixo, em ordem decrescente de preced\'eancia. \fs24\par
\b\f2\fs20 Fig. 4.2 \b0 Preced\'eancia e associatividade dos operadores. \line\b\fs26 4.3 Declarando arrays \line\b0\f1\fs18 Os arrays ocupam espa\'e7o na mem\'f3ria. O programador especifica o tipo de cada elemento e o n\'famero de elementos exigidos pelo array, de forma que o compilador possa reservar a quantidade apropriada de mem\'f3ria. Para dizer ao compilador para reservar 12 elementos para o array inteiro c, use a declara\'e7\'e3o \line int c[ \b\fs14 12 ); \line\b0\fs18 Pode-se reservar mem\'f3ria para v\'e1rios arrays com uma \'fanica declara\'e7\'e3o. A seguinte declara\'e7\'e3o reserva 100 elementos para o array inteiro b e 27 elementos para o array inteiro x. \line intb[ \b\fs14 100 \b0\i\fs18 ] \i0\f2\fs8 , \b\fs16 x[ \f1\fs14 27 \b0\i\fs18 ] \line\i0 Podem ser declarados arrays para conter outros tipos de dados. Por exemplo, pode ser usado um array do tipo char para armazenar um \i string \i0 de caracteres. Os \i strings \i0 de caracteres e seu relacionamento com os arrays (um relacionamento que C++ herdou de C) e o relacionamento entre ponteiros e arrays s\'e3o discutidos no Cap\'edtulo 5. Depois, ent\'e3o, discutiremos \i strings \i0 como objetos no pleno sentido da palavra. \line\b\f2\fs26 4\'c3 Exemplos usando arrays \line\b0\f1\fs18 O programa da Fig. 4.3 usa uma estrutura de repeti\'e7\'e3o for para inicialiLar com zeros os elementos de um array inteiro a de dez elementos e imprime o array em formato de tabela. O primeiro comando de sa\'edda exibe os cabe\'e7alhos das colunas para as colunas impressas na estrutura for subsequente. Lembre-se de que setw especifica o comprimento do campo no qual o \i pr\'f3ximo \i0 valor ser\'e1 exibido. \fs24\par
\pard\par
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2334\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4389\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx6155\pard\intbl\b\f2\fs20 Operadores \b0\f1\fs24\cell\b\f2\fs20 Associatividade \b0\f1\fs24\cell\b\f2\fs20 Tipo \b0\f1\fs24\cell\fs20\row
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx342\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx720\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2334\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4389\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx6155\pard\intbl\fs18 O \fs24\cell\fs18 [) \fs24\cell\cell\fs18 da esquerda para a direita \fs24\cell\fs18 preced\'eancia mais alta \fs24\cell\fs20\row
\b\fs14\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx342\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx720\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2334\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4389\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx6155\intbl ++ \b0\fs24\cell\f2\fs8 - - \f1\fs24\cell\fs18 static_cast<tipo> () \fs24\cell\fs18 da esquerda para a direita \fs24\cell\fs18 p\'f3s-fixo \fs24\cell\fs20\row
\b\fs14\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx342\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx720\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2334\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4389\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx6155\intbl ++ \b0\fs24\cell\f2\fs8 -- \f1\fs24\cell\b\fs14 + \b0\f2\fs10 - \f1\fs24\cell\fs18 da direita para a esquerda \fs24\cell\fs18 un\'e1rio \fs24\cell\fs20\row
\f2\fs10\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx342\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx720\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2334\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4389\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx6155\intbl * \f1\fs24\cell\i\fs18 1 \i0\fs24\cell\fs18 % \fs24\cell\fs18 da esquerda para a direita \fs24\cell\fs18 multiplicativo \fs24\cell\fs20\row
\b\fs14\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx342\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx720\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2334\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4389\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx6155\intbl + \b0\fs24\cell\f2\fs8 - \f1\fs24\cell\cell\fs18 da esquerda para a direita \fs24\cell\fs18 aditivo \fs24\cell\fs20\row
\i\fs18\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx342\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx720\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2334\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4389\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx6155\intbl\'ab \i0\fs24\cell\fs18\'bb \fs24\cell\cell\fs18 da esquerda para a direita \fs24\cell\fs18 inser\'e7\'e3o/extra\'e7\'e3o \fs24\cell\fs20\row
\b\fs14\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx342\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx720\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2334\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4389\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx6155\intbl < \b0\fs24\cell\b\fs14 <= \b0\fs24\cell\b\fs14 > > \b0\fs24\cell\fs18 da esquerda para a direita \fs24\cell\fs18 relacional \fs24\cell\fs20\row
\b\fs14\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx342\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx720\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2334\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4389\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx6155\intbl == \b0\fs24\cell\b\fs14 ! = \b0\fs24\cell\cell\fs18 da esquerda para a direita \fs24\cell\fs18 igualdade \fs24\cell\fs20\row
\b\fs14\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx342\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx720\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2334\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4389\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx6155\intbl && \b0\fs24\cell\cell\cell\fs18 da esquerda para a direita \fs24\cell\fs18 E l\'f3gico \fs24\cell\fs20\row
\fs18\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx342\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx720\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2334\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4389\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx6155\intbl 1 \fs24\cell\cell\cell\fs18 da esquerda para a direita \fs24\cell\fs18 OU l\'f3gico \fs24\cell\fs20\row
\fs18\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx342\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx720\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2334\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4389\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx6155\intbl ?: \fs24\cell\cell\cell\fs18 da direita para a esquerda \fs24\cell\fs18 condicional \fs24\cell\fs20\row
\fs24\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx342\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx720\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2334\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4389\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx6155\intbl\cell\b\fs14 += \b0\fs24\cell\f2\fs12 -= *= \i\f1\fs18 1= \b\i0\fs14 %= \b0\fs24\cell\fs18 da direita para a esquerda \fs24\cell\fs18 atribui\'e7\'e3o \fs24\cell\fs20\row
\f2\fs8\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx342\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx720\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2334\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4389\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx6155\intbl , \f1\fs24\cell\cell\cell\fs18 da esquerda para a direita \fs24\cell\fs18 v\'edrgula \fs24\cell\fs20\row
\pard\fs24\par
\pard\sb100\sa240\fs14 CAP\'cdTULO \i\fs20 4 \i0\f2\fs8 - \f1\fs14 ARRAYS \i\f2\fs20 265 \i0\f1\fs24\par
\f0\fs16 1 \i\f1\fs20 II \i0\f0\fs16 Fig. 4.3: figO4_03.cpp \line 2 \i\f2\fs20 II \i0\f0\fs16 inicializando um array \line 3 #include <iostream> \line 4 \line 5 usirig std::cout; \line 6 using std: :endl; \line 7 \line 8 #include <iomanip> \f1\fs24\par
\f2\fs20 Os elementos de um array tamb\'e9m podem ser inicializados na declara\'e7\'e3o do array com um sinal de igual e uma lista de \i\f1 inicializadores \i0\f2 separados por v\'edrgulas (entre chaves). O programa da Fig. 4.4 inicializa um array inteiro com dez valores e o imprime em forma de tabela. \f1\fs24\par
\f0\fs16 9 \line 10 using std::setw; \line 11 \line 12 int main() \line 13 \line 14 int i, n[ 10 ]; \line 15 \line 16 for \i\f2\fs20 ( \i0\f0\fs16 i \f2\fs10 = \f0\fs16 O; i < 10; i++ \i\f2\fs20 ) II \i0\f0\fs16 inicializa o array \line 17 n[ i \i\f2\fs20 ] \i0\fs10 = \f0\fs16 0; \line 18 \line 19 cout \'ab \ldblquote Elemento\rdblquote  \'ab setw( 13 \i\f2\fs20 ) \i0\f1\fs14\'ab \f0\fs16\ldblquote Valor\rdblquote  \'ab endi; \line 20 \line 21 for \i\f2\fs20 ( \i0\f0\fs16 i \f2\fs10 = \f0\fs16 O; i < 10; i++ \i\f2\fs20 ) \f1 II \i0\f0\fs16 imprime o array \line 22 cout \'ab setw( 7 \i\f2\fs20 ) \i0\f1\fs14\'ab i \f0\fs16\'ab setw( 13 \i\f2\fs20 ) \i0\f0\fs16\'ab n[ i \i\f2\fs20 ] \i0\f1\fs14\'ab \f0\fs16 endl; \line 23 \line 24 return O; \line 25 \i\f2\fs20 ) \i0\f1\fs24\par
\b\f2\fs18 Fig. 4.3 \b0 Inicializando os elementos de um array com zeros. \f1\fs24\par
\b\f2\fs18 Fig. \b0 4.4 Inicializando os elementos de um array com uma declara\'e7\'e3o (parte 1 de 2). \f1\fs24\par
\pard\par
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx877\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1574\pard\intbl\f0\fs16 Elemento \f1\fs24\cell\f0\fs16 Valor \f1\fs24\cell\fs20\row
\fs24\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx877\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1574\intbl o \cell o \cell\fs20\row
\f0\fs16\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx877\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1574\intbl 1 \f1\fs24\cell\f0\fs16 O \f1\fs24\cell\fs20\row
\f0\fs16\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx877\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1574\intbl 2 \f1\fs24\cell\f0\fs16 O \f1\fs24\cell\fs20\row
\b\f2\fs18\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx877\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1574\intbl 3 \b0\f1\fs24\cell o \cell\fs20\row
\f0\fs16\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx877\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1574\intbl 4 \f1\fs24\cell\f0\fs16 O \f1\fs24\cell\fs20\row
\f0\fs16\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx877\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1574\intbl 5 \f1\fs24\cell\f0\fs16 O \f1\fs24\cell\fs20\row
\f0\fs16\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx877\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1574\intbl 6 \f1\fs24\cell o \cell\fs20\row
\f0\fs16\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx877\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1574\intbl 7 \f1\fs24\cell\f0\fs16 O \f1\fs24\cell\fs20\row
\f0\fs16\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx877\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1574\intbl 8 \f1\fs24\cell\f0\fs16 O \f1\fs24\cell\fs20\row
\f0\fs16\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx877\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1574\intbl 9 \f1\fs24\cell o \cell\fs20\row
\pard\sa240\fs24\par
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx301\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2438\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4959\pard\intbl\f0\fs16 1 \f1\fs24\cell\i\fs20 II \i0\f0\fs16 Fig. 4.4: figO4O \f1\fs24\cell\f0\fs16 4.cpp \f1\fs24\cell\fs20\row
\f0\fs16\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx301\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2438\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4959\intbl 2 \f1\fs24\cell\i\f2\fs20 1/ \i0\f0\fs16 Inicializando um \f1\fs24\cell\f0\fs16 array com uma declara\'e7\'e3o \f1\fs24\cell\fs20\row
\f0\fs16\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx301\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2438\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4959\intbl 3 \f1\fs24\cell\f0\fs16 #include <iostreain> \f1\fs24\cell\cell\fs20\row
\f0\fs16\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx301\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2438\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4959\intbl 4 \f1\fs24\cell\cell\cell\fs20\row
\f0\fs16\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx301\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2438\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4959\intbl 5 \f1\fs24\cell\f0\fs16 using std::cout; \f1\fs24\cell\cell\fs20\row
\f0\fs16\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx301\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2438\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4959\intbl 6 \f1\fs24\cell\f0\fs16 using std: :endl; \f1\fs24\cell\cell\fs20\row
\f0\fs16\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx301\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2438\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4959\intbl 7 \f1\fs24\cell\cell\cell\fs20\row
\f0\fs16\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx301\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2438\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4959\intbl 8 \f1\fs24\cell\f0\fs16 #include <iomanip> \f1\fs24\cell\cell\fs20\row
\f0\fs16\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx301\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2438\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4959\intbl 9 \f1\fs24\cell\cell\cell\fs20\row
\f0\fs16\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx301\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2438\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4959\intbl 10 \f1\fs24\cell\f0\fs16 using std::setw; \f1\fs24\cell\cell\fs20\row
\pard\fs24\par
\pard\sb100\sa240\b\f2\fs20 266 \b0\i\f1 C++ \b\i0\fs16 COMO PROGRAMAR \b0\fs24\par
\f2\fs20 20 \f1\fs24\par
\b\f0\fs16 21 returri 0; \line\f1 22 \f2\fs20 ) \b0\f1\fs24\par
\b\f0\fs16 Elemento Valor \b0\f1\fs24\par
\b\fs14 < \f0\fs16 10; i++) \line i \'ab setw( 13 \f2\fs20 ) \b0\f1\'ab \b\f0\fs16 n[ i \b0\f1\fs20 J \'ab \b\f0\fs16 endl; \b0\f1\fs24\par
\fs18 Se houver menos inicializadores do que o n\'famero de elementos do array, os elementos restantes s\'e3o inicializados automaticamente com zero. Por exemplo, os elementos do array n da Fig. 4.3 poderiam ser inicializados com o valor \fs24\par
\fs20 zero por meio da declara\'e7\'e3o \fs24\par
\b\f0\fs16 int n[ 10 \f2 ] \b0\fs12 = \b\fs16\{ \f1 O \}; \b0\fs24\par
\fs20 que inicializa explicitamente o primeiro elemento com zero e automaticamente inicializa os nove elementos restantes tamb\'e9m com zero, porque h\'e1 menos inicializadores do que elementos do array. Lembre-se de que os arrays autom\'e1ticos n\'e3o s\'e3o inicializados implicitamente com zero, O programador deve inicializar pelo menos o primeiro elemento com zero para que os elementos restantes sejam automaticamente zerados. O m\'e9todo usado na Fig. 4.3 pode ser usado repetidamente durante a execu\'e7\'e3o do programa. \line A declara\'e7\'e3o de array \fs24\par
\b\f0\fs16 int n[ 5 \f2\fs20 ] \{ \f0\fs16 32, 27, 64, 18, 95, 14 \}; \b0\f1\fs24\par
\fs20 causaria um erro de sintaxe, porque h\'e1 seis inicializadores e apenas 5 elementos no array. \fs24\par
\i\fs18 IErro comum de programa\'e7\'e3o 4.2 \line Esquecer de inicializar os elementos de um array cujos elementos precisam ser inicializados \'e9 um erro de l\'f3gica. \i0\fs24\par
\i\fs18 Erro comum de programa\'e7\'e3o 4.3 \line Fornecer mais inicializadores para um array do que o n\'famero de seus elementos \'e9 um erro de sintaxe. \i0\fs24\par
\b\fs16 11 \line 12 \line 13 \line 14 \b0\fs24\par
\b\fs16 15 \line 16 \b0\fs24\par
\b\fs16 17 \b0\fs24\par
\b\f0\fs16 int main \b0\f1\fs20 O \line\b\f0\fs16 int n[ 10 \b0\f1\fs20 3 \b\f2\{ \f1\fs16 32, 27, 64, 18, 95, 14, 90, 70, 60, 37 \}; \f0 cout \'ab \ldblquote Elemento \'ab setw( 13 \f2\fs20 ) \f0\fs16\'ab \lquote Valor\rdblquote  \'ab endl; \b0\f1\fs24\par
\b\fs16 18 \line 19 \b0\fs24\par
\b\f0\fs16 for \f2\fs20 ( \f0\fs16 int i \b0\f2\fs12 = \b\f0\fs16 0; i cout \'ab setw( 7 \b0\f1\fs24\par
\f2\fs20 Fig. 4.4 Inicial\'edzando os elementos de \f1 um \f2 array com uma declara\'e7\'e3o (parte 2 de 2). \f1\fs24\par
\pard\par
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx208\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx880\pard\intbl\b\f0\fs16 O \b0\f1\fs24\cell\b\f0\fs16 32 \b0\f1\fs24\cell\fs20\row
\b\fs14\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx208\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx880\intbl 1 \b0\fs24\cell\b\f0\fs16 27 \b0\f1\fs24\cell\fs20\row
\f2\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx208\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx880\intbl 2 \f1\fs24\cell\f2\fs20 64 \f1\fs24\cell\fs20\row
\b\fs16\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx208\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx880\intbl 3 \b0\fs24\cell\b\fs16 18 \b0\fs24\cell\fs20\row
\b\fs14\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx208\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx880\intbl 4 \b0\fs24\cell\b\fs16 95 \b0\fs24\cell\fs20\row
\b\fs16\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx208\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx880\intbl 5 \b0\fs24\cell\b\fs16 14 \b0\fs24\cell\fs20\row
\b\fs16\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx208\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx880\intbl 6 \b0\fs24\cell\b\fs16 90 \b0\fs24\cell\fs20\row
\b\fs16\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx208\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx880\intbl 7 \b0\fs24\cell\b\fs16 70 \b0\fs24\cell\fs20\row
\b\fs16\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx208\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx880\intbl 8 \b0\fs24\cell\b\fs16 60 \b0\fs24\cell\fs20\row
\b\fs16\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx208\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx880\intbl 9 \b0\fs24\cell\b\fs16 37 \b0\f3\fs56 1 \f1\fs24\cell\fs20\row
\pard\fs24\par
\pard\sb100\sa240\fs14 CAP\'cdTULO \i\f2\fs18 4- \i0\f1\fs14 ARRAYS \b\f2\fs16 267 \b0\f1\fs24\par
\fs18 Se o tamanho do array for omitido em uma declara\'e7\'e3o com uma lista de inicializadores, o n\'famero de elementos do array ser\'e1 o n\'famero de elementos da lista de inicializadores. Por exemplo, \line criaria um array com cinco elementos. \line\i Dica de desempenho \f2 4.1 \line\f1 Se, em vez de inicializar um array com comandos de atribui\'e7\'e3o, durante a execu\'e7\'e3o, voc\'ea inicializar o array durante a compila\'e7\'e3o com uma lista de inicializadores de array, seu programa ser\'e1 executado mais rapidamente. \line\i0 O programa da Fig. 4.5 inicializa os dez elementos de um array s com os valores 2, 4, 6 \b\f0\fs16 20 \b0\f1\fs18 e imprime o \line array em formato de tabela. Os valores s\'e3o gerados multiplicando-se o contador de controle do la\'e7o por 2 e somando- \line se 2. \line\b\f0\fs16 1 \b0\i\f1\fs18 II \b\i0\f0\fs16 Fig. 4.5 figO4O5.cpp \line 2 \b0\f1\fs18 // \b\f0\fs16 Inicializa os elementos do array com os inteiros pares de 2 a 20 \line 3 #include <iostream> \b0\f1\fs24\par
\b\f0\fs16 4 \b0\f1\fs24\par
\b\f0\fs16 5 using std::cout; \line 6 using std: :endl; \line 7 \line 8 #include<iomanip> \line\b0\i\f2\fs18 9 \line\b\i0\f0\fs16 10 using std::setw; \line 11 \b0\f1\fs24\par
\b\f0\fs16 24 \b0\f1\fs24\par
\b\f0\fs16 int main \b0\f1\fs24\par
\b\f0\fs14 const int arraySize \b0\f2\fs10 = \b\f0\fs14 10; \line int \b0\f1\fs20 j, \b\f0\fs14 s[ arraySize ]; \b0\f1\fs24\par
\b\f0\fs16 for \b0\f1\fs20 ( \f0\fs22 j \f2\fs10 = \b\f0\fs16 0; \b0\fs22 j \f1\fs14 < \b\f0\fs16 arraySize; ++ \b0\f1\fs20 ) \i\f0\fs22 II \b\i0\fs16 define os valores s[ \b0\f1\fs20 j ] \f2\fs10 = \b\f0\fs16 2 + 2 \b0\f2\fs12 * \f1\fs20 j; \line\b\f0\fs16 cout \'ab \ldblquote Elemento\rdblquote  \'ab setw( 13 \b0\f1\fs20 ) \b\f0\fs16\'ab \ldblquote Valor\rdblquote  \'ab endl; \line for \b0\f1\fs20 ( \f0\fs22 j \f2\fs10 = \b\f0\fs16 0; \b0\fs22 j \b\fs16 < arraySize; \b0\fs22 j++ ) \i II \b\i0\fs16 imprime os valores \line cout \'ab setw( 7 \b0\f1\fs20 ) \'ab j \b\f0\fs16\'ab setw( 13 \b0\f1\fs20 ) \'ab \b\f0\fs16 s[ \b0\f1\fs20 j ] \'ab \b\f0\fs16 endi; \b0\f1\fs24\par
\b\f0\fs16 25 return 0; \b0\f1\fs24\par
\b\f0\fs16 26 \b0\f1\fs18 ) \fs24\par
\b\f0\fs16 intn[] \{1, 2,3,4,5); \b0\f1\fs24\par
\fs20 iados \fs24\par
\fs20 valor \fs24\par
\b\f0\fs16 12 \line 13 \line 14 \line 15 \line 16 \line 17 \line 18 \line 19 \line 20 \line 21 \line 22 \line 23 \b0\f1\fs24\par
\fs20 stanrrays eiro \line\b\f2\fs16 ;. \b0\fs18 4.3 \f1\fs24\par
\i\fs18 rode \i0\fs24\par
\b\f2\fs18 Fig. \b0 4.5 Gerando os valores para serem colocados nos elementos de um array. \f1\fs24\par
\pard\par
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx877\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1574\pard\intbl\b\f0\fs16 Elemento \b0\f1\fs24\cell\b\f0\fs16 Valor \b0\f1\fs24\cell\fs20\row
\b\f0\fs16\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx877\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1574\intbl O \b0\f1\fs24\cell\b\f0\fs16 2 \b0\f1\fs24\cell\fs20\row
\b\f0\fs16\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx877\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1574\intbl 1 \b0\f1\fs24\cell\b\f0\fs16 4 \b0\f1\fs24\cell\fs20\row
\b\f0\fs16\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx877\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1574\intbl 2 \b0\f1\fs24\cell\b\f0\fs16 6 \b0\f1\fs24\cell\fs20\row
\b\f0\fs16\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx877\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1574\intbl 3 \b0\f1\fs24\cell\b\f0\fs16 8 \b0\f1\fs24\cell\fs20\row
\i\f2\fs18\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx877\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1574\intbl 4 \i0\f1\fs24\cell\b\f0\fs16 10 \b0\f1\fs24\cell\fs20\row
\b\f0\fs16\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx877\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1574\intbl 5 \b0\f1\fs24\cell\b\f0\fs16 12 \b0\f1\fs24\cell\fs20\row
\b\f0\fs16\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx877\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1574\intbl 6 \b0\f1\fs24\cell\b\f0\fs16 14 \b0\f1\fs24\cell\fs20\row
\b\f0\fs16\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx877\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1574\intbl 7 \b0\f1\fs24\cell\b\f0\fs16 16 \b0\f1\fs24\cell\fs20\row
\b\f0\fs16\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx877\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1574\intbl 8 \b0\f1\fs24\cell\b\f0\fs16 18 \b0\f1\fs24\cell\fs20\row
\b\f0\fs16\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx877\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1574\intbl 9 \b0\f1\fs24\cell\b\f0\fs16 20 \b0\f1\fs24\cell\fs20\row
\pard\fs24\par
\pard\sb100\sa240\f2\fs22 268 C++ \fs14 COMO PROGRAMAR \line\f0\fs20 A linha 14 \line const int arraySize \f2\fs12 = \f1\fs16 10; \line usa o qualificador const para declarar arraySize. denominada uma \i\fs18 vari\'e1vel constante, \i0\fs16 cujo valor \'e9 10. Vari\'e1veis constantes devem ser inicializadas com uma express\'e3o constante quando de sua declara\'e7\'e3o e n\'e3o podem mais ser modificadas (Fig. 4.6 e Fig. 4.7). Vari\'e1veis constantes s\'e3o tamb\'e9m chamadas de \i\fs18 constantes com nome \i0\fs16 ou \i\fs18 vari\'e1veis somente leitura. \i0\fs16 Note que o termo \ldblquote vari\'e1vel constante\rdblquote  \'e9 um ox\'edmoro \f2\fs8 - \f1\fs16 uma contradi\'e7\'e3o de linguagem, como \ldblquote camar\'e3o gigante\rdblquote  ou \ldblquote queimadura de frio\rdblquote . (Favor mandar seus ox\'edmoros favoritos para nosso e-mail listado no pref\'e1cio. Obrigado!). \line\b\f0 1 \b0\i\f1\fs18 II \b\i0\f0\fs16 F\'edg. 4.6: fig04_06.cpp \line 2 \b0\i\f1\fs18 II \b\i0\f0\fs16 Usando \b0\f1 uma \b\f0 vari\'e1vel constante inicializada apropriadamente \line 3 #include <iostream> \line 4 \line 5 us\'edng std::cout; \line 6 us\'edng std::endl; \line 7 \line 8 int main \b0\fs20 O \line\b\fs16 9\{ \line 10 const int x \b0\f2\fs12 = \b\f0\fs16 7; \b0\i\f1\fs18 1/ \b\i0\f0\fs16 vari\'e1vel constante inicializada \line 11 \line 12 cout \'ab \ldblquote O valor da vari\'e1vel constante x \'e9: \line 13 \'ab x \'ab endl; \line 14 \line 15 return 0; \line 16 \b0\fs20\} \line\b\fs16 O \b0\f1 valor da vari\'e1vel constante x \b\f0\'e9: 7 \line\b0\f1 Fig. \b\fs18 4.6 \b0\fs16 Inicializando \f2\fs20 e usando corretamente uma vari\'e1vel constante. \line\f1\fs16 1 \i\fs18 II \i0\fs16 Fig. \b\f0 4.7: \b0\f1 figO4O7.cpp \line 2 \i\fs18 II \b\i0\f0\fs16 Um \b0\f1 ob:jeto const deve ser \b\f0 inicializado \line 3 \line 4 int main() \line 5\{ \line 6 const int \f2\fs18 x; \b0\i\f1 /1 \b\i0\f0\fs16 Erro: x deve ser inicializado \line 7 \line 8 x \b0\f2\fs12 = \b\f0\fs16 7; \b0\fs20 7/ \b\fs16 Erro: n\'e3o se pode modificar \b0\f1 uma \b\f0 vari\'e1vel const \line 9 \line 10 return 0; \line\f1\fs18 11 \b0\f0\fs20\} \line\i\f1\fs18 Mensagens de erro do compilador Borland C+ \i0\f2\fs14 + \i\f1\fs18 com linha de comando: \line\i0\fs16 Fig0407 \f2\fs8 . \b\f0\fs16 cpp: \line\b0\f1 Error E2304 FigO4_07.cpp \b\f0 6: \b0\f1 Constant variable \lquote x\rquote  must be \line initialized in function main() \line Error E2024 FigO4_07.cpp \b\f0 8: \b0\f1 Cannot modify a const object \b\f0 in \line\b0\f1 function main() \line\f2\fs10 *** \b\f1\fs18 2 \b0\fs16 errors \b\f0 in \b0\f1 Compile \line\f2\fs20 Fig. 4.7 Um \f1\fs16 objeto const \f2\fs20 deve ser \f1\fs16 inicializado (parte \f2\fs20 1 de 2). \f1\fs24\par
\f2\fs20 Fig. 4.7 Um objeto \b\f1\fs16 const \b0\f2\fs20 deve ser inicializado (parte 2 de 2). \line\b\i\f1\fs18 Erro comum de programa\'e7\'e3o 4.4 \line\b0 Atribuir um valor a uma vari\'e1vel constante em um co\'ednando execut\'e1vel \'e9 um erro de sintaxe. \line\i0 Vari\'e1veis constantes podem ser colocadas em qualquer lugar onde \'e9 permitida uma express\'e3o constante. Na Fig. 4.5, a vari\'e1vel constante arraySize \'e9 usada para especificar o tamanho do array s na declara\'e7\'e3o \line int j, s [ arraySize ]; \line\b\i Erro comum de programa\'e7\'e3o 4.5 \line\b0 Somente constantes devem ser usadas para declarar arrays autom\'e1ticos e est\'e1ticos. N\'e3o usar uma constante para esta finalidade \'e9 um erro de sintaxe. \line\i0 Usar vari\'e1veis constantes para especificar tamanhos de arrays torna os programas \i mais flex\'edveis. \i0 Na Fig. 4.5, o primeiro la\'e7o for preencheria um array de 1000 elementos, simplesmente modificando-se de 10 para 1000 o valor de arraySize. Se a vari\'e1vel constante arraySize n\'e3o tivesse sido utilizada, ter\'edamos de modificar o programa em tr\'eas lugares diferentes para adapt\'e1-lo ao array de 1000 elementos. A medida que os programas se tornam maiores, essa t\'e9cnica se torna mais \'fatil para escrever programas mais claros. \line\b\i Observa\'e7\'e3o de engenharia de software 4.1 \line\b0\i0\f2\fs8 ______ \i\f1\fs18 Definir o tamanho de cada array com uma vari\'e1vel constante torna os programas mais flex\'edveis. \line\b Boa pr\'e1tica de programa\'e7\'e3o 4.1 \line\b0 Definir o tamanho do array como uma vari\'e1vel constante, em vez de se usar uma constante, torna os programas mais claros. Esta t\'e9cnica \'e9 usada para se eliminar os chamados \i0 n\'fameros m\'e1gicos; \i ou seja, mencionar repetidamente o n\'famero 10 no c\'f3digo que processa um array de 10 elementos d\'e1 ao n\'famero 10 um significado artificial, podendo infelizmente confundir o leitor quando tamb\'e9m existirem no programa outros n\'fameros 10 que nada t\'eam a ver com o tamanho do array. \line\i0\f2\fs20 O \f1\fs18 programa da Fig. 4.8 soma os valores contidos em um array a, que possui 12 elementos inteiros. O comando no corpo do la\'e7o for faz a totaliza\'e7\'e3o. E importante lembrar que os valores que est\'e3o sendo fornecidos como inicializadores para o array a normalmente seriam digitados pelo usu\'e1rio atrav\'e9s do teclado para o programa ler. Por exemplo, a seguinte estrutura for \line for ( int \f2\fs12 = \f1\fs18 O; j \b\f0 < arraySize; \b0\f1 j++ \line cm \b\f0\'bb a[ j \b0\f1 1; \fs24\par
\i\fs16 Mensagens de erro do compilador Microsoft Visual C+ \i0 + \fs24\par
\fs16 riaais \line mo no \fs24\par
\b\f2\fs14 CAP\'cdTULO \b0\fs20 4 \fs8 - \f1\fs16 ARRAYS \fs24\par
\f2\fs20 269 \f1\fs24\par
\fs18 l\'ea um valor digitado no teclado de cada vez e armazena o valor no elemento a \f3\fs24 [ j \f1\par
\pard\par
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2917\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4646\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx5079\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx5620\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx6485\pard\intbl\b\f0\fs18 Compiling... \b0\f1\fs24\cell\cell\cell\cell\cell\fs20\row
\b\f0\fs18\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2917\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4646\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx5079\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx5620\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx6485\intbl FigO4_07 cpp \b0\f1\fs24\cell\cell\cell\cell\cell\fs20\row
\b\f0\fs16\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2917\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4646\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx5079\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx5620\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx6485\intbl d:\\FigOd_07.cpp(6) error \b0\f1\fs24\cell\b\f0\fs18 C2734: \b0\f1\fs24\cell\cell\cell\cell\fs20\row
\b\f0\fs18\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2917\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4646\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx5079\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx5620\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx6485\intbl const object must \b0\f1\fs24\cell\b\f0\fs18 be initialized \b0\f1\fs24\cell\b\f0\fs18 if \b0\f1\fs24\cell\b\f0\fs18 not \b0\f1\fs24\cell\b\f0\fs18 extern \b0\f1\fs24\cell\fs20\row
\b\f0\fs18\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2917\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4646\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx5079\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx5620\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx6485\intbl d:\\figO4_07.cpp(8) : error \b0\f1\fs24\cell\b\f0\fs18 C2166: \b0\f1\fs24\cell\cell\cell\cell\fs20\row
\b\f0\fs18\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2917\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4646\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx5079\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx5620\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx6485\intbl 1-value specifies const \b0\f1\fs24\cell\b\f0\fs18 object \b0\f1\fs24\cell\cell\cell\cell\fs20\row
\b\f0\fs18\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2917\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4646\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx5079\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx5620\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx6485\intbl Error executing ciexe. \b0\f1\fs24\cell\cell\cell\cell\cell\fs20\row
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4646\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx5079\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx5620\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx6485\pard\intbl\b\f0\fs16 test.exe \b0\f2\fs8 - \b\f0\fs16 2 error(s), O warning(s) \b0\f1\fs24\cell\cell\cell\cell\fs20\row
\pard\fs24\par
\pard\sb100\sa240\fs20 270 \b\f2\fs18 C++ \b0\fs14 COMO \b\f1\fs12 PROGRAMAR \line\f0\fs14 1 \b0\i\f2\fs22 II \b\i0\f0\fs14 Fig. 4.8: figO4O8.cpp \line 2 \b0\i\f2\fs20 II \b\i0\f0\fs14 Calcula a soma dos elementos de um array \line 3 #include <iostream> \line 4 \line 5 using std::cout; \line 6 using std: :endl; \line 7 \line 8 int main \b0\f1\fs20 () \line\b\f0\fs14 9\{ \line 10 const int arraySize \b0\f2\fs10 = \b\f0\fs14 12; \line 11 int a[ arraySize \b0\f1\fs20 ] \f2\fs10 = \f1\fs20\{ \b\f0\fs14 1, 3, 5, 4, 7, 2, 99, \line 12 16, 45, 67, 89, 45 \}; \line 13 int total \b0\f2\fs10 = \b\f0\fs14 O; \line 14 \line 15 for \b0\f1\fs20 ( \b\f0\fs14 nt i \b0\f2\fs10 = \b\f0\fs14 0; i \f1\fs12 <= \f0\fs14 arraySize; i++ \line 16 total \f1\fs12 += \f0\fs14 a[ i ]; \line 17 \line 18 cout \'ab \ldblquote A soma dos valores dos elementos do array e \b0\f2\fs8\lquote  \f1\fs20\'ab \b\f0\fs14 total \'ab enl; \line 19 return 0; \line 20 \b0\f1\fs20\} \fs24\par
\b\f0\fs16 A soma dos valores dos elementos do array \'e9 383 \b0\f1\fs24\par
\f2\fs20 Fig. 4.8 Calculando a soma dos elementos de um array. \line Nosso \f1\fs18 pr\'f3ximo exemplo usa arrays para resumir os resultados dos dados coletados em uma pesquisa. Considere o seguinte enunciado de problema: \line\i\fs16 h)iperguntado a quarenta alunos o n\'edvel de qualidade da comida na cantina estudantil, em uma escala de O a 10 \line (1 significando horrorosa e 10 significando excelente). Coloque as quarenta respostas em um array inteiro e \line resuma os resultados da pesquisa. \line\i0\fs18 Essa \'e9 uma aplica\'e7\'e3o t\'edpica de arrays (veja a Fig. 4.9). Queremos resumir o n\'famero de respostas de cada tipo (i.e., 1 a 10). O array responses possui 40 elementos, com as respostas dos alunos. Usamos um array frequency. com li elementos, para contar o n\'famero de ocorr\'eancias de cada resposta. Ignoramos o primeiro elemento, frequency [ O 1 porque \'e9 mais l\'f3gico fazer com que a resposta 1 incremente frequency [ 1 ] do que frequency [ O ]. Isso permite usar diretamente cada resposta como subscrito do array frequency. \line\b\f0\fs16 1 \b0\i\f2\fs22 II \b\i0\f0\fs16 Fig 4.9: fig04_09.cpp \line 2 \b0\i\f2\fs22 II \b\i0\f0\fs16 Programa de resumo da pesquisa com os estudantes \line 3 #include <iostream> \line 4 \line 5 using std::cout; \line 6 using std::endl; \line 7 \line 8 #include <iomanip> \line 9 \line 10 using std::setw; \line\b0\f1\fs18 11 \line\b\f0\fs16 12 int main() \line 13 \line 14 const int responseSize \f1\fs12 = \f0\fs16 40, frequencySize \f1\fs12 = \f0\fs16 11; \line 15 int responses[ responseSize \b0\f1\fs18 ] \b\fs12 = \b0\fs18\{ \b\f0\fs16 1, 2, 6, 4, 8, 5, 9, 7, 8, \line 16 10,1,6,3,8, 6,10,3,8,2,7, 6,5,7,6,8, 6,7, \line\f2\fs18 Fig. 4.9 \b0\fs20 Um programa de an\'e1lise de uma vota\'e7\'e3o de estudantes (parte 1 de 2). \f1\fs24\par
\b\fs16 CAP\'cdTULO \b0\i\fs18 4 \i0\f2\fs8 - \b\f1\fs16 ARRAYS \b0\f2\fs22 271 \line\b\f1\fs16 17 5, 6, 6, 5, 6, 7, 5, 6, 4, 8, 6, 8, 10 \}; \line 18 int frepiency[ frequencySize \b0\f2\fs22 1 \fs10 = \fs22\{ \b\f0\fs16 O \}; \line 19 \line 20 for \b0\f2\fs22 ( \b\f1\fs16 int \f0 answer 0; answer < responseSize; answer++ \line 21 ++frequency[ responses[answer] ]; \line 22 \line 23 cout \'ab \ldblquote Avalia\'e7\'e3o \'ab setw( 17 \b0\f2\fs22 ) \b\f0\fs16\'ab \ldblquote Freq\'fc\'eancia\rdblquote  \'ab endi; \line 24 \line 25 for \b0\f2\fs22 ( \b\f0\fs16 int rating \b0\f2\fs10 = \b\f0\fs16 1; rating < frequencySize; rating++ \line 26 cout \'ab setw( 6 \b0\f2\fs22 ) \b\f1\fs16\'ab \f0 rating \line 27 \'ab setw( 17 \b0\f2\fs22 ) \b\f0\fs16\'ab frequency[ rating \b0\f2\fs22 ] \b\f1\fs16\'ab \f0 endi; \line 28 \line 29 return 0; \line 30 \b0\f2\fs22\} \line\b\f1\fs16 Avalia\'e7\'e3o Freq\'fc\'eancia \line\f0 1 2 \line 2 2 \line 3 2 \line 4 2 \line 5 5 \line 6 11 \line 7 5 \line 8 7 \line\f1 9 1 \line\f0 10 3 \line lere o \line\b0\f2\fs20 Fig. 4.9 Um programa de an\'e1lise de uma vota\'e7\'e3o de estudantes (parte 2 de 2). \line\ul\i\f1 Boa pr\'e1tica de programa\'e7\'e3o 4.2 \ulnone\line Procure obter clareza nos programas. Algumas vezes, vale a pena trocar um uso mais eficiente da mem\'f3ria e do processador por programas escritos com maior clareza. \line\i0\fs18 (i.e., \line flCY. 1 \ul\i\fs20 Dica de desempenho 4.2 \ulnone\line\i0\fs18 ento, \f2\fs8 - ___________________________________________________________________________________________________ \line\f1\fs18 que \i Algumas vezes, as considera\'e7\'f5es de desempenho s\'e3o muito mais importantes do que as considera\'e7\'f5es de clareza. \line\i0 O primeiro la\'e7o for (linhas 20 e 21) obt\'e9m uma resposta por vez do array responses e incrementa 1 dos 10 \line contadores (frequency \f2\fs22 [ \f1\fs18 1 1 a frequency 10 1) no array frequency. O comando principal do la\'e7o \line e \line\b\f0\fs16 ++frequency[ responses[ answer \b0\f2\fs22 ] \b\f1\fs16 ]; \line\b0\fs18 Esse comando incrementa o contador frequency apropriado, dependendo do valor de responses \f2\fs22 [ \f1\fs18 answer \line\f2\fs22 1. \f1\fs18 Por exemplo, quando a vari\'e1vel do contador answer for O, responses \f2\fs22 [ \f1\fs18 answer \f2\fs22 ] \f1\fs18\'e9 1, portanto \line ++frequency \f2\fs22 [ \f1\fs18 responses \f2\fs22 [ \f1\fs18 answer 1 1 \b\fs16 ; \b0\fs18\'e9 na verdade interpretado como \line ++frequency[ \b\f0\fs16 1 ]; \line\b0\f1\fs18 que incrementa o elemento um do array. Quando answer for 1, responses [ answer ] ser\'e1 2, portanto ++frequency [ responses [ answer 1 1 \b\fs16 ; \b0\fs18\'e9 interpretado como \line ++frequency[ \b\f0\fs16 2 \b0\f1\fs18 1; \fs24\par
\fs18 272 \f2\fs28 c\'f7+ \b\fs14 COMO \f1 PROGRAMAR \line\b0\fs18 que incrementa o elemento dois do array. Quando answer for 2, responses \i\fs20 [ \i0\fs18 answer \b\fs16 J \b0\fs18 ser\'e1 6, portanto ++frequency \i\fs20 [ \i0\fs18 responses \i\fs20 [ \i0\fs18 answer j \i\fs20 1 \b\i0\f0\fs16 ; \b0\f1\fs18\'e9 interpretado como \line ++frequency[ 6 ]; \line que incrementa o elemento seis do array, e assim por diante. Observe que, independentemente do n\'famero de respostas processadas, apenas um array de 11 elementos \'e9 necess\'e1rio (ignorando o elemento zero) para resumir os resultados. Se os dados tivessem valores inv\'e1lidos, como 13, o programa tentaria adicionar 1 a frequency \i\fs20 [ \i0\fs18 13 \b\fs16 ]. \b0\fs18 Isso estaria al\'e9m dos limites do array. \i\fs20 C+ \b\i0\fs14 + \b0\i\f2\fs18 n\'e3o verifica \f1\fs20 os limites do array para evitar que o computadorfa\'e7a refer\'eancia a uni elemento n\'e3o-existente. \i0\fs18 Assim, um programa pode ultrapassar os limites de um array sem emitir qualquer aviso. O programador deve ter certeza de que todas as refer\'eancias ao array permanecem dentro de seus limites. No Cap\'edtulo 8, estenderemos C++ implementando um array como um tipo definido pelo programador atrav\'e9s do emprego de uma classe. Nossa nova defini\'e7\'e3o de array nos permitir\'e1 executar muitas opera\'e7\'f5es que n\'e3o s\'e3o opera\'e7\'f5es padr\'e3o dos arrays primitivos dispon\'edveis em C++. Por exemplo, seremos capazes de comparar arrays diretamente, atribuir um array a outro array, exibir ou ler arrays completos usando cm e cout, inicializar arrays automaticamente, evitar o acesso a elementos fora do array e mudar o intervalo dos subscritos (e mesmo o tipo de seus subscritos) de maneira que o primeiro elemento de um array n\'e3o precise ser o elemento 0. \line\i Erro comum de programa\'e7\'e3o \b\f2\fs20 4.6 \line\b0\f1\fs18 Fazer refer\'eancia a um elemento al\'e9m dos limites de um array \'e9 um erro de l\'f3gica que ocorre durante a \line execu\'e7\'e3o. N\'e3o \'e9 um erro de sintaxe. \line Dica de teste e depura \'e7\'e3o \b\f2\fs20 4.1 \line\b0\f1\fs18 Ao usar um la\'e7o para percorrer um array, os subscritos nunca devem ser menores do que O e sempre devem ser menores do que o n\'famero total de elementos do array (uma menos que o tamanho do array). Certifique-se de que a condi\'e7\'e3o de t\'e9rmino do la\'e7o evite o acesso a elementos fora desses limites. \line Dica de teste e depura \'e7\'e3o 4.2 \line Os programas devem verificar a exatid\'e3o de todos os valores de entrada para evitar que informa\'e7\'f5es \line erradas afetem os c\'e1lculos executados pelo programa. \line Dica de portabilidade \b\f2\fs20 4.1 \line\b0\f1\fs18 Os efeitos (geralmente graves) da refer\'eancia a elementos situados fora dos limites de um array dependem \line dos sistemas. Freq\'fcentemente isso resulta em altera\'e7\'e3o do valor de uma vari\'e1vel n\'e3o-relacionada. \line Dica de teste e depura \'e7\'e3o \b\f2\fs20 4.3 \line\b0\f1\fs18 Quando estudarmos classes (a partir do Cap\'edtulo 6), veremos como desenvolver um \ldblquote array inteligente \i0\f2\fs8\ldblquote , \i\f1\fs18 que verifica automaticamente se os subscritos em todas as refer\'eancias est\'e3o dentro dos limites durante a execu\'e7\'e3o. O uso de tais tipos de dados inteligentes ajuda a eliminar erros. \line\i0 Nosso pr\'f3ximo exemplo (Fig. 4.10) l\'ea os n\'fameros de um array e p\'f5e em gr\'e1fico as informa\'e7\'f5es na forma de um gr\'e1fico de barras ou histograma \f2\fs8 - \f1\fs18 cada n\'famero \'e9 impresso e ent\'e3o uma barra constitu\'edda do mesmo n\'famero de asteriscos \'e9 impressa ao seu lado. O la\'e7o for aninhado na verdade desenha as barras. Observe o uso de endl para finalizar uma barra do histograma. \line\b\f0\fs16 1 \b0\i\f1\fs20 II \b\i0\f0\fs16 Fig. 4.10: figO4lO.cpp \line 2 \b0\i\f1\fs20 II \b\i0\f0\fs16 Programa para imprimir histograina \line 3 #include <iostream> \line 4 \line\f2\fs18 Fig. 4.10 \b0\fs20 Um programa que imprime histogramas (parte 1 de 2). \f1\fs24\par
\fs16 CAP\'cdTULO \f2\fs20 4 \fs8 - \f1\fs16 ARRAYS \f2\fs20 273 \line\b\f0\fs16 5 using std::cout; \line 6 using std: :endl; \line 7 \line 8 #include <iomanip> \line 9 \line 10 using std::setw; \line 11 \line 12 int main \b0\f2\fs20 O \line\b\f0\fs16 13 \line 14 const int arraySize \b0\f2\fs10 = \b\f0\fs16 10; \line 15 int n[ arraySize \b0\f1\fs20 J \f2\fs10 = \fs20\{ \b\f0\fs16 19, 3, 15, 7, 11, 9, 13, 5, 17, 1 \}; \line 16 \line 17 cout \'ab \lquote Elemento\rdblquote  \'ab setw( 13 \b0\f2\fs20 ) \f1\fs16\'ab \b\f0\ldblquote Valor\rdblquote  \line 18 \'ab setw( 17 \b0\f2\fs20 ) \b\f0\fs16\'ab \ldblquote Histograma\rdblquote  \'ab endi; \line 19 \line 20 for \b0\f2\fs20 ( \b\f0\fs16 int i \b0\f2\fs10 = \b\f0\fs16 i < arraySize; i++ \b0\f2\fs20 ) \{ \line\b\f0\fs16 21 cout \'ab setw( 7 \b0\f2\fs20 ) \f1\fs16\'ab i \b\f0\'ab setw( 13 \line 22 \'abn[i)\'absetw(9); \line 23 \line 24 for \b0\f2\fs20 ( \b\f0\fs16 int \b0\f2\fs10 = \b\f0\fs16 0; \b0\f1\fs20 j \b\f0\fs16 < n[ i ); \b0\f1\fs20 j++ ) \i\fs18 II \b\i0\f0\fs16 imprime \b0\f2\fs18 urna \b\f0\fs16 barra \line 25 cout \'ab \b0\f2\fs10\lquote\lquote ; \line\b\f0\fs16 26 \line 27 cout \'ab endl; \line 28 \b0\f2\fs20\} \line\b\f0\fs16 29 \line 30 return 0; \line 31 \b0\f2\fs20\} \line\b\f0\fs16 Elemento Valor Histograrna \line O 19 \line 1 3 \line 2 15 \line 3 7 \b0\f2\fs12 ******* \line\b\f0\fs16 4 11 \line 5 9 \line 6 13 \line 7 5 \b0\f2\fs12 ***** \line\b\f0\fs16 8 17 \line 9 1 \b0\f2\fs12 * \line\b\fs18 Fig. 4.10 \b0\fs20 Um programa que imprime histogramas (parte 2 de 2). \line\i\f1\fs18 Erro comum de programa\'e7\'e3o 4.7 \line Embora seja poss\'edvel usar a mesma vari\'e1vel contadora de um la\'e7o \i0\fs16 for \i\fs18 em um segundo la\'e7o \i0\fs16 for \i\fs18 aninhado no interior do primeiro, isto \'e9 normalmente um erro de l\'f3gica. \line\i0\f3\fs78\'ae \i\f1\fs18 Dica de teste e depura \'e7\'e3o 4.4 \line Embora seja poss\'edvel modificar um contador de la\'e7o no corpo de um \i0\fs16 for, \i\fs18 evite fazer isso porque essa \line pr\'e1tica freq\'fcentemente leva \'e0 ocorr\'eancia de erros sutis. \line\i0\fs20 No Cap\'edtulo 3, afirmamos que mostrar\'edamos um m\'e9todo mais elegante de escrever o programa do jogo de dados da Fig. 3.8. O problema era lan\'e7ar um dado de seis faces 6000 vezes para verificar se o gerador de n\'fameros aleat\'f3rios produzia realmente n\'fameros aleat\'f3rios. Uma vers\'e3o desse programa utilizando arrays \'e9 mostrada na Fig. 4.11. \fs24\par
\b\f2\fs20 274 \b0\fs28 c++ \b\fs14 COMO \b0\f1 PROGRAMAR \line\b\f0\fs16 1 \b0\i\f2\fs22 II \b\i0\f0\fs16 Fig. 4.11: figO4ll.cpp \line 2 \f2\fs20 // \f0\fs16 Lan\'e7ar um dado de seis lados 6000 vezes \line 3 #include <iostream> \line 4 \line 5 using std::cout; \line 6 using std::endl; \line 7 \line 8 #include <iomanip> \line 9 \line 10 using std::setw; \line 11 \line 12 #include <cstdlib> \line 13 #include <ctime> \line 14 \line 15 int main \f2\fs20 () \line\f0\fs16 16 \line 17 const int arraySize \b0\f2\fs10 = \b\f0\fs16 7; \line 18 int face, frequency[ arraySize \f2\fs20 ] \b0\fs10 = \b\fs20\{ \f0\fs16 O \}; \line 19 \line 20 srand( time( O \f2\fs20 ) \f0\fs16 ); \line 21 \line 22 for \f2\fs20 ( \f0\fs16 int roll \b0\f2\fs10 = \b\f0\fs16 1; roll \b0\f1\fs14 <= \b\f0\fs16 6000; roll++ \line 23 ++frequency[ 1 + rand() % 6 ]; \b0\i\f2\fs22 II \b\i0\f0\fs16 substitui o switch de \line 24 \f2\fs20 // \f0\fs16 20 linhas da Fig. 3.8 \line 25 \line 26 cout \'ab \ldblquote Face\rdblquote  \'ab setw( 13 \f2\fs20 ) \f0\fs16\'ab \ldblquote Freq\'fc\'eancia\rdblquote  \'ab endi; \line 27 \line 28 \b0\i\f2\fs22 II \b\i0\f0\fs16 ignora o elemento O no array frequency \line 29 for \f2\fs20 ( \f0\fs16 face \b0\f1\fs14 = \b\f0\fs16 1; face < arraySize \b0\f1\fs14 ; \b\f0\fs16 face++ \line 30 cout \b0\i\f1\fs18\'ab \b\i0\f0\fs16 setw( 4 \f2\fs20 ) \b0\i\f1\fs18\'ab \b\i0\f0\fs16 face \line 31 \'ab setw( 13 \f2\fs20 ) \f0\fs16\'ab frequency[ face \f2\fs20 1 \b0\i\f1\fs18\'ab \b\i0\f0\fs16 endl; \line 32 \line 33 return 0; \line 34 \f2\fs20\} \b0\f1\fs24\par
\b\f2\fs20 Fig. 4.11 \b0\fs18 Programa de lan\'e7amento de dados usando arrays em vez de switch. \line At\'e9 este ponto, analisamos apenas arrays de inteiros. Entretanto, os arrays s\'e3o capazes de conter dados de qualquer tipo. Analisamos, agora, o armazenamento de \i\f1 strings \i0\f2 em arrays de caracteres. At\'e9 agora, o \'fanico recurso de processamento de \i\f1 strings \i0\f2 que utilizamos foi imprimir um \i\f1 string \i0\f2 com cout e \'ab. Um \i\f1 string \i0\f2 como \ldblquote al\'f4\rdblquote  \'e9, na realidade, um array de caracteres em C++. \line Os arrays de caracteres possuem v\'e1rias caracter\'edsticas exclusivas. Um array de caracteres pode ser inicializado \line usando um \i\f1 string \i0\f2 literal. Por exemplo, a declara\'e7\'e3o \line\f1 char stringl[ \f2 ] \f1\fs14 = \ldblquote primeiro\rdblquote ; \line\f2\fs18 inicializa os elementos do array \f1 stringl com \f2 os valores de cada um dos caracteres do \i\f1 string \i0\f2 literal \ldblquote primeiro\rdblquote . O tamanho do array stringl na declara\'e7\'e3o anterior \'e9 determinado pelo compilador, com base no comprimento do \i\f1 string. \i0 E \f2 importante notar que o \i\f1 string \i0\ldblquote primeiro\rdblquote  \f2 cont\'e9m oito caracteres \i\f1 mais \i0\f2 um caractere especial \f1\fs24\par
\pard\par
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx493\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1670\pard\intbl\b\f0\fs16 Face \b0\f1\fs24\cell\b\f0\fs16 Freq\'fc\'eancia \b0\f1\fs24\cell\fs20\row
\b\f0\fs16\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx493\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1670\intbl 1 \b0\f1\fs24\cell\b\f0\fs16 1037 \b0\f1\fs24\cell\fs20\row
\b\f0\fs16\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx493\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1670\intbl 2 \b0\f1\fs24\cell\b\f0\fs16 987 \b0\f1\fs24\cell\fs20\row
\b\f0\fs16\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx493\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1670\intbl 3 \b0\f1\fs24\cell\b\f0\fs16 1013 \b0\f1\fs24\cell\fs20\row
\b\f0\fs16\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx493\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1670\intbl 4 \b0\f1\fs24\cell\b\f0\fs16 1028 \b0\f1\fs24\cell\fs20\row
\b\f0\fs16\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx493\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1670\intbl 5 \b0\f1\fs24\cell\b\f0\fs16 952 \b0\f1\fs24\cell\fs20\row
\b\f0\fs16\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx493\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1670\intbl 6 \b0\f1\fs24\cell\b\f0\fs16 983 \b0\f1\fs24\cell\fs20\row
\pard\fs24\par
\pard\sb100\sa240\fs18 CAP\'cdTULO 4- \b\f0\fs16 ARRAYS \b0\f2\fs22 275 \line\f1\fs18 de t\'e9rmino de \i string, \i0 chamado \i caractere nulo. \i0 Dessa forma, o array stringl cont\'e9m, na verdade, nove elementos. A representa\'e7\'e3o como caractere constante do caractere nulo \'e9 \\O\rquote  \f2\fs8 . \f1\fs18 Todos os \i strings \i0 em C++ terminam com esse caractere. Um array de caracteres representando um \i string \i0 deve sempre ser declarado com tamanho suficiente para conter o n\'famero de caracteres do \i string \i0 mais o caractere nulo de t\'e9rmino. \line Os arrays de caracteres tamb\'e9m podem ser inicializados com constantes de caracteres individuais em uma \line lista de inicializadores. A declara\'e7\'e3o anterior \'e9 equivalente a \line char stringl[ ] \f2\fs12 = \f1\fs18\{ \lquote p\rquote , \lquote r\rquote , \lquote i\rquote , \lquote m\rquote , \lquote e\rquote , \b\f2\fs14\lquote i\rquote , \b0\f1\fs18\lquote r\rquote , \lquote o\rquote , \lquote\\O\rquote  \}; \line Como os \i strings \i0 s\'e3o, na verdade, arrays de caracteres, podemos acessar diretamente os caracteres individuais de um \i string \i0 usando a nota\'e7\'e3o de subscritos de arrays. Por exemplo, stringl O \i ] \i0\'e9 o caractere p\rquote  e stringl \i [ \i0\f0 3 \line\f1\'e9 o caractere \lquote m\rquote . \line Tamb\'e9m podemos ler um \i string \i0 diretamente para um array de caracteres, a partir do teclado, usando cm e\'bb. \line Por exemplo, a declara\'e7\'e3o \line char string2 [ 20 ); \line cria um array de caracteres capaz de armazenar um \i string \i0 de 19 caracteres e um caractere nulo de t\'e9rmino. O \line comando \line\f0 cm \b\fs16\'bb \b0\f1\fs18 string2; \line\f0 l\'ea um \i\f1 string \i0 do teclado para string2 e automaticamente acrescenta o caractere nulo ao fim \f0 de string2. Observe \f1 que, no comando precedente, somente o nome do array \f0\'e9 passado; nenhuma informa\'e7\'e3o sobre o tamanho do array \f1\'e9 fornecida. E responsabilidade do programador assegurar que o array para o qual o \i string \i0\'e9 lido pode conter qualquer string que o usu\'e1rio digite no teclado. cm l\'ea caracteres do teclado, at\'e9 que o primeiro caractere de espa\'e7o em branco seja encontrado \f2\fs8 - \f1\fs18 para cm o tamanho do array n\'e3o tem import\'e2ncia. Dessa forma, ler dados com ciri e \f0\fs20\'bb \f1\fs18 pode inserir dados al\'e9m do final do array (veja a Se\'e7\'e3o \i\f2\fs20 5.12 \i0\f1\fs18 para obter informa\'e7\'f5es de como evitar a inser\'e7\'e3o de dados al\'e9m do final de um array char). \line\ul\i Erro comum de programa\'e7\'e3o 4.8 \ulnone\line N\'e3o fornecer a \i0\f0 cm \'bb \i\f1 um array de caracteres com comprimento suficiente para armazenar um \i0\f0 string \i\f1 digitado no teclado pode resultar na perda de dados em um programa e em outros erros s\'e9rios durante a execu\'e7\'e3o. \line\i0 Um array de caracteres representando um \i string \i0 terminado com o caractere nulo pode ser impresso com cout e \f2\fs14\'ab. \f0\fs18 O array \b\fs16 string2 \b0\f1\fs18\'e9 impresso com o comando \line\b\f0\fs16 cout \'ab string2 \'ab endi; \line\b0\f1\fs18 Observe que para cout \f2\fs22\'ab, \f1\fs18 assim como para cm\'bb, n\'e3o importa o tamanho do array de caracteres. Os caracteres \line lquer do \i string \i0 s\'e3o impressos at\'e9 que seja encontrado um caractere nulo de t\'e9rmino. \line so de A Fig. 4.12 mostra como inicializar um array de caracteres com um \i string \i0 literal, ler um \i string \i0\f0 e \f1 armazen\'e1-lo \'e9, na em um array de caracteres, imprimir um array de caracteres como \i string \i0 e ter acesso a caracteres individuais de um \line\i string. \line\i0 izado \line\b\f0\fs16 1 \b0\i\f2\fs20 II \b\i0\f0\fs16 Fig. 4.12: figO4l2.cpp \line 2 \b0\f1\fs18 // \b\f0\fs16 Tratando arrays de caracteres como strings \line 3 #include <iostream> \line\f2\fs14 4 \line\b0\f0\fs18 aei- \b\fs16 5 using std::cout; \line\b0\fs20 Tipri ecia \line\b\f2\fs18 Fig. 4.12 \b0\fs20 Tratando \f0 arrays \f2 de caracteres como \i strings \i0 (parte 1 de 2). \f1\fs24\par
\f2\fs20 276 \fs28 c++ \b\fs14 COMO PROGRAMAR \line\f0\fs16 6 using std::cin; \line 7 using std: :endl; \line 8 \line 9 int main \b0\f2\fs20 O \line\b\f0\fs16 10 \line 11 char stringl[ 20 \b0\f2\fs20 ], \b\f0\fs16 string2[] \f1\fs14 = \f0\fs16\ldblquote string constante\rdblquote ; \line 12 \line 13 cout \'ab \ldblquote Digite um string: \line 14 cm \'bb stringl; \line 15 cout \'ab \ldblquote stringl \'e9: \b0\f2\fs8\ldblquote  \b\f0\fs16\'ab stringl \line 16 \'ab \lquote\\nstring2 \'e9: \b0\f2\fs8\ldblquote  \b\f0\fs16\'ab string2 \line 17 \'ab \ldblquote\\nstringl com espa\'e7os entre os caracteres \'e9:\\n\rquote ; \line 18 \line 19 for \b0\f2\fs20 ( \b\f0\fs16 int i \f1\fs14 = \f0\fs16 0; stringl[ i \b0\f2\fs20 ] \b\f1\fs14 != \f0\fs16\lquote\\O\rquote ; i++ \line 20 cout \'ab stringl \b0\f2\fs20 [ \b\f0\fs16 i \b0\f2\fs20 ] \b\f0\fs16\'ab \line 21 \line 22 cm \'bb stringl; \b0\i\f1\fs18 II \b\i0\f0\fs16 l\'ea \ldblquote bem?\rdblquote  \line 23 cout \'ab \ldblquote\\nstringl \'e9: \b0\f2\fs8\ldblquote  \b\f0\fs16\'ab stringl \'ab endi; \line 24 \line 25 cout \'ab endi; \line 26 return 0; \line 27 \b0\f2\fs20\} \line\b\f0\fs16 Digite um string: Tudo bem? \line stringl \'e9: Tudo \line string2 \'e9: string constante \line stringl com espacos entre os caracteres \'e9: \line Tudo \line Stringl \'e9: bem? \line\b0\f2\fs20 Fig. 4.12 Tratando arrays de caracteres como \i strings \i0 (parte 2 de 2). \line\f1\fs18 A Fig. 4.12 usa uma estrutura for (linhas 19 e 20) para fazer um la\'e7o atrav\'e9s do array stringl e imprimir os caracteres individuais, separados por espa\'e7os. A condi\'e7\'e3o na estrutura for, stringl \f2\fs20 [ i ] ! \b\f1\fs14 = \lquote\\O \b0\f2\fs8\lquote  \f1\fs18 ,\'e9 verdadeira enquanto o caractere nulo n\'e3o for encontrado no \i string. \line\i0 O Cap\'edtulo 3 analisou o especiticador de classe de armazenamento static \f2\fs8 . \f1\fs18 Uma vari\'e1vel local static em uma defini\'e7\'e3o de fun\'e7\'e3o existe durante toda a execu\'e7\'e3o do programa, mas s\'f3 \'e9 vis\'edvel no corpo da fun\'e7\'e3o. \line\i Dica de desempenho 4.3 \line\i0\f2\fs30 f \i\f1\fs18 Podemos aplicar \b\i0\f0\fs16 static \b0\i\f1\fs18 a uma declara\'e7\'e3o de um array local de modo que o array n\'e3o seja criado e \line inicializado, cada vez que a fun\'e7\'e3o \'e9 chamada, e destru\'eddo cada vez que a execu\'e7\'e3o deixa afun\'e7\'e3o. Isto \line melhora o desempenho. \line\i0 Os arrays declarados como est\'e1ticos (static) s\'e3o inicializados automaticamente uma \'fanica vez, durante a compila\'e7\'e3o. Se um array static n\'e3o for inicializado explicitamente pelo programador, ser\'e1 inicializado com zeros pelo compilador quando o array for criado. \line A Fig. 4.13 mostra a fun\'e7\'e3o staticArraylnit com um array local declarado static e a fun\'e7\'e3o automaticArraylnit com um array local autom\'e1tico. A fun\'e7\'e3o staticArraylnit \'e9 chamada duas vezes. O array local static na fun\'e7\'e3o \'e9 inicializado com zeros pelo compilador. A fun\'e7\'e3o imprime o array, adiciona 5 a cada elemento e imprime o array novamente. Na segunda vez em que a fun\'e7\'e3o \'e9 chamada, o array static cont\'e9m os valores armazenados durante a primeira execu\'e7\'e3o da fun\'e7\'e3o. A fun\'e7\'e3o automaticArraylnit tamb\'e9m \'e9 chamada duas vezes. Os elementos do array local autom\'e1tico na fun\'e7\'e3o s\'e3o inicializados com os valores 1, 2 e 3. A fun\'e7\'e3o imprime o array, adiciona \i 5 \i0 a cada elemento e imprime o array novamente. Na segunda vez em que a fun\'e7\'e3o \'e9 chamada, os elementos do array s\'e3o inicializados com 1, 2 e 3 novamente porque o array tem classe de armazenamento autom\'e1tica. \fs24\par
\fs16 CAP\'cdTULO \i\fs20 4- \i0\fs16 ARRAYS \f2\fs20 277 \line\f1\fs16 1 \i\fs20 II \i0\fs16 Fig. 4.13: figO4_13.cpp \line\f0 2 \i\f1\fs20 II \i0\f0\fs16 Arrays static s\'e3o inicializados com zeros \line 3 #include <iostream> \line 4 \line 5 using std::cout; \line 6 using std: :endl; \line\b\f2\fs18 7 \line\b0\f0\fs16 8 void staticArraylnit( void ); \line 9 void automaticArraylnit( void ); \line 10 \line 11 int main() \line 12 \line 13 cout \'ab Primeira chamada para cada fun\'e7\'e3o:\\n\rdblquote ; \line 14 staticArraylnitQ; \line 15 automaticArraylnitO; \line 16 \line 17 cout \'ab \\n\\nSegunda chamada para cada fun\'e7\'e3o:\\n\rquote ; \line 18 staticArraylnitO; \line 19 automaticArraylnitO; \line 20 cout \'ab endl; \line 21 \line 22 return 0; \line 23 \line 24 \line 25 \f2\fs20 // \f0\fs16 fun\'e7\'e3o para demonstrar um array local static \line 26 void staticArraylnit( void \line 27 \line 28 static int arrayl[ 3 ]; \line 29 int i; \line 30 \line 31 cout \'ab \\nValores ao entrar em staticArraylnit:\\n\rdblquote ; \line 32 \line\f1 iprimiros \f0 33 for \f2\fs20 ( \f0\fs16 i 0; i < 3; i++ \line\f1 verdadei- 34 cout \'ab \ldblquote arrayl[\rdblquote  \'ab i \'ab \f2\fs12\ldblquote ] = \ldblquote  \f1\fs16\'ab arrayl \f2\fs20 [ \f0\fs16 i \f2\fs20 ] \f1\fs16\'ab \line\f0 35 \line static 36 cout \'ab \ldblquote\\nValores ao sair de staticArraylnit:\\n\rdblquote ; \line in\'e7\'e3o. 37 \line 38 for (i=0; i<3; i++) \line 39 cout \'ab \ldblquote arrayl[ \'ab i \'ab \f2\fs12\ldblquote ) \b\f1\fs14 = \line\b0\f0\fs16 40 \'ab \f2\fs20 ( \f0\fs16 arrayl[ i \f2\fs20 ] \b\f1\fs14 += 5 \b0\f2\fs20 ) \f1\fs16\'ab \line\i\fs20 icriadoe \i0\f2\fs8 - \f0\fs16 41 \f2\fs20\} \line\i\f1 i\'e7\'e3o. Isto \b\i0\fs14 42 \line 43 \b0\i\fs20 II \i0\f0\fs16 fun\'e7\'e3o para demonstrar um array local autom\'e1tico \line 44 void automaticArraylnit( void \line acompi- \f1 5 \f2\fs20\{ \line\f0\fs16 erospe1o 46 int i, array2[ 3 \f2\fs20 ] \{ \f0\fs16 1, 2, 3 \}; \line 47 \line a fun\'e7\'e3o 48 cout \'ab \ldblquote\\n\\nValores ao entrar em automaticArraylnit:\\n\rdblquote ; \line\f1 ias vezes. \line\f0 50 for(i=O;i<3;.++) \line\f1 iciona5a 51 cout \'ab array2[\rdblquote  \'ab i \'ab \f2\fs12\ldblquote ] \b\f1\fs14 = \b0\fs16\'ab array2[ i \f2\fs20 ] \f1\fs16\'ab \line\f0 contem 52 \line amb\'e9m\'e9 53 cout \'ab \ldblquote\\nValores ao sair de automaticArraylnit:\\n\rdblquote ; \line ,2e3,A 54 \line afun\'e7\'e3o 55 for \f2\fs20 ( \f0\fs16 i \b\f1\fs14 = i < 3; i++ \b0\f2\fs20 ) \line\f0\fs16 Diasse de \line\b\f2\fs18 Fig. 4.13 \b0\fs20 Comparando a inicializa\'e7\'e3o de arrays \f1\fs16 static \f2\fs20 com a inicializa\'e7\'e3o autom\'e1tica (parte 1 de 2). \f1\fs24\par
\fs16 278 C++ COMO PROGRAMAR \line 56 cout \'ab \ldblquote array2 \f2\fs12 [\ldblquote  \f1\fs16\'ab i \'ab \lquote 1 \f2\fs12 = \line\f1\fs16 57 \'ab ( array2[ i ] \b\f0\fs12 += 5 \b0\f1\fs16 ) \'ab \line 58 \} \line\b\f0 Primeira chamada para cada fun\'e7\'e3o: \line Valores ao entrar em staticArraylnit: \line arrayl[O) = O arrayl[l] = O arrayl[2] = O \line Valores ao sair de staticArraylnit: \line arrayl[O] = 5 arrayl[l] 5 arrayl[2] = 5 \line Valores ao entrar em automaticArraylnit: \line array2[O] = 1 array2[l] = 2 array2[2] = 3 \line Valores ao sair de automaticArraylnit: \line array2[O) = 6 array2[l] = 7 array2[2] = 8 \line Segunda chamada para cada fun\'e7\'e3o: \line Valores ao entrar em staticArraylnit: \line arrayl[O] = 5 arrayl[l] = 5 arrayl[2] = 5 \line Valores ao sair de staticArraylnit: \line arrayl[O] = 10 arrayl[1) = 10 arrayl[2] = 10 \line Valores ao entrar em automaticArraylnit: \line array2[OJ = 1 array2[l] = 2 array2[2) = 3 \line Valores ao sair de automaticArraylnit: \line array2[O] = 6 array2[l] = 7 array2[2] = 8 \line\f2\fs18 Fig. 4.13 \b0\fs20 Comparando a in\'edcializa\'e7\'e3o de arrays \f1\fs16 static \f2\fs20 com a inicializa\'e7\'e3o autom\'e1tica (parte 2 de 2). \line\i\f1\fs18 Erro comum de programa\'e7\'e3o 4.9 \line Supor que os elementos de um array local declarado \i0\fs16 static \i\fs20 s\'e3o inicializados com zeros sempre que a \line fun\'e7\'e3o na qual o array \i0\fs16\'e9 \i\fs18 declarado for chamada, pode levar a erros em um programa. \line\b\i0\f2\fs26 4.5 Passando arrays a fun\'e7\'f5es \line\b0\f1\fs16 Para passar um array como argumento para uma fun\'e7\'e3o. especifique o nome do array sem os colchetes. Por exemplo, se o array temperaturaPorHora for declarado como \line\b\f0 int temperaturaPorHora[ 24 ); \line\b0\f1 o comando de chamada de fun\'e7\'e3o \line\b\f0 modifyArray( temperaturaPorHora, 24 ); \line\b0\f1 passa o array temperaturaPorHora e seu tamanho para a fun\'e7\'e3o modifyArray. Freq\'fcentemente, ao passar um array para uma fun\'e7\'e3o, o tamanho do array tamb\'e9m \'e9 passado, para que ela possa processar o n\'famero total de elementos do aay (caso contr\'e1rio, ter\'edamos de embutir este conhecimento na pr\'f3pria fun\'e7\'e3o ou, pior ainda, colocar o tamanho do array em uma vari\'e1vel global). No Cap\'edtulo 8, quando introduzirmos a classe Array. incorporaremos o tamanho do array no tipo definido pelo usu\'e1rio \f2\fs8 - \f1\fs16 cada objeto Array que criarmos \ldblquote saber\'e1\rdblquote  seu pr\'f3prio tamanho. Assim, quando passarmos um objeto Array para uma fun\'e7\'e3o, n\'e3o precisaremos mais passar seu pr\'f3prio tamanho como argumento. \fs24\par
\b\fs14 CAP\'cdTULO \b0\fs18 4 \f2\fs8 - \b\f1\fs14 ARRAYS \b0\fs18 279 \line A linguagem C++ automaticamente passa os arrays \'e0s fun\'e7\'f5es usando chamadas por refer\'eancia simulada as fun\'e7\'f5es chamadas podem modificar os valores dos elementos nos arrays originais do chamador. O nome do array \'e9 o endere\'e7o do primeiro e\rquote emento do array. Por ser passado o endere\'e7o inicial do array, a fun\'e7\'e3o chamada sabe precisamente onde o array est\'e1 armazenado. Portanto, quando a fun\'e7\'e3o chamada modifica os elementos do array em seu corpo de fun\'e7\'e3o, os elementos reais est\'e3o sendo modificados em suas posi\'e7\'f5es originais da mem\'f3ria. \line\ul\b\f2\fs36 1 \ulnone\i\f1\fs20 Dica de desempenho 4.4 \line\b0\i0\f2\fs30 t \i\f1\fs18 Faz sentido passar arrays atrav\'e9s de chamadas por refer\'eancia simuladas, por motivos de desempenho. Se os arrays fossem passados por chamadas por valor seria passada uma c\'f3pia de cada elemento. Para arrays grandes, passadosfreq\'fcentemente, isso seria demorado e consumiria um espa\'e7o consider\'e1vel para armazenar as c\'f3pias dos arrays. \line Observa\'e7\'e3o de engenharia de software 4.2 \line\i0\f2\fs8 ______ \i\f3\fs26\'c9 \f1\fs18 poss\'edvel passar um array por valor (usando um truque simples explicado no Cap\'edtulo 16) \i0\f2\fs8 - \i\f1\fs18 isso rara- mente \'e9feito. \line\i0 Embora arrays inteiros sejam passados simultaneamente por meio de chamadas por refer\'eancia simuladas, os elementos individuais dos arrays s\'e3o passados por meio de chamadas por valor, exatamente como as vari\'e1veis simples. Tais por\'e7\'f5es simples de dados s\'e3o chamadas de \i escalares \i0 ou \i quantidades escalares. \i0 Para passar um elemento de um array para uma fun\'e7\'e3o, use o nome do elemento do array, com o subscrito, como argumento na chamada da fun\'e7\'e3o. No Cap\'edtulo 5, mostramos como simular chamadas por refer\'eancia para escalares (i.e., vari\'e1veis individuais e elementos espec\'edficos de arrays). \line Para uma fun\'e7\'e3o receber um array por meio de uma chamada de fun\'e7\'e3o, sua lista de par\'e2metros deve \line especificar que um array ser\'e1 recebido. Por exemplo, o cabe\'e7alho da fun\'e7\'e3o modifyArray pode ser escrito como \line\f0 void modifyArray( int \b\f1\fs16 b[], \b0\fs18 int arraySize ); \line\f0 indicando que modifyArray espera receber o \f1 endere\'e7o \f0 de um array de \f1 inteiros no par\'e2metro b e \b\fs16 o \b0\f0\fs18 n\'famero de \f1 elementos do array no par\'e2metro \b\fs16 arraySize. \b0\fs18 N\'e3o \'e9 exigido o tamanho do array entre colchetes. Se ele for inclu\'eddo, o compilador o ignorar\'e1. Como os arrays s\'e3o passados atrav\'e9s de chamadas por refer\'eancia simuladas, quando a fun\'e7\'e3o chamada usa o nome do array b, na realidade ela est\'e1 se referindo ao array real no local que faz a chamada (array temperaturaPorHora na chamada anterior). No Cap\'edtulo 5, apresentamos outras nota\'e7\'f5es para indicar que um array est\'e1 sendo recebido por uma fun\'e7\'e3o. Como veremos, essas nota\'e7\'f5es se baseiam no estreito relacionamento entre arrays e ponteiros. \line Observe o aspecto estranho do prot\'f3tipo de fun\'e7\'e3o para modifyArray \line\f0 void modifyArray( int[], \b\f1\fs16 int \b0\fs18 ); \line\f0 Esse prot\'f3tipo \f1 poderia ter sido escrito como \line\b\fs16 void modifyArray( int anyArrayName[], int anyVariableName \line\b0\fs18 mas, como aprendemos no Cap\'edtulo 3, o compilador C++ ignora os nomes de vari\'e1veis em prot\'f3tipos. \line r \line\b\i\fs20 Boa pr\'e1tica de programa\'e7\'e3o 4.3 \line\b0\i0\fs18 r \i Alguns programadores incluem nomes de vari\'e1veis em prot\'f3tipos de fun\'e7\'f5es para tornar os programas mais claros, O compilador ignora esses nomes. \line\i0 Lembre-se de que o prot\'f3tipo informa ao compilador o n\'famero de argumentos e o tipo de cada argumento (na ordem em que se espera que os argumentos se apresentem). \fs24\par
\f2\fs22 280 C++ \fs14 COMO PROGRAMAR \line\f1\fs20 O programa da Fig. 4.14 demonstra a diferen\'e7a entre passar um array inteiro e passar um elemento de um array. O programa imprime inicialmente os cinco elementos de um array inteiro a. A seguir, a e seu tamanho s\'e3o passados para a fun\'e7\'e3o modifyArray. na qual cada elemento de a \'e9 multiplicado por 2. Ent\'e3o, a \'e9 impresso novamente em main. Como mostra a sa\'edda do programa, os elementos de a s\'e3o verdadeiramente modificados por modifyArray. Depois disso, o programa imprime o valor de a \f2\fs22 [ 3 1 \f1\fs20 e o passa para a fun\'e7\'e3o modifyElement. A fun\'e7\'e3o modifyElement multiplica seu argumento por 2 e imprime o novo valor. Observe que, ao ser impresso novamente em main, a \f2\fs22 [ \f1\fs20 3] n\'e3o \'e9 modificado porque os valores individuais dos elementos do array s\'e3o passados por meio de uma chamada por valor. \line\b\f0\fs16 1 \b0\i\f2\fs22 II \b\i0\f0\fs16 Fig. \f2 4.14: \b0\f1\fs20 fig04_14.cpp \line\b\f0\fs16 2 \b0\i\f2\fs22 II \b\i0\f0\fs16 Passando arrays e elementos individuais de arrays para fun\'e7\'f5es \line 3 #include <iostream> \line\f2 4 \line\f0 5 using std::cout; \line 6 using std::endl; \line\f2 7 \line\f0 8 #include <iomanip> \line\f2 9 \line\f0 10 using std::setw; \line 11 \line 12 void niodifyArray( int \b0\f2\fs22 [], \b\f0\fs16 int ); \b0\i\f2\fs22 II \b\i0\f0\fs16 parece estranho \line 13 void modifyElement( int ); \line 14 \line 15 int main() \line 16 \line 17 const int arraySize 5; \line 18 inti, a[arraySize]=\{0, 1,2,3,4); \line 19 \line 20 cout \'ab \lquote Efeitos de passar o array inteiro usando \b0\f1 chamada \b\f0 por rexerencia: \line 21 \'ab \ldblquote\\n\\nOs valores do array original s\'e3o:\\n\rquote ; \line 22 \line 23 for \b0\f1\fs20 ( \b\f0\fs16 i \b0\f2\fs10 = \b\f0\fs16 0; i < arraySize; i++ \line 24 cout \'ab setw( 3 \b0\f1\fs20 ) \'ab \b\f0\fs16 a[ i ]; \line 25 \line 26 cout \'ab endl; \line 27 \line 28 \b0\i\f2\fs20 II \b\i0\f0\fs16 array a passado usando chamada por refer\'eancia \line 29 modifyArray( a, arraySize ); \line 30 \line 31 cout \'ab \ldblquote Os valores do array modificado s\'e3o:\\n\rdblquote ; \line 32 \line 33 for \b0\f1\fs20 ( \b\f0\fs16 i \b0\f2\fs10 = \b\f0\fs16 0; i < arraySize; i++ \line 34 cout \'ab setw( 3 \b0\f1\fs20 ) \b\f0\fs16\'ab a[ i \b0\f1\fs20 1; \line\b\f0\fs16 35 \line 36 cout \'ab \ldblquote\\n\\n\\n\rdblquote  \line 37 \'ab \ldblquote Efeitos de passar elemento do array usando chamada \b0\f1 por \b\f0 valor:\rdblquote  \line 38 \'ab \ldblquote\\n\\nO valor de a[3] \'e9 \b0\f2\fs8\ldblquote  \b\f0\fs16\'ab a[ 3 \b0\f1\fs20 ] \b\f0\fs16\'ab \lquote\\n\rquote ; \line 39 \line 40 modifyElement( a[ 3 \b0\f1\fs20 J ); \line\b\f0\fs16 41 \line 42 cout \'ab \ldblquote O valor de a[3] \'e9 \b0\f2\fs8\ldblquote  \b\f0\fs16\'ab a[ 3 \b0\f1\fs20 ] \b\f0\fs16\'ab endl; \line 43 \line 44 return 0; \line 45 \b0\f1\fs20\} \line\b\f0\fs16 46 \line 47 \b0\f1\fs20 // \b\f0\fs16 Na fun\'e7\'e3o modifyArray, \ldblquote b\rdblquote  aponta para \line\b0\f2\fs20 Fig. 4.14 Passando arrays e elementos individuais de arrays para fun\'e7\'f5es (parte 1 de 2). \f1\fs24\par
\fs14 CAP\'edTULO \fs20 4 \f2\fs8 - \f1\fs14 ARRAYS \b\f2\fs20 281 \b0\f1\fs24\par
\b\f0\fs16 48 \b0\i\f2\fs22 II \b\i0\f0\fs16 o array \ldblquote a\rdblquote  original na mem\'f3ria. \line 49 void modifyArray( int b[), int sizeOfArray \line 50 \line 51 for \f2\fs20 ( \f0\fs16 int \b0\f1\fs20 j \f2\fs10 = \b\f0\fs16 0; \b0\f1\fs20 j \fs14 < \b\f0\fs16 sizeOfArray; \b0\f1\fs20 j++ \line\b\f0\fs16 52 b[j] *=2; \line 53 \f2\fs20\} \line\b0\i II \b\i0\f0\fs16 Na fun\'e7\'e3o modifyElement, \ldblquote e\rdblquote  \'e9 \b0\f1 uma \b\f0 c\'f3pia local \line\b0\i\f2\fs22 II \b\i0\f0\fs16 do elemento de array a[ 3 \f2\fs20 ] \f0\fs16 recebido de main. \line void modifyElement( int e \line cout \'ab \ldblquote Valor em modifyElement \'e9 \line\'ab \f2\fs20 ( \f0\fs16 e \b0\f2\fs10 *= \b\f0\fs16 2 \f2\fs20 ) \b0\f1\fs14\'ab \b\f0\fs16 endl; \b0\f1\fs24\par
\b\f2\fs18 Fig. 4.14 \b0 Passando arrays e elementos individuais de arrays para fun\'e7\'f5es (parte 2 de 2). \f1\fs24\par
\fs20 Podem existir situa\'e7\'f5es em seu programa nas quais n\'e3o se deve permitir que uma fun\'e7\'e3o modifique os elementos de um array. Como os arrays s\'e3o sempre passados por chamadas por refer\'eancia simuladas, as modifica\'e7\'f5es nos valores de um array s\'e3o dif\'edceis de controlar. A linguagem C++ fornece o qualificador de tipo const para evitar a modifica\'e7\'e3o dos valores de um array em uma fun\'e7\'e3o. Quando uma fun\'e7\'e3o especifica um par\'e2metro array que \'e9 precedido pelo qualificador const, os elementos do array se tornam constantes no corpo da fun\'e7\'e3o e qualquer tentativa de modificar ali um elemento do array resulta em um erro durante a compila\'e7\'e3o. Isso permite que o programador corrija um programa para que n\'e3o se tente modificar o valor dos elementos do array. \line A Fig. 4.15 demonstra o qualificador const. A fun\'e7\'e3o tryToModifyArray \'e9 definida com o par\'e2metro cons t int b \b\f2 [ ] \b0\f1 que especifica que o array b \'e9 constante e n\'e3o pode ser modificado. Cada uma das tr\'eas tentativas da fun\'e7\'e3o de modificar os elementos do array resulta no erro de compila\'e7\'e3o \lquote Cannot modify a const obj ect.\rdblquote  (N\'e3o \'e9 poss\'edvel modificar um objeto const.). O qualificador const ser\'e1 analisado novamente no Cap\'edtulo 7. \fs24\par
\b\f0\fs16 54 \line 55 \line 56 \line 57 \line 58 \line 59 \line 60 \line 61 \b0\f1\fs24\par
\b\f2\fs26 1 \b0\f1\fs24\par
\b\f0\fs16 L. \b0\f1\fs24\par
\f2\fs20 Fig. 4.15 Demonstrando o qualificador de tipo const (parte 1 de 2). \f1\fs24\par
\pard\par
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx301\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx6577\pard\intbl\b\f0\fs16 1  2  3 \b0\f1\fs24\cell\i\f2\fs22 II \b\i0\f0\fs16 Fig. 4.15: figO4l5.cpp  \b0\i\f2\fs22 II \b\i0\f0\fs16 Demonstrando o qualificador de tipo const #include <iostream> \b0\f1\fs24\cell\fs20\row
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx301\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx5121\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx6233\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx6577\pard\intbl\b\f0\fs16 4 \b0\f1\fs24\cell\cell\cell\cell\fs20\row
\b\f0\fs16\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx301\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx5121\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx6233\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx6577\intbl 5  6  7 \b0\f1\fs24\cell\b\f0\fs16 using std: :cout; using std: :endl; \b0\f1\fs24\cell\cell\cell\fs20\row
\b\f0\fs16\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx301\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx5121\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx6233\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx6577\intbl 8  9 \b0\f1\fs24\cell\b\f0\fs16 void tryToModifyArray( const \b0\f1\fs24\cell\b\f0\fs16 int \f2\fs18 [) ) \b0\f1\fs24\cell\fs14 ; \fs24\cell\fs20\row
\b\f0\fs16\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx301\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx5121\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx6233\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx6577\intbl 10 \b0\f1\fs24\cell\b\f0\fs16 int main \b0\f1\fs20 O \fs24\cell\cell\cell\fs20\row
\b\f0\fs16\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx301\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx5121\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx6233\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx6577\intbl 11 \b0\f1\fs24\cell\b\f2\fs20\{ \b0\f1\fs24\cell\cell\cell\fs20\row
\pard\sa240\fs24\par
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1069\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx6449\pard\intbl\b\f0\fs16 Efeitos de \b0\f1\fs24\cell\b\f0\fs16 passar o array inteiro usando \b0 chamada \b por refer\'eancia: \b0\f1\fs24\cell\fs20\row
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1069\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4262\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx5151\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx5656\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx6449\pard\intbl\b\f0\fs16 Os valores  012  Os valores  024 \b0\f1\fs24\cell\b\f0\fs16 do array original s\'e3o:  34  do array modificado s\'e3o:  68 \b0\f1\fs24\cell\cell\cell\cell\fs20\row
\b\f0\fs16\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1069\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4262\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx5151\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx5656\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx6449\intbl Efeitos de \b0\f1\fs24\cell\b\f0\fs16 passar elemento do array usando \b0\f1\fs24\cell\b\f0\fs16 chamada \b0\f1\fs24\cell\f0\fs16 por \f1\fs24\cell\b\f0\fs16 valor: \b0\f1\fs24\cell\fs20\row
\b\f0\fs16\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1069\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4262\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx5151\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx5656\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx6449\intbl O valor de  Valor em  O valor de \b0\f1\fs24\cell\b\f0\fs16 a[3] \'e9 6  modifyElement \'e9 12  a[3] \'e9 6 \b0\f1\fs24\cell\cell\cell\cell\fs20\row
\pard\fs24\par
\pard\sb100\sa240\f2\fs20 282 C++ \fs14 COMO PROGRAMAR \line\f0\fs16 12 int a[] \f2\fs12 = \fs20\{ \f1\fs16 10, 20, 30 \}; \line\f0 13 \line 14 tryToModifyArray( a ); \line 15 cout\'aba[ 0] \'ab \'aba[ 1] \'ab \f2\fs8\lquote  \f0\fs16\'aba[ 2] \'ab \lquote\\n\rquote ; \line 16 return 0; \line 17 \line 18 \line 19 \i\f1\fs18 II \i0\f0\fs16 Na fun\'e7\'e3o tryToModifyArray, \ldblquote b\rdblquote  n\'e3o pode ser \line 20 \f2\fs20 // \f0\fs16 usado para modificar o array \ldblquote a\rdblquote  original em main. \line 21 void tryToModifyArray(const int b[]) \line 22 \line 23 b[ O \f2\fs20 ] / \fs12 = \f0\fs16 2; \f2\fs20 // \f0\fs16 erro \line 24 b[ 1 \f2\fs20 ] / \fs12 = \f0\fs16 2; \f2\fs20 // \f0\fs16 erro \line 25 b[ 2 \f2\fs20 ] / \fs12 = \f0\fs16 2; \i\f1\fs18 II \i0\f0\fs16 erro \line 26 \line\i\f1\fs18 Mensagens de erro do compilador Borland C+ \i0\f2\fs12 + \i\f1\fs18 com linha de comando \i0\fs24\par
\i\fs16 Observa\'e7\'e3o de engenharia de software 4.3 \line\i0\f2\fs8 ______ \i\f1\fs16 O qualificador de tipo \i0\f0 cons \i\f1 t pode ser aplicado a um par\'e2metro de um array em uma defini\'e7\'e3o de fun\'e7\'e3o para evitar que o array original seja modificado no corpo da fun\'e7\'e3o. Esse \'e9 outro exemplo do princ\'edpio do m\'ednimo privil\'e9gio. As fun\'e7\'f5es n\'e3o devem ter a capacidade de modificar um array, a menos que isso seja absolutamente necess\'e1rio. \i0\fs24\par
\pard\par
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx8946\pard\intbl\f0\fs12 FigO4_15 \f2\fs8 . \f0\fs12 cpp: \f1\fs24\cell\fs20\row
\f0\fs16\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx8946\intbl Error E2024 FigO4_15.cpp 23: Cannot modify a const object in \f1\fs24\cell\fs20\row
\f0\fs14\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx8946\intbl function tryToModifyArray(const int \f2\fs12 * \f0\fs14 const) \f1\fs24\cell\fs20\row
\f0\fs16\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx8946\intbl Error E2024 FigO4_15.cpp 24: Cannot modify a const object in \f1\fs24\cell\fs20\row
\f0\fs14\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx8946\intbl function tryToModifyArray(const int \f2\fs12 * \f0\fs14 const) \f1\fs24\cell\fs20\row
\f0\fs16\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx8946\intbl Error E2024 FigO4 15.cpp 25: Cannot modify a const object in \f1\fs24\cell\fs20\row
\f0\fs14\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx8946\intbl function tryToModifyArray(const int \f2\fs12 * \f0\fs14 const) \f1\fs24\cell\fs20\row
\f0\fs16\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx8946\intbl Warning W8057 FigO4_15.cpp 26: Paraxneter \lquote b\rquote  is never used in \f1\fs24\cell\fs20\row
\f0\fs14\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx8946\intbl function tryToModifyArray(const int \f2\fs12 * \f0\fs14 const) \f1\fs24\cell\fs20\row
\fs16\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx8946\intbl 3 \f0\fs14 errors in Compile \f2\fs12 *** \f1\fs24\cell\fs20\row
\i\fs16\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx8946\intbl Mensagens de erro do compilador Microsofi Visual C+ \i0\f2\fs14 + \f1\fs24\cell\fs20\row
\fs16\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx8946\intbl Compiling... \fs24\cell\fs20\row
\f0\fs16\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx8946\intbl FigO 415. cpp \f1\fs24\cell\fs20\row
\f0\fs16\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx8946\intbl D:\\FigO4_15.cpp(23) : error C2166: \f1\fs24\cell\fs20\row
\f0\fs16\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx8946\intbl 1-value specifies const object \f1\fs24\cell\fs20\row
\f0\fs16\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx8946\intbl D:\\FigOd_15.cpp(24) : error C2166: \f1\fs24\cell\fs20\row
\f0\fs16\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx8946\intbl l-value specifies const object \f1\fs24\cell\fs20\row
\f0\fs16\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx8946\intbl D:\\FigO4_15.cpp(25) : error C2166: \f1\fs24\cell\fs20\row
\f0\fs16\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx8946\intbl 1-value specifies const object \f1\fs24\cell\fs20\row
\f0\fs16\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx8946\intbl Error executing cl.exe. \f1\fs24\cell\fs20\row
\f0\fs14\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx8946\intbl test.exe \f2\fs8 - \f0\fs14 3 error(s), O warning(s) \f1\fs24\cell\fs20\row
\f2\fs18\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx8946\intbl Fig. 4.15 Demonstrando o qualificador de tipo const (parte 2 de 2).  \i\f1 Erro comum de programa\'e7\'e3o 4.10 \i0\fs24\cell\fs20\row
\i\fs18\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx8946\intbl Esquecer que arrays s\'e3o passados por refer\'eancia e, portanto, podem ser modificados, pode resultar em um erro de l\'f3gica. \i0\fs24\cell\fs20\row
\pard\fs24\par
\pard\sb100\sa240\fs18 CAP\'cdTULO \i\f2\fs20 4 \i0\fs8 - \f1\fs18 ARRAYS \b\f2\fs26 283 \line 4.6 Ordenando arrays \line\b0\i\fs20 Ordenar \i0\f1\fs18 dados (i.e., colocar os dados segundo uma determinada ordem, como ascendente ou descendente) \'e9 uma das aplica\'e7\'f5es computacionais mais importantes. Um banco classifica todos os cheques pelos n\'fameros das contas para que possa preparar os extratos de cada conta no final do m\'eas. As companhias telef\'f4nicas classificam suas listas pelo \'e1 1 timo nome e, dentro disso, pelo primeiro nome, para que fique f\'e1cil encontrar n\'fameros de telefone. Pratica- mente todas as organiza\'e7\'f5es devem classificar algum dado e, em muitos casos, quantidades muito grandes de dados. Classificar dados \'e9 um problema fascinante, que tem atra\'eddo alguns dos esfor\'e7os mais intensos de pesquisa no campo da Ci\'eancia da Computa\'e7\'e3o. Neste cap\'edtulo, analisamos o que talvez seja o esquema mais simples de classifica\'e7\'e3o. Nos exerc\'edcios e no Cap\'edtulo 15, investigamos esquemas mais complexos, que levam a um desempenho muito superior. \line\ul\f2\fs34 1 \ulnone\i\f1\fs18 Dica de desempenho 4.5 \line\i0\f2\fs34 f \i\f1\fs18 Freq\'fcentemente, os algoritmos mais simples apresentam um desempenho muito ruim. Sua virtude reside no fato de que s\'e3o f\'e1ceis de escrever testar e depurar Algumas vezes, por\'e9m, s\'e3o necess\'e1rios algoritmos \line mais complexos para se atingir o melhor desempenho poss\'edvel. \line\i0 O programa na Fig. 4.16 classifica os valores dos elementos de um array a de dez elementos em ordem ascendente. A t\'e9cnica utilizada \'e9 chamada de \i bubble sort, \i0 ou \i sinking sort, \i0 porque os valores menores \ldblquote sobem\rdblquote  gradualmente para o topo do array, da mesma forma que bolhas de ar sobem na \'e1gua, enquanto os valores maiores afundam (submergem) para a parte de baixo do array. A t\'e9cnica faz diversas passagens pelo array. Em cada passagem, s\'e3o comparados pares sucessivos de elementos. Se um par estiver na ordem crescente (ou se os valores forem iguais), os valores s\'e3o deixados como est\'e3o. Se um par estiver na ordem decrescente, seus valores s\'e3o permutados no array. \line\b\f0\fs16 1 \b0\i\f2\fs20 II \b\i0\f0\fs16 Fig.4.16: \b0\f1\fs18 figo4_16.cpp \line\b\f0\fs16 2 \b0\i\f2\fs20 II \b\i0\f0\fs16 Este programa classifica os valores de \line 3 \b0\i\f2\fs20 II \b\i0\f0\fs16 um array em ordem ascendente \line 4 #include <iostream> \line\f2\fs18 5 \line\f0\fs16 6 using std::cout; \line 7 using std::endl; \line 8 \line 9 #include <iomanip> \line 10 \line 11 using std::setw; \line 12 \line 13 int main \b0\i\f2\fs20 () \line\b\i0\f0\fs16 14 \line 15 const int arraySize \b0\f2\fs12 = \b\f0\fs16 10; \line 16 int a[ arraySize \b0\i\f2\fs20 ] \i0\fs12 = \i\fs20\{ \b\i0\f0\fs16 2, 6, 4, 8, 10, 12, 89, 68, 45, 37 \}; \line 17 int i, hold; \line 18 \line 19 cout \'ab \ldblquote Itens de dados na ordem original\\n\rdblquote ; \line 20 \line 21 for \b0\i\f2\fs20 ( \b\i0\f0\fs16 i \b0\f2\fs12 = \b\f0\fs16 0; i < arraySize; i++ \line 22 cout \'ab setw( 4 \b0\i\f2\fs20 ) \i0\f1\fs18\'ab \b\f0\fs16 a[ i \b0\i\f2\fs20 3; \line\b\i0\f0\fs16 23 \line 24 for \b0\i\f2\fs20 ( \b\i0\f0\fs16 int pass \b0\f2\fs12 = \b\f0\fs16 0; pass < arraySize \b0\f2\fs8 - \b\f0\fs16 1; pass++ \b0\i\f2\fs20 ) II \b\i0\f0\fs16 passagens \line 25 \line 26 for \b0\i\f2\fs20 ( \b\i0\f0\fs16 i \b0\f2\fs12 = \b\f0\fs16 0; i < arraySize \b0\f2\fs8 - \f1\fs18 1; i++ \i\f2\fs20 ) II \i0\f1\fs18 uma \b\f0\fs16 passagem \line 27 \line 28 if \b0\f1\fs18 ( \b\f0\fs16 a[ i \b0\f1\fs18 3 > a[ i + 1 3 ) \{ \b\i\f2\fs22 II \b0\i0\f1\fs18 uma \b\f0\fs16 compara\'e7\'e3o \line 29 hold \b0\f2\fs12 = \b\f0\fs16 a[ i \b0\f1\fs18 3; // uma \b\f0\fs16 permuta \line 30 a[ i \b0\f1\fs18 1 \f2\fs12 = \b\f0\fs16 a[ i + 1 \b0\f1\fs18 3; \line\b\f2 Fig. \b0\fs20 4.16 Ordenando um array com o \i bubble sort \i0 (parte 1 de 2). \f1\fs24\par
\f2\fs20 284 C++ \b\f1\fs14 COMO PROGRAMAR \line\f0\fs16 31 a[ i + 1 \b0\f2\fs20 ] \b\f0\fs16 hoJ.d; \line\f1\fs14 32 \b0\f2\fs20\} \line\b\f0\fs16 33 \line 34 cout \'ab \ldblquote\\nltens de dados em ordem ascendente\\n\rdblquote ; \line 35 \line 36 for \b0\f2\fs20 ( \b\f0\fs16 i \b0\f2\fs12 = \b\f0\fs16 O; i < arraySize; i++ \line 37 cout \'ab setw( 4 \b0\f2\fs20 ) \i\'ab \b\i0\f0\fs16 a[ i ]; \line 38 \line 39 cout \'ab endi; \line 40 return O; \line 4\rquote  \b0\f2\fs20\} \line\b\f0\fs16 Itens de dados na ordem original \line 2 6 4 8 10 12 89 68 45 37 \line Itens de dados em ordem ascendente \line 2 4 6 8 10 12 37 45 68 89 \line\f2\fs18 Fig. 4.16 \b0\fs20 Ordenando um array com o \i bubble sort(parte \i0 2 de 2) \line\f1\fs18 Inicialmente, o programa compara a [ O ) com a [ \f2 1 \f1 1 \f2\fs8 , \f1\fs18 depois a [ 1 1 com a [ \b\f2 2 \b0\f1 ] \f2\fs8 , \f1\fs18 depois a [ 2 1 com a [ 3 J e assim por diante, at\'e9 completar a passagem, comparando a [ 8 1 com a [ 9 ] \f2\fs8 . \f1\fs18 Observe que, embora existam 10 elementos, s\'e3o realizadas apenas nove compara\'e7\'f5es. Tendo em vista o modo como s\'e3o feitas as compara\'e7\'f5es, um valor grande pode se mover para baixo v\'e1rias posi\'e7\'f5es, mas um valor pequeno s\'f3 pode se mover para cima uma \'fanica posi\'e7\'e3o. Na primeira passagem, garante-se que o maior valor \ldblquote submergir\'e1\rdblquote  para o elemento mais baixo (para o \ldblquote fundo\rdblquote ) do array, a [ 9 ] \f2\fs12 . \f1\fs18 Na segunda passagem, garante-se que o segundo maior valor submergir\'e1 para a [ 8 1 \f2\fs8 . \f1\fs18 Na nona passagem, o nono maior valor submerge para a [ 1 \f2\fs12 ]. \f1\fs18 Isso deixa o menor valor em a [ O 1, sendo necess\'e1rias apenas nove passadas no array para classific\'e1-lo, embora ele tenha dez elementos. \line A classifica\'e7\'e3o \'e9 realizada pelo la\'e7o for aninhado. Se for necess\'e1ria uma permuta, ela \'e9 realizada pelas tr\'eas \line atribui\'e7\'f5es seguintes \line\b\f0\fs16 hold \b0\f2\fs12 = \f1\fs18 a[ \b\f0\fs16 i ]; \line\b0\f1\fs18 a[ \b\f0\fs16 i \b0\f1\fs18 1 \f2\fs12 = \f1\fs18 a[ \b\f0\fs16 i \f1\fs14 + 1 \b0\fs18 1; \line a[ \b\f0\fs16 i + 1 \b0\f1\fs18 1 \f2\fs12 = \b\f0\fs16 hold; \line\b0\f1\fs18 hold armazena temporariamente um dos valores que est\'e1 sendo permutado. A permuta n\'e3o pode \line ser realizada somente com as duas atribui\'e7\'f5es seguintes \line a[ \b\f0\fs16 i \b0\f1\fs18 J \f2\fs12 = \f1\fs18 a[ \b\f0\fs16 i + 1 \b0\f1\fs18 1; \line a[ \b\f0\fs16 i + 1 \b0\f1\fs18 ] \f2\fs12 = \f1\fs18 a[ \b\f0\fs16 i \b0\f1\fs18 1; \line Se, por exemplo, a [ i ] \'e9 7 e a [ i \b\fs14 + \b0\fs18 1 1 \'e9 5, depois da primeira atribui\'e7\'e3o ambos os valores ser\'e3o iguais a 5 e o valor 7 ser\'e1 perdido. Da\'ed necessitarmos da vari\'e1vel extra hold. \line A principal virtude do \i\fs20 bubble sort \i0\fs18 reside no fato de que ele \'e9 f\'e1cil de programar. Entretanto, o \i\fs20 bubble sort \'e9 \i0\fs18 lento. Isso se toma percept\'edvel durante a classifica\'e7\'e3o de arrays grandes. Nos exerc\'edcios, desenvolveremos vers\'f5es mais eficientes do \i\fs20 bubble sort \i0\fs18 e investigaremos algoritmos de classifica\'e7\'e3o muito mais eficientes do que o \i\fs20 bubble sort. \i0\fs18 Cursos mais avan\'e7ados investigam classifica\'e7\'e3o e pesquisa em arrays com maior profundidade. \line\b\f2\fs26 4.7 Estudo de caso: calculando m\'e9dia, mediana e moda usando arrays \line\b0\f1\fs18 Veremos agora um exemplo maior. Os computadores s\'e3o usados normalmente para compilar e analisar os resultados de pesquisas de opini\'e3o e levantamentos. O programa da Fig. 4.17 usa o array response inicializado com 99 \fs24\par
\fs14 CAP\'cdTULO \fs20 4 \f2\fs8 - \f1\fs14 ARRAYS \i\f2\fs22 285 \i0\f1\fs24\par
\fs20 (representado pela vari\'e1vel constante responseSize) respostas a uma pesquisa de opini\'e3o. Cada uma das respostas \'e9 um n\'famero de 1 a 9. O programa calcula a m\'e9dia, a mediana e a moda dos 99 valores. \fs24\par
\fs14 1 \line\f2\fs20 2 \line\f0\fs16 3 \line 4 \line 5 \line 6 \line 7 \line 8 \line 9 \line 10 \line 11 \line 12 \line 13 \line 14 \line 15 \line 16 \line 17 \line 18 \line 19 \line 20 \line 21 \line 22 \line 23 \line 24 \line 25 \line 26 \line 27 \line 28 \line 29 \line 30 \line 31 \line 32 \line 33 \line 34 \line 35 \line 36 \line 37 \line 38 \line 39 \line 40 \line 41 \line\f1\fs14 42 \line\fs20 43 \line\f0\fs16 44 \line 45 \line 46 \line 47 \line 48 \line 49 \line 50 \line 51 \line 52 \line 53 \f1\fs24\par
\f0\fs16 using std::cout; \line using std::endl; \line using std::ios; \line #include <iomanip> \line using std::setw; \line using std: :setiosflags; using std: :setprecision; \f1\fs24\par
\fs20\{ 6, \f0\fs16 7, 8, 9, 8, \line 7, 8, 9, 5, 9, \line 6, 7, 8, 9, 3, \line 7, 8, 9, 8, 9, \line 6, 7, 8, 7, 8, \line 7, 8, 9, 8, 9, \line 5, 6, 7, 2, 5, \line 7, 8, 9, 6, 8, \line 7, 4, 4, 2, 5, \line 4, 5, 6, 1, 6, \f1\fs24\par
\f0\fs16 7, 8, 9, 8, 9, \line 8, 7, 8, 7, 8, \line 9, 8, 7, 8, 7, \line 8, 9, 7, 8, 9, \line 7, 9, 8, 9, 2, \line 8, 9, 7, 5, 3, \line 3, 9, 4, 6, 4, \line 7, 8, 9, 7, 8, \line 3, 8, 7, 5, 6, \line 5, 7, 8, 7 \}; \f1\fs24\par
\i\f2\fs22 II \i0\f0\fs16 Fig. 4.17: fig04_17.cpp \line\f1\fs20 // \f0\fs16 Este programa apresenta o t\'f3pico de an\'e1lise de dados de pesquisas. \line\f1\fs20 // \f0\fs16 Ele calcula a m\'e9dia, a mediana e a moda dos dados \line #include <iostream> \f1\fs24\par
\f0\fs16 j \f1\fs18 com mbora itas as ode se para o maior leixa o tenha \fs24\par
\f0\fs16 void mean( const int [], int ); void median( int [], int ); \line voidmode( int [), int \f1\fs20 [1, \f0\fs16 int ); void bubbleSort( int[], int ); void printArray( const int[J, int ); \line int main \f1\fs20 Q \line\f0\fs16 const int responseSize \f2\fs12 = \f0\fs16 99; \line int frequency[ 10 \f1\fs20 ] \f2\fs12 = \f1\fs20\{ O \f0\fs16\}, \line response[ responseSize \f1\fs20 ] \f2\fs12 = \f1\fs24\par
\fs20 as tr\'eas \fs24\par
\fs20 pode \fs24\par
\fs20 isa5 \fs24\par
\i\f2\fs20 sort\'e9 \line\i0\f1 Ts\'f5es \line\i\f2 ubble \i0\f1\fs24\par
\f0\fs16 mean( response, responseSize ); \line median( response, responseSize ); mode( frequency, response, responseSize ); \line return 0; \line void mean( const int answer[), int arraySize int total \f2\fs12 = \f0\fs16 0; \line cout \'ab \ldblquote ********\\n M\'e9dia\\n********\\n\rdblquote ; \line for (int j \f2\fs12 = \f0\fs16 0; j \f1\fs14 < \f0\fs16 arraySize; j++ total \f2\fs12 += \f0\fs16 answer[ j ]; \f1\fs24\par
\fs20 Lados rn 99 \fs24\par
\b\f2\fs18 Fig. \b0 4.17 Programa de an\'e1lise de uma pesquisa de opini\'e3o (parte 1 de 3). \f1\fs24\par
\f3\fs122 ] \f1\fs24\par
\fs16 286 C++ COMO \f2\fs14 PROGRAMAR \f1\fs24\par
\f0\fs16 54 cout \'ab \ldblquote A m\'e9dia \'e9 o valor m\'e9dio dos itens de\\n\rdblquote  \line 55 \'ab \ldblquote dados. A m\'e9dia \'e9 igual \'e0 soma de todos os\\n\rdblquote  \line 56 \'ab \ldblquote itens de dados dividido pelo n\'famero de\\n\rdblquote  \line 57 \'ab \ldblquote itens de dados (\ldblquote  \'ab arraySize \line 58 \'ab \f1\fs14\ldblquote ) \f0\fs16 O valor m\'e9dio para\\n este caso \'e9: \line 59 \'ab total \'ab \f2\fs8\ldblquote  \f1\fs20 / \f2\fs8\ldblquote  \fs20\'ab \f0\fs16 arraySize \'ab \f2\fs8\ldblquote  = \line\f0\fs16 60 \'ab setiosflags \f1\fs20 ( \f0\fs16 ios: : fixed \f1\fs20 1 \f0\fs16 ios: : showpoint \line 61 \'ab setprecision( 4 \line 62 \'ab static_cast< double >( total \f1\fs20 ) / \f0\fs16 arraySize\'ab \lquote\\n\\n\rdblquote ; \line 63 \line 64 \line 65 void median( int answer[], int size \line 66 \line 67 cout \'ab \ldblquote\\n********\\n Mediana\\n********\\n\rdblquote  \line 68 \'ab \ldblquote 0 array de respostas n\'e3o ordenado \'e9\rdblquote ; \line 69 \line 70 printArray( answer, size ); \line 71 bubbleSort( answer, size ); \line 72 cout \'ab \ldblquote\\n\\nO array ordenado \'e9\rdblquote ; \line 73 printArray( answer, size ); \line 74 cout \'ab \lquote\\n\\nA mediana \'e9 o elemento \f2\fs8\ldblquote  \f0\fs16\'ab size \f1\fs20 / \f0\fs16 2 \line 75 \'ab \f2\fs8\ldblquote  \f0\fs16 do\\narray ordenado de \f2\fs8\ldblquote  \fs20\'ab \f0\fs16 size \line 76 \'ab \f2\fs8\ldblquote  \f0\fs16 elementos.\\npara este caso a mediana \'e9 \line\f1\fs14 77 \f0\fs16\'ab answer[ size \f1\fs20 / \f0\fs16 2 \f1\fs20 1 \f2\'ab \f0\fs16\ldblquote\\n\\n\rdblquote ; \line 78 \line 79 \line 80 void mode( int freq[], int answer[), int size \line 81 \f1\fs20\{ \line\f0\fs16 82 int rating, largest \f2\fs10 = \f0\fs16 0, modeValue \f2\fs10 = \f0\fs16 0; \line 83 \line 84 cout \'ab \b\f1\fs12\ldblquote\\fl********\\fl \b0\f0\fs16 Moda\\n********\\n; \line 85 \line 86 for \f1\fs20 ( \f0\fs16 rating \f2\fs10 = \f0\fs16 1; rating \f1\fs14 <= \f0\fs16 9; rating++ \line 87 freq[ rating \f1\fs20 ] \fs14 = \f0\fs16 0; \line 88 \line 89 for \f1\fs20 ( \f0\fs16 int \f1\fs20 j \fs14 = \f0\fs16 0; \f1\fs20 j \fs14 < \f0\fs16 size; \f1\fs20 j++ \line\f0\fs16 90 ++freq[ answer[ \f1\fs20 j ) ]; \line\f0\fs16 91 \line\f2\fs30 ] \f0\fs16 92 cout \'ab \ldblquote Resposta\rdblquote  \'ab setw( 11 \f1\fs20 ) \f2\'ab \f0\fs16 Freq\'fc\'eancia\rdblquote  \line 93 \'ab setw( 19 \f1\fs20 ) \f0\fs16\'ab \ldblquote Histograma\\n\\n\rdblquote  \'ab setw( 55 \line 94 \'ab \ldblquote 1 1 2 2\\n\rdblquote  \'ab setw( 56 \line 95 \'ab \ldblquote 5 O 5 O 5\\n\\n\rdblquote ; \line 96 \line 97 for \f1\fs20 ( \f0\fs16 rating \f1\fs14 = \f0\fs16 1; rating \f1\fs14 <= 9; \f0\fs16 rating+-I- \f1\fs20 ) \{ \line\f0\fs16 98 cout \'ab setw( 8 \f1\fs20 ) \f0\fs16\'ab rating \'ab setw( 11 \line 99 \'ab freq[ rating \f1\fs20 1 \f2\'ab \fs8\ldblquote  \line\f0\fs16 100 \line 101 if \f1\fs20 ( \f0\fs16 freq[ rating \f1\fs20 ] \fs14 > \f0\fs16 largest \f1\fs20 ) \{ \line\f0\fs16 102 largest \f1\fs14 = \f0\fs16 freq[ rating ); \line 103 modeValue \f1\fs14 = \f0\fs16 rating; \line 104 \f1\fs20\} \line\f0\fs16 105 \line 106 for \f1\fs20 ( \f0\fs16 int h \f1\fs14 = \f0\fs16 1; h \f1\fs14 <= \f0\fs16 freq[ rating \f1\fs20 J; \f0\fs16 h++ \line 107 cout \'ab \f2\fs8 *\lquote . \line\f0\fs16 108 \line 109 cout \'ab \lquote\\n\rquote ; \line 110 \f1\fs20\} \fs24\par
\f2\fs18 Fig. 4.17 Programa de an\'e1lise de uma pesquisa de opini\'e3o (parte 2 de 3). \f1\fs24\par
\fs18 CAP\'cdTuLo 4 \f2\fs8 - \f1\fs18 ARRAYS \f2\fs22 287 \f1\fs24\par
\b\f0\fs16 112 cout \'ab \lquote A moda \'e9 o valor mais freq\'fcente.\\n\rdblquote  \line 113 \'ab \ldblquote Para este caso a moda \'e9 \b0\f2\fs8\ldblquote  \b\f0\fs16\'ab modeValue \line 114 \'ab \b0\f2\fs8\ldblquote  \f1\fs18 que \b\f0\fs16 ocorreu \b0\f2\fs8\ldblquote  \b\f0\fs16\'ab largest \b0\f2\fs8\'ab\ldblquote  \b\f0\fs16 vezes.\rdblquote  \'ab endl; \line 115 \line 116 \line 117 void bubbleSort( int a[], int size \line 118 \b0\f1\fs18\{ \line\b\f0\fs16 119 int hold; \line 120 \line 121 for \b0\f1\fs18 ( \b\f0\fs16 int pass \b0\f2\fs12 = \b\f0\fs16 1; pass < size; pass++ \line 122 \line 123 for \b0\f1\fs18 ( \b\f0\fs16 int \b0\f2\fs22 j \fs12 = \fs22 j \b\f0\fs16 < size \b0\f2\fs8 - \b\f0\fs16 1; \b0\f1\fs18 j++ \line\b\f0\fs16 124 \line if \b0\f1\fs18 ( a[ \f2\fs22 j 3 \b\f0\fs16 > a[ \b0\f2\fs22 j \b\f0\fs16 + 1 \b0\f1\fs18 3 ) \{ \line\b\f0\fs16 hold= a[ \b0\f2\fs22 j \f1\fs18 ]; \line\b\f0\fs16 a[ \b0\f2\fs22 j 3 \fs12 = \b\f0\fs16 a[ \b0\f2\fs22 j \b\f0\fs16 + 1 ]; \line a[ \b0\f2\fs22 j \b\f0\fs16 + 1 \b0\f1\fs18 3 \f2\fs12 = \b\f0\fs16 hold; \line 132 void printArray( const int a[], int size \line 133 \line 134 for \b0\f1\fs18 ( \b\f0\fs16 int \b0\f1\fs18 j \f2\fs12 = \b\f0\fs16 0; \b0\f1\fs18 j \b\f0\fs16 < size; \b0\f1\fs18 j++ \line\b\f0\fs16 135 \line if \b0\f1\fs18 ( j % \b\f0\fs16 20 \b0\f2\fs12 == \b\f0\fs16 O \line cout \'ab endl; \line 138 \line 139 cout \'ab setw( 2 \b0\f1\fs18 ) \b\f0\fs16\'ab a[ \b0\f1\fs18 j 1; \line\b\f0\fs16 140 \b0\f1\fs18\} \line\b\f0\fs16 141 \b0\f1\fs18 ) \line\f2\fs20 Fig. 4.17 Programa de an\'e1lise de uma pesquisa de opini\'e3o (parte 3 de 3). \line\f1\fs18 A m\'e9dia \'e9 a m\'e9dia aritm\'e9tica dos 99 valores. A fun\'e7\'e3o mean calcula a m\'e9dia somando os 99 elementos e dividindo o resultado por 99. \line A mediana \'e9 o \ldblquote valor do meio\rdblquote . A fun\'e7\'e3o median determina a mediana chamando bubbleSort para ordenar o array answer e apanha o elemento situado no meio do array ordenado, answer \f2\fs22 [ \f1\fs18 size \f2\fs22 / \f1\fs18 2]. Observe que, quando houver um n\'famero par de elementos, a mediana deve ser calculada como a m\'e9dia dos dois elementos do meio. A fun\'e7\'e3o median n\'e3o possui atualmente a capacidade de fazer isso. A fun\'e7\'e3o printArray \'e9 chamada para imprimir o array answer. \fs24\par
\f2\fs20 Fig. 4.18 Exemplo de execu\'e7\'e3o do programa de an\'e1lise de dados de uma pesquisa de opini\'e3o (parte 1 de 2). \f1\fs24\par
\b\f0\fs16 111 \b0\f1\fs24\par
\b\f0\fs16 125 \line 126 \line 127 \line 128 \line 129 \line 130 \line 131 \b0\f1\fs24\par
\b\f0\fs16 136 \line 137 \b0\f1\fs24\par
\f3\fs178 [ \f1\fs24\par
\pard\par
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4073\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx5488\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx8537\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx8946\pard\intbl\f2\fs10 ******** \f1\fs24\cell\cell\cell\cell\fs20\row
\b\f0\fs16\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4073\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx5488\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx8537\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx8946\intbl M\'e9dia \b0\f1\fs24\cell\cell\cell\cell\fs20\row
\f2\fs10\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4073\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx5488\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx8537\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx8946\intbl ******** \f1\fs24\cell\cell\cell\cell\fs20\row
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx5488\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx8537\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx8946\pard\intbl\b\f0\fs16 A m\'e9dia \'e9 o valor m\'e9dio \b0\f1\fs24\cell\b\f0\fs16 dos itens de \b0\f1\fs24\cell\cell\fs20\row
\b\f0\fs16\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx5488\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx8537\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx8946\intbl dados. A m\'e9dia \'e9 igual itens de dados dividida itens de dados (99). O este caso \'e9: 681 \b0\f1\fs20 / \b\f0\fs16 99 \b0\f2\fs12 = \f1\fs24\cell\b\f0\fs16\'e0 soma de todos pelo n\'famero de valor m\'e9dio para  6.8788 \b0\f1\fs24\cell\b\f0\fs16 os \b0\f1\fs24\cell\fs20\row
\pard\fs24\par
\pard\sb100\sa240\f2\fs20 288 C++ CoMo \f1\fs18 PROGRAMAR \line Mediana \line\f2\fs10 ******** \line\f0\fs24 o \b\fs16 array de respostas n\'e3o ordenado \'e9 \line 67898789897895987878 \line 67893987877898989789 \line 67878798927898989753 \line 56725394647896878978 \line 7442538756456165787 \line\b0\fs24 o \b\fs16 array ordenado \'e9 \line 12223333444445555555 \line 56666666667777777777 \line 77777777777788888888 \line 88888888888888888888 \line 9999999999999999999 \line A mediana \'e9 o elemento 49 do \line array ordenado de 99 elementos. \line Para este caso a mediana \'e9 7 \line\b0\f2\fs10 ******** \line\b\f0\fs16 Moda \line\b0\f2\fs10 ******** \line\b\f0\fs16 Resposta Freq\'fc\'eancia Histograma \line 1 1 2 2 \line 5 \b0\fs24 o \b\fs16 5 O 5 \line\b0\f1\fs18 1 1 \f2\fs10 * \line\b\f0\fs16 2 3 \line 3 4 \b0\f2\fs10 **** \line\b\f0\fs16 4 5 \b0\f2\fs10 ****** \line\b\f0\fs16 5 8 \b0\f2\fs10 ********* \line\b\f0\fs16 6 9 \b0\f2\fs10 ********** \line\b\f0\fs16 7 23 \b0\f2\fs10 ************************ \line\b\f0\fs16 8 27 \b0\f2\fs10 *************************** \line\b\f0\fs16 9 19 \line A moda \'e9 o valor mais freq\'fcente. \line Para este caso a moda \'e9 8 \b0 que \b ocorreu 27 vezes. \line\b0\f2\fs20 Fig. 4.1 8 Exemplo de execu\'e7\'e3o do programa de an\'e1lise de dados de uma pesquisa de opini\'e3o (parte 2 de 2). \line\f1\fs18 A moda o valor que ocorre mais freq\'fcentemente entre as 99 respostas. A fun\'e7\'e3o mode determina a moda contando \line o n\'famero de respostas de cada tipo e depois selecionando o valor que obteve maior contagem. Essa vers\'e3o da fun\'e7\'e3o \line mode n\'e3o manipula um empate na contagem (veja o Exerc\'edcio 4.14). A fun\'e7\'e3o mode produz ainda um histograma \line para ajudar na determina\'e7\'e3o da moda graficamente. A Fig. 4.18 cont\'e9m um exemplo de execu\'e7\'e3o desse programa. \line Esse exemplo inclui a maioria das manipula\'e7\'f5es comuns exigidas normalmente em problemas de arrays, incluindo \line a passagem de arrays a fun\'e7\'f5es. \line\b\f2\fs26 4.8 Pesquisando arrays: pesquisa linear e pesquisa bin\'e1ria \line\b0\f1\fs18 Freq\'fcentemente, um programador trabalhar\'e1 com grandes quantidades de dados armazenadas em arrays. Pode ser necess\'e1rio determinar se um array cont\'e9m um valor que corresponde a um determinado \i valor-chave. \i0 O processo de encontrar um determinado elemento de um array \'e9 chamado de \i pesquisa. \i0 Nesta se\'e7\'e3o, analisaremos duas t\'e9cnicas de pesquisa \f2\fs8 - \f1\fs18 a t\'e9cnica simples de \i pesquisa linear \i0 e a t\'e9cnica mais eficiente de \i pesquisa bin\'e1ria. \i0 Os Exerc\'edcios 4.33 e 4.34, no final do cap\'edtulo, pedem a implementa\'e7\'e3o de vers\'f5es recursivas da pesquisa linear e da pesquisa bin\'e1ria. \line A pesquisa linear (Fig. 4.19) compara cada elemento do array com a \i chave de pesquisa. \i0 Como o array n\'e3o \line est\'e1 em uma ordem espec\'edfica, as probabilidades de o valor ser encontrado no primeiro elemento ou no \'faltimo s\'e3o \fs24\par
\fs16 CAP\'cdTULO \i\f2\fs20 4 \i0\fs8 - \f1\fs16 ARRAYS \b\f2\fs20 289 \line\b0\f1 as mesmas. Entretanto, na m\'e9dia, o programa precisar\'e1 comparar a chave de pesquisa com metade dos elementos do array. Para determinar que um elemento n\'e3o est\'e1 no array, o programa deve comparar a chave de pesquisa com cada elemento do array. \line\b\f0\fs16 1 \b0\i\fs22 II \b\i0\fs16 Fig. 4.19: figO4l9.cpp \line 2 \b0\i\fs22 /1 \b\i0\fs16 Pesquisa linear em um array \line 3 #include <iostreaxn> \line 4 \line 5 using std::cout; \line 6 using std::cin; \line 7 using std::endl; \line 8 \line 9 int linearSearch \b0\i\f2\fs20 ( \b\i0\f0\fs16 const int \b0\i\f2\fs20 [] \i0\fs8 , \b\f0\fs16 int, int ); \line\b0\f1 lo \line\b\f0 11 int main() \line 12 \line 13 const int arraySize \b0\f2\fs12 = \b\f0\fs16 100; \line 14 int a[ arraySize \b0\i\f2\fs20 ], \b\i0\f0\fs16 searchKey, element; \line 15 \line 16 for \b0\i\f2\fs20 ( \b\i0\f0\fs16 int x \b0\f2\fs12 = \b\f0\fs16 0; x < arraySize; x++ \b0\i\f2\fs20 ) II \b\i0\f0\fs16 cria alguns dados \line 17 a[ x \f2\fs20 ] \b0\fs12 = \b\f0\fs16 2 \b0\f2\fs10 * \b\f0\fs16 x; \line 18 \line 19 cout \'ab \ldblquote Digite a chave de pesquisa, valor inteiro:\rdblquote  \'ab endl; \line 20 cm \'ab searchKey; \line 21 element \b0\f2\fs12 = \b\f0\fs16 linearSearch \f2\fs20 ( \f0\fs16 a, searchKey, arraySize \line 22 \line 23 if \f2\fs20 ( \f0\fs16 element \b0\f2\fs12 ! \b\f0\fs16 -1 \line 24 cout \'ab \ldblquote Valor encontrado no elemento \b0\f2\fs8\ldblquote  \b\f0\fs16\'ab element \'ab endl; \line 25 else \line 26 cout \'ab \ldblquote Valor n\'e3o encontrado\rdblquote  \'ab endl; \line 27 \line 28 return 0; \line 29 \f2\fs20 ) \line\f0\fs16 30 \line 31 int linearSearch( const int array[], mnt key, int smzeOfArray \line 32 \f2\fs20\{ \line\f0\fs16 33 for \f2\fs20 O \f0\fs16 int n \b0\f2\fs12 = \f1\fs16 o; \b\f0 n < sizeOfArray; n++ \line 34 if \f2\fs20 ( \f0\fs16 array[ n \f2\fs20 ] \b0\fs12 == \b\f0\fs16 key \line 35 return n; \line 36 \line 37 return -1; \line 38 \f2\fs20\} \line\f0\fs16 Digite a chave de pesquisa, valor inteiro: \line 36 \line Valor encontrado no elemento 18 \line Digite a chave de pesquisa, valor inteiro: \line 37 \line Valor n\'e3o encontrado \line Fig. \b0\fs20 4.19 Pesquisa linear de um \f2 array. \line\f1 O m\'e9todo de pesquisa linear funciona bem com arrays pe9uciios ou com arrays n\'e3o-ordenados. Entretanto, para arrays grandes, a pesquisa linear \'e9 ineficiente. Se o array estiver ordenado, a t\'e9cnica veloz de pesquisa bin\'e1ria pode ser utilizada. \line O algoritmo de pesquisa bin\'e1ria elimina metade dos elementos do array que est\'e1 sendo pesquisado ap\'f3s cada compara\'e7\'e3o. O algoritmo localiza o elemento do meio do array e o compara com a chave de pesquisa. Se forem \fs24\par
\b\fs16 290 C++ COMO \f2\fs14 PROGRAMAR \b0\f1\fs24\par
\fs18 iguais, a chave de pesquisa foi encontrada e o subscrito daquele elemento do array \'e9 retornado. Se n\'e3o forem iguais, o problema fica reduzido a pesquisar uma metade do array. Se a chave de busca for menor que o elemento do meio do array, a primeira metade do array ser\'e1 pesquisada; caso contr\'e1rio, a segunda metade do array ser\'e1 pesquisada. Se a chave de busca n\'e3o for encontrada no subarray (parte do array original), o algoritmo \'e9 repetido na quarta parte do array original. A pesquisa continua at\'e9 que a chave de busca seja igual ao elemento situado no meio de um subarray, ou at\'e9 que o subarray consista em um elemento que n\'e3o seja igual \'e0 chave de busca (i.e., a chave de busca n\'e3o \'e9 encontrada). \line No pior caso, pesquisar um array de 1024 elementos precisar\'e1 de apenas 10 compara\'e7\'f5es utilizando pesquisa bin\'e1ria. Dividir repetidamente 1 024 por 2 leva aos valores 5 1 2, \i\f2\fs20 256, \i0\f1\fs18 128, 64, 32, 16, 8, 4, 2 e 1 \f2\fs8 . \b\f1\fs20 O \b0\fs18 n\'famero 1 024 \b\fs16 (2b0) \b0\fs18\'e9 dividido por 2 apenas 10 vezes para que seja obtido o valor 1. Dividir por 2 \'e9 equivalente a uma compara\'e7\'e3o no algoritmo de pesquisa bin\'e1ria. Um array com 1048576 \b\fs16 (220) \b0\fs18 elementos precisa de um m\'e1ximo de 20 compara\'e7\'f5es para que a chave de pesquisa seja encontrada. Um array com um bilh\'e3o de elementos precisa de um m\'e1ximo de 30 compara\'e7\'f5es para que a chave de pesquisa seja encontrada. Isso significa uma grande melhoria no desempenho, comparado com a pesquisa linear, que exigia, em m\'e9dia, a compara\'e7\'e3o da chave de pesquisa com metade dos elementos do array. Para um array de um bilh\'e3o de elementos, isso significa uma diferen\'e7a entre 500 milh\'f5es de compara\'e7\'f5es e um m\'e1ximo de 30 compara\'e7\'f5es! A quantidade m\'e1xima de compara\'e7\'f5es para qualquer array pode ser determinada encontrando-se a primeira pot\'eancia de 2 maior do que o n\'famero de elementos do array. \line\ul\i 1-Dica \ulnone de desempenho 4.6 \line\i0\f3\fs30 -F \i\f1\fs18 Os tremendos ganhos em desempenho da pesquisa bin\'e1ria em rela\'e7\'e3o \'e0 linear n\'e3o s\'e3o obtidos sem um pre\'e7o. Classificar um array \'e9 uma opera\'e7\'e3o cara, comparada com pesquisar todo um array em busca de \line um \'fanico item, uma vez s\'f3. O overhead de classificar um array passa a valer a pena quando o array necessitar\'e1 ser pesquisado muitas vezes em alta velocidade. \line\i0 A Fig. 4.20 apresenta uma vers\'e3o interativa da fun\'e7\'e3o binarySearch \f2\fs8 . \f1\fs18 A fun\'e7\'e3o recebe quatro argumentos \f2\fs8 - \f1\fs18 um \line array inteiro b, um inteiro searchKey. o subscrito do array low e o subscrito do array high. Se a chave de \line pesquisa n\'e3o for igual ao elemento situado no meio de um subarray, o subscrito low ou high \'e9 modificado, de \line forma que um subarray menor possa ser examinado. Se a chave de pesquisa for menor que o elemento situado no \line meio, o subscrito high \'e9 definido como middle \f2\fs8 - \f1\fs18 1, e a pesquisa continua nos elementos de \b low a middle \b0\f2\fs8 - \b\f1\fs16 1 \b0\f2\fs8 . \f1\fs18 Se a chave de pesquisa for maior do que o elemento situado no meio, o subscrito low \'e9 definido como middle \line\b\fs16 + 1, \b0\fs18 e a pesquisa continua nos elementos de middle \b\fs16 + 1 \b0\fs18 a high \f2\fs8 . \b\f1\fs20 O \b0\fs18 programa usa um array de 15 elementos. \line A primeira pot\'eancia de 2 maior do que o n\'famero de elementos no array \'e9 16 (2); portanto, exige-se um m\'e1ximo de \i\f2\fs20 4 \i0\f1\fs18 compara\'e7\'f5es para encontrar a chave de pesquisa. A fun\'e7\'e3o printHeader exibe os subscritos do array e a fun\'e7\'e3o \line\b printRow exibe cada \b0 subarray durante o processo de pesquisa bin\'e1ria. O elemento do meio de cada subarray \'e9 marcado com um asterisco \b\fs20 (*), \b0\fs18 para indicar o elemento com o qual a chave de pesquisa \'e9 comparada. \line\b\f0\fs16 1 \b0\i\f1\fs18 II \b\i0\f0\fs16 Fig. 4.20: figO42O.cpp \line 2 \b0\i\f1\fs18 II \b\i0\f0\fs16 Pesquisa bin\'e1ria em um array \line 3 #include <iostream> \line 4 \line 5 using std::cout; \line 6 using std::cin; \line 7 using std: :endl; \line 8 \line 9 #include <iomanip> \line 10 \line 11 using std::setw; \line 12 \line 13 int binarySearch \f1\fs20 ( \f0\fs16 const int \f1\fs20 [] \f0\fs16 int, int, int, int ); \line 14 void printHeader \f1\fs20 ( \f0\fs16 int ); \line 15 void printRow \f1\fs20 ( \f0\fs16 const int \f1\fs20 [], \f0\fs16 int, int, int, int); \line 16 \b0\f1\fs24\par
\f3\fs212 1 \f1\fs24\par
\b\f2\fs18 Fig. 4.20 \b0 Pesquisa bin\'e1ria em um array ordenado (parte 1 de 3). \f1\fs24\par
\fs14 CAP\'cdTULO \f2\fs20 4 \fs8 - \f1\fs14 ARRAYS \b\f2\fs20 291 \line\b0\f0\fs16 uais, \f1\fs14 17 \f0\fs16 int main \f2\fs20 () \line\f0\fs16 meio \f1\fs14 18 \line\f0\fs16 la.Se 19 const int arraySize \f2\fs10 = \f0\fs16 15; \line rtedo 20 int a[ arraySize \f2\fs20 ), \f0\fs16 key, result; \line array, \f2\fs30 1 \f0\fs16 21 \line n\'e3o\'e9 22 for \f2\fs20 ( \f0\fs16 int i \f2\fs10 = \f0\fs16 O; i \f1\fs14 < \f0\fs16 arraySize; i++ \f2\fs20 ) \line\f0\fs16 23 a[ i \f2\fs20 ] \fs10 = \f0\fs16 2 \f2\fs10 * \f0\fs16 j; \f2\fs20 // \f0\fs16 coloca alguns dados no array \line\f1\fs14 24 \line\f0\fs16 quisa \f2\fs8 . . - \line\f0\fs16 11O\\ 25 cout \'ab Digite um numero entre O e 28: \line\b\f2 1 26 \b0\f0 cm \'bb \b\f2 key; \line\b0\f1\fs14 ElOflo \f0\fs16 27 \line El\'e7\'f5es 28 printHeader( arraySize ); \line E1e30 29 result \f2\fs10 = \f0\fs16 binarySearch( a, key, 0, arraySize \f2\fs8 - \f0\fs16 1, arraySize ); \line nho, 30 \line dos 31 if \f2\fs20 ( \f0\fs16 result \f1\fs14 != -1 \f2\fs20 ) \line\f0\fs16 es de \f1 32 cout \f0\'ab \\n\rquote  \'ab \f1 key \f0\'ab \f2\fs10\lquote  \f1\fs16 encontrado \f0 no \f1 elenento \f0 do array \line leser 33 \f1\'ab result \'ab endl; \line 34 else \line 35 cout \'ab \lquote\\n\rquote  \'ab key \b\f2\fs14\'ab\ldblquote  \b0\f0\fs16 n\'e3o encontrado\rdblquote  \'ab \f1 endl; \line 36 \line\f2\fs8 - \f0\fs16 37 return 0; \line\i\fs20 num \i0\fs16 38 \f2\fs20\} \line\i\f0 fade \i0\fs16 39 \line\i\fs20 rray \i0\fs16 40 \f2\fs20 II \f0\fs16 Pesquisa bin\'e1ria \line 41 int binarySearch \f2\fs20 ( \f0\fs16 const int b[], int searchKey, int 10w, int high, \line\f1 42 int size \line\f0 -um 43 \{ \line iede \f1 44 int middle; \line\f0 o,de 45 \line [ono 46 while ( low \f1\fs14 <= high \f2\fs20 ) \{ \line\b\fs14 e \b0\fs8 - \f0\fs16 47 middle \f1\fs14 = \f2\fs20 ( \f0\fs16 low + high \f2\fs20 ) / \f1\fs16 2; \line\f0 dle 48 \line ntos. 49 printRow( b, low, middle, high, size ); \line iode 50 \line n\'e7\'e3o 51 if (searchKey \f1\fs14 == b[ \f0\fs16 middle \f2\fs20 ] ) \i\f0 1/ \i0\fs16 encontrou elemento igual \line ay\'e9 52 return middle; \line 53 else if (searchKey < b[ middle \line 54 high \f1\fs14 = \f0\fs16 middle \f2\fs8 - \f0\fs16 1; \i\fs20 /1 \i0\fs16 pesquisa metade do array c/valores menores \line 55 else \line 56 low \f1\fs14 = \f0\fs16 middle + 1; \i\fs20 1/ \i0\fs16 pesquisa metade do array c/valores maiores \line 57 \line 58 \line 59 return -1; \f2\fs20 1/ \f0\fs16 chave de pesquisa n\'e3o encontrada \line 60 \f2\fs20\} \line\f0\fs16 61 \line\f1 62 \f2\fs20 1/ \f0\fs16 Imprime um cabe\'e7alho para a saida \line 63 void prmntHeader( int size \line 64 \f2\fs20\{ \line\f0\fs16 65 int i; \line 66 \line 67 cout \'ab \ldblquote\\nSubscritos:\\n\rquote ; \line 68 \line 69 for \f2\fs20 ( \f0\fs16 i \f1\fs14 = 0; i < \f0\fs16 size; i++ \line 70 cout \'ab setw( 3 \f2\fs20 ) \f0\fs16\'ab \f1\fs14 i \f0\fs16\'ab \f2\fs10\lquote  \line\fs20 Fig. 4.20 Pesquisa bin\'e1ria em um array ordenado (parte 2 de 3). \f1\fs24\par
\f2\fs20 292 C++ \fs14 COMO PROGRAMAR \line\f0\fs16 71 \line 72 cout \'ab \lquote\\n; \line 73 \line 74 for \f2\fs20 ( \f0\fs16 i \b\f1\fs12 = \b0\f0\fs16 1; i \b\f1\fs12 < 4 \b0\f2\fs10 * \f0\fs16 size; i++ \line 75 cout\'ab \line 76 \line 77 cout \'ab endi; \line 78 \line 79 \line 80 \i\f2\fs22 II \i0\f0\fs16 Imprime \f1 uma \f0 linha da sa\'edda mostrando a parte \line 81 \i\f2\fs22 II \i0\f0\fs16 do array \f1 que \f0 est\'e1 sendo processada. \line 82 void printRow( const int b[], int low, int mid, int high, int size \line 83 \line 84 for \f2\fs20 ( \f0\fs16 int i \b\f1\fs12 = \b0\f0\fs16 0; i < size; i++ \line 85 if \f2\fs20 ( \f0\fs16 i < low \f2\fs20 1 1 \f0\fs16 i > high \line 86 cout \'ab \line 87 else if \f2\fs20 ( \f0\fs16 i \b\f1\fs12 == \b0\f0\fs16 mid \f2\fs20 ) // \f0\fs16 marca valor do meio \line 88 cout \'ab setw( 3 \f2\fs20 ) \f0\fs16\'ab b[ i \f2\fs20 ] \f0\fs16\'ab \f2\fs10\lquote\lquote ; \line\f0\fs16 89 else \line 90 cout \'ab setw( 3 \f2\fs20 ) \f0\fs16\'ab b[ i \f2\fs20 ] \f0\fs16\'ab \f2\fs10\lquote ; \line\f0\fs16 91 \line 92 cout \'ab endl; \line\f3\fs42 1 \line\f0\fs16 Digite um n\'famero entre O e 28: 25 \line Subscritos: \line\f1\fs24 o \f0\fs16 i 2 3 4 5 6 7 8 9 10 11 12 13 14 \line\f1\fs24 o \f0\fs16 2 4 6 8 10 12 14* 16 18 20 22 24 26 28 \line 16 18 20 22* 24 26 28 \line 24 26* 28 \line 24* \line 25 n\'e3o encontrado \line Digite um n\'famero entre O e 28: 8 \line Subscritos: \line\f1\fs24 o \f0\fs16 i 2 3 4 5 6 7 8 9 10 11 12 13 14 \line\f1\fs24 o \f0\fs16 2 4 6 8 10 12 14* 16 18 20 22 24 26 28 \line\f1\fs24 o \f0\fs16 2 4 6* 8 10 12 \line 8 10* 12 \line 8* \line 8 encontrado no elemento 4 do array \line Digite um n\'famero entre O e 28: 6 \line Subscritos: \line\f1\fs24 o \f0\fs16 i 2 3 4 5 6 7 8 9 10 11 12 13 14 \line\f1\fs24 o \f0\fs16 2 4 6 8 10 12 14* 16 18 20 22 24 26 28 \line\f1\fs24 o \f0\fs16 2 4 6* 8 10 12 \line 6 encontrado no elemento 3 do array \line\f2\fs20 Fig. 4.20 Pesquisa bin\'e1ria em um array ordenado (parte 3 de 3). \f1\fs24\par
\b\f2\fs18 Linha O \line Linha 1 \line Linha 2 \b0\f1\fs24\par
\b\f2\fs18 Subscrito da coluna \line Subscrito da linha \line Nome do array \line\b0\fs20 Fig. 4.21 Um array bidimensional com tr\'eas linhas e quatro colunas. \line\b\i\f1 Erro comum deprograma\'e7\'e3o 4.11 \line\b0 Referenciar um elemento de array a \b\i0\fs22 [ \i\fs20 x \b0 1 [ y ] \i0\f2\fs8 , \i\f1\fs20 incorretamente, com subscritos como a [ x \i0\f2\fs8 , \b\i\f1\fs20 y \b0 1. \line Na realidade, a [ x \i0\f2\fs10 , \b\i\f1\fs20 y \b0 1 \'e9 tratado como a [ y ] porque C+ \b\i0\f0\fs16 + \b0\i\f1\fs20 calcula o valor da express\'e3o \i0\f2\fs10 , \i\f1\fs20 y \line (contendo um operador v\'edrgula) simplesmente como y (a \'faltima das express\'f5es separadas por v\'edrgulas). \line\b\i0\f2\fs18 Um array com \b0\f1 v\'e1rios subscritos pode ser inicializado em sua declara\'e7\'e3o da mesma forma que um array de apenas um subscrito [array unidimensional]. Por exemplo, um array b \i\fs20 [ \b\i0\f2\fs18 2 \b0\i\f1\fs20 ] [ \b\i0\f2\fs18 2 \b0\i\f1\fs20 ] \i0\fs18 com dois subscritos poderia ser declarado e inicializado com \line\b\f0\fs16 intb[ 2 \i\f1\fs20 ][ \i0\f0\fs16 2 \i\f1\fs20 ] \b0\i0\f2\fs10 = \b\i\f1\fs20\{ \{ \i0\f0\fs16 1, 2 \}, \{ 3, 4 \i\f1\fs20\} \i0\f0\fs16\}; \line\b0\f1\fs18 Os valores s\'e3o agrupados por linha e colocados entre chaves. Assim, 1 e 2 inicializam b \b\i\fs20 [ \b0\i0\fs18 O 1 [ O \b\i\fs20 ] \b0\i0\fs18 e b [ O 1 \b\i\fs20 1 \b0\i0\fs18 e 3 e 4 inicializam b \b\i\fs20 [ \b0\i0\fs18 1 \b\i\fs20 ] [ \b0\i0\fs18 O \b\i\fs20 ] \b0\i0\fs18 e b \b\i\fs20 [ \b0\i0\fs18 1 \b\i\fs20 1 [ \b0\i0\fs18 1 \b\i\fs20 1. \b0\i0\fs18 Se n\'e3o houver inicializadores suficientes para uma \line determinada linha, os elementos restantes daquela linha s\'e3o inicializados com O. Desta forma, a declara\'e7\'e3o \line intb[ \b\f0\fs16 2 \i\f1\fs20 ][ \i0\f0\fs16 2 \i\f1\fs20 ] \b0\i0\f2\fs10 = \b\i\f1\fs20\{ \{ \i0\f0\fs16 1 \f1\fs22 ), \{ \f0\fs16 3, 4 \i\f1\fs20\} \i0\f0\fs16 ); \line\b0\f1\fs18 inicializariab[ O \b\i\fs20 ] [ \b0\i0\fs18 O \b\i\fs20 ] \b0\i0\fs18 comi, b[ O \b\i\fs20 1 [ \b0\i0\fs18 1 \b\i\fs20 1 \b0\i0\fs18 com O, b[ 1 \b\i\fs20 1 [ \b0\i0\fs18 O ) com 3eb[ 1 \b\i\fs20 1 [ \i0\f0\fs16 1 \i\f1\fs20 ] \b0\i0\fs18 com 4. A Fig. 4.22 demonstra a inicializa\'e7\'e3o de arrays bidimensionais em declara\'e7\'f5es. O programa declara tr\'eas arrays \line de duas linhas e tr\'eas colunas. A declara\'e7\'e3o de arrayl fornece seis inicializadores em duas sublistas. A primeira \fs24\par
\b\fs14 CAP\'cdTULO \fs22 4 \fs8 - \fs14 ARRAYS \fs22 293 \line\f2\fs26 4.9 Arrays multidimensionais \line\b0\f1\fs18 Os arrays em C++ podem ter v\'e1rios subscritos. Um uso comum de arrays com v\'e1rios subscritos \'e9 representar \i\fs20 tabelas \i0\fs18 de valores que consistem em informa\'e7\'f5es organizadas em \i\fs20 linhas \i0\fs18 e \i\fs20 colunas. \i0\fs18 Para identificar um elemento espec\'edfico de uma tabela, devemos especificar dois subscritos: o primeiro (por conven\'e7\'e3o) identifica a linha do elemento e o segundo (por conven\'e7\'e3o) identifica a coluna do elemento. \line As tabelas, ou arrays, que exigem dois subscritos s\'e3o chamados \i\fs20 arrays bidimensionais. \i0\fs18 Observe que arrays podem ter mais de dois subscritos. Os compiladores de C++ suportam no m\'ednimo 12 subscritos para um array. A Fig. 4.21 ilustra um array \b\i\fs20 a \b0\i0\fs18 com dois subscritos. O array cont\'e9m tr\'eas linhas e quatro colunas; portanto, diz-se que ele \'e9 \b\f2 um \b0\f1 array 3 por 4. Em geral, diz-se que um array com \i\fs20 m \i0\fs18 linhas e \i\fs20 n \i0\fs18 colunas \'e9 um \i\fs20 array m por n. \line\i0\fs18 Cada elemento de a \'e9 identificado na Fig. 4.21 por um nome na forma \b\i\fs20 a [ \b0\i0\fs18 i \b\fs22 J [ j ]; \i\fs20 a \'e9 \b0\i0\fs18 o nome do array e i e \f3\fs24 j \f1\fs18 s\'e3o subscritos que identificam um elemento espec\'edfico em a. Observe que os nomes de todos os elementos da primeira linha t\'eam um primeiro subscrito igual a O; todos os nomes dos elementos da quarta coluna possuem um segundo subscrito igual a 3. \line\f2\fs20 Coluna O Coluna 1 Coluna 2 Coluna 3 \line\b\f0\fs16 a[O) [O] \b0\f2\fs20 a[O) \b\f0\fs16 [1] a[O] [2] \b0\f2\fs20 a[O] \b\f0\fs16 [3] \b0\f1\fs24\par
\pard\par
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2513\pard\intbl\b\f2\fs18 a[1) [O) a[1] [1] a[1] [2] a[1] [3) \b0\f1\fs24\cell\fs20\row
\b\f2\fs16\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2513\intbl a[2] [O] a[2] [1) a[2] [2] a[2] [3)  \f1\fs8 -* \'c0 \b0\fs24\cell\fs20\row
\pard\fs24\par
\pard\sb100\sa240\b\f0\fs16 1 \line 2 \line 3 \line 4 \b0\f1\fs24\par
\b\f0\fs16 5 \line 6 \line 7 \b0\f1\fs24\par
\b\f0\fs16 8 \line 9 \b0\f1\fs24\par
\b\f0\fs16 10 \line 11 \line\b0\f1\fs18 12 \line\b\f0\fs16 13 \line 14 \line 15 \line 16 \line 17 \line 18 \line 19 \line\b0\f1\fs18 20 \line\b\f0\fs16 21 \b0\f1\fs24\par
\b\f0\fs16 22 \line\b0\f1 23 \fs24\par
\b\f0\fs16 24 \b0\f1\fs24\par
\b\f0\fs16 25 \line 26 \line 27 \b0\f1\fs24\par
\b\f0\fs16 28 \line 29 \line 30 \line 31 \b0\f1\fs24\par
\b\f0\fs16 32 \line 33 \b0\f1\fs24\par
\b\f0\fs16 34 \b0\f1\fs24\par
\b\f0\fs16 35 \line 36 \line 37 \b0\f1\fs24\par
\b\f0\fs16 using std::cout; \line using std::endl; \b0\f1\fs24\par
\f0\fs20 294 C++ \f1\fs16 COMO PROGRAMAR \fs24\par
\fs18 sublista inicializa a primeira linha do array com os valores 1. 2 e 3; e a segunda sublista inicializa a segunda linha do array com os valores 4, 5 e 6. Se as chaves em torno de cada sublista fossem removidas da lista de inicializadores de arrayl, o compilador inicializaria automaticamente os elementos da primeira linha e, a seguir, inicializaria os elementos da segunda linha. \fs24\par
\i\f2\fs22 II \b\i0\f0\fs16 Fig. 4.22: figo4_22.cpp \line\b0\i\f2\fs22 II \b\i0\f0\fs16 Inicializando arrays multidimensionais #include <iostream> \b0\f1\fs24\par
\b\f0\fs16 6 \b0\f1\fs18\} \f0 ), \f1\fs24\par
\b\f0\fs16 void printArray( int \b0\f1\fs18 [] [ 3 ] ); \line\b\f0\fs16 int main \b0\f1\fs18 O \line\b\f0\fs16 intarrayl[2][3]=\{\{1,2,3\},\{4,5, array2[2][3]\{1,2,3,4,5\}, array3[2][3](\{1,2\},\{4\}\}; \line cout \b0\f1\fs18\'ab \b\f0\fs16\ldblquote Valores em arrayl por linha: \b0\f2\fs8\ldblquote  \b\f0\fs16\'ab endl; \b0\f1\fs18 printArray ( arrayl ); \line\b\f0\fs16 cout \'ab \ldblquote Valores em array2 por linha:\rdblquote  \'ab endl; \line\b0\f1\fs18 printArray( array2 ); \line\b\f0\fs16 cout \'ab \ldblquote Valores em array3 por linha:\rdblquote  \'ab endl; printArray( array3 ): \line return 0; \b0\f1\fs24\par
\fs18\} \fs24\par
\b\f0\fs16 void printArray( int a[] \b0\f1\fs18 [ 3 ] \line\b\f0\fs16 for \b0\f1\fs18 ( \b\f0\fs16 int i \b0\f2\fs12 = \b\f0\fs16 0; i < 2; i++ \b0\f1\fs18 ) \line\b\f0\fs16 for (intjo; j<3; \b0\fs20 j++) \b\fs16 cout\'aba[ i \b0\f1\fs18 )[ j ] \b\f0\fs16\'ab \b0\f2\fs8\lquote  \line\b\f0\fs16 cout \'ab endl; \b0\f1\fs24\par
\fs18\} \fs24\par
\fs18\} \fs24\par
\b\f0\fs16 Valores em arrayl por linha: \line 123 \line 456 \line Valores em array2 por linha: \line 123 \line 450 \line Valores em array3 por linha. \line 120 \line 400 \b0\f1\fs24\par
\b\f2\fs18 Fig. 4.22 \b0\fs20 Inicializando arrays multidimensionais. \line\f1\fs18 A declara\'e7\'e3o de array2 fornece cinco inicializadores. Os inicializadores s\'e3o atribu\'eddos \'e0 primeira linha e, depois, \line\'e0 segunda linha. Quaisquer elementos que n\'e3o tenham um inicializador expl\'edcito s\'e3o inicializados com zero automaticamente; portanto, array2 [ 1 1 [ 2 J \'e9 inicializado com O. \fs24\par
\b\fs16 CAP\'cdTULO \b0\fs18 4 \f2\fs8 - \b\f1\fs16 ARRAYS \i\f2\fs22 295 \line\i0\f3\fs14 L \b0\f1\fs18 do A declara\'e7\'e3o de array3 fornece tr\'eas inicializadores em duas sublistas. A sublista da primeira linha inicializa, \b\fs16 ; \b0\fs18 de explicitamente, os dois primeiros elementos da primeira linha com os valores 1 e 2. O terceiro elemento \'e9 inicializado flos automaticamente com o valor zero. A sublista da segunda linha inicializa explicitamente o primeiro elemento com 4. \line Os dois \'faltimos elementos s\'e3o automaticamente inicializados com zero. \line O programa chama a fun\'e7\'e3o printArray para criar a sa\'edda dos elementos de cada array. Observe que a defini\'e7\'e3o da fun\'e7\'e3o especifica o par\'e2metro do aay como int a \b\i\f2\fs22 [ J [ \b0\i0\f1\fs18 3 \b\i\f2\fs22 ] \b0\i0\fs8 . \f1\fs18 Ao recebermos um array unidimensional como argumento de uma fun\'e7\'e3o, os colchetes ficam vazios na lista de par\'e2metros da fun\'e7\'e3o. O primeiro subscrito de um array multidimensional tamb\'e9m n\'e3o \'e9 exigido, mas todos os outros subscritos o s\'e3o. O compilador usa esses subscritos para determinar as posi\'e7\'f5es na mem\'f3ria dos elementos de arrays multidimensionais. Todos os elementos do array s\'e3o armazenados seq\'fcencialmente na mem\'f3ria, independentemente do n\'famero de subscritos. Em um array bidimensional, a primeira linha \'e9 armazenada na mem\'f3ria, seguida da segunda linha. \line Fornecer os valores dos subscritos na declara\'e7\'e3o de par\'e2metros permite ao compilador informar \'e0 fun\'e7\'e3o como localizar os elementos do array. Em um array bidimensional, cada linha \'e9 um array com um \'fanico subscrito. Para localizar um elemento de uma determinada linha, o compilador deve saber exatamente quantos elementos existem em cada linha, para que possa saltar o n\'famero adequado de locais da mem\'f3ria quando tiver acesso ao array. Desta forma, ao ter acesso a a \b\i\f2\fs22 [ \b0\i0\f1\fs18 1 \b\i\f2\fs22 ] [ \i0\f1\fs18 2 \i\f2\fs22 1 \b0\i0\f1\fs18 em nosso exemplo, o compilador sabe que deve saltar os tr\'eas elementos da primeira linha na mem\'f3ria para obter a segunda linha (linha 1). A seguir, o compilador tem acesso ao terceiro elemento daquela linha (elemento 2). \line Muitas manipula\'e7\'f5es comuns de arrays usam estruturas de repeti\'e7\'e3o for. Por exemplo, a estrutura a seguir atribui zero a todos os elementos da terceira linha do array a da Fig. 4.21: \line for ( colunin \f2\fs12 = \f1\fs18 O; column < \b\fs16 4; column++ \b0\fs18 ) \line\b\fs16 a[ 2 \b0\fs18 1 [ column ] \f2\fs12 = \f1\fs18 O; \line Especificamos a \i terceira \i0 linha e, portanto, sabemos que o primeiro subscrito sempre ser\'e1 \b 2 (O \b0\'e9 o subscrito da primeira linha e 1 \'e9 o da segunda linha). O la\'e7o for faz variar apenas o segundo subscrito (i.e., o subscrito da coluna). A estrutura for anterior \'e9 equivalente aos comandos de atribui\'e7\'e3o: \line\b\fs16 a[ 2 \b0\fs18 ] [ \b\fs16 O \b0\fs18 3 O; \line\b\fs16 a[ 2 \b0\fs18 ] [ \b\fs16 1 \b0\fs18 ] \f2\fs12 = \b\f1\fs16 O; \line a[ 2 \b0\fs18 ] [ \b 2 1 \b0\f2\fs12 = \b\f1\fs16 O; \line a[ 2 \b0\fs18 ) [ 3 ] \f2\fs12 = \b\f1\fs16 O; \line\b0\fs18 A estrutura for aninhada a seguir determina o total de elementos no array a. \line\b\fs16 total \b0\f2\fs12 = \b\f1\fs16 O; \line\f0\fs18 for \b0\f1 ( \b\f0 row \b0\f2\fs12 = \b\f0\fs18 O; row \f1\fs16 < \f0\fs18 3; row++ \line\f1\fs16 for \b0\fs18 ( column \f2\fs12 = \b\f1\fs16 O; column < 4; column++ \line total \b0\f2\fs12 += \b\f1\fs16 a[ row \b0\fs18 ][ column 1; \line A estrutura for calcula o total de elementos do array, passando por uma linha de cada vez. A estrutura for externa come\'e7a definindo row (i.e., o subscrito da linha) como O para que os elementos da primeira linha possam ser contados pela estrutura for interna. A estrutura for externa incrementa row de 1, para que os elementos da segunda linha possam ser contados. A seguir, a estrutura for externa incrementa row de \b 2, \b0 para que os elementos da terceira linha possam ser contados. O resultado \'e9 impresso quando a estrutura for aninhada chega ao fim. \line\b O programa da Fig. \b0 4.23 realiza v\'e1rias outras manipula\'e7\'f5es de arrays no array studentGrades usando estruturas for. Cada linha do anay representa um aluno e cada coluna representa uma nota em um dos quatro exames que os alunos fizeram durante o semestre. As manipula\'e7\'f5es de arrays s\'e3o realizadas por quatro fun\'e7\'f5es. A fun\'e7\'e3o minimum determina a menor nota de qualquer aluno naquele semestre. A fun\'e7\'e3o maximum determina a maior nota de qualquer aluno no semestre. A fun\'e7\'e3o ave rage determina a m\'e9dia semestral de um determinado aluno. A fun\'e7\'e3o printArray imprime a sa\'edda do array de dois subscritos em um formato elegante de tabela. \fs24\par
\fs20 296 \f2\fs28 c++ \fs14 COMO PROGRAMAR \line\f0\fs16 1 \i\fs20 II \i0\fs16 Fig. 4.23: figO4_23.cpp \line 2 \i\fs20 /1 \i0\fs16 Exemplo de uso de array bidimensional \line 3 #include <iostream> \line 4 \line 5 using std::cout; \line 6 using std::endl; \line 7 using std: :ios; \line 8 \line 9 #include <iomanip> \line lo \line 11 using std::setw; \line 12 using std::setiosflags; \line 13 using std::setprecision; \line 14 \line 15 const int students 3; \i\fs20 /1 \i0\fs16 n\'famero de alunos \line 16 const int exaxns 4; \i\fs20 /1 \i0\fs16 n\'famero de exames \line 17 \line 18 int minimum( int \f1\fs20 [] [ \b\fs16 exams \b0\fs20 ) \f2\fs8 , \f0\fs16 int, int ); \line 19 int maximum( int \f1\fs20 [] [ \f0\fs16 exains \f1\fs20 ] \f2\fs8 , \f0\fs16 int, int ); \line 20 double average( int \f1\fs20 [3 \f2\fs8 , \f0\fs16 int ); \line 21 void printArray( int \f1\fs20 [) [ \f0\fs16 exams \f1\fs20 J \f2\fs8 , \f0\fs16 int, int ); \line\f2\fs14 22 \line\f0\fs16 23 int main O \line 24 \f1\fs20\{ \line\f0\fs16 25 int studentGrades[ students \f1\fs20 ] [ \f0\fs16 exams \f1\fs20 ) \line\f0\fs16 26 \i\fs20\{ \{ \i0\fs16 77, 68, 86, 73 \f1\fs20\}, \line\f0\fs16 27 \f1\fs20\{ \f0\fs16 96, 87, 89, 78 \f1\fs20\}, \line\f0\fs16 28 \f1\fs20\{ \f0\fs16 70, 90, 86, 81 \f1\fs20\} \f0\fs16\}; \line 29 \line 30 cout \'ab \ldblquote O array \'e9:\\n\rquote ; \line 31 printArray( studentGrades, students, exams ); \line 32 cout \'ab \ldblquote\\n\\nNenor nota: \line 33 \'ab minimum( studentGrades, students, exams \line 34 \'ab \ldblquote\\n\\nMaior nota: \line 35 \'ab maximum( studentGrades, students, exams \f1\fs20 ) \f2\'ab \f0\fs16\lquote\\n\rquote ; \line 36 \line 37 for \f1\fs20 ( \f0\fs16 int person \f2\fs10 = \f0\fs16 0; person < students; person++ \line 38 cout \f2\fs20\'ab \f0\fs16\ldblquote A nota m\'e9dia do aluno \f2\fs8\ldblquote  \f0\fs16\'ab person \'ab \f2\fs8\ldblquote  \f0\fs16\'e9 \line 39 \'ab setiosflags( ios::fixed \f1\fs20 1 \f0\fs16 ios::showpoint \line 40 \'ab setprecision( 2 \line 41 \'ab average( studentGrades[ person \f1\fs20 ), \f0\fs16 exams \f1\fs20 ) \f0\fs16\'ab endl; \line 42 \line 43 return 0; \line 44 \f1\fs20\} \line\f0\fs16 45 \line 46 \f1\fs20 // \f0\fs16 Encontra a nota m\'ednima \line 47 int minimum( int grades[J \f1\fs20 [ \f0\fs16 exams \f1\fs20 ], \f0\fs16 int pupils, int tests \line 48 \f1\fs20\{ \line\f0\fs16 49 int lowGrade \f2\fs10 = \f0\fs16 100; \line 50 \line 51 for \f1\fs20 ( \f0\fs16 int i \f2\fs10 = \f0\fs16 O; i \f2\fs14 < \f0\fs16 pupils \f2\fs14 ; \f0\fs16 i++ \line 52 \line 53 for \f1\fs20 ( \f0\fs16 int \f1\fs20 j \f2\fs10 = \f0\fs16 0; < tests ; \f1\fs20 j++ \line\f0\fs16 54 \line\f2\fs20 55 \f0\fs16 if \f1\fs20 ( \f0\fs16 grades[ i \f1\fs20 ] [ j ] \f0\fs16 < lowGrade \line 56 lowGrade \f2\fs10 = \f0\fs16 grades \f1\fs20 ( \f0\fs16 i \f1\fs20 ] [ \f0\fs16 j ]; \line 57 \line\f2\fs20 Fig. 4.23 Exemplo de uso de arrays bidimensionais (parte 1 de 2). \f1\fs24\par
\fs14 CAP\'cdTULO \f2\fs20 4 \fs8 - \f1\fs14 ARRAYS \f2\fs22 297 \line\f0\fs16 58 return lowGrade; \line 59 \f2\fs20 ) \line\f0\fs16 60 \line 61 \i\fs22 1/ \i0\fs16 Encontra a nota m\'e1xima \line 62 int maximuxn( int gradest] \f2\fs20 [ \f0\fs16 exaxns \f2\fs20 ) \fs8 , \f0\fs16 int pupils, int tests \line 63 \f2\fs20\{ \line\f0\fs16 64 int highGrade \f2\fs12 = \f0\fs16 0; \line 65 \line 66 for \f2\fs20 ( \f0\fs16 int i 0; i < pupils ; i++ \line 67 \line 68 for \f2\fs20 ( \f0\fs16 int \fs22 j \f2\fs12 = \f0\fs16 0; \fs22 j \f1\fs14 < \f0\fs16 tests \f1\fs14 ; \f0\fs22 j++ \line\fs16 69 \line 70 if \f2\fs20 ( \f0\fs16 grades[ i \fs22 3[ \fs16 j \f2\fs20 ] \f1\fs14 > \f0\fs16 highGrade \line 71 highGrade \f2\fs12 = \f0\fs16 grades[ i \f2\fs20 ] [ \f0\fs22 j 1; \line\fs16 72 \line 73 return highGrade; \line 74 \f2\fs20 ) \line\f0\fs16 75 \line 76 \i\fs22 II \i0\fs16 Determina a nota m\'e9dia de um determinado aluno \line 77 double average( int setOfGrades[), int tests \line 78 \f2\fs20\{ \line\fs12 4_ \f0\fs16 79 int total \f2\fs12 = \f0\fs16 0; \line 80 \line 81 for \f2\fs20 ( \f0\fs16 int i 0; i < tests; i++ \line 82 total \f1\fs14 + \f0\fs16 setOfGrades \f2\fs20 [ \f0\fs16 i ]; \line 83 \line 84 return staticcast< double >( total \f2\fs20 ) / \f0\fs16 tests; \line 85 \line 86 \line 87 \i\fs22 1/ \i0\fs16 Imprime o array \line 88 void printArray( int grades[) \f2\fs20 [ \f0\fs16 exaxns \f2\fs20 ) \fs8 , \f0\fs16 int pupils, int tests \line 89 \line 90 cout \'ab \f2\fs8\lquote  \f0\fs16 10) [1] [2] [3)\rquote ; \line 91 \line 92 for \f2\fs20 ( \f0\fs16 int i 0; i < pupils; i++ \f2\fs20 ) \{ \line\f0\fs16 93 cout \'ab \lquote\\nstudentGrades[\rdblquote  \'ab i \'ab \f2\fs12\ldblquote ) \ldblquote ; \line\f0\fs16 94 \line 95 for \f2\fs20 ( \f0\fs16 int \fs22 j \f1\fs14 = \f0\fs16 0; j < tests; \f2\fs20 j++ \line\f0\fs16 96 cout\'ab setiosflags( ios::left \f2\fs20 ) \f1\fs24\'ab \f0\fs16 setw( 5 \line 97 \'ab grades[ i \f2\fs20 ) [ j ]; \line\f0\fs16 98 \f2\fs20 ) \line\f0\fs16 99 \f2\fs20\} \line\f1\fs24 o \f0\fs16 array \'e9: \line [0] [1] [2] [3) \line studentGrades[0] 77 68 86 73 \line studentGrades[l) 96 87 89 78 \line studentGrades[2] 70 90 86 81 \line Menor nota: 68 \line Maior nota: 96 \line A nota m\'e9dia do aluno O \'e9 76.00 \line A nota m\'e9dia do aluno 1 \'e9 87.50 \line A nota m\'e9dia do aluno 2 \'e9 81.75 \line\b\f2\fs18 Fig. 4.23 \b0\fs20 Exemplo de uso de arrays bidimensionais (parte 2 de 2). \line\f1 Cada uma das fun\'e7\'f5es minimum, maximum e printArray recebe tr\'eas argumentos \f2\fs8 - \f1\fs20 o array studentGrades \line (chamado grades em cada fun\'e7\'e3o), o n\'famero de alunos (linhas do array) e o n\'famero de exames (colunas do array). \line\f3\fs102 E \f1\fs24\par
\fs18 298 C++ \b COMO PROGRAMAR \line\b0 Cada fun\'e7\'e3o executa um la\'e7o pelo array grades usando estruturas for aninhadas. A estrutura for aninhada a seguir \'e9 da defini\'e7\'e3o da fun\'e7\'e3o minimum: \line\b\f0\fs16 for \b0\f1\fs18 ( \b\f0\fs16 i \b0\f2\fs10 = \b\f0\fs16 O; i \f1\fs18 < \f0\fs16 pupils; i++ \line for \b0\f1\fs18 ( \f0\fs22 j \f2\fs10 = \b\f0\fs16 O; \b0\f1\fs18 j \b < \f0\fs16 tests; \b0\f1\fs18 j++ \line\b\f0\fs16 if \b0\f1\fs18 ( \b\f0\fs16 grades \b0\f1\fs18 [ \b\f0\fs16 i \b0\f1\fs18 ] [ :i ] \b < \f0\fs16 lowGrade \line lowGrade \b0\f2\fs10 = \b\f0\fs16 grades[ i \b0\f1\fs18 ][ \f0\fs22 j \b\fs16 ]; \line\b0\f1\fs18 A estrutura for externa come\'e7a definindo i (i.e., o subscrito da linha) como O para que os elementos da primeira linha possam ser comparados com \b lowGrade no corpo da estrutura for interna. \b0 A estrutura for interna percorre as quatro notas de uma determinada linha e compara cada nota com lowGrade. Se uma nota for menor do que \b lowGrade, lowGrade \b0\'e9 definido como essa nota. A seguir, a estrutura for externa incrementa o subscrito da linha em 1. Os elementos da segunda linha s\'e3o comparados com a vari\'e1vel lowGrade. A estrutura for externa incrementa ent\'e3o o subscrito da linha para 2. Os elementos da terceira linha s\'e3o comparados com a vari\'e1vel lowGrade. Quando a execu\'e7\'e3o da estrutura aninhada for conclu\'edda. lowGrade conter\'e1 a menor nota do array bidimensional. A fun\'e7\'e3o maximum funciona de maneira similar \'e0 fun\'e7\'e3o minimum. \line\f2 A \f1 fun\'e7\'e3o average recebe dois argumentos \f2\fs8 - \f1\fs18 um array unidimensional de resultados de testes para um estudante em particular e o n\'famero de resultados de testes no array. Quando a fun\'e7\'e3o average \'e9 chamada, o \b primeiro argumento passado \b0\'e9 studentGrades \f0\fs22 [ \b\f1\fs18 student \b0\fs24 J \f2\fs8 , \f1\fs18 que especifica que uma linha particular do array bidimensional studentGrades seja passada para average \f2\fs8 . \f1\fs18 Por exemplo, o argumento studentGrades \f0\fs22 [ \f1\fs18 1 \f0\fs22 ] \f1\fs18 representa os quatro valores (um array unidimensional de notas) armazenados na segunda linha do array bidimensional studentGrades. Um array bidimensional pode ser considerado um array com elementos que s\'e3o arrays unidimensionais. A fun\'e7\'e3o average calcula a soma dos elementos do array, divide o total pelo n\'famero de resultados de testes e retorna o valor de ponto flutuante obtido. \line\b\f2\fs26 4.10 (Estudo de caso opcional) Pensando em objetos: identificando as opera\'e7\'f5es de uma classe \line\b0\f1\fs18 Nas se\'e7\'f5es \ldblquote Pensando em objetos\rdblquote  nos finais dos Cap\'edtulos 2 e 3, executamos algumas etapas iniciais de um projeto orientado a objetos para nosso simulador de elevador. No Cap\'edtulo 2, identificamos as classes que precisamos implementar e criamos um diagrama de classes que modela a estrutura do nosso sistema. No Cap\'edtulo 3, determina- mos muitos dos atributos de nossas classes, investigamos os estados poss\'edveis da classe Elevator e os representamos em um diagrama de mapa de estados, modelando em um diagrama de atividades a l\'f3gica que o elevador utiliza para responder ao pressionamento de bot\'f5es. \line Nesta se\'e7\'e3o, concentramos-nos na determina\'e7\'e3o das \i opera\'e7\'f5es \i0 (ou comportamentos) das classes necess\'e1rias \line para implementar o simulador de elevador. No Cap\'edtulo 5, concentrar-nos-emos nas colabora\'e7\'f5es (intera\'e7\'f5es) entre os objetos de nossas classes. \line Uma opera\'e7\'e3o de uma classe \'e9 um servi\'e7o que a classe presta a \ldblquote clientes\rdblquote  (usu\'e1rios) daquela classe. Consideremos as opera\'e7\'f5es de algumas classes do mundo real. As opera\'e7\'f5es de um r\'e1dio incluem ajustar sua esta\'e7\'e3o e volume (normalmente invocadas por um ouvinte que est\'e1 ajustando os controles do r\'e1dio). As opera\'e7\'f5es de um carro incluem acelerar (invocada apertando-se o pedal do acelerador), desacelerar (invocada pressionando-se o pedal do freio), girar o volante e trocar de marchas. \line Objetos normalmente n\'e3o executam suas opera\'e7\'f5es expontaneamente. Em vez disso, uma opera\'e7\'e3o espec\'edfica \'e9 normalmente invocada quando um objeto remetente (freq\'fcentemente chamado de \i objeto cliente) \i0 envia uma mensagem para um objeto destinat\'e1rio (freq\'fcentemente chamado de \i objeto servidor), \i0 solicitando que o objeto destinat\'e1rio execute aquela opera\'e7\'e3o espec\'edfica. Isto se parece com uma chamada de fun\'e7\'e3o membro \f2\fs8 - \b\f1\fs18 exatamente \b0 como as mensagens s\'e3o enviadas para objetos em C++. Nesta se\'e7\'e3o, identificaremos muitas das opera\'e7\'f5es que nossas classes precisam oferecer a seus clientes em nosso sistema. \line Podemos derivar muitas das opera\'e7\'f5es de cada classe diretamente da defini\'e7\'e3o do problema. Para fazer isso, examinamos os verbos e frases com verbos da defini\'e7\'e3o do problema. Relacionamos, ent\'e3o, cada uma destas frases a uma classe particular em nosso sistema (ver Fig. 4.24). Muitas das frases com verbos na tabela da Fig. 4.24 ajudar\'e3o a determinar as opera\'e7\'f5es de nossas classes. \fs24\par
\fs16 CAP\'cdTULO 4 \f2\fs8 - \f1\fs16 ARRAYS 299 \fs24\par
\b\f2\fs18 Fig. 4.24 \b0 Frases com verbos para cada classe do simulador. \f1\fs24\par
\fs18 Para criar opera\'e7\'f5es a partir destas frases com verbos, examinamos as frases com verbos listadas com cada classe. O verbo \ldblquote move-se\rdblquote , listado com a classe Elevator. refere-se \'e0 atividade na qual o elevador se move entre andares. Deve \ldblquote move-se\rdblquote  ser uma opera\'e7\'e3o da classe Elevator? Nenhuma mensagem diz ao elevador para se mover; em vez disso, o elevador decide se mover em resposta ao pressionamento de um bot\'e3o, com base na condi\'e7\'e3o da porta estar fechada. Assim, \ldblquote move-se\rdblquote  n\'e3o corresponde a uma opera\'e7\'e3o. A frase \ldblquote chega em um andar\rdblquote  tamb\'e9m n\'e3o \'e9 uma opera\'e7\'e3o porque o elevador decide sozinho quando chegou em um andar, baseado no tempo. \line A frase \ldblquote desliga bot\'e3o do elevador\rdblquote  implica que o elevador envie uma mensagem para o bot\'e3o do elevador, dizendo ao bot\'e3o para se desligar. Portanto, a classe ElevatorButton precisa de uma opera\'e7\'e3o para oferecer este servi\'e7o para o elevador. Colocamos esta opera\'e7\'e3o no compartimento inferior da classe ElevatorButton em nosso diagrama de classes (Fig. 4.25). Representamos os nomes das opera\'e7\'f5es como nomes de fun\'e7\'f5es e inclu\'edmos as informa\'e7\'f5es sobre o tipo de valor devolvido: \line resetButton() : void \line O nome da opera\'e7\'e3o \'e9 escrito primeiro, seguido por par\'eanteses contendo uma lista de par\'e2metros, separados por v\'edrgulas, que a opera\'e7\'e3o recebe (neste caso, nenhum). Um dois-pontos segue a lista de par\'e2metros, seguido pelo tipo de valor devolvido pela opera\'e7\'e3o (neste caso, void). Observe que a maioria de nossas opera\'e7\'f5es parece n\'e3o ter par\'e2metros e ter um tipo devolvido void; isto pode mudar na medida em que nossos processos de projeto e implementa\'e7\'e3o continuarem. \line Da frase \ldblquote soa a campainha do elevador\rdblquote  listada com a classe Elevator. conclu\'edmos que a classe Beil \line deveria ter uma opera\'e7\'e3o que presta um servi\'e7o \f2\fs8 - \f1\fs18 soar. Listamos a opera\'e7\'e3o ringBell sob a classe Beil. \line Quando o elevador chega em um andar, ele \ldblquote sinaliza sua chegada em um andar\rdblquote  e o andar responde executando suas diversas atividades (i.e., desligando o bot\'e3o do andar e ligando a luz). Portanto, a classe Floor precisa de \fs24\par
\fs20\lquote ada a \fs24\par
\fs18 meira rcorre \line o que ito da tema cade. \line ional. \fs24\par
\fs18 a um ida, o array ides array ie s\'e3o ro de \fs24\par
\fs20 ojeto amos iinaesenvador \fs24\par
\fs20\'e1rias entre \fs24\par
\pard\sb100\sa100\fs20 side\'e7\'e3o e e um o pe ec\'edfium \fs24\par
\pard\sb100\sa240\fs18 bjeto lente \f2\fs14 ; \f1\fs18 que \fs24\par
\fs20 isso, rases \line 4.24 \fs24\par
\pard\par
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1208\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx8946\pard\intbl\fs20 Classe \fs24\cell\fs20 Frases com verbos \f3\fs50 1 \f1\fs24\cell\fs20\row
\intbl E].evator \fs24\cell\fs20 move-se, chega em um andar, desliga o bot\'e3o do elevador, soa a campainha do elevador, sinaliza sua chegada em um andar, abre a porta, fecha a porta \fs24\cell\fs20\row
\intbl Clock \fs24\cell\fs20 bate a cada segundo \fs24\cell\fs20\row
\intbl Scheduler \fs24\cell\fs20 escalona momentos aleatoriamente, cria uma pessoa, diz a uma pessoa para entrar em um andar, verifica se um andar est\'e1 desocupado, retarda a cria\'e7\'e3o de uma pessoa em um segundo \fs24\cell\fs20\row
\fs18\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1208\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx8946\intbl Person \fs24\cell\fs18 entra em um andar, aperta o bot\'e3o do andar, aperta o bot\'e3o do elevador, entra no elevador, sai do elevador \fs24\cell\fs20\row
\fs18\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1208\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx8946\intbl Floor \fs24\cell\fs18 desliga o bot\'e3o do andar, apaga a luz, acende a luz \fs24\cell\fs20\row
\fs18\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1208\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx8946\intbl FloorButton \fs24\cell\fs18 chama o elevador \fs24\cell\fs20\row
\fs18\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1208\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx8946\intbl ElevatorButton \fs24\cell\fs18 avisa o elevador para se mover \fs24\cell\fs20\row
\fs18\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1208\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx8946\intbl Door \fs24\cell\fs18 (abertura da porta) avisa a pessoa para sair do elevador, (abertura da porta) avisa a pessoa para entrar no elevador \fs24\cell\fs20\row
\fs18\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1208\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx8946\intbl Beli \fs24\cell\fs18 nenhuma na defini\'e7\'e3o do problema \fs24\cell\fs20\row
\fs18\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1208\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx8946\intbl Light \fs24\cell\fs18 nenhuma na defini\'e7\'e3o do problema \fs24\cell\fs20\row
\fs18\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1208\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx8946\intbl Building \fs24\cell\fs18 nenhuma na defini\'e7\'e3o do problema \fs24\cell\fs20\row
\pard\fs24\par
\pard\sb100\sa240\b\f2 300 \b0\fs28 c++ \b\fs14 COMO \f1 PROGRAMAR \line\b0\f2\fs20 Elevator Clock Door \line currentFloor : int \fs12 = \fs20 1 time : int \fs12 = \fs20 O \ul open : bool \fs12 = \fs20 false \ulnone\line direction : enum up getTime \b\fs24 ( ) \b0\fs20 : int openDoor( \b\fs24 ) \b0\fs20 : void \line capacity : int \fs12 = \fs20 1 tick( \b\fs24 ) \b0\fs20 : void closeDoor( \b\fs24 ) \b0\fs20 : void \line arrivalTime : int \line\ul moving \ulnone : \ul bool \fs12 = \fs20 false \ulnone\line processTime (time : int) : void Floor \line personEnters( \b\fs24 ) \b0\fs20 : void occupied : bool \fs12 = \fs20 false Beli \line personExits( \b\fs24 ) \b0\fs20 : void \fs8 . \fs20 <nenhuma ainda> \line summonElevator( \b\fs24 ) \b0\fs20 : void elevatorArrived( \b\fs24 ) \b0\fs20 : void \fs8\bullet  \fs20 B \line prepareToLeave( \b\fs24 ) \b0\fs20 : void isOccupied( \b\fs24 ) \b0\fs20 : bool ring e \fs8 . \fs20 voi \line\ul Scheduler \ulnone FloorButton \ul Light \ulnone\line floorlArrivalTime : int \ul pressed \ulnone : \ul bool \fs12 = \fs20 false \ulnone\line floor2ArrivalTime : int \fs8 . \b\fs14 ( \b0\fs8 . \fs20 bool \fs12 = \fs20 false \line pressButton( \b\fs24 ) \b0\fs20 : void \fs8 . \line\fs20 processTime(time : int) : void resetButton( \b\fs24 ) \b0\fs20 : void turnOn( \b\fs24 ) \b0\fs20 : void \line Person 4 \line ID : int ElevatorButton \fs8 ____________________ \line\fs20 stepOntoFloor( \b\fs24 ) \b0\fs20 : void \ul pressed : bool \fs12 = \fs20 false Building \ulnone\line exitElevator( \b\fs24 ) \b0\fs20 : void resetButton( \b\fs24 ) \b0\fs20 : void <nenhuma ainda> \line enterElevator( \b\fs24 ) \b0\fs20 : void pressButton( \b\fs24 ) \b0\fs20 : void runSimulation( \b\fs24 ) \b0\fs20 : void \line\b\fs18 Fig. 4.25 \b0\fs20 Diagrama de classes com atributos e opera\'e7\'f5es. \line uma opera\'e7\'e3o que preste este servi\'e7o. \f1\fs18 Chamamos \f2\fs20 esta \f1\fs18 opera\'e7\'e3o de elevatorArrived e colocamos o nome da opera\'e7\'e3o no compartimento inferior da classe Floor na Fig. 4.25. \line\f2\fs20 As duas frases \f1\fs18 com verbos \f2\fs20 restantes, listadas \f1\fs18 com \f2\fs20 a classe \f1\fs18 Elevator, afirmam que o elevador precisa abrir \line e fechar sua porta. Portanto, a classe Door precisa oferecer estas opera\'e7\'f5es. Colocamos as opera\'e7\'f5es openDoor e closeDoor no compartimento inferior da classe Door. \line A classe Clock lista a frase \ldblquote bate a cada segundo\rdblquote . Esta frase chama a aten\'e7\'e3o para um ponto interessante. \line Certamente, \ldblquote obter a hora\rdblquote  \'e9 uma opera\'e7\'e3o que o rel\'f3gio oferece, mas ser\'e1 a batida do rel\'f3gio tamb\'e9m uma opera- \'e7\'e3o? Para responder a esta quest\'e3o, concentramo-nos em como funcionar\'e1 nossa simula\'e7\'e3o. \line A defini\'e7\'e3o do problema indica que o \i\fs20 scheduler \i0\fs18 precisa saber a hora atual para decidir se ele deve criar uma nova pessoa para entrar em um andar. O elevador precisa da hora para decidir se \'e9 hora de chegar em um andar. Tamb\'e9m decidimos que cabe ao edif\'edcio a responsabilidade de executar a simula\'e7\'e3o e passar a hora para o \i\fs20 scheduler \i0\f2 e \f1\fs18 para o elevador. Come\'e7amos agora a ver como vai funcionar nossa simula\'e7\'e3o. O edif\'edcio repete as seguintes etapas, uma vez por segundo, durante toda a dura\'e7\'e3o da simula\'e7\'e3o: \line\f2\fs20 1 \fs8 . \fs20 Obter \f1\fs18 a hora do rel\'f3gio. \line 2. Passar a hora ao \i\fs20 scheduler \i0\fs18 para que ele possa criar uma nova pessoa, se necess\'e1rio. \line\f2\fs20 3. \f1\fs18 Passar a hora para o elevador para que ele possa decidir chegar a um andar, se o elevador estiver se movendo. \line Decidimos que o edif\'edcio tem responsabilidade total para executar todas as partes da simula\'e7\'e3o. Portanto, o edif\'edcio tamb\'e9m deve incrementar o rel\'f3gio. O rel\'f3gio deve ser incrementado uma vez por segundo; ent\'e3o, a hora deve ser passada para o \i\fs20 scheduler \i0\fs18 e para o elevador. \fs24\par
\fs18 CAP\'cdTULO 4- ARRAYS \b\f2\fs22 301 \line\b0\f1\fs18 Isto nos leva a criar duas opera\'e7\'f5es \f2\fs8 - \f1\fs18 getTime e tick \f2\fs8 - \f1\fs18 e list\'e1-las sob a classe Clock. A opera\'e7\'e3o getTime devolve um inteiro como o valor do atributo hora do rel\'f3gio. Nos itens \f2\fs20 2 \f1\fs18 e 3 anteriores, vemos as frases \ldblquote passar a hora para o \i\fs20 scheduler\rdblquote  \i0\fs18 e \ldblquote passar a hora para o elevador\rdblquote . Assim, podemos adicionar a opera\'e7\'e3o processTime \'e0s classes Scheduler e Elevator. Podemos tamb\'e9m adicionar a opera\'e7\'e3o runSimulation \'e0 classe Bui].ding. \line A classe Scheduler lista as frases com verbos \ldblquote escalona momentos aleatoriamente\rdblquote  e \ldblquote retarda a cria\'e7\'e3o de \line uma pessoa em um segundo\rdblquote . O \i\fs20 scheduler \i0\fs18 decide executar estas a\'e7\'f5es ele mesmo e n\'e3o oferece estes servi\'e7os para clientes. Portanto, estas duas frases n\'e3o correspondem a opera\'e7\'f5es. \line A frase \ldblquote cria pessoa\rdblquote , listada com a classe Scheduler. representa um caso especial. Embora possamos modelar um objeto da classe Scheduler enviando uma mensagem \ldblquote criar\rdblquote , um objeto da classe Person n\'e3o pode responder a uma mensagem \ldblquote criar\rdblquote  porque este objeto ainda n\'e3o existe. A cria\'e7\'e3o de objetos \'e9 deixada para os detalhes da implementa\'e7\'e3o e n\'e3o \'e9 representada como uma opera\'e7\'e3o de uma classe. Discutimos a cria\'e7\'e3o de novos objetos quando discutimos implementa\'e7\'e3o, no Cap\'edtulo 7. \line A frase \ldblquote diz a uma pessoa para entrar em um andar\rdblquote , listada na Fig. 4.24, significa que a classe Person deve \line ter uma opera\'e7\'e3o que o \i\fs20 scheduler \i0\fs18 possa invocar para dizer \'e0 pessoa para entrar em um andar. Chamamos esta opera\'e7\'e3o de stepOntoFloor e a listamos sob a classe Person. \line A frase \ldblquote verifica se um andar est\'e1 desocupado\rdblquote  implica que a classe Floor precisa prestar um servi\'e7o que \line permita aos objetos do sistema saber se o andar est\'e1 ocupado ou desocupado. A opera\'e7\'e3o que criamos para este servi\'e7o deve devolver true se o andar est\'e1 ocupado e false caso contr\'e1rio. Colocamos a opera\'e7\'e3o \line isOccupied( ) : bool \line no compartimento inferior da classe Floor. \line A classe Person lista as frases \ldblquote aperta o bot\'e3o do andar\rdblquote  e \ldblquote aperta o bot\'e3o do elevador\rdblquote . Portanto, colocamos a opera\'e7\'e3o pressButton sob as classes FloorButton e ElevatorButton em nosso diagrama de classes da UML (Fig. 4.25). Note que \fs24 j\'e1 \fs18 lidamos com o fato de que uma pessoa \ldblquote entra em um andar\rdblquote  quando analisamos as frases com verbos para a classe Scheduler, de modo que n\'e3o precisamos criar nenhuma opera\'e7\'e3o com base na frase \ldblquote entra em um andar\rdblquote , listada com a classe Person. As frases \ldblquote entra no elevador\rdblquote  e \ldblquote sai do elevador\rdblquote , listadas com a classe Person, sugerem que a classe Elevator precisa opera\'e7\'f5es que correspondam a estas a\'e7\'f5es.1 \line A classe Floor tamb\'e9m lista \ldblquote desliga o bot\'e3o do andar\rdblquote  em sua coluna de frases com verbos, de modo que \line listamos a opera\'e7\'e3o resetButton apropriada sob a classe FloorButton. A classe Floor tamb\'e9m lista \ldblquote apaga a nome da luz\rdblquote  e \ldblquote acende a luz\rdblquote , de modo que criamos as opera\'e7\'f5es turnOff e turnOn e as listamos sob a classe Light. \line A frase \ldblquote chama o elevador\rdblquote , listada sob a classe FloorButton, implica que a classe Elevator precisa de \line cisa abrir uma opera\'e7\'e3o sununonElevator. A frase \ldblquote avisa o elevador para se mover\rdblquote , listada com a classe ElevatorButton, nDoor e implica que a classe Elevator precisa prestar um servi\'e7o \ldblquote mover-se\rdblquote . Antes que o elevador possa se mover, \line entretanto, o elevador precisa fechar aporta. Portanto, listar uma opera\'e7\'e3o prepareToLeave. na qual o elevador \line ressante. executa as a\'e7\'f5es necess\'e1rias antes de se mover, sob a classe Elevator. parece uma escolha mais apropriada. \line na opera- As frases listadas com a classe Door implicam que a porta envie uma mensagem para uma pessoa para dizer a ela que saia do elevador ou entre no elevador. Criamos duas opera\'e7\'f5es para a classe Person para cobrir estes \line cnar uma comportamentos \f2\fs8 - \b\f1\fs18 exitElevator e enterElevator. \line\b0 im andar. Por enquanto, n\'e3o nos preocupamos demais com os par\'e2metros ou tipos de valores devolvidos; estamos \i\fs20 tcheduler \i0\fs18 tentando somente obter um entendimento b\'e1sico das opera\'e7\'f5es de cada classe. A medida que continuarmos em seguintes nosso processo de projeto, o n\'famero de opera\'e7\'f5es pertencentes a cada classe pode variar \f2\fs8 - \f1\fs18 podemos descobrir que \line s\'e3o necess\'e1rias novas opera\'e7\'f5es ou que algumas das opera\'e7\'f5es atuais s\'e3o desnecess\'e1rias. \line\b\i\fs22 Diagramas de seq\'fc\'eancia \line\b0\i0\fs18 Podemos usar o diagrama de seq\'fc\'eancia da UML (ver Fig. 4.26) para modelar nosso \ldblquote la\'e7o de simula\'e7\'e3o\rdblquote  \f2\fs8 - \f1\fs18 as etapas da discuss\'e3o precedente que o edif\'edcio repete enquanto durar a simula\'e7\'e3o. O diagrama de seq\'fc\'eancia enfoca como as mensagens s\'e3o enviadas entre objetos ao longo do tempo. \line e moven \line edif\'edcio \line deve ser Neste ponto, podemos apenas adivinhar o que fazem estas opera\'e7\'f5es. Por exemplo, talvez estas opera\'e7\'f5es modelem elevadores do mundo real com um sensor que detecta quando entram e saem passageiros. Por enquanto, simplesmente listamos estas opera\'e7\'f5es. Descobriremos quais a\'e7\'f5es esta classe executa, se for o caso, quando nos concentrarmos na implementa\'e7\'e3o de nosso simulador em C++. \fs24\par
\f2\fs18 302 \fs28 c++ \b\fs16 COMO \f1\fs14 PROGRAMAR \b0\fs24\par
\f2\fs20 : \ul Building : Clock : Scheduler : Elevator \line tick() \ulnone\f1\fs12 1 1 \ul 1 \f2\fs20 getTime( \ulnone ) \f1\fs12 1 \line\f2\fs20 processTime (cLirrentTime : int) \line\ul\f1\fs12 III \ulnone\line\f3\fs114 q \line\ul\f2\fs20 processjme (currentTim : int) \ulnone\line\f3\fs34 < \f2\fs8\ldblquote  \f3\fs84 H \line\f2\fs20 Fig. 4.26 Diagrama de seq\'fc\'eancia modelando um la\'e7o de simula\'e7\'e3o. \line Cada objeto \'e9 representado por um ret\'e2ngulo no topo do diagrama. O nome do objeto \'e9 colocado dentro do ret\'e2ngulo. Escrevemos nomes de objetos no diagrama de seq\'fc\'eancia usando a conven\'e7\'e3o que apresentamos com o diagrama de objetos, na se\'e7\'e3o \ldblquote Pensando em objetos\rdblquote  no fim do Cap\'edtulo 2 (Fig. 2.45). A linha tracejada que se estende para baixo, a partir do ret\'e2ngulo de um objeto, \'e9 a \i\f1\fs18 linha de vida \i0\f2\fs20 deste objeto. A linha de vida representa a progress\'e3o do tempo. A\'e7\'f5es acontecem ao longo da linha de vida de um objeto em ordem cronol\'f3gica, de cima para baixo \fs8 - \fs20 uma a\'e7\'e3o pr\'f3xima ao topo de uma linha de vida acontece antes de uma a\'e7\'e3o pr\'f3xima \'e0 base. \line Uma mensagem entre dois objetos em um diagrama de seq\'fc\'eancia \'e9 representada como uma linha cheia com \line uma seta na ponta, que parte do objeto que envia aquela mensagem e chega no objeto que recebe a mensagem. O \f3\fs34 1 \f2\fs20 nome da mensagem aparece acima da linha da mensagem e deve incluir quaisquer par\'e2metros que sejam passa- dos. Por exemplo, o objeto da classe Building envia a mensagem processTime para o objeto da classe \line\b\f1\fs18 Elevator. \f2 O \f1 nome da \b0\f2\fs20 mensagem aparece acima da linha da mensagem e o nome do par\'e2metro ( currentTime) aparece entre par\'eanteses \'e0 direita da mensagem; cada nome de par\'e2metro \'e9 seguido por dois-pontos e o tipo do par\'e2metro. \line Se um objeto devolve o fluxo de controle ou se um objeto devolve um valor, uma mensagem de retorno \line (representada como uma linha tracejada com uma seta na ponta) parte do objeto que est\'e1 devolvendo o controle para \line o objeto que inicialmente enviou a mensagem. Por exemplo, um objeto da classe Clock devolve time em resposta \line\'e0 mensagem getTime recebida de um objeto da classe Building. \line Cada um dos ret\'e2ngulos ao longo das linhas de vida dos objetos \fs8 - \fs20 chamados de \i\f1\fs18 ativa\'e7\'f5es \i0\f2\fs8 - \fs20 representa a \line dura\'e7\'e3o de uma atividade. Uma ativa\'e7\'e3o \'e9 iniciada quando um objeto recebe uma mensagem e \'e9 indicada por um \f3\fs34 ,f1 \f2\fs20 ret\'e2ngulo na linha de vida deste objeto. A altura do ret\'e2ngulo corresponde \'e0 dura\'e7\'e3o da atividade ou atividades \fs28 : \fs20 iniciadas pela mensagem \fs8 - \fs20 quanto mais longa a dura\'e7\'e3o da atividade, mais alto \'e9 o ret\'e2ngulo. \line O texto na extremidade esquerda do diagrama na Fig. 4.26 indica uma restri\'e7\'e3o de temporiza\'e7\'e3o. Enquanto a \line hora atual \'e9 menor do que o tempo total de simula\'e7\'e3o (currentTime \b\fs16 < totalTime), \b0\fs20 os objetos continuam enviando mensagens uns para os outros, na seq\'fc\'eancia modelada no diagrama. \line A Fig. 4.27 modela como o \i\f1\fs18 scheduler \i0\f2\fs20 manipula o tempo e cria novas pessoas para entrar nos andares. Para este diagrama, supomos que o \i\f1\fs18 scheduler \i0\f2\fs20 escalonou uma pessoa para entrar em cada um dos dois andares em um \line momento que coincide com a hora fornecida pelo edif\'edcio. Sigamos o fluxo de mensagens atrav\'e9s deste diagrama de seq\'fc\'eancia. \f1\fs24\par
\f2\fs16\{currentTime < totalTime\} \f1\fs24\par
\b\f2\fs14 CAP\'cdTULO \b0\fs16 4 \fs8 - \b\fs14 ARRAYS \b0\fs16 303 \line\ul\fs34 l_ \fs16 jding BuiId9J \fs34 1 \fs16 scheduler : Scheduler \ulnone\b\fs8 1 \b0\fs16 [2 \ul : \line iir1:FIoQrl \line isOccupied( \fs24 ) : bool \ulnone\line\b\fs14 1 \b0\fs16 boI \line\'e7_ 1 \b\fs12 1 \line\\ \b0\fs16 [occupied \fs10 = \fs16 false] 1 \line\'abcreate\'bbr \line 1 personArrives(\rquote ) \line\fs8 - 1 \line\fs16 )schedJIeArrivaI (floorl1) \line\b\i\fs10 1 \b0\i0\fs16 1 \line isOcdupied( \fs24 ) : bool \fs16 i \line\b\fs12 1 1 \line\b0\fs16 1 1 \line\i\f1\fs18 re \i0\f2\fs16 :chIeArriv (floo9) 1 \'abc \line\ul 1 personArives( \fs24 ) \fs16 1 \ulnone\line 1 1 \line 1 1 \line\fs10 , \b\fs12 1 \line 7 \line\lquote  1 1 \b0\f1\fs24\par
\f2\fs20 processTime (time) \f1\fs24\par
\f2\fs16 [occupied \fs10 = \fs16 true] \f1\fs24\par
\f2\fs20 delayArrival (floc \f1\fs24\par
\b\f2\fs8 / \b0\f1\fs24\par
\b\f2\fs8 7 \b0\f1\fs24\par
\fs18 ret\'e2nguliagrama nde para ess\'e3o do o \f2\fs8 - \f1\fs18 uma \fs24\par
\f2 (\\ \line\b\fs8\\ \b0\fs16 [occupied \fs10 = \fs16 false] \f1\fs24\par
\f2\fs16 [occupied \fs10 = \fs16 true] \f1\fs24\par
\fs18 leia com agem. O \b\f2\fs14 Il \b0\f1\fs18 passa- [a classe tTime) \line )tipodo \fs24\par
\f2\fs20 delayArrival (fio \f1\fs24\par
\fs20 retorno role para resposta \fs24\par
\fs18 esenta a \f2\fs12 1 \f1\fs18 por um ividades \fs24\par
\b\f2\fs18 Fig. 4.27 \b0 Diagrama de seq\'fc\'eancia para o processo de agendamento. \f1\fs24\par
\fs20 quanto a ntinuam \fs24\par
\fs20 es. Para em um rama de \fs24\par
\fs18 Inicialmente, o objeto Building envia a mensagem processTime para o scheduler. passando a hora atual. O objeto scheduler precisa ent\'e3o decidir se deve criar uma pessoa para entrar no primeiro andar (representado pelo objeto floori da classe Floor). A defini\'e7\'e3o do problema nos diz que o scheduler precisa primeiro verificar se o andar est\'e1 desocupado antes que possa criar uma nova pessoa para entrar naquele andar. Portanto, o objeto scheduler envia uma mensagem isOccupied para o objeto floori para realizar esta tarefa. \line O objeto floori devolve true ou false (indicado pela linha tracejada de mensagem de retomo e pelo tipo boo1. Neste ponto. a linha de vida do objeto scheduler se divide em duas linhas de vida paralelas para representar cada seq\'fc\'eancia poss\'edvel de mensagens que o objeto pode enviar, com base no valor devolvido pelo objeto floori. A linha de vida de um objeto pode se dividir em duas ou mais linhas de vida para indicar a \i execu\'e7\'e3o condicional de atividades. \i0 Para cada linha de vida, deve ser especificada uma condi\'e7\'e3o. A(s) nova(s) linha(s) de vida corre(m) em paralelo com a linha de vida principal e as linhas de vida podem convergir em algum ponto mais adiante. \fs24\par
\b\f2\fs18 304 \b0\fs28 c++ \b\fs14 COMO PROGRAMAR \line\b0\f1\fs16 Se o objeto floori devolve true (i.e., o andar est\'e1 ocupado), o scheduler chama sua pr\'f3pria fun\'e7\'e3o delayArrival, passando um par\'e2metro que indica que o tempo de chegada no andar 1 precisa ser reescalonado. Esta fun\'e7\'e3o n\'e3o \'e9 uma opera\'e7\'e3o da classe Schedu].er porque n\'e3o \'e9 invocada por outro objeto. A fun\'e7\'e3o delayArrival \'e9 simplesmente uma atividade que a classe Scheduler executa dentro de uma opera\'e7\'e3o. Note que, quando o objeto scheduler envia uma mensagem para si mesmo (i.e., invoca uma de suas pr\'f3prias fun\'e7\'f5es membro), a barra de ativa\'e7\'e3o para esta mensagem est\'e1 alinhada sobre a borda direita da barra de ativa\'e7\'e3o corrente. \line Se o objeto floori devolve false (i.e., o andar est\'e1 desocupado), o scheduler cria um novo objeto da classe Person. Em um diagrama de seq\'fc\'eancia, quando \'e9 criado um novo objeto, o ret\'e2ngulo do novo objeto \'e9 colocado em uma posi\'e7\'e3o vertical que corresponde ao momento em que o objeto \'e9 criado. Um objeto que cria outro objeto envia uma mensagem com a palavra \ldblquote create\rdblquote  colocada entre os sinais (\'ab \b\f2\fs18\'bb). \b0\f1\fs16 A seta na ponta desta mensagem aponta para o ret\'e2ngulo do novo objeto. Um \ldblquote X\rdblquote grande no fim da linha de vida de um objeto indica a destrui\'e7\'e3o daquele objeto. [Nota: nosso diagrama de seq\'fc\'eancia n\'e3o modela a destrui\'e7\'e3o de nenhum objeto da classe Person portanto, n\'e3o aparece nenhum \ldblquote X\rdblquote  no diagrama. A cria\'e7\'e3o e a destrui\'e7\'e3o de objetos de forma din\'e2mica, usando os operadores new e delete s\'e3o discutidas no Cap\'edtulo 71. \line Depois que um novo objeto da classe Person \'e9 criado, a pessoa precisa, a seguir, entrar no primeiro andar. \line Portanto, o novo objeto Person envia uma mensagem personArrives para o objeto f].oorl. Esta mensagem avisa o objeto floori de que uma pessoa est\'e1 entrando nele. \line Depois que o objeto scheduler criou um novo objeto da classe Person, ele escalona uma nova chegada para floori. O objeto scheduler invoca sua pr\'f3pria fun\'e7\'e3o scheduleArrival e a barra de ativa\'e7\'e3o para esta chamada \'e9 centrada na borda direita da barra de ativa\'e7\'e3o corrente. A fun\'e7\'e3o scheduleArrival n\'e3o \'e9 uma opera\'e7\'e3o; \'e9 uma atividade que a classe Scheduler executa dentro de uma opera\'e7\'e3o. Neste ponto, as duas linhas de vida convergem. O objeto scheduler, ent\'e3o, trata do segundo andar da mesma maneira que o primeiro. Quando o \i\fs18 scheduler \i0\fs16 terminou com floor2, o objeto scheduler devolve o controle para o objeto building. \line Nesta se\'e7\'e3o, discutimos as opera\'e7\'f5es de classes e apresentamos o diagrama de seq\'fc\'eancia da UML para ilustrar estas opera\'e7\'f5es. Na se\'e7\'e3o \ldblquote Pensando em objetos\rdblquote  no fim do Cap\'edtulo 5, examinamos como os objetos em um sistema interagem uns com os outros para executar uma tarefa espec\'edfica e come\'e7amos a implementar nosso simulador de elevador em C++. \line\b\i\f2\fs26 Resumo \line\b0\i0\fs10 . \f1\fs16 C++ armazena listas de valores em arrays. Um array \'e9 um grupo de posi\'e7\'f5es de mem\'f3ria consecutivas relacionadas. Estas posi\'e7\'f5es s\'e3o relacionadas pelo fato de que todas elas t\'eam o mesmo nome e o mesmo tipo. Para se referir a uma posi\'e7\'e3o ou elemento particular no array, especificamos o nome do array e o subscrito. O subscrito indica o n\'famero de elementos a partir do in\'edcio do array. \line\f2\fs10 . \f1\fs16 Um subscrito pode ser um inteiro ou uma express\'e3o inteira. As express\'f5es de subscritos s\'e3o avaliadas para determinar o elemento particular do array. \line\f2\fs10 . \f3\fs24\'c9 \f1\fs16 importante notar a diferen\'e7a ao se referir ao s\'e9timo elemento do array em vez do elemento sete do array. O s\'e9timo elemento tem um subscrito 6, enquanto o elemento sete do array tem um subscrito 7 (na realidade, \'e9 o oitavo elemento do array). Isso \'e9 fonte de \ldblquote erros por um\rdblquote . \line\f2\fs10 . \f1\fs22 os arrays ocupam espa\'e7o na mem\'f3ria. Para reservar 100 elementos para o array inteiro b e 27 elementos para o array inteiro \b\f2\fs16 x, \b0\f1 o programador deve escrever \line\b\f0 int b[ 100 \f2\fs18 ], \f0\fs16 x[ 27 \f2\fs18 1; \line\b0\fs10 . \f1\fs16 Pode ser usado um array do tipo char para armazenar um \i\fs18 string \i0\fs16 de caracteres. \line\f2\fs10 . \f1\fs16 Os elementos de um array podem ser inicializados de tr\'eas maneiras: por declara\'e7\'e3o, por atribui\'e7\'e3o e por entrada de dados. \line\f2\fs10 . \f1\fs16 Se houver menos inicializadores do que elementos do array, C++ inicializa os elementos restantes com o valor zero. \line\f2\fs10 . \f1\fs16 A linguagem C++ n\'e3o evita a refer\'eancia a elementos al\'e9m dos limites do array. \line\f2\fs10 . \f1\fs16 Um array de caracteres pode ser inicializado por meio de um \i\fs18 string \i0\fs16 literal. \line\f2\fs10 . \f1\fs16 Todos os \i\fs18 strings \i0\fs16 em C++ terminam com o caractere nulo \b\f2\fs18 ( \b0\fs8\lquote  \b\fs18\\ \b0\f1\fs16 O \f2\fs8\lquote  \b\fs18 ) \line\b0\fs10 . \f1\fs16 Os arrays de caracteres podem ser inicializados com constantes de caracteres em uma lista de inicializadores. \fs24\par
\b\fs14 CAP\'cdTULO \b0\fs16 4 \f2\fs8 - \b\f1\fs14 ARRAYS \i\f2\fs24 305 \line\b0\i0\fs10 . \f3\fs22\'c9 \f1\fs16 poss\'edvel ter acesso direto a cada caractere de um string armazenado em um array utilizando a nota\'e7\'e3o de subscritos de array. \line\f2\fs10 . \f1\fs16 Para passar um array a uma fun\'e7\'e3o, o nome do array \'e9 passado. Para passar um elemento espec\'edfico de um array para uma fun\'e7\'e3o, simplesmente passe o nome do array seguido do subscrito (entre colchetes) do elemento em particular. \line\f2\fs10 . \f1\fs16 A linguagem C++ passa arrays para fun\'e7\'f5es usando chamada por refer\'eancia simulada \f2\fs8 - \f1\fs16 as fun\'e7\'f5es chamadas podem modificar os valores dos elementos nos arrays originais dos chamadores. O nome do array \'e9 o endere\'e7o de seu primeiro elemento. Por ser passado o endere\'e7o inicial do array, a fun\'e7\'e3o chamada sabe precisamente onde o array est\'e1 armazenado. \line\f2\fs10 . \f1\fs16 Para receber um array como argumento, a lista de par\'e2metros da fun\'e7\'e3o deve especificar que um array ser\'e1 recebido. Para um array unidimensional passado como par\'e2metro, n\'e3o \'e9 exigido o tamanho do array entre colchetes. \line\f2\fs10 . \fs26 c++ \f1\fs16 fornece o qualificador de tipo const para evitar a modifica\'e7\'e3o dos valores dos arrays em uma fun\'e7\'e3o. Quando um par\'e2metro array \'e9 precedido pelo qualificador const, os elementos do array se tornam constantes no corpo da fun\'e7\'e3o, e qualquer tentativa de modificar um elemento ali situado resulta em um erro durante a compila\'e7\'e3o. \line\f2\fs10 . \f1\fs16 Um array pode ser ordenado usando o algoritmo de \i\fs18 bubble sort. \i0\fs16 S\'e3o feitas v\'e1rias passagens pelo array. Em cada passagem, s\'e3o comparados pares sucessivos de elementos. Se um par estiver em ordem (ou se os valores forem id\'eanticos), tudo fica como estava. Se um par estiver fora de ordem, os valores s\'e3o permutados. Para arrays pequenos, o \i\fs18 bubble sort \'e9 \i0\fs16 aceit\'e1vel, mas para arrays grandes ele \'e9 ineficiente comparado com outros algoritmos de classifica\'e7\'e3o mais sofisticados. \line\f2\fs10 . \f1\fs16 A pesquisa linear compara cada elemento do array com a chave de busca. Como o array n\'e3o se encontra em nenhuma ordem determinada, as probabilidades de o elemento ser o primeiro ou o \'faltimo s\'e3o as mesmas. Na m\'e9dia, portanto, o programa precisar\'e1 comparar a chave de busca com metade dos elementos do array. O m\'e9todo de pesquisa linear funciona bem com arrays pequenos e \'e9 aceit\'e1vel para arrays que n\'e3o estejam ordenados. \line\f2\fs10 . \f1\fs16 A pesquisa bin\'e1ria elimina metade dos elementos do array que est\'e1 sendo pesquisado ap\'f3s cada compara\'e7\'e3o. O algoritmo localiza o elemento no meio do array e o compara com a chave de busca. Se forem iguais, a chave de busca foi encontrada e o subscrito do array daquele elemento \'e9 retornado. Se n\'e3o forem iguais, o problema \'e9 reduzido para a pesquisa em metade do array. \line\f2\fs10 . \f1\fs16 Na pior hip\'f3tese, pesquisar um array de 1024 elementos, utilizando pesquisa bin\'e1ria, precisar\'e1 de apenas lO compara\'e7\'f5es. \line\f2\fs10 . \f1\fs16 Os arrays podem ser usados para representar tabelas de valores que consistem em informa\'e7\'f5es organizadas em linhas e colunas. Para identificar um elemento espec\'edfico de uma tabela, s\'e3o especificados dois subscritos: o primeiro (por conven\'e7\'e3o) identifica a linha, e o segundo (por conven\'e7\'e3o) identifica a coluna na qual o elemento est\'e1 contido. As tabelas ou arrays que exigem dois subscritos para identificar um determinado elemento s\'e3o chamados de arrays bidimensionais. \line\f2\fs10 . \f1\fs16 Quando recebemos um array de um \'fanico subscrito como argumento de uma fun\'e7\'e3o, os colchetes est\'e3o vazios na lista de par\'e2metros da fun\'e7\'e3o. O primeiro subscrito de um array multidimensional tamb\'e9m n\'e3o \'e9 exigido, mas todos os subscritos subseq\'fcentes o s\'e3o. O compilador usa esses subscritos para determinar, na mem\'f3ria, os locais dos elementos de um array multidimensional. \line\f2\fs10 . \f1\fs16 Para passar uma linha de um array bidimensional para uma fun\'e7\'e3o que recebe um array de um subscrito, simplesmente passe o nome do array seguido do primeiro subscrito. \line\b\i\f2\fs24 Terminologia \line\b0\f1\fs18 a[ \b\i0\fs14 i \i\f2\fs24 ] \b0\i0\f1\fs16\ldblquote erroporum\rdblquote  \line\i\fs18 a[ \i0\fs16 i \b\i\f2\fs24 )[ \b0\i0\f3\fs22 j ] \f1\fs16 escalar \line\'e1rea tempor\'e1ria para permuta de valores escalabilidade \line array formato de tabela \line array bidimensional inicializar um array \line array tridimensional inicializador \line array multidimensional nome de um array \line array unidimensional n\'famero da posi\'e7\'e3o \line array \i\fs18 m \i0\fs16 por \i\fs18 n \i0\fs16 n\'famero m\'e1gico \line lista de inicializadores de um array passagem do \i\fs18 bubble sort \line\i0\fs16 vari\'e1vel constante passagem por refer\'eancia \line\i\fs18 bubble .sort \i0\fs16 passando arrays para fun\'e7\'f5es \line pesquisa linear em um array pesquisa bin\'e1ria em um array \line caractere nulo (\\O\rquote ) pesquisar um array \line chave de pesquisa \ldblquote sair de\rdblquote  um array \line colchetes \f3\fs22 [ 1 \f1\fs16 chamada por refer\'eancia simulada \fs24\par
\b\f2\fs20 306 \b0\fs28 c++ \b\fs20 COMO \f1\fs14 PROGRAMAR \b0\fs24\par
\b\i\f2 Terminologia de \ldblquote Pensando em objetos\rdblquote  \b0\i0\f1\par
\b\i\f2 Erros comuns de programa\'e7\'e3o \b0\i0\f1\par
\fs16 4.1 \f3\fs24\'c9 \f1\fs16 importante observar a diferen\'e7a entre o \ldblquote s\'e9timo elemento do array\rdblquote  e o \ldblquote elemento n\'famero sete do array\rdblquote . Como os subscritos dos arrays iniciam em O, o \ldblquote s\'e9timo elemento do array\rdblquote  tem subscrito 6, ao passo que o \ldblquote elemento n\'famero sete \line do array\rdblquote  tem subscrito 7 e, na realidade, \'e9 o oitavo elemento do array. Esse fato \'e9 uma fonte de \ldblquote erros por um\rdblquote . \line 4.2 Esquecer de inicializar os elementos de um array cujos elementos precisam ser inicializados \'e9 um erro de l\'f3gica. \line 4.3 Fornecer mais inicializadores para um array do que o n\'famero de seus elementos \'e9 um erro de sintaxe. \line 4.4 Atribuir um valor a uma vari\'e1vel constante em um comando execut\'e1vel \'e9 um erro de sintaxe. \line\b\i\f2\fs18 4.5 \b0\i0\f1\fs16 Somente constantes devem ser usadas para declarar arrays autom\'e1ticos e est\'e1ticos. N\'e3o usar uma constante para esta finalidade \'e9 um eno de sintaxe. \line 4.6 Fazer refer\'eancia a um elemento al\'e9m dos limites de um array \'e9 um erro de l\'f3gica que ocorre durante a execu\'e7\'e3o. N\'e3o \'e9 um erro de sintaxe. \line\b\i\f2\fs18 4.7 \b0\i0\f1\fs16 Embora seja poss\'edvel usar a mesma vari\'e1vel contadora de um Ja\'e7o for em um segundo la\'e7o for aninhado no interior do primeiro, isto \'e9 normalmente um erro de l\'f3gica. \line\b\f2 4. \b0\f1 N\'e3o fornecer a cm \f2\fs20\'bb \f1\fs16 um array de caracteres com comprimento suficiente para armazenar um \i string \i0 digitado no teclado pode resultar na perda de dados em um programa e em outros erros s\'e9rios durante a execu\'e7\'e3o. \line\b\f2 4.9 \b0\f1 Supor que os elementos de um array local declarado static s\'e3o inicializados com zeros sempre que a fun\'e7\'e3o na qual o array \'e9 declarado for chamada, pode levar a erros em um programa. \line\b\f2 4. 1 O \b0\f1 Esquecer que arrays s\'e3o passados por refer\'eancia e, portanto, podem ser modificados, pode resultar em um erro de l\'f3gica. \line\b\f2 4. 1 1 \b0\f1 Referenciar um elemento de array a [ x 1 [ y ] \f2\fs8 , \f1\fs16 incorretamente, com subscritos como a [ x \f2\fs8 , \i\f1\fs16 y \b\i0\f2\fs22 ] \b0\fs8 . \f1\fs16 Na realidade. a \b\f2 x \b0\fs8 , \i\f1\fs16 y \b\i0\f2\fs22 ] \b0\f1\fs16\'e9 tratado como a [ y ] porque C\'f7\'f7 calcula o valor da express\'e3o x \f2\fs8 , \i\f1\fs16 y \i0 (contendo um operador v\'edrgula) simplesmente como y (a \'faltima das express\'f5es separadas por v\'edrgulas). \fs24\par
\b\i\f2 Boas pr\'e1ticas de programa\'e7\'e3o \b0\i0\f1\par
\fs16 4.1 Definir o tamanho do array como uma vari\'e1vel constante. em vez de se usar uma constante, toma os programas mais claros. Esta t\'e9cnica \'e9 usada para se eliminar os chamados \i n\'fameros m\'e1gicos; \i0 ou seja, mencionar repetidamente o n\'famero lo no c\'f3digo que processa um array de 10 elementos d\'e1 ao n\'famero 10 um significado artificial, podendo infelizmente confundir o leitor quando tamb\'e9m existirem no programa outros n\'fameros 1 O que nada t\'eam a ver com o tamanho do array. \line 4.2 Procure obter clareza nos programas. Algumas vezes, vale a pena trocar um uso mais eficiente da mem\'f3ria e do processador por programas escritos com maior clareza. \line 4.3 Alguns programadores incluem nomes de vari\'e1veis em prot\'f3tipos de fun\'e7\'f5es para tomar os programas mais claros. O compilador ignora esses nomes. \fs24\par
\fs16 qualificador de tipo const \i .sinking sort \line\i0 classificar um array constante com nome declarar um array elemento de um array elemento de ordem zero \fs24\par
\i\fs16 string \line\i0 subscrito subscrito de coluna subscrito de linha tabela de valores valor de um elemento verifica\'e7\'e3o dos limites \fs24\par
\fs18 colabora\'e7\'e3o \line comportamento \line diagrama de seq\'fc\'eancia \line dividindo a linha de vida de um objeto \line dura\'e7\'e3o de atividade \line execu\'e7\'e3o condicional de atividades \line fluxo de mensagens em diagrama de seq\'fc\'eancia UML la\'e7o de simula\'e7\'e3o \line linha de vida de um objeto em diagrama de seq\'fc\'eancia UML linha s\'f3lida com seta na ponta em diagrama de seq\'fc\'eancia mensagem \fs24\par
\fs18 objeto cliente \line objeto servidor \line opera\'e7\'e3o \line servi\'e7o que um objeto presta \line s\'edmbolo ret\'e2ngulo de ativa\'e7\'e3o em diagrama de seq\'fc\'eancia \line UML \line s\'edmbolo de devolu\'e7\'e3o de mensagem em diagrama de seq\'fc\'eancia UML \line s\'edmbolo de objeto em um diagrama de seq\'fc\'eancia UML tipo de retomo de uma operac\'e3o \line verbos em uma defini\'e7\'e3o de problema \fs24\par
\fs16 CAP\'cdTULO \b\fs18 4 \b0\f2\fs8 - \f1\fs16 ARRAYS \b\f2\fs22 307 \b0\f1\fs24\par
\b\i\f2 Dicas de desempenho \line\i0\f1\fs18 4.1 \b0 Se, em vez de inicializar um array com comandos de atribui\'e7\'e3o durante a execu\'e7\'e3o, voc\'ea inicializar o array durante a compila\'e7\'e3o com uma lista de inicializadores de array, seu programa ser\'e1 executado mais rapidamente. \line 4.2 Algumas vezes, as considera\'e7\'f5es de desempenho s\'e3o muito mais importantes do que as considera\'e7\'f5es de clareza. \line 4.3 Podemos aplicar static a uma declara\'e7\'e3o de um array local de modo que o array n\'e3o seja criado e inicializado. cada vez que a fun\'e7\'e3o \'e9 chamada, e destru\'eddo cada vez que a execu\'e7\'e3o deixa a fun\'e7\'e3o. Isto melhora o desempenho. \line 4.4 Faz sentido passar arrays atrav\'e9s de chamadas por refer\'eancia simuladas, por motivos de desempenho. Se os arrays fossem passados por chamadas por valor, seria passada uma c\'f3pia de cada elemento. Para arrays grandes, passados freq\'fcentemente, isso seria demorado e consumiria um espa\'e7o consider\'e1vel para armazenar as c\'f3pias dos arrays. \line 4.5 Freq\'fcentemente, os algoritmos mais simples apresentam um desempenho muito ruim. Sua virtude reside no fato de que s\'e3o f\'e1ceis de escrever, testar e depurar. Algumas vezes, por\'e9m, s\'e3o necess\'e1rios algoritmos mais complexos para se atingir o melhor desempenho poss\'edvel. \line 4.6 Os tremendos ganhos em desempenho da pesquisa bin\'e1ria em rela\'e7\'e3o \'e0 linear n\'e3o s\'e3o obtidos sem um pre\'e7o. Classificar um array \'e9 uma opera\'e7\'e3o cara, comparada com pesquisar todo um array em busca de um \'fanico item, uma vez s\'f3. O \i\fs16 overhead \i0\fs18 de classificar um array passa a valer a pena quando o array necessitar\'e1 ser pesquisado muitas vezes em alta velocidade. \line\b\i\f2\fs24 Dica de portabilidade \line\b0\i0\f1\fs18 4.1 Os efeitos (geralmente graves) da refer\'eancia a elementos situados fora dos limites de um array dependem dos sistemas. Freq\'fcentemente, isso resulta em altera\'e7\'e3o do valor de uma vari\'e1vel n\'e3o-relacionada. \line\b\i\f2\fs24 Observa\'e7\'f5es de engenharia de software \line\b0\i0\f1\fs18 4.1 Definir o tamanho de cada array com uma vari\'e1vel constante toma os programas mais flex\'edveis. \line 4.2 E poss\'edvel passar um array por valor (usando um truque simples explicado no Cap\'edtulo 6) \f2\fs8 - \f1\fs18 isso raramente \'e9 feito. \line 4.3 O qualificador de tipo const pode ser aplicado a um par\'e2metro de um arras em uma defini\'e7\'e3o de fun\'e7\'e3o para evitar que o array original seja modificado no corpo da fun\'e7\'e3o. Esse \'e9 outro exemplo do princ\'edpio do m\'ednimo privil\'e9gio. As fun\'e7\'f5es n\'e3o devem ter a capacidade de modificar um array, a menos que isso seja absolutamente necess\'e1rio. \line\b\i\f2\fs24 Dicas de teste e depura \'e7\'e3o \line\b0\i0\f1\fs18 4.1 Ao usar um la\'e7o para percorrer um array, os subscritos nunca devem ser menores do que O e sempre devem ser menores do que o n\'famero total de elementos do array (um a menos que o tamanho do array). Certifique-se de que a condi\'e7\'e3o de t\'e9rmino do la\'e7o evita o acesso a elementos fora desses limites. \line 4.2 Os programas devem verificar a exatid\'e3o de todos os valores de entrada para evitar que informa\'e7\'f5es erradas afetem os c\'e1lculos executados pelo programa. \line\b 4.3 \b0 Quando estudarmos classes (a partir do Cap\'edtulo 6), veremos como desenvolver um \ldblquote array inteligente\rdblquote , que verifica automaticamente se os subscritos em todas as refer\'eancias est\'e3o dentro dos limites durante a execu\'e7\'e3o. O uso de tais tipos de dados inteligentes ajuda a eliminar erros. \line 4.4 Embora seja poss\'edvel modificar um contador de la\'e7o no corpo de um for, evite fazer isso porque essa pr\'e1tica freq\'fcentemente leva \'e0 ocorr\'eancia de erros sutis. \line\b\i\f2\fs24 Exerc\'edcios de auto-revis\'e3o \line\i0\f1\fs18 4.1 \b0 Complete os espa\'e7os em branco: \line a) Listas e tabelas de valores s\'e3o armazenadas em \f2\fs8 _______________ \line\f1\fs18 b) Os elementos de um array s\'e3o relacionados entre si pelo fato de que possuem o mesmo \f2\fs8 _______ \f1\fs18 e \f2\fs8 _______ \line\f1\fs18 c O n\'famero usado para fazer refer\'eancia a um elemento espec\'edfico de um array \'e9 chamado de \f2\fs8 _______________ \line\f1\fs18 d) Deve ser usado um(a) para declarar o tamanho de um array porque isso torna os programas mais flex\'edveis. \line e) O processo de colocar em ordem os elementos de um array \'e9 chamado de \f2\fs8 ______ \f1\fs18 de um array. \line f) O processo de determinar se um array cont\'e9m um valor-chave espec\'edfico \'e9 chamado de \f2\fs8 ___________ \f1\fs18 o array. \line g) Um array que usa dois subscritos \'e9 chamado um array \fs24\par
\b\f2\fs20 30S \b0\fs28 c++ \b\fs14 COMO PROGRAMAR \line\b0\f1\fs16 4.2 Diga se cada uma das senten\'e7as a seguir \'e9 \i verdadeira oufalsa. \i0 Se a resposta \i forfalsa, \i0 explique o motivo. \line a) Um array pode armazenar muitos tipos diferentes de valores. \line b) Um subscrito de array pode ser do tipo de dado float. \line c) Se houver menos inicializadores em uma lista do que o n\'famero de elementos no array, C++ inicializa automaticament,e os elementos restantes com o \'faltimo valor da lista de inicializadores. \line d) E um erro se uma lista de inicializadores possuir mais inicializadores do que o n\'famero de elementos do array. \line e) Um elemento individual de um array que for passado a uma fun\'e7\'e3o e modificado pela fun\'e7\'e3o chamada manter\'e1 o valor modificado quando a fun\'e7\'e3o chamada terminar sua execu\'e7\'e3o. \line 4.3 Responda \'e0s seguintes perguntas a respeito de um array chamado fracoes. \line a) Defina uma vari\'e1vel constante tamanhoDoArray inicializada com 10. \line b) Declare um array com um n\'famero de elementos tamanhoDoArray, do tipo double. e inicialize os elementos com o valor O. \line e) D\'ea o nome do quarto elemento a partir do in\'edcio do array. \line d) Referencie o elemento 4 do array. \line e) Atribua o valor 1 \f2\fs8 . \f1\fs16 667 ao elemento nove do array. \line h) Atribua o valor 3 \f2\fs8 . \f1\fs16 333 ao s\'e9timo elemento do array. \line g) Imprima os elementos 6 e 9 do array com dois d\'edgitos de precis\'e3o \'e0 direita da casa decimal e mostre a sa\'edda que \'e9 realmente apresentada na tela. \line h) Imprima todos os elementos do array usando uma estrutura de repeti\'e7\'e3o for. Defina a vari\'e1vel inteira x como uma vari\'e1vel de controle para o la\'e7o. Mostre a sa\'edda do programa. \line 4.4 Responda \'e0s seguintes perguntas a respeito de um array chamado tabela. \line a) Declare o array como um array inteiro, com 3 linhas e 3 colunas. Considere que a vari\'e1vel constante tamarihoDoArray foi definida como 3. \line b) Quantos elementos cont\'e9m o array? \line c) Use uma estrutura de repeti\'e7\'e3o for para inicializar cada elemento do array com a soma de seus subscritos. Assuma que as vari\'e1veis inteiras x e y s\'e3o declaradas como vari\'e1veis de controle. \line d) Imprima os valores de cada elemento do array tabela. Assuma que o array foi inicializado com a declara\'e7\'e3o \line int tabela[ tamanhoDoArray \b\f2\fs20 ) [ \b0\f1\fs16 tamanhoDoArray \b\f2\fs20 ] \line\{ \{ \f0\fs18 1, 8 \}, \{ 2, 4, 6 \f2\fs20\}, \{ \f0\fs18 5 ) \}; \line\b0\f1\fs16 e as vari\'e1veis inteiras x e y s\'e3o declaradas como vari\'e1veis de controle. Mostre a sa\'edda. \line 4.5 Encontre o erro em cada um dos segmentos de programa a seguir e o corrija. \line a) #include <iostreain>; \line\b\f0\fs18 b) tamanhoDoArray \f1\fs12 = \f0\fs16 10; \b0\i\fs22 II \b\i0\fs16 taiuanhoDoArray foi declarado const \line\b0\f1 c) Pressuponha que int b \b\f2\fs20 [ \b0\f1\fs16 10 \b\f2\fs20 ] \f1\fs12 = \f2\fs20\{ \b0\f1\fs16 O \}; \line\b\f0 for \f2\fs20 ( \f0\fs16 int i \f1\fs12 = \f0\fs16 O; i \f1\fs12 <= \f0\fs16 10; i++ \line b[ i ] \f1\fs12 = \b0\fs16 1; \line d) Pressuponhaque irit a[ \b\f0\fs18 2 ][ 2 ] \f1\fs12 = \f2\fs20\{ \{ \b0\f1\fs16 1, \b\f0\fs18 2 \}, \{ 3, \f1\fs12 4 \f2\fs20\} \b0\f1\fs16\}; \line\b\f0 a[ 1, 1 \f2\fs20 ] \f1\fs12 = 5; \line\i\f2\fs24 Respostas dos exerc\'edcios de auto-revis\'e3o \line\b0\i0\f1\fs16 4.1 a) Arrays. b) Nome, tipo. c) Subscrito. d) Vari\'e1vel constante. \line e) Classifica\'e7\'e3o. t) Pesquisa. g) Bidimensional. \line\b\fs12 4.2 \b0\fs16 a) Falsa. Um array pode armazenar apenas valores do mesmo tipo. \line b) Falsa. Um subscrito de array deve ser um inteiro ou uma express\'e3o inteira. \line c) Falsa. C++ inicializa automaticamente os elementos restantes com zeros. \line d) Verdadeira. \line e) Falsa. Os elementos individuais de um array s\'e3o passados por meio de chamadas por valor. Se o array inteiro for passado a uma fun\'e7\'e3o, ent\'e3o quaisquer modifica\'e7\'f5es se refletir\'e3o no original. \line\b\f0\fs18 4.3 \b0\f1\fs16 a) const int tamanhoDoArray \b\fs12 = 10; \line\b0\fs16 b) double fracoes \b\f2\fs20 [ \b0\f1\fs16 tamanhoDoArray \b\f2\fs20 ] \f1\fs12 = \f2\fs20\{ \b0\f1\fs16 O \}; \line c) fracoes[ 3 \b\f2\fs20 ] \line\f0\fs18 d) fracoes[ 4 \b0\f1\fs24\par
\b\f2\fs14 CAP\'cdTULO \fs20 4 \b0\fs8 - \b\fs14 ARRAYS \fs20 309 \line\f0\fs16 e) fracoes[ 9 \f2\fs20 ] \f0\fs16 1.667; \line f) fracoes[ 6 \f2\fs20 ] \f0\fs16 3.333; \line\b0\i\fs18 g) \b\i0\fs16 cout \'ab setiosflags( ios::fixed \b0\fs20 1 \b\fs16 ios::showpoint \line\b0\f2\fs20\'ab \b\f0\fs16 setprecision( 2 \f2\fs20 ) \f0\fs16\'ab fracoes[ 6 \b0\fs20 1\'ab \line\b\fs16\'abfracoes[ 9 \f2\fs20 ] \f0\fs16\'ab endi; \line\b0\i\fs18 Sa\'edda:3.33 \b\i0\fs16 1.67. \line h) for \f2\fs20 ( \f0\fs16 int x O; x \b0\f2\fs14 < \b\f0\fs16 tamanhoDoArray; x++ \line\b0\f1 cout\'ab \ldblquote fracoes \f2\fs14 [\ldblquote  \fs20\'ab \b\f1\fs16 x \b0\f2\fs20\'ab \f1\fs16\ldblquote j \f2\fs10 = \b\f0\fs16\'ab \b0\f1 fracoes \b\f2\fs20 [ \f1\fs16 x \line\b0\f2\fs20\'ab \f1\fs16 eridi; \line\i\f0\fs18 Sa\'edda: \line\b\i0\fs16 fracoes[ O \f2\fs20 ] \b0\f1\fs16 O \line\b\f0 fracoes[ 1 \f2\fs20 ] \f0\fs16 O \line fracoes[ 2 \f2\fs20 ] \b0\fs10 = \b\f0\fs16 O \line fracoes[ 3 \f2\fs20 1 \b0\fs10 = \b\f0\fs16 O \line fracoes[ 4 \f2\fs20 ] \b0\fs10 = \b\f0\fs16 O \line fracoes[ 5 \b0\fs20 1 \f2\fs10 = \b\f0\fs16 O \line fracoes[ 6 \f2\fs20 ] \b0\fs10 = \b\f0\fs16 3.333 \line fracoes[ 7 \f2\fs20 ] \b0\fs10 = \b\f0\fs16 O \line fracoes[ 8 \f2\fs20 ) \b0\fs10 = \b\f0\fs16 O \line fracoes[ 9 \f2\fs20 ] \b0\fs10 = \b\f0\fs16 1.667 \line\f2\fs18 4.4 \f1\fs16 a) int tabela \f2\fs20 [ \b0\f1\fs16 tamanhoDoArray \b\f2\fs20 ] [ \b0\f1\fs16 tamarihoDoArray ]; \line\b\f2\fs18 b) \b0\f1\fs16 Nove elementos. \line e) for \b\f2\fs20 ( \f1\fs16 x \b0\f2\fs10 = \b\f0\fs16 O; x < tamanhoDoArray; x++ \line\b0\f1 for \b\f2\fs20 ( \f0\fs16 y \b0\f2\fs10 = \b\f0\fs16 O; y < tamanhoDoArray; y++ \line\b0\f1 tabela[ x \b\f2\fs20 ][ \f0\fs16 y \f2\fs20 ] \f0\fs16 x + y; \line d)cout \'ab \b0\f2\fs8\ldblquote  \b\f0\fs16 [O] [1] [2]\rdblquote  \'ab endl; \line for \f2\fs20 ( \f0\fs16 int x \b0\f2\fs10 = \b\f0\fs16 O; x < tamanhoDoArray; x++ \f2\fs20 ) \{ \line\f0\fs16 cout \'ab \b0\f2\fs14 [\lquote  \fs20\'ab \b\f1\fs16 x \'ab \ldblquote ] \line\f0 for \f2\fs20 ( \f0\fs16 int y \b0\f2\fs10 = \b\f0\fs16 O; y < tamanhoDoArray; y++ \line\b0\f1 cout \'ab setw( 3 \b\f2\fs20 ) \f0\fs16\'ab \b0\f1 tabela[ x \b\f2\fs20 ] [ \b0\f1\fs16 y \b\f2\fs20 ] \f0\fs16\'ab \line cout \'ab endl; \line\b0\i\fs18 Sa\'edda: \line\b\i0\fs16 [O] [1] [2] \line [O] 1 8 O \line [1] 2 4 6 \line [2] 5 O O \line\b0\i\f2\fs18 4.5 \i0\f1\fs16 a) Erro: o ponto-e-v\'edrgula no final da diretiva de pr\'e9-processador #include. \line Corre\'e7\'e3o: elimine o ponto-e-v\'edrgula. \line\b\f2\fs18 b) Erro: \b0\f1\fs16 atribuir um valor a uma vari\'e1vel constante usando um comando de atribui\'e7\'e3o. \line Corre\'e7\'e3o: atribuir um valor a uma vari\'e1vel constante em uma declara\'e7\'e3o const int taxnanhoDoArray. \line\b\f0 e) \b0\f1 Erro: fazer refer\'eancia a um elemento al\'e9m dos limites do array (b [ 10 \b\f2\fs20 ]). \line\b0\f1\fs16 Corre\'e7\'e3o: mudar o valor final da vari\'e1vel de controle para 9. \line d) Erro: uso incorreto de subscritos do array. \line Corre\'e7\'e3o: mudar o comando para a [ 1 ] [ 1 ] \f2\fs10 = \f1\fs16 5; \line\b\i\f2\fs24 Exerc\'edcios \line\b0\i0\f1\fs16 4.6 Preencha as lacunas em cada uma das senten\'e7as a seguir: \line a) C++ armazena listas de valores em \f2\fs8 ___________ \line\f1\fs16 b) Os elementos de um array est\'e3o relacionados entre si pelo fato de que eles_________ \line c) Ao se referir a um elemento de array, o n\'famero da posi\'e7\'e3o contida entre colchetes \'e9 chamado de________ \line d) Os nomes dos quatro elementos do array p s\'e3o \f2\fs8 , ________, ________ \f1\fs16 e \f2\fs8 ________ \line\f1\fs16 e) Denominar um array, declarar seu tipo e especificar seu n\'famero de elementos \'e9 chamado de___________ um array. \line\f2\fs32 o \f1\fs26 o \fs16 processo de colocar elementos de um array em ordem descendente ou ascendente \'e9 chamado de___________ \line g) Em um aiay bidimensional, o primeiro subscrito (por conven\'e7\'e3o) identifica a \f2\fs8 ____________ \f1\fs16 de um elemento e o segundo (por conven\'e7\'e3o) identifica a \f2\fs8 ______________ \f1\fs16 de um elemento. \fs24\par
\fs18 310 \fs24\par
\fs18 4.7 \fs24\par
\fs18 falsas. \fs24\par
\fs18 4.8 \fs24\par
\f2\fs30 c++ \f1\fs18 CoMo \b\f2\fs14 PROGRAMAR \b0\f1\fs24\par
\fs16 h) Um array \i\f2 m \i0\f1 por \i\f2 n \i0\f1 cont\'e9m _______linhas, \f2\fs8 ___________ \f1\fs16 colunas e__________ elementos. \line i) O nome do elemento na linha 3 e coluna 5 do array d \'e9 \f2\fs8 _______________ \f1\fs24\par
\fs18 Diga quais das senten\'e7as a seguir s\'e3o verdadeiras e quais s\'e3o falsas; explique os motivos pelos quais as senten\'e7as s\'e3o \fs24\par
\fs18 a) Para se referir a uma posi\'e7\'e3o ou um elemento em particular dentro de um array. especificamos o nome do array e o \fs24\par
\fs18 valor daquele elemento. \line b) Uma declara\'e7\'e3o de array reserva espa\'e7o para ele. \line c) Para indicar que 1 00 posi\'e7\'f5es devem ser reservadas para um array inteiro p. o programador deve escrever a declara\'e7\'e3o \fs24\par
\fs18 p[ 100 ]; \fs24\par
\fs18 d) Um programa em C++ que inicializa todos os 15 elementos de um array com zeros deve conter um comando for. \line e) Um programa em C++ que soma os elementos de um array de dois subscritos deve conter comandos for aninhados. \fs24\par
\fs18 Escreva comandos em C++ que realizem o seguinte: \fs24\par
\fs18 a) Exibam na tela o valor do s\'e9timo elemento do array de caracteres f. \line b) Leiam um valor para o elemento 4 de um array unidimensional de ponto flutuante b. \line c) Inicializem cada um dos 5 elementos de um array unidimensional inteiro g com o valor 8. \line d) Somem os elementos de um array de ponto flutuante de 100 elementos. \line e) Copiem o array a para a primeira parte do array b. Assuma double a [ 11 ] \f2\fs8 , \f1\fs18 b [ 34 ] \line\f2\fs30 o \f1\fs18 Determine e imprima o menor e o maior valor contidos em um array de ponto flutuante w com 99 elementos. \fs24\par
\fs18 Considere um array inteiro, \b\f2\fs14 t, \b0\f1\fs18 2 por 5. \line a) Escreva uma declara\'e7\'e3o para t. \line b) Quantas linhas t possui? \line c) Quantas colunas t possui? \line d) Quantos elementos t possui? \line e) Escreva os nomes de todos os elementos da segunda linha de t. \line f) Escreva os nomes de todos os elementos da terceira coluna de t. \line g) Escreva um \'fanico comando que defina como zero o elemento da linha 1 e coluna 2 de t. \line h) Escreva uma s\'e9rie de comandos que inicialize como zero cada elemento de t. N\'e3o use um la\'e7o. \line i) Escreva uma estrutura for aninhada que inicialize cada elemento de t como zero. \line\fs24 i) \fs18 Escreva um comando que entre com os valores dos elementos de t a partir do terminal. \line k) Escreva uma s\'e9rie de comandos que determine e imprima o menor valor do array t. \line 1) Escreva um comando que exiba na tela os elementos da primeira linha de t. \line m) Escreva um comando que some os elementos da quarta coluna de t. \line n) Escreva uma s\'e9rie de comandos que imprima o array t em um formato organizado de tabela. Liste os subscritos das colunas como cabe\'e7alho ao longo do topo e liste os subscritos das linhas \'e0 esquerda de cada linha. \fs24\par
\fs18 4.10 Use um array unidimensional para resolver o seguinte problema. Uma empresa paga seus vendedores com base em comiss\'f5es. O vendedor recebe $200 por semana mais 9 por cento de suas vendas brutas daquela semana. Por exemplo, um vendedor que teve vendas brutas de $3000 em uma semana recebe $200 mais 9 por cento de $3000, ou seja. um total de $470. Escreva um programa (usando um array de contadores) que determine quantos vendedores receberam sal\'e1rios nos seguintes intervalos de valores (considere que o sal\'e1rio de cada vendedor \'e9 truncado para que seja obtido um valor inteiro): \line 1) $200-$299 \line 2) $300-$399 \line 3) $400- $499 \line 4) $500-$599 \line 5) $600-$699 \line 6) $700-$799 \line 7) $800-$899 \line 8) $900 -$999 \line 9) $ 1000 em diante \fs24\par
\fs16 4. 1 1 A classifica\'e7\'e3o com o \i\f2 huhhle sort \i0\f1 apresentada na Fig. 4. 1 6 \'e9 ineficiente para arrays grandes. Fa\'e7a as modifica\'e7\'f5es simples a seguir para melhorar o desempenho do \i\f2\fs18 bubble sort. \line\i0\f1\fs16 a) Depois da primeira passagem, garante-se que o maior n\'famero esteja no elemento de maior n\'famero do array; depois da segunda passagem, os dois maiores n\'fameros est\'e3o em \ldblquote seus lugares\rdblquote , e assim por diante. Em vez de fazer nove compara\'e7\'f5es em cada passagem, modifique o \i\f2\fs18 bubble sort \i0\f1\fs16 para fazer oito compara\'e7\'f5es na segunda passagem, sete na terceira e assim por diante. \fs24\par
\fs18 4.9 \fs24\par
\f3\fs84 r \line\b\f1\fs14 CAP\'cdTULO \b0\fs16 4 \f2\fs8 - \b\f1\fs14 ARRAYS \f2\fs20 311 \line\b0\f1\fs16 b) Os dados do array podem estar na ordem adequada ou quase ordenados completamente; assim, por que fazer nove \f2\fs8 . \line\f1\fs16 passagens se um n\'famero menor seria suficiente? Modifique a classifica\'e7\'e3o para verificar se alguma permuta foi feita \line ao final de cada passagem. Se nenhuma permuta foi realizada, os dados j\'e1 devem estar na ordem adequada e o \line programa deve ser encerrado. Se foram feitas permutas, \'e9 necess\'e1ria pelo menos mais uma passagem \f2\fs8 . \line\f1\fs16 4.12 Escreva comandos simples que realizem cada uma das opera\'e7\'f5es seguintes em um array unidimensional: \line a) Inicialize com zeros os lO elementos do array inteiro contagem. \line b) Adicione 1 a cada um dos 15 elementos do array inteiro bonus. \line c) Leia os 12 valores do array de ponto flutuante double temperaturasMensais a partir do teclado. \line d) Imprima os 5 valores do array inteiro melhoresResultados em um formato de coluna. \line 4.13 Encontre o(s) erro(s) em cada um dos seguintes comandos: \line a) Assumaque: char str[ 5 \b\f2\fs20 ] \f1\fs14 ; \line\f0\fs16 cm \b0\f2\fs20\'bb \b\f0\fs16 str; \f2\fs20 // \f0\fs16 Usu\'e1rio digita al\'f4 \line\b0\f1 b) Assuma que: int a \b\f2\fs20 [ \b0\f1\fs16 3 \b\f2\fs20 ] \line\b0\f1\fs16 cout \b\fs14\'ab \f0\fs16 a[ 1 \f2\fs20 ] \f1\fs14\'ab \b0\f2\fs10\lquote  \ldblquote  \b\f1\fs14\'ab \f0\fs16 a[ 2 \f2\fs20 ] \f1\fs14\'ab \'ab \b0\fs16 a[ 3 ] \b\fs14\'ab endi; \line\f0\fs16 c) double \b0\i\fs18 f[ \b\i0\fs16 3 \b0\f1 ] \f2\fs10 = \f1\fs16\{ \b\f0 1.1, 10.01, 100.001, 1000.0001 \}; \line\b0\f1 d) Assumaque: double d[ \b\fs14 2 \f2\fs20 ] [ \b0\f1\fs16 10 \b\f2\fs20 ] \line\f0\fs16 d[ 1, 9 \f2\fs20 ] \b0\fs10 = \b\f0\fs16 2.345; \line\b0\i\f2\fs12 ,l \i0\f1\fs16 4. \f2\fs20 14 \f1\fs16 Modifique o programa da Fig. 4. 1 7 de forma que a fun\'e7\'e3o mode seja capaz de manipular um empate no valor da moda. Modi\'cdique tamb\'e9m a fun\'e7\'e3o median de forma que seja encontrada a m\'e9dia dos dois valores do meio de um array com n\'famero par de elementos. \line\f2\fs20 4.15 \f1\fs16 Use um array unidimensional para resolver o seguinte problema. Leia 20 n\'fameros, todos situados entre 10 e 100, inclusive. A medida que cada n\'famero for lido, imprima-o somente se n\'e3o for duplicata de um n\'famero j\'e1 lido. Experimente o \ldblquote pior caso\rdblquote , no qual todos os 20 n\'fameros s\'e3o diferentes. Use o menor array poss\'edvel para resolver esse problema. \line 4.16 Classifique os elementos do array vendas bidimensional 3 por 5 para indicar a ordem na qual eles s\'e3o definidos como zero pelo seguinte segmento de programa: \line\b\f0 for \b0\f1 ( \b\f0 linha \b0\f2\fs10 = \b\f0\fs16 O; linha < 3; linha++ \line for \b0\f1 ( \b\f0 coluna O; coluna \f1\fs14 < \f0\fs16 5; coluna++ \line vendas[ linha \f2\fs20 ] [ \f0\fs16 coluna \f2\fs20 ] \b0\fs10 = \b\f0\fs16 O; \line\b0\f1 4.17 Escreva um programa que simule ajogada de dois dados. O programa deve usar rand para lan\'e7ar o primeiro dado e deve usar rand novamente para lan\'e7ar o segundo dado. A soma dos dois valores deve ent\'e3o ser calculada. \i Nota: \i0 como cada dado pode mostrar um valor inteiro de 1 a 6, a soma dos dois valores variar\'e1 de 2 a 12, com 7 sendo a soma mais freq\'fcente e 2 e 12 sendo as somas menos freq\'fcentes. A Fig. 4.24 mostra as 36 combina\'e7\'f5es poss\'edveis dos dois dados. Seu programa deve lan\'e7ar os dados 34.000 vezes. Use um array unidimensional para registrar o n\'famero de vezes que \'e9 obtida cada soma poss\'edvel. Imprima os resultados em formato de tabela. Al\'e9m disso, determine se as somas s\'e3o razo\'e1veis, i.e., h\'e1 seis maneiras de obter 7, portanto, aproximadamente um sexto do total de jogadas deve ser 7. \line 1 2 3 4 5 6 \fs24\par
\b\f0\fs16 2 \line\b0\f1 3 \line\i\f0\fs18 4 \line\i0\f1\fs16 5 \line 6 \fs24\par
\f2\fs20 Fig. 4.28 As 36 combina\'e7\'f5es poss\'edveis lan\'e7ando-se dois dados. \f1\fs24\par
\pard\par
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx217\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx530\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx843\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1239\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1635\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2044\pard\intbl\fs18 2 \fs24\cell\fs18 3 \fs24\cell\fs18 4 \fs24\cell\fs18 5 \fs24\cell\fs18 6 \fs24\cell\fs18 7 \fs24\cell\fs20\row
\fs18\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx217\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx530\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx843\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1239\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1635\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2044\intbl 3 \fs24\cell\fs18 4 \fs24\cell\fs18 5 \fs24\cell\fs18 6 \fs24\cell\b\f0\fs16 7 \b0\f1\fs24\cell\b\f0\fs16 8 \b0\f1\fs24\cell\fs20\row
\i\f0\fs18\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx217\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx530\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx843\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1239\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1635\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2044\intbl 4 \i0\f1\fs24\cell\fs18 5 \fs24\cell\fs18 6 \fs24\cell\fs18 7 \fs24\cell\b\f0\fs16 8 \b0\f1\fs24\cell\b\f0\fs16 9 \b0\f1\fs24\cell\fs20\row
\fs18\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx217\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx530\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx843\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1239\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1635\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2044\intbl 5 \fs24\cell\b\f0\fs16 6 \b0\f1\fs24\cell\b\f0\fs16 7 \b0\f1\fs24\cell\b\f0\fs16 8 \b0\f1\fs24\cell\b\f0\fs16 9 \b0\f1\fs24\cell\b\f0\fs16 10 \b0\f1\fs24\cell\fs20\row
\fs18\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx217\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx530\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx843\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1239\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1635\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2044\intbl 6 \fs24\cell\fs18 7 \fs24\cell\fs18 8 \fs24\cell\fs18 9 \fs24\cell\fs18 10 \fs24\cell\fs18 11 \fs24\cell\fs20\row
\fs18\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx217\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx530\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx843\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1239\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1635\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2044\intbl 7 \fs24\cell\fs18 8 \fs24\cell\fs18 9 \fs24\cell\fs18 10 \fs24\cell\fs18 11 \fs24\cell\fs18 12 \fs24\cell\fs20\row
\pard\fs24\par
\pard\sb100\sa240\b\fs16 312 \b0\f2\fs28 c++ \b\fs14 COMO PROGRAMAR \line\f1\fs18 4.IX O \b0\fs16 que faz o seguinte programa? \line\b\f0 1 \b0\i\fs22 II \b\i0\fs16 ex0418.cpp \line\f2\fs14 2 \f0\fs16 #include <iostream> \line 3 \line 4 using std: :cout; \line 5 using std: :endl; \line 6 \line 7 int whatlsThis( int \f1 [], \f0 int ); \line 8 \line 9 int main \line\f1\fs18 lo \{ \line\f0\fs16 11 const int arraySize \b0\f2\fs10 = \b\f0\fs16 10; \line 12 inta[arraySize]=\{1, 2, 3, 4, 5, 6, 7, 8, 9, 10); \line 13 \line 14 int result \b0\f2\fs10 = \b\f0\fs16 whatlsThis( a, arraySize ); \line 15 \line 16 cout \'ab \ldblquote O resultado \'e9 \'ab result \b0\f2\fs20\'ab \b\f0\fs16 endl; \line 17 return 0; \line 18 \f1\} \line\f0 19 \line 20 int whatlsThis( int b[J, int size \line\f1\fs18 21 \{ \line 22 if ( \f0\fs16 size=1 \f1 ) \line\f0 23 return b[ O ]; \line 24 else \line 25 return b[ size \b0\f2\fs8 - \b\f0\fs16 1 \f1 ] \f0 + whatlsThis( b, size \b0\f2\fs8 - \b\f0\fs16 1 ); \line\f1\fs18 26 \} \line 4.19 \b0\fs16 Escreva um programa que rode 1000 jogos de \i craps \i0 e responda a cada uma das seguintes perguntas: \line a) Quantos jogos s\'e3o vencidos na I jogada, 2 jogada \b ,.., \b0\f2\fs18 2O \f1\fs16 jogada e depois da \f2\fs18 2O \f1\fs16 jogada? \line\b\fs18 b) \b0\fs16 Quantos jogos s\'e3o perdidos na i\rquote  jogada, 2 jogada \f2\fs18 2O \f1\fs16 jogada e depois da \f2\fs18 2O \f1\fs16 jogada? \line e) Quais as probabilidades de se vencer no jogo de \i craps? (Nota: \i0 voc\'ea deve descobrir que \i craps \'e9 \i0 um dos jogos de cassino mais honestos. O que voc\'ea acha que isso significa?) \line d) Qual a dura\'e7\'e3o m\'e9dia de um jogo de \i craps? \line\i0 e) As probabilidades de se vencer aumentam com a dura\'e7\'e3o do jogo? \line 4.20 \i (Sistema de reservas de companhias a\'e9reas) \i0 Uma pequena companhia a\'e9rea acabou de comprar um computador para o seu novo sistema autom\'e1tico de reservas. Pediram a voc\'ea que programasse o novo sistema. Voc\'ea deve escrever um programa para atribuir assentos a cada v\'f4o do \'fanico avi\'e3o da companhia (capacidade: 10 assentos). \line Seu programa deve exibir o seguinte menu de alternativas: \f2\fs8 - \f1\fs16 Favor digitar 1 para \ldblquote Primeira Classe\rdblquote  e Favor digitar 2 para \ldblquote Classe Econ\'f4mica\rdblquote . Se a pessoa digitar 1, seu programa deve fazer a reserva de um assento na primeira classe (assentos 1 -5). Se a pessoa digitar 2, seu programa deve reservar um assento na classe econ\'f4mica (assentos 6- \b\fs18 10). \b0\fs16 Seu programa deve ent\'e3o imprimir um cart\'e3o de embarque indicando o n\'famero do assento do passageiro e se ele se encontra na primeira classe ou na classe econ\'f4mica do avi\'e3o. \line Use um array unidimensional para representaro esquema dos assentos do avi\'e3o. Inicialize todos os elementos do array \line com O para indicar que todos os assentos est\'e3o livres. A medida que cada assento for reservado, iguale os elementos correspondentes a 1 para indicar que o assento n\'e3o est\'e1 mais dispon\'edvel. \line Seu programa nunca deve, obviamente, reservar um assento que \b j\'e1 \b0 tenha sido reservado. Quando a classe econ\'f4mica \line estiver lotada, seu programa deve perguntar se a pessoa aceita um lugar na primeira classe (e vice-versa). Em caso positivo, fa\'e7a a reserva do assento apropriada. Em caso negativo, imprima a mensagem \ldblquote Pr\'f3ximo v\'f4o sai em 3 horas.\rdblquote  \line 4.21 O que faz o seguinte programa? \line\b\f0 1 \b0\i\fs22 II \b\i0\fs16 exO4_21.cpp \line 2 #include <iostream> \b0\f1\fs24\par
\b\fs16 CAP\'cdTULO \b0\f2\fs20 4 \fs8 - \b\f1\fs16 ARRAYS \f2\fs24 313 \line 7 \line\f1\fs16 3 \line\f0 4 using std: :cout; \line 5 using std::endl; \line\f1 6 \line\f0 7 void someFunction( int \b0\f2\fs20 [] \fs8 , \b\f0\fs16 int ); \line 8 \line\f2\fs24 1 \f0\fs16 int main \b0\f2\fs20 O \line\b\f1\fs16 lo \b0\f2\fs20\{ \line\f1\fs16 1- \b\f0 11 const int arraySize \b0\f2\fs12 = \b\f0\fs16 10; \line 12 int a[ arraySize \b0\f2\fs20 1 \fs12 = \line\b\f0\fs16 13 \b0\f2\fs20\{ \b\f0\fs16 32, 27, 64, 18, 95, 14, 90, 70, 60, 37 \}; \line 14 \line 15 cout \'ab \ldblquote Os valores no array s\'e3o:\rdblquote  \'ab endl; \line 16 someFunction( a, arraySize ); \line 17 cout \'ab endl; \line 18 return 0; \line 19 \line 20 \line\b0\f2\fs20 ;i \b\f0\fs16 21 void someFunction( int b[], int size \line 22 \b0\f2\fs20\{ \line\b\f0\fs16 23 if(size>0) \b0\f2\fs20\{ \line\b\f0\fs16 24 someFunction( &b[ 1 \b0\f2\fs20 ] \fs8 , \b\f0\fs16 size \b0\f2\fs8 - \b\f0\fs16 1 \b0\f2\fs20 ) \line\b\f0\fs16 25 cout \'ab b[ O \b0\f2\fs20 ] \b\f1\fs16\'ab \b0\f2\fs8\ldblquote  \line - \b\f0\fs16 26 \b0\f2\fs20\} \line\b\f0\fs16 27 \b0\f2\fs20\} \line\f1\fs16 4.22 Use um array bidimensional para resolver o seguinte problema. Uma empresa tem quatro vendedores ( 1 a 4) que vendem \line 5 produtos diferentes ( 1 a \i\f2 5). \i0\f1 Uma vez por dia, cada vendedor elabora um memorando de cada tipo diferente de produto vendido. \line Cada memorando cont\'e9m o seguinte: \line a) O n\'famero do vendedor \line b) O n\'famero do produto \line dos jogos de e) O valor total, em d\'f3lares, daquele produto vendido naquele dia \line Dessa forma, cada vendedor elabora de O a \i\f2 5 \i0\f1 memorandos de vendas por dia. Admita que as informa\'e7\'f5es de todos os memorandos do \'faltimo m\'eas est\'e3o dispon\'edveis. Escreva um programa que leia todas essas informa\'e7\'f5es de vendas do \'faltimo m\'eas e fa\'e7a um resumo do total de vendas por vendedor e por produto. Todos os totais devem ser armazenados no array bidimensional vendas. Depois de \line itador para o processar todas as informa\'e7\'f5es do \'faltimo m\'eas, imprima os resultados em um formato de tabela, com cada coluna representando um ograma para vendedor diferente e cada linha representando um produto diferente. Fa\'e7a a soma dos valores de cada linha para obter as vendas \line totais de cada produto no \'faltimo m\'eas; fa\'e7a a soma dos valores em cada coluna para obter as vendas totais de cada vendedor no \'faltimo \line 1asse\rquote  e m\'eas. A tabela impressa deve incluir esses totais \'e0 direita das linhas somadas e abaixo das colunas somadas. \line e um assento \line (assentos 6- 4.23 \i\f2 (Gr\'e1ficos de tartaruga) \i0\f1 A linguagem Logo, particularmente popular entre os usu\'e1rios de computadores pessoais, tornou \line se encontra famoso o conceito dos \i\f2 gr\'e1ficos de tartaruga. \i0\f1 Imagine uma tartaruga mec\'e2nica que percorra uma sala sob o controle de um programa em C++. A tartaruga segura uma caneta em uma de duas posi\'e7\'f5es, para cima ou para baixo. Enquanto a caneta est\'e1 para \line nos do array baixo, a tartaruga desenha figuras \'e0 medida que se move; quando a caneta est\'e1 para cima, a tartaruga se move livremente, sem s correspon- desenhar nada. Neste problema, voc\'ea simular\'e1 a opera\'e7\'e3o da tartaruga e criar\'e1 tamb\'e9m um bloco de desenho computadorizado. \line Use um array piso, 20 por 20, inicializado com zeros. Leia os comandos de um array que os cont\'e9m. Controle sempre \line econ\'f4mica a posi\'e7\'e3o atual da tartaruga e se a caneta est\'e1 para cima ou para baixo. Admita que a tartaruga sempre come\'e7a na posi\'e7\'e3o 0,0 do ositivo, fa\'e7a com a caneta para cima. O conjunto de comandos da tartaruga que seu programa deve processar s\'e3o os seguintes: \fs24\par
\f3\fs60 1 \f1\fs18 Comando Significado \fs24\par
\b\f0\fs16 1 Caneta para cima \line\b0\f1 2 Caneta para baixo \line 3 Giro para a direita \line 4 Giro para a esquerda \fs24\par
\b\f2\fs18 314 \b0\fs26 c++ \b\fs18 COMO PROGRAMAR \b0\f1\fs24\par
\fs18 Movimento 10 espa\'e7os para a frente \fs24\par
\fs18 (ou outro n\'famero diferente de 10) Imprime o array 20 por 20 \fs24\par
\fs18 Fim dos dados (sentinela) \fs24\par
\fs18 Suponha que a tartaruga esteja em algum lugar pr\'f3ximo do centro do piso. O \ldblquote programa\rdblquote  a seguir desenharia e imprimiria um quadrado 1 2-por- 12: \fs24\par
\b\fs18 2 \b0\fs24\par
\b\f2\fs16 5,12 \line\f1\fs18 3 \b0\fs24\par
\b\fs18 5,12 \b0\fs24\par
\b\fs18 3 \b0\fs24\par
\fs18 5,12 \fs24\par
\b\fs18 3 \b0\fs24\par
\fs18 5,12 \fs24\par
\fs18 1 \fs24\par
\b\fs18 6 \b0\fs24\par
\b\fs18 9 \b0\fs24\par
\'c0 \fs18 medida que a tartaruga se move com a caneta para baixo, defina os elementos apropriados do array piso como is. Quando o comando 6 (imprimir) for emitido, onde houver um 1 no array exiba um asterisco, ou outro caractere de sua escolha. Sempre que houver um zero, exiba um espa\'e7o em branco. Escreva um programa para implementar os recursos do gr\'e1fico de tartaruga descritos aqui. Escreva v\'e1rios programas de gr\'e1ficos de tartaruga para desenhar formas interessantes. Adicione outros comandos para aumentar a potencialidade de sua linguagem de gr\'e1fico de tartaruga. \fs24\par
\fs18 4.24 \i\fs16 (Passeio do cavalo) \i0\fs18 Um dos problemas mais interessantes para os fs do jogo de xadrez \'e9 o problema do Passeio do Cavalo, proposto originalmente pelo matem\'e1tico Euler. A quest\'e3o \'e9 esta: a pe\'e7a do jogo de xadrez chamada de cavalo pode se mover ao longo de um tabuleiro vazio e passar uma \'fanica vez em cada uma das 64 casas? Estudamos aqui esse interessante problema em profundidade. \line\f2\fs26 o \f1\fs18 cavalo faz movimentos em forma de L (percorre duas casas em uma dire\'e7\'e3o e uma no sentido perpendicular \'e0s duas primeiras). Dessa forma, de uma casa no meio do tabuleiro, o cavalo pode fazer oito movimentos diferentes (numerados de O a 7), como mostra a Fig. 4.29. \fs24\par
\f2\fs26 o \f1\fs24\par
\fs18 1 \fs24\par
\b\f2\fs20 2 \b0\f1\fs24\par
\b\fs18 3 \b0\fs24\par
\fs18 4 \fs24\par
\b\fs18 5 \b0\fs24\par
\b\fs18 6 \b0\fs24\par
\b\fs18 7 \b0\fs24\par
\f2\fs26 o \b\f1\fs18 i 2 3 4 5 6 7 \b0\fs24\par
\b\f2\fs18 Comando \f1 Significado \b0\fs24\par
\b\fs18 5,10 \line 6 \line 9 \b0\fs24\par
\b\f2\fs20 Fig. 4.29 Os 8 movimentos poss\'edveis do cavalo. \b0\f1\fs24\par
\b\fs16 CAP\'cdTULO \b0\fs20 4 \f2\fs8 - \b\f1\fs16 ARRAYS \f2\fs22 315 \b0\f1\fs24\par
\fs16 a) Desenhe um tabuleiro de xadrez 8 por 8 em uma folha de papel e tente fazer o Passeio do Cavalo a m\'e3o. Coloque um 1 na primeira casa para a qual se mover, um 2 na segunda casa, um 3 na terceira, etc. Antes de come\'e7ar os movimentos, imagine at\'e9 onde voc\'ea chegar\'e1, lembrando-se de que um passeio completo consiste em 64 movimentos. At\'e9 onde voc\'ea chegou? Chegou t\'e3o perto quanto havia imaginado? \line b) Agora, vamos desenvolver um programa que mover\'e1 o cavalo pelo tabuleiro de xadrez. O tabuleiro, em si, \'e9 representado pelo array bidimensional. 8 por 8. tabuleiro. Cada um dos quadrados (casas \'e9 inicializado com o valor zero. Descrevemos cada um dos oito movimentos poss\'edveis em termos de seus componentes horizontais e verticais. Por exemplo, um movimento do tipo O, como mostra a Fig. 4.24, consiste em mover dois quadrados horizontalmente para a direita e um quadrado verticalmente para cima. O movimento 2 consiste em mover um quadrado horizontalmente para a esquerda e dois quadrados verticalmente para cima. Os movimentos horizontais para a esquerda e verticais para cima s\'e3o indicados por n\'fameros negativos. Os oito movimentos podem ser descritos por arrays bi-dimensionais, \b horizontal e vertical. como segue: \line horizontal[ O \b0 ] \b 2 \line horizontal[ 1 \b0 ] \b 1 \line horizontal[ 2 \b0 J \b -1 \line horizontal[ 3 \b0 ] \b\f2\fs14 = \f1\fs16 -2 \line horizontal[ 4 \b0 ] \b\f2\fs14 = \f1\fs16 -2 \line horizontal[ 5 \b0 ] \b -1 \line\f0 horizontal[ 6 \b0\f1 ] \b\f0 1 \line horizontal[ 7 \b0\f1 ] \b\f0 2 \line vertical[ O \b0\f1 J \b\f2\fs14 = \f1\fs16 -1 \line vertical[ 1 \b0 ] \b\f2\fs14 = \f0\fs16 -2 \line vertical[ 2 \b0\f1 ] \b\f2\fs14 = \f0\fs16 -2 \line vertical[ 3 \b0\f1 ] \b\f0 -1 \line\f1 vertical[ 4 \b0 ] \b\f2\fs14 = \f0\fs16 1 \line\b0\f2\fs26 e \b\f1\fs16 vertical[ 5 \b0 ] \b\f0 2 \line vertical[ 6 \b0\f1 ] \b\f2\fs14 = \f0\fs16 2 \line vertical[ 7 \b0\f1 ] \b\f0 =1 \line\b0\f1 o As vari\'e1veis linhaAtual e colunaAtual indicam a linha e a coluna da posi\'e7\'e3o atual do cavalo. Para fazer um e movimento do tipo numMov. em que numMov est\'e1 entre O e 7, seu programa usa os comandos \line linhaAtual \b\f2\fs14 + \f0\fs16 vertical[ numMov ]; \line\b0\f1 colunaAtual \b\f2\fs14 + \f1\fs16 horizontal \b0 [ \f2 nunMov ); \line\f1 Utilize um contador que varie de 1 a 64. Grave a \'faltima contagem em cada casa para a qual o cavalo se mover. Lembre-se de testar cada movimento potencial para verificar se o cavaloj\'e1 esteve naquele quadrado. E, obviamente, teste cada movimento potencial para se certificar de que o cavalo n\'e3o esteja saindo do tabuleiro. Agora, escreva um programa para mover o cavalo pelo tabuleiro de xadrez. Rode o programa. Quantos movimentos o cavalo fez? \line c) Depois de tentar escrever e rodar o programa do Passeio do Cavalo, provavelmente voc\'ea adquiriu alguns conceitos valiosos. Usaremos esses conceitos para desenvolver uma \i heur\'edstica \i0 (ou estrat\'e9gia) para mover o cavalo. A heur\'edstica n\'e3o garante o sucesso, mas uma heur\'edstica cuidadosamente desenvolvida aumenta as probabilidades de ele ser atingido. Voc\'ea pode ter observado que os quadrados extemos s\'e3o, de alguma forma, mais problem\'e1ticos do que os quadrados pr\'f3ximos ao centro do tabuleiro. Na realidade, os quadrados mais problem\'e1ticos, ou inacess\'edveis, s\'e3o os quatro cantos. \line A intui\'e7\'e3o pode sugerir que voc\'ea deve tentar mover o cavalo para os quadrados mais problem\'e1ticos e \line deixar livres os quadrados mais f\'e1ceis de atingir para que, quando o tabuleiro ficar congestionado pr\'f3ximo ao final do \line passeio, haja a maior probabilidade de sucesso. \line Podemos desenvolver uma \ldblquote heur\'edstica de acessibilidade\rdblquote , classificando cada um dos quadrados de acordo com sua acessibilidade e depois sempre mover o cavalo para o quadrado (dentro dos movimentos em forma de L, obviamente) que seja mais inacess\'edvel. Colocamos no array bidimensional acessibilidade os n\'fameros que indicam a partir de quantos quadrados um determinado quadrado pode ser acessado. Portanto, em um tabuleiro vazio, as casas centrais s\'e3o classificadas com 8s, os quadrados dos cantos s\'e3o classificados com 2s e os outros quadrados possuem n\'fameros de acessibilidade 3, 4 e 6. como \'e9 mostrado a seguir \line\b\f0 2 3 4 4 4 4 3 2 \line 3 4 6 6 6 6 4 3 \line\f2\fs14 4 6 8 8 8 8 6 4 \line 4 6 8 8 8 8 6 4 \line 4 6 8 8 8 8 6 4 \line 4 6 8 8 8 8 6 4 \line\f0\fs16 3 4 6 6 6 6 4 3 \b0\f1\fs24\par
\b\f0\fs16 2 3 4 4 4 4 3 2 \b0\f1\fs24\par
\f2\fs20 316 \fs28 c++ \b\fs14 COMO PROGRAMAR \line\b0\f1\fs16 Agora escreva uma vers\'e3o do programa do Passeio do Cavalo usando a heur\'edstica de acessibilidade. Em qualquer tempo, o cavalo deve se mover para o quadrado com menor n\'famero de acessibilidade. Em caso de empate, o cavalo pode se mover para qualquer um dos quadrados que empataram. Portanto, o passeio pode come\'e7ar em qualquer um dos quatro cantos. \i (Nota: \'e0 \i0 medida que o cavalo se mover no tabuleiro, seu programa deve reduzir os n\'fameros de acessibilidade quando cada vez mais quadrados forem ocupados. Dessa forma, a qualquer instante durante o passeio o n\'famero de acessibilidade de cada quadrado dispon\'edvel permanecer\'e1 igual ao n\'famero de quadrados a partir dos quais aquele espa\'e7o pode ser alcan\'e7ado). Rode essa vers\'e3o de seu programa. Voc\'ea conseguiu fazer um passeio com- pleto?Agora modifique o programa para executar 64 passeios, um para cada quadrado do tabuleiro. Quantos passeios completos voc\'ea conseguiu fazer? \line d) Escreva uma vers\'e3o do programa do Passeio do Cavalo na qual, ao encontrar um empate entre dois ou mais quadra- dos, voc\'ea fa\'e7a sua escolha verificando os quadrados que podem ser alcan\'e7ados a partir dos quadrados \ldblquote empatados\rdblquote . Seu programa deve fazer o movimento do cavalo para o quadrado para o qual o pr\'f3ximo movimento levar ao quadra- do com menor n\'famero de acessibilidade. \line 4.25 \i (Passeio do Cavalo: m\'e9todos defor\'e7a bruta) \i0 No Exerc\'edcio 4.24, desenvolvemos uma solu\'e7\'e3o para o problema do Passeio do Cavalo. O m\'e9todo usado, chamado de \ldblquote heur\'edstica de acessibilidade\rdblquote , gera muitas solu\'e7\'f5es e funciona de uma maneira eficiente. \line Como os computadores continuam a ser cada vez mais poderosos, poderemos resolver muitos problemas com base \line apenas no poder computacional e com algoritmos relativamente simples. Vamos chamar esse m\'e9todo de resolu\'e7\'e3o de problemas de \ldblquote for\'e7a bruta\rdblquote . \line a) Use a gera\'e7\'e3o de n\'fameros aleat\'f3rios para permitir que o cavalo percorra o tabuleiro (em seus movimentos permitidos na forma de L, obviamente) de maneira aleat\'f3ria. Seu programa deve executar um passeio e imprimir o tabuleiro \line final. At\'e9 onde o cavalo chegou? \line b) Muito provavelmente, o programa anterior levar\'e1 a um passeio relativamente curto. Agora, modifique seu programa para tentar 1 \f2\fs18 000 \f1\fs16 passeios. Use um array unidimensional para controlar o n\'famero de passeias por extens\'e3o alcan\'e7ada. \fs24 Q \fs16 uando seu programa terminar de fazer os \f2\fs18 1000 \f1\fs16 passeios, ele deve imprimir essas informa\'e7\'f5es em um formato de tabela. Qual o melhor resultado? \line e) Muito provavelmente, o programa anterior forneceu alguns passeios \ldblquote respeit\'e1veis\rdblquote , mas nenhum passeio completo. Agora, \ldblquote retire os limites\rdblquote  e simplesmente deixe seu programa ser executado at\'e9 que um passeio completo seja produzido. \i (Cuidado: \i0 essa vers\'e3o do programa pode rodar durante horas em um computador poderoso). Mais uma vez, mantenha uma tabela com o n\'famero de passeios para cada extens\'e3o alcan\'e7ada e imprima essa tabela quando o primeiro passeio completo for realizado. Quantos passeias seu programa tentou fazer antes de produzir um passeio completo? Quanto tempo levou? \line d) Compare a vers\'e3o de for\'e7a bruta do Passeio do Cavalo com a vers\'e3o de heur\'edstica de acessibilidade. Qual exigiu um estudo mais cuidadoso do problema? Que algoritmo foi mais dif\'edcil de desenvolver? Qual exigiu mais poder computacional? Poder\'edamos estar certos (antecipadameme) de obter um passeio completo com a heur\'edstica de acessibilidade? Poder\'edamos estar certos (antecipadamente) de obter um passeio completo com o m\'e9todo da for\'e7a bruta? Analise as vantagens e desvantagens da resolu\'e7\'e3o de problemas em geral por for\'e7a bruta. \line 4.26 \i (Oito Rainhas) \i0 Outro quebra-cabe\'e7a para os \fs18 f\'e3s \fs16 do jogo de xadrez \'e9 o problema das Oito Rainhas. Resumidamente: \'e9 poss\'edvel colocar oito rainhas em um tabuleiro vazio de xadrez, de forma que nenhuma rainha \ldblquote ataque\rdblquote  qualquer uma das outras, isto \'e9, de forma que n\'e3o haja duas rainhas na mesma linha, na mesma coluna ou ao longo da mesma diagonal? Use o m\'e9todo de racioc\'ednio desenvolvido no Exerc\'edcio 4.24 para formular uma heur\'edstica para resolver o problema das Oito Rainhas. Execute seu programa. \i (Dica: \i0\'e9 poss\'edvel atribuir um valor num\'e9rico a cada quadrado do tabuleiro indicando quantos quadrados s\'e3o \ldblquote eliminados\rdblquote  se uma rainha for colocada. Por exemplo, cada um dos quatro cantos receberia o valor 22, como na Fig. 4.30.) Depois desses \ldblquote n\'fameros de elimina\'e7\'f5es\rdblquote  serem colocados em todas as 64 casas, uma heur\'edstica apropriada poderia ser: coloque a pr\'f3xima rainha no quadrado com menor n\'famero de elimina\'e7\'f5es. Por que essa estrat\'e9gia \'e9 intuitivamente atraente? \fs24\par
\f2\fs20 Fig. 4.30 As 22 casas eliminadas ao se colocar uma rainha no canto superior esquerdo do tabuleiro. \f1\fs24\par
\pard\par
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx424\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx956\pard\intbl\f2\fs10 **** \f1\fs24\cell\f2\fs10 **** \f1\fs24\cell\fs20\row
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx424\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx690\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx956\pard\intbl\f2\fs10 ** \f1\fs24\cell\cell\cell\fs20\row
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx158\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx424\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx690\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx956\pard\intbl\f2\fs10 * \f1\fs24\cell\f2\fs10 * \f1\fs24\cell\cell\cell\fs20\row
\f2\fs10\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx158\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx424\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx690\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx956\intbl * \f1\fs24\cell\f2\fs10 * \f1\fs24\cell\cell\cell\fs20\row
\f2\fs10\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx158\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx424\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx690\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx956\intbl * \f1\fs24\cell\cell\f2\fs10 * \f1\fs24\cell\cell\fs20\row
\f2\fs10\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx158\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx424\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx690\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx956\intbl * \f1\fs24\cell\cell\f2\fs10 * \f1\fs24\cell\cell\fs20\row
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx158\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx424\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx956\pard\intbl\f2\fs10 * \f1\fs24\cell\cell\f2\fs10 * \f1\fs24\cell\fs20\row
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx158\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx424\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx690\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx956\pard\intbl\f2\fs10 * \f1\fs24\cell\cell\cell\f2\fs10 * \f1\fs24\cell\fs20\row
\pard\fs24\par
\pard\sb100\sa240\b\f2\fs22 318 \b0\fs28 c++ \b\fs16 COMO \f1\fs14 PROGRAMAR \line\b0\i\fs16 Bubble Sort \i0\f2\fs8 - \f1\fs16 para um array de \i n \i0 elementos, devem ser feitas \i n \i0\f2\fs8 - \f1\fs16 1 passagens, e para cada subarray devem ser feitas \i n \i0\f2\fs8 - \f1\fs16 1 compara\'e7\'f5es para encontrar o menor valor. Quando o subarray a ser processado possuir um elemento, o array estar\'e1 ordenado. Escreva uma fun\'e7\'e3o recursiva selectionSort para implementar esse algoritmo. \line\b\f2 4.32 \b0\i\f1 (Pal\'edndromos) \i0 Um pal\'edndromo \'e9 um string que \'e9 soletrado da mesma forma da frente para tr\'e1s ou de tr\'e1s para a frente. Alguns exemplos de pal\'edndromos s\'e3o \ldblquote radar\rdblquote  \ldblquote orava o avaro\rdblquote  e \ldblquote socorram marrocos\rdblquote . Escreva uma fun\'e7\'e3o recursiva testePalind que retorne 1 se o string armazenado no array for um pal\'edndromo ou O em caso contr\'e1rio. A fun\'e7\'e3o deve ignorar espa\'e7os e pontua\'e7\'e3o no string. \line 4.33 \i (Pesquisa linear) \i0 Modifique o programa da Fig. 4. 1 9 para usar uma fun\'e7\'e3o recursiva buscaLinear para realizar a pesquisa linear no array. A fun\'e7\'e3o deve receber um array inteiro e o tamanho do array como argumentos. Se a chave de pesquisa for encontrada, retome o subscrito do array; caso contr\'e1rio, retorne -1. \line 4.34 \i (Pesquisa bin\'e1ria) \i0 Modifique o programa da Fig. 4.20 para usar uma fun\'e7\'e3o recursiva buscaBinaria para realizar a \line pesquisa bin\'e1ria no array. A fun\'e7\'e3o deve receber um array inteiro e os subscritos inicial e final como argumentos. Se a chave de \line pesquisa for encontrada, retome o subscrito do array; caso contr\'e1rio, retome \f2\fs8 - \f1\fs16 1. \line\b\f2 4.35 \b0\i\f1 (Oito Rainhas) \i0 Modifique o programa Oito Rainhas criado no Exerc\'edcio 4.26 para que o probkma seja resolvido recursivamente. \line\b\f2 4.36 \b0\i\f1 (Imprimir um array) \i0 Escreva uma fun\'e7\'e3o recursiva imprimeArray que tome um array e seu tamanho como argumentos, imprima o array e n\'e3o retome nada. A fun\'e7\'e3o deve parar o processamento e retomar quando receber um array de tamanho zero. \line\b\f2 4.37 \b0\i\f1 (imprimir um \i0 string \i de tr\'e1s para a frente) \i0 Escreva uma fun\'e7\'e3o recursiva inverteStririg que tome um array de \line caracteres como argumento, imprima o array de caracteres na ordem inversa e nada retorne. A fun\'e7\'e3o deve parar o processamento \line e retornar quando for encontrado um caractere nulo de t\'e9rmino de \i string. \line\i0 4.38 \i (Encontrar o valor m\'ednimo de um array) \i0 Escreva uma fun\'e7\'e3o recursiva minimoArrayRecursiva que tome um array inteiro e o tamanho do array como argumentos e retorne o menor elemento do array. A fun\'e7\'e3o deve parar o processamento e retornar quando receber um array de 1 elemento.\par
\pard\lang1033\f4\fs20\par
}
 