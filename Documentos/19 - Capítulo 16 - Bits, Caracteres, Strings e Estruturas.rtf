{\rtf1\ansi\ansicpg1252\deff0\deflang1033{\fonttbl{\f0\fswiss\fprq2\fcharset0 Arial;}{\f1\froman\fcharset0 Times New Roman;}}
\viewkind4\uc1\pard\sb100\sa240\lang2070\f0\fs24\par
\par
16 \par
\pard\par
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1998\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2645\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx5933\pard\intbl Bits\cell , \cell Caracteres, Strings e Estruturas \cell\row
\intbl\cell\cell\cell\row
\intbl\cell\cell\cell\row
\intbl Objetivos\cell\cell\cell\row
\intbl\cell\cell\cell\row
\intbl\cell\cell\cell\row
\pard\sb100\sa240\bullet  Ser capaz de criar e usar estruturas. \line\bullet  Ser capaz de passar estruturas para fun\'e7\'f5es atrav\'e9s de chamadas por valor e chamadas por refer\'eancia. \line\bullet  Manipular dados com os operadores sobre bits e criar campos de bits para armazenar dados de forma compacta. \line\bullet  Ser capaz de usar as fun\'e7\'f5es da biblioteca de manipula\'e7\'e3o de caracteres (cctype). \line\bullet  Ser capaz de usar as fun\'e7\'f5es de convers\'e3o de strings da biblioteca de utilit\'e1rios gen\'e9ricos (cstdlib). \line\bullet  Ser capaz de usar as fun\'e7\'f5es de processamento de strings da biblioteca de manipula\'e7\'e3o de strings (cstring). \line\bullet  Apreciar o poder das bibliotecas de fun\'e7\'f5es como meio de conseguir a reutiliza\'e7\'e3o de software. \line\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1998\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2645\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx5933\pard\intbl\cell\cell\cell\row
\pard\sb100\sa240\par
\par
\par
The sarne old charitable lie \line Repeated as the years scoot by \line Perpetually makes a hit - \line\ldblquote You really haven \lquote t changed a bit!\rdblquote  \line Margaret Fishback \line The chi ef defect of Henry King \line Was chewing little bits ofstring. \line Hilaire BeIloc \line A escrita vigorosa \'e9 concisa. Urna senten\'e7a n\'e3o deve conter palavras desnecess\'e1rias; um par\'e1grafo, senten\'e7as desnecess\'e1rias. \line William Strunk,  \par
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1998\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2645\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx5933\pard\intbl\cell\cell\cell\row
\intbl\cell\cell\cell\row
\intbl\cell\cell\cell\row
\pard\par
\pard\sb100\sa240 808 C++ COMO PROGRAMAR \line\ul Vis\'e3o Geral \ulnone\line 16.1 Introdu\'e7\'e3o \line 16.2 Defini\'e7\'f5es de estrutura \line 16.3 Inicializando estruturas \line 16.4 Usando estruturas com fun\'e7\'f5es \line 16.5 typedef \line 16.6 Exemplo: uma simula\'e7\'e3o de alto desempenho do embaralhamento e distribui\'e7\'e3o de cartas \line 16.7 Operadores sobre bits \line 16.8 Campos de bits \line 16.9 A biblioteca de manipula\'e7\'e3o de caracteres \line 16.10 Fun\'e7\'f5es de convers\'e3o de strings \line 16.11 Fun\'e7\'f5es de pesquisa da biblioteca de manipula\'e7\'e3o de strings \line 16.12 Fun\'e7\'f5es de mem\'f3ria da biblioteca de manipula\'e7\'e3o de strings \line 16.13 Uma outra fun\'e7\'e3o da biblioteca de manipula\'e7\'e3o de strings \line Resumo\bullet  Terminologia Erros comuns de programa\'e7\'e3o Boas pr\'e1ticas de programa\'e7\'e3o \bullet  Dicas de desempenho . Dicas de portabilidade Exerc\'edcios de auto-revis\'e3o \bullet  Respostas aos exerc\'edcios de auto-revis\'e3o Exerc\'edcios \line 16.1 Introdu\'e7\'e3o \line Neste cap\'edtulo, falamos mais sobre estruturas e, ent\'e3o, discutimos a manipula\'e7\'e3o de bits, caracteres e strings. Muitas das t\'e9cnicas que apresentamos seguem o estilo empregado em C e s\'e3o inclu\'eddas para ajudar o programador de C++ que tenha que trabalhar com c\'f3digo legado em C. \line As estruturas podem conter vari\'e1veis de muitos tipos de dados diferentes - em contraste com arrays, que cont\'eam somente elementos do mesmo tipo de dados. Este fato e a maior parte do que falamos sobre estruturas nas \line pr\'f3ximasp\'e1ginas aplicam-se tamb\'e9m a classes. Repetindo: a principal diferen\'e7a entre estruturas e classes em \line\'e9 que membros de estrutura tem acesso default public e membros de classes tem acesso default private. As estruturas s\'e3o usadas comumente para definir registros de dados para serem armazenados em arquivos (veja o Cap\'edtulo 14, \ldblquote Processamento de arquivos\rdblquote ). Ponteiros e estruturas facilitam a forma\'e7\'e3o de estruturas de dados mais complexas, tais como listas encadeadas, filas, pilhas e \'e1rvores (ver Cap\'edtulo 15, \ldblquote Estruturas de dados\rdblquote ). Discutiremos como declarar estruturas, inicializ\'e1-las e pass\'e1-las para fun\'e7\'f5es. Ent\'e3o, apresentaremos uma simula\'e7\'e3o de alto desempenho de embaralhamento e distribui\'e7\'e3o de cartas. \line 16.2 Defini\'e7\'f5es de estrutura \line Considere a seguinte defini\'e7\'e3o de estrutura: \line struct Card \{ \line char *face; \line char *sujt; \line A palavra-chave struct inicia a defini\'e7\'e3o da estrutura Card. O identificador Card \'e9 o nome da estrutura e \'e9 usado em C++ para declarar vari\'e1veis do tipo estrutura (em C, o nome de tipo da estrutura precedente \'e9 struct Card). Neste exemplo, o tipo de estrutura \'e9 Card. Dados (e possivelmente fun\'e7\'f5es - da mesma maneira que com classes) declarados dentro das chaves da defini\'e7\'e3o da estrutura s\'e3o os membros da estrutura. Membros da mesma \par
CAP\'cdTULO 16 - BITS, CARACTERES, STRINGS E ESTRUTURAS 809 \line estrutura devem ter nomes \'fanicos, mas duas estruturas diferentes podem conter membros com o mesmo nome sem risco de conflito. Cada defini\'e7\'e3o de estrutura deve terminar com um ponto-e-v\'edrgula. \line Erro comum de programa\'e7\'e3o 16.1 \line Esquecer o ponto-e-v\'edrgula que termina uma defini\'e7\'e3o de estrutura. \line A defini\'e7\'e3o de Card cont\'e9m dois membros do tipo char* - face e suit. Os membros da estrutura podem ser vari\'e1veis dos tipos de dados b\'e1sicos ou primitivos (por exemplo: int, float. etc.), ou agregados, tais como arrays e outras estruturas. Como vimos no Cap\'edtulo 4, cada elemento de um array deve ser do mesmo tipo. Membros de dados de uma estrutura, por\'e9m, podem ser de tipos de dados diferentes. Por exemplo, uma estrutura Employee poderia conter membros do tipo string de caracteres para o nome e sobrenome, um membro int para a idade do empregado, um membro char contendo M\rquote  ou \lquote F\rquote  para o sexo do empregado, um membro double para o sal\'e1rio-hora do empregado, e assim por diante. \line Uma estrutura n\'e3o pode conter uma inst\'e2ncia de si mesma. Por exemplo, uma vari\'e1vel estrutura Card n\'e3o pode ser declarada na defini\'e7\'e3o da estrutura Card. Um ponteiro para uma estrutura Card. por\'e9m, pode ser inclu\'eddo. Uma estrutura que cont\'e9m um membro que \'e9 um ponteiro para o mesmo tipo de estrutura \'e9 chamada de uma estrutura auto-referente. As estruturas auto-referentes s\'e3o usadas no Cap\'edtulo 15 para construir v\'e1rios tipos de estruturas de dados encadeadas. \line A defini\'e7\'e3o de estrutura precedente n\'e3o reserva qualquer espa\'e7o na mem\'f3ria; em vez disso, a defini\'e7\'e3o cria \line um novo tipo de dados que \'e9 usado para declarar vari\'e1veis do tipo estrutura. As vari\'e1veis estrutura s\'e3o declaradas como as vari\'e1veis de outros tipos. A declara\'e7\'e3o \line Card oneCard, deck[ 52 ], *cptr; \line declara oneCard como uma vari\'e1vel estrutura do tipo Card, deck como sendo um array com 52 elementos do tipo Card e cPtr como um ponteiro para uma estrutura Card. As vari\'e1veis de um dado tipo de estrutura tamb\'e9m podem ser declaradas colocando-se uma lista de nomes de vari\'e1veis separados por v\'edrgulas entre a chave de t\'e9rmino da defini\'e7\'e3o da estrutura e o ponto-e-v\'edrgula que termina a defini\'e7\'e3o da estrutura. Por exemplo, a declara\'e7\'e3o precedente poderia ter sido incorporada \'e0 defini\'e7\'e3o da estrutura Card como segue: \line struct Card \{ \line char *face; \line char *suit; \line\} oneCard, deck[ 52 ], *cptr; \line O nome de estrutura \'e9 opcional. Se uma defini\'e7\'e3o de estrutura n\'e3o cont\'e9m um nome de estrutura, vari\'e1veis do tipo da estrutura somente podem ser declaradas na defini\'e7\'e3o da estrutura - n\'e3o em uma declara\'e7\'e3o separada. \line Boa pr\'e1tica de programa\'e7\'e3o 16.1 \line Forne\'e7a um nome de estrutura quando criar um tipo de estrutura. O nome de estrutura \'e9 conveniente para declarar novas vari\'e1veis do tipo da estrutura mais \'e0frente no programa e \'e9 obrigat\'f3rio se a estrutura for passada como um par\'e2metro para uma fun\'e7\'e3o. \line As \'fanicas opera\'e7\'f5es primitivas v\'e1lidas que podem ser executadas sobre estruturas s\'e3o atribuir uma estrutura a uma estrutura do mesmo tipo, pegar o endere\'e7o (&) de uma estrutura, acessar os membros de uma estrutura (ver Cap\'edtulo 6, \ldblquote Classes e abstra\'e7\'e3o de dados\rdblquote  ) e usar o operador sizeof para determinar o tamanho de uma estrutura. Como acontece com classes, a maioria dos operadores podem ser sobrecarregados para trabalhar com objetos de um tipo estrutura. \line Os membros de estruturas n\'e3o est\'e3o necessariamente armazenados em bytes sucessivos de mem\'f3ria. As vezes, existem \ldblquote buracos\rdblquote  em uma estrutura, porque os computadores podem armazenar tipos de dados espec\'edficos somente em certos limites de mem\'f3ria, tais como in\'edcio de uma meia palavra, palavra ou palavra dupla. Uma palavra \'e9 uma unidade padr\'e3o de mem\'f3ria usada para armazenar dados em um computador - normalmente 2 bytes ou 4 \par
810 C++ COMO PROGRAMAR \line bytes. Considere a seguinte defini\'e7\'e3o de estrutura em que s\'e3o declaradas as vari\'e1veis estrutura (na verdade, objetos) samplel e sample2 do tipo Example: \line structExample \{ \line char c; \line int i; \line\} samplel, sample2; \line Um computador com palavras de 2 bytes pode exigir que cada um dos membros de Example seja alinhado em um limite de palavra, i.e., no princ\'edpio de uma palavra (isto \'e9 dependente da m\'e1quina). A Fig. 16.1 mostra um exemplo de alinhamento de mem\'f3ria para um objeto de tipo Example ao qual foram atribu\'eddos o caractere \lquote a\rquote  e o inteiro 97 (s\'e3o mostradas as representa\'e7\'f5es dos valores em bin\'e1rio). Se os membros s\'e3o armazenados no in\'edcio de limites de palavras, existe um buraco de 1 byte (byte 1 na figura) na mem\'f3ria para objetos do tipo Example. O valor do buraco de 1 byte \'e9 indefinido. Se os valores dos membros samplel e sample2 s\'e3o de fato iguais, a compara\'e7\'e3o das estruturas n\'e3o \'e9 necessariamente igual, porque os buracos indefinidos de 1 byte provavelmente n\'e3o conter\'e3o valores id\'eanticos. \line Erro comum de programa\'e7\'e3o 16.2 \line Comparar estruturas \'e9 um erro de sintaxe por causa dos diferentes requisitos de alinhamento nos diversos \line sistemas. \line Dica de portabilidade 16.1 \line ______ Como o tamanho dos itens de dados de um tipo particular \'e9 dependente de m\'e1quina e como considera\'e7\'f5es de alinhamento de mem\'f3ria s\'e3o dependentes de m\'e1quina, assim tamb\'e9m o \'e9 a representa\'e7\'e3o de uma \line estrutura. \par
Fig. 16.1 Um alinhamento de mem\'f3ria poss\'edvel para uma vari\'e1vel do tipo Example mostrando uma \'e1rea indefinida na mem\'f3ria. \line 16.3 Inicializando estruturas \line As estruturas podem ser inicializadas usando-se listas de inicializadores, como \'e9 feito com arrays. Para inicializar uma estrutura, coloque em seguida ao nome da vari\'e1vel na declara\'e7\'e3o de estrutura um sinal de igual e uma lista de inicializadores entre chaves, separados por v\'edrgulas. Por exemplo, a declara\'e7\'e3o \line Card oneCard = \{ \ldblquote Tr\'eas\rdblquote , \ldblquote Copas\rdblquote  ); \line cria uma vari\'e1vel oneCard do tipo estrutura Card (como definida anteriormente) e inicializa o membro face com \ldblquote Tr\'eas\rdblquote  e o membro suit com \ldblquote Copas\rdblquote . Se existem menos inicializadores na lista do que membros na estrutura, os membros restantes s\'e3o automaticamente inicializados com 0. Vari\'e1veis estrutura declaradas fora de uma defini\'e7\'e3o de fun\'e7\'e3o (i.e., externamente) s\'e3o inicializadas com 0, se n\'e3o forem explicitamente inicializadas na declara\'e7\'e3o externa. As vari\'e1veis estrutura podem tamb\'e9m ser inicializadas em comandos de atribui\'e7\'e3o, atribuindo- se a elas uma vari\'e1vel estrutura do mesmo tipo ou atribuindo valores aos membros de dados individuais da estrutura. \line 16.4 Usando estruturas com fun\'e7\'f5es \line Existem dois modos de passar as informa\'e7\'f5es contidas em estruturas para fun\'e7\'f5es. Voc\'ea pode passar a estrutura inteira ou pode passar membros isolados da estrutura. Por default, os dados (exceto membros individuais de um \par
\pard\par
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2358\pard\intbl Byte O 1 2 3  01100001 00000000 01100001 \cell\row
\pard\par
\pard\sb100\sa240 CAP\'cdTULO 16 - BIT5, CARACTERES, STRJNGS E ESTRUTURAS 811 \line array) s\'e3o passados atrav\'e9s de chamadas por valor. As estruturas e seus membros podem tamb\'e9m ser passados atrav\'e9s de chamadas por refer\'eancia, passando ou refer\'eancias ou ponteiros. \line Para passar uma estrutura atrav\'e9s de uma chamada por refer\'eancia, passe o endere\'e7o da vari\'e1vel estrutura ou \line uma refer\'eancia para a vari\'e1vel estrutura. Arrays de estruturas - como todos os outros arrays - s\'e3o passados atrav\'e9s de chamadas por refer\'eancia. \line No Cap\'edtulo 4, afirmamos que um array poderia ser passado atrav\'e9s de uma chamada por valor usando uma estrutura. Para passar um array por uma chamada por valor, crie uma estrutura (ou uma classe) com o array como um membro. Como estruturas s\'e3o passadas atrav\'e9s de chamadas por valor, o array \'e9 passado atrav\'e9s de uma chamada por valor. \line IErro com um de programa\'e7\'e3o 16.3 \line Assumir que estruturas, como arrays, s\'e3o passadas atrav\'e9s de chamadas por refer\'eancia e tentar modificar os valores da estrutura do chamador na fun\'e7\'e3o chamada. \line Dica de desempenho 16.1 \line ______ Passar estruturas (especialmente estruturas grandes) atrav\'e9s de chamada por refrr\'e9ncia \'e9 mais eficiente do que passar estruturas atrav\'e9s de chamadas por valor (o que exige a c\'f3pia da estrutura inteira). \line 16.5 typedef \line A palavra-chave typedef fornece um mecanismo para criar sin\'f4nimos (ou nomes alternativos) para tipos de dados previamente definidos. Os nomes para tipos estrutura s\'e3o freq\'fcentemente definidos com typedef para criar nomes de tipo menores ou mais leg\'edveis. Por exemplo, o comando \line typedef Card *CardPtr; \line define o novo nome de tipo CardPtr como um sin\'f4nimo para o tipo Card . \line Boa pr\'e1tica de programa\'e7\'e3o 16.2 \line Comece nomes typedef com mai\'fasculas, para enfatizar que estes nomes s\'e3o sin\'f4nimos de outros nomes \line de tipo. \line Criar um novo nome com typedef n\'e3o cria um novo tipo de dados; typedef simplesmente cria um novo nome de tipo que pode ser ent\'e3o usado no programa como um nome alternativo para um nome de tipo existente. \line Sin\'f4nimos para tipos de dados primitivos podem ser criados com typedef. Por exemplo, um programa que necessita de inteiros de 4 bytes pode usar o tipo int em um sistema e o tipo long int em outro sistema que tem inteiros de 2 bytes. Os programas projetados pensando em portabilidade podem usar typedef para criar um nome alternativo, tal como Integer, para inteiros de 4 bytes. Integer pode ent\'e3o ser tornado sin\'f4nimo de int em sistemas com inteiros de 4 bytes e pode ser tornado sin\'f4nimo de long int em sistemas com inteiros de 2 bytes onde valores long int ocupam 4 bytes. Ent\'e3o, para escrever programas port\'e1veis, o programador simplesmente declara todas as vari\'e1veis inteiras de 4 bytes como sendo do tipo Integer. \line Dica de portabilidade 16.2 \line _____ Usar typedef pode ajudar a tornar um programa mais port\'e1vel. \line 16.6 Exemplo: uma simula\'e7\'e3o de alto desempenho do \line embaralhamento e distribui\'e7\'e3o de cartas \line O programa na Fig. 16.2 se baseia na simula\'e7\'e3o do embaralhamento e distribui\'e7\'e3o de cartas discutido no Cap\'edtulo 5. \line O programa representa o baralho de cartas como um array de estruturas e usa algoritmos de alto desempenho para \line embaralhamento e distribui\'e7\'e3o. A sa\'edda \'e9 mostrada na Fig. 16.3. \par
812 C++ COMO PROGRAMAR \line 60 \line 1 II Fig. 16.2: figl6O2.cpp 61 \line 2 II Programa para embaralhar e distribuir cartas usando estruturas 62 \line 3 #include <iostream> 63 \line 64 \line 5 using std::cout; 65 \line 6 using std::cin; 66 \line 7 using std: :endl; 67 \line 8 using std: :ios; 68 \line 69 \line 10 #include <iomanip> 70 \line 11 71 \line 12 using std::setiosflags; - \line 13 using std::setw; Fig. \line 14 \line 15 #include <cstdlib> \line 16 #include <ctime> Nop \line 17 \'c1sal \line 18 struct Card \{ deal \line 19 char *face; ment \line 20 char *suit; \line 21 entre \line 22 namt \line 23 void fillDeck( Card * const, char *E], char *[] ); eoa \line 24 void shuffle( Card * const ); com \line 25 void deal ( Card * const ); pr\'f3pi \line 26 array \line 27 int main() \line 28 \{ \line 29 Card deck[ 52 ]; \line 30 char *face [] = ( \'c1s\rdblquote , \ldblquote Dois\rdblquote , \ldblquote Tr\'eas\rdblquote , \ldblquote Quatro\rdblquote , \line 31 \ldblquote Cinco\rdblquote , \ldblquote Seis\rdblquote , \ldblquote Sete\rdblquote , \ldblquote Oito\rdblquote , \line 32 \ldblquote Nove\rdblquote , \ldblquote Dez\rdblquote , \ldblquote Valete\rdblquote , \ldblquote Dama\rdblquote , \line 33 \ldblquote Rei\rdblquote  \}; \line 34 char *suit[] = \{ \ldblquote Copas\rdblquote , \ldblquote Ouros\rdblquote , \line 35 \ldblquote Paus\rdblquote , \ldblquote Espadas\rdblquote  \}; \line 36 \line 37 srand( time( O ) ); // randomiza \line 38 fillDeck( deck, face, suit ); \line 39 shuffle( deck ); \line 40 deal( deck ); \line 41 return 0; \line 42 \} \line 43 \line 44 void fillDeck( Card * const wDeck, char *wFace[), \line 45 char *wsuit[] \line 46 \{ \line 47 for ( int i = 0; i < 52; i++ \line 48 wDeck[ i ) .face = wFace[ i % 13 ]; \line 49 wDeck[ i ) .suit = wSuit[ i / 13 \line 50 \line 51 \} \line 52 \line 53 void shuffle( Card * const wDeck \line 54 \line 55 for ( int i = 0; i < 52; i++ \line 56 int j = rand() % 52; \line 57 Card temp = wDeck[ i ]; \line 58 wDeck[ i ] = wDeck[ j ]; \line 59 wDeck[ j ) = temp; \line Fig. 16.2 Simula\'e7\'e3o de alto desempenho de embaralhamento e distribui\'e7\'e3o de cartas (parte 1 de 2). Fig. \par
CAP\'cdTULO 16 - BIT5, CARACTERES, STRINGS E ESTRUTURAS 813 \par
60 \} \line 61 \} \line 62 \line 63 void deal( Card * const wDeck \line 64 \line 65 for ( int i 0; i < 52; i++ \line 66 cout \'ab setiosflags( ios::right \line 67 \'ab setw( 5 ) \'ab wDeck[ i ] .face \'ab de \line 68 \'ab setiosflags ( ios: : left \line 69 \'ab setw( 8 ) \'ab wDeck[ i ].suit \line 70 \'ab((i+1)%2?\\t\rquote  : \line 71 \par
Fig. 16.2 Simula\'e7\'e3o de alto desempenho de embaralhamento e distribui\'e7\'e3o de cartas (parte 2 de 2). \line No programa, a fun\'e7\'e3o fillDeck inicializa o array Card segundo a ordem de strings de caracteres representando As a Rei de cada naipe (\ldblquote suit\rdblquote ). O array Card\'e9 passado para a fun\'e7\'e3o shuffle. onde o algoritmo de embaralhamento de alto desempenho est\'e1 implementado. A fun\'e7\'e3o shuffle recebe um array de 52 estruturas Card como argumento. A fun\'e7\'e3o executa um la\'e7o atrav\'e9s de todas as 52 cartas (\'edndices de array O a 51). Para cada carta, um n\'famero entre O e SI \'e9 escolhido aleatoriamente. Em seguida, a estrutura Card atual e a estrutura Card selecionada aleatoriamente s\'e3o trocadas de posi\'e7\'e3o no array. Um total de 52 trocas s\'e3o feitas em uma \'fanica passagem de todo o array e o array de estruturas Card est\'e1 embaralhado! Este algoritmo n\'e3o sofre do problema de adiamento indefinido como o algoritmo de embaralhamento apresentado no Cap\'edtulo 5. Como as estruturas Card foram trocadas no pr\'f3prio array, o algoritmo de alto desempenho implementado na fun\'e7\'e3o deal exige somente uma passagem pelo array para distribuir as cartas embaralhadas. \par
Erro comum de programa\'e7\'e3o 16.4 \par
ras. \par
\pard\sb100\sa100 Esquecer de incluir o \'edndice de array quando refrrenciar estruturas individuais em um array de estrutu Oito \par
\pard\sb100\sa240 Fig. 16.3 Sa\'edda da simula\'e7\'e3o de alto desempenho de embaralhamento e distribui\'e7\'e3o de cartas. \par
\pard\par
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx685\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1094\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1983\pard\intbl\cell de \cell Ouros \cell\row
\intbl Oito \cell de \cell Paus \cell\row
\intbl Sete \cell de \cell Copas \cell\row
\intbl As \cell de \cell Paus \cell\row
\intbl Dois \cell de \cell Espadas \cell\row
\intbl Sete \cell de \cell Espadas \cell\row
\intbl Valete \cell de \cell Paus \cell\row
\intbl Rei \cell de \cell Copas \cell\row
\intbl Tr\'eas \cell de \cell Copas \cell\row
\intbl Tr\'eas \cell de \cell Paus \cell\row
\intbl Dez \cell de \cell Copas \cell\row
\intbl Dez \cell de \cell Paus \cell\row
\intbl Seis \cell de \cell Paus \cell\row
\intbl Seis \cell de \cell Copas \cell\row
\intbl Nove \cell de \cell Ouros \cell\row
\intbl Valete \cell de \cell Espadas \cell\row
\intbl Rei \cell de \cell Ouros \cell\row
\intbl Nove \cell de \cell Espadas \cell\row
\intbl Seis \cell de \cell Espadas \cell\row
\intbl Dama \cell de \cell Ouros \cell\row
\intbl As \cell de \cell Espadas \cell\row
\intbl Rei \cell de \cell Paus \cell\row
\intbl Rei \cell de \cell Espadas \cell\row
\intbl Dama \cell de \cell Copas \cell\row
\intbl Quatro \cell de \cell Espadas \cell\row
\intbl Quatro \cell de \cell Paus \cell\row
\pard\sa240\par
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx685\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1094\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1983\pard\intbl\'c1s \cell de \cell Copas \cell\row
\intbl Cinco \cell de \cell Espadas \cell\row
\intbl Dois \cell de \cell Ouros \cell\row
\intbl Dez \cell de \cell Ouros \cell\row
\intbl Seis \cell de \cell Ouros \cell\row
\intbl Dois \cell de \cell Paus \cell\row
\intbl Dez \cell de \cell Espadas \cell\row
\intbl Valete \cell de \cell Ouros \cell\row
\intbl Tr\'eas \cell de \cell Ouros \cell\row
\intbl Nove \cell de \cell Paus \cell\row
\intbl Dois \cell de \cell Copas \cell\row
\intbl Sete \cell de \cell Ouros \cell\row
\intbl Dama \cell de \cell Espadas \cell\row
\intbl Tres \cell de \cell Espadas \cell\row
\intbl As \cell de \cell Ouros \cell\row
\intbl Cinco \cell de \cell Paus \cell\row
\intbl Sete \cell de \cell Paus \cell\row
\intbl Quatro \cell de \cell Copas \cell\row
\intbl Oito \cell de \cell Espadas \cell\row
\intbl Cinco \cell de \cell Ouros \cell\row
\intbl Nove \cell de \cell Copas \cell\row
\intbl Cinco \cell de \cell Copas \cell\row
\intbl Quatro \cell de \cell Ouros \cell\row
\intbl Oito \cell de \cell Copas \cell\row
\intbl Valete \cell de \cell Copas \cell\row
\intbl Dama \cell de \cell Paus \cell\row
\pard\par
\pard\sb100\sa240 814 C++ COMO PROGRAMAR \line 16.7 Operadores sobre bits \line C++ fornece recursos de manipula\'e7\'e3o de bits abrangentes para os programadores que necessitam descer ao chamado n\'edvel de \ldblquote bits e bytes\rdblquote . Sistemas operacionais, software de equipamentos de teste, software de rede e muitos outros tipos de software exigem que o programador se comunique \ldblquote diretamente com o hardware\rdblquote . Nestas e nas pr\'f3ximas se\'e7\'f5es, discutimos os recursos de manipula\'e7\'e3o de bits de C++. Introduzimos cada um dos muitos operadores sobre bits de C++ e discutimos como economizar mem\'f3ria usando campos de bits. \line Todos os dados s\'e3o representados internamente pelos computadores como seq\'fc\'eancias de bits. Cada bit pode assumir o valor O ou o valor 1. Na maioria dos sistemas, uma seq\'fc\'eancia de 8 bits forma um byte - a unidade padr\'e3o de armazenamento para uma vari\'e1vel do tipo char. Outros tipos de dados s\'e3o armazenados em quantidades maiores de byres. Os operadores sobre bits s\'e3o usados para manipular os bits de operandos integrais (char, short, int e long; tanto signed como uns igned). Inteiros uns igned s\'e3o normalmente usados com os operadores sobre bits. \line Dica de portabilidade 16.3 \line _____ As manipula\'e7\'f5es de dados sobre bits s\'e3o dependentes de m\'e1quina. \line Note que as discuss\'f5es de operadores sobre bits nesta se\'e7\'e3o mostram as representa\'e7\'f5es bin\'e1rias dos operandos inteiros. Para uma explica\'e7\'e3o detalhada da nota\'e7\'e3o bin\'e1ria (tamb\'e9m chamada de sistema de numera\'e7\'e3o de base 2), veja o ap\'eandice C, \ldblquote Sistemas de numera\'e7\'e3o\rdblquote . Por causa da natureza dependente de m\'e1quina das manipula\'e7\'f5es sobre bits, estes programas podem n\'e3o funcionar em seu sistema. \line Os operadores sobre bits s\'e3o: AND (&) sobre bits, OR inclusivo (1) sobre bits, OR exclusivo (A) sobre bits, deslocamento \'e0 esquerda (\'ab), deslocamento \'e0 direita (\'bb) e complemento (-). (Note que temos usado &. \'ab e\'bb para outras finalidades. Este \'e9 um exemplo cl\'e1ssico de sobrecarga de operador). Os operadores sobre bits AND, OR inclusivo e OR exclusivo comparam seus dois operandos bit a bit. O operador sobre bits AND define cada bit no resultado como 1 se o bit correspondente em ambos os operandos \'e9 1. O operador sobre bits OR inclusivo define cada bit no resultado como 1 se o bit correspondente em qualquer um dos (ou ambos os) operandos \'e9 1. O operador sobre bits OR exclusivo define cada bit no resultado como 1 se o bit correspondente em exatamente um operando \'e9 1. O operador de deslocamento \'e0 esquerda move os bits de seu operando esquerdo para a esquerda pelo n\'famero de bits especificados em seu operando direito. O operador de deslocamento \'e0 direita move os bits em seu operando esquerdo para a direita pelo n\'famero de bits especificados em seu operando direito. O operador sobre bits complemento transforma todos os bits O em seu operando em 1 no resultado e todos os bits 1 em O no resultado. As discuss\'f5es detalhadas de cada operador sobre bits aparecem nos exemplos seguintes. Os operadores sobre bits est\'e3o resumidos na Fig. 16.4. \line Ao se usar os operadores sobre bits, \'e9 \'fatil se imprimir valores em sua representa\'e7\'e3o bin\'e1ria para ilustrar os efeitos precisos destes operadores. A Fig. 16.5 imprime um inteiro unsigned em sua representa\'e7\'e3o bin\'e1ria, em grupos de oito bits. A fun\'e7\'e3o displayBits usa o operador AND sobre bits para combinar a vari\'e1vel value com a constante MASK. Freq\'fcentemente, o operador AND sobre bits \'e9 usado com um operando chamado de m\'e1scara - um valor inteiro com bits espec\'edficos colocados em 1. M\'e1scaras s\'e3o usadas para esconder alguns bits em um valor ao mesmo tempo que selecionam outros bits. Em displayBits, a m\'e1scara constante MASK recebe o valor \line 1 \'ab SHIFT \line A constante SHIFT recebe o resultado de \line 8 * sizeof( unsigned ) - 1 \par
Operador Nome Descri\'e7\'e3o \par
& AND sobre bits Os bits no resultado s\'e3o inicializados com 1 se os bits corres pondente nos dois operandos s\'e3o ambos 1. \line Fig. 16.4 Os operadores sobre bits (parte 1 de 2). \par
CAP\'cdTULO 16- BITs, CARACTERES, STRINGS E ESTRUTURAS 815 \par
1 II Fig. 16.5: figl6O5.cpp \line 2 // Imprimindo um inteiro sem sinal em bin\'e1rio \line 3 #include <iostream> \line 4 \line 5 using std::cout; \line 6 using std::cin; \line 7 \line 8 #include <iomanip> \line 9 \line 10 using std::setw; \line li using std: :endl; \line 12 \line 13 void displayBits ( unsigned ); \line 14 \line 15 int main() \line 16 \{ \line 17 unsigned x; \line 18 \line 19 cout \'ab \ldblquote Digite um inteiro sem sinal: \line 20 cm \'bb x; \line 21 displayBits ( x \line 22 return 0; \line 23 \line 24 \line 25 void displayBits( unsigned value \line 26 \{ \line 27 const int SHIFT = 8 * sizeof( unsigned ) - 1; \line 28 const unsigned MASK = 1 \'ab SHIFT; \line 29 \line 30 cout \'ab setw( 7 ) \'ab value \'ab \ldblquote  = \line 31 \line 32 for ( unsigned e 1; c <= SHIFT + 1; c++ \line 33 cout \'ab ( value & MASK ? 1\rquote  : \lquote 0 \line Fig. 16.5 Imprimindo um inteiro sem sinal em bin\'e1rio (parte 1 de 2). \par
\pard\par
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx991\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx3270\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx8946\pard\intbl Operador \cell Nome \cell Descri\'e7\'e3o \cell\row
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx425\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx991\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx3270\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx8946\pard\intbl\cell 1 \cell OR inclusivo sobre bits \cell Os bits no resultado s\'e3o inicializados com 1 se pelo menos um \cell\row
\intbl\cell\cell\cell dos bits correspondentes no dois operandos \'e9 1. \cell\row
\intbl\cell A \cell OR exclusivo sobre bits \cell Os bits no resultado s\'e3o inicializados com 1 se exatamente um dos bits correspondentes nos dois operandos \'e9 1. \cell\row
\intbl\cell\'ab \cell deslocamento para a esquerda \cell Desloca para a esquerda os bits do primeiro operando pelo n\'famero de bits especificado pelo segundo operando; preenche a partir da direita com bits O. \cell\row
\intbl\cell\'bb \cell deslocamento para a direita com extens\'e3o de sinal \cell Desloca para a direita os bits do primeiro operando pelo n\'famero de bits especificado pelo segundo operando; a forma de preencher a partir da esquerda depende da m\'e1quina. \cell\row
\intbl\cell - \cell complemento un\'e1rio \cell Todos os bits O s\'e3o inicializados com is e todos os bits is s\'e3o \cell\row
\intbl\cell\cell\cell inicializados com 0. \cell\row
\intbl Fig. \cell 16.4 \cell s operadores sobre bits (parte 2 d \cell e 2). \cell\row
\pard\par
\pard\sb100\sa240 16 C++ COMO PROGRAMAR \line 34 value \'ab= 1; \line 35 \line 36 if(c%8==0) \line 37 cout\'ab \line 38 \line 39 \line 40 cout \'ab endl; \line 41 \line Digite um inteiro sem sinal: 65000 \line 65000 = 00000000 00000000 11111101 11101000 \line Fig. 16.5 Imprimindo um inteiro sem sinal em bin\'e1rio (parte 2 de 2). \line Esta express\'e3o multiplica a quantidade de bytes necess\'e1rios para armazenar um valor uns igned por 8 para obter o n\'famero total de bits e. ent\'e3o, subtrai 1. A representa\'e7\'e3o de 1 \'ab SHIFT \'e9 \line 10000000 00000000 00000000 00000000 \line O operador de deslocamento \'e0 esquerda desloca o valor 1 do bit menos significativo (o mais \'e0 direita) para o bit mais significativo (o mais \'e0 esquerda) em MASK e preenche com bits O a partir da direita, O comando \line cout \'ab ( value & MASK ? 1 : 0\rquote  ); \line determina se um 1 ou um O deve ser impresso para o bit atualmente mais \'e0 esquerda da vari\'e1vel value. Suponha queavari\'e1velvaluecont\'e9m 65000 (00000000 00000000 11111101 1ii0i000).QuandovalueeMASK s\'e3o combinados usando &, todos os bits, exceto o bit de mais alta ordem da vari\'e1vel value. s\'e3o \ldblquote mascarados\rdblquote  (escondidos), porque qualquer bit combinado por AND comO fica 0. Se o bit mais \'e0 esquerda \'e9 1. value & MASK \'e9 avaliada como \line 00000000 00000000 11111101 11101000 (value) \line 10000000 00000000 00000000 00000000 (MASK) \line 00000000 00000000 00000000 00000000 (value & MASK) \line que \'e9 interpretado como false. e O \'e9 impresso. A vari\'e1vel value \'e9 ent\'e3o deslocada para a esquerda em um bit, pela express\'e3o value \'ab= 1 (isto \'e9 equivalente \'e0 atribui\'e7\'e3o value = value \'ab 1). Estes passos s\'e3o repetidos para cada bit da vari\'e1vel value. Em algum momento, um bit com o valor 1 \'e9 deslocado para a posi\'e7\'e3o mais \'e0 esquerda, e a manipula\'e7\'e3o dos bits \'e9 como segue: \line 11111101 11101000 00000000 00000000 (value) \line 10000000 00000000 00000000 00000000 (MASK) \line 10000000 00000000 00000000 00000000 (value & MASK) \line Como os dois bits da esquerda s\'e3o is, \'e9 impresso o valor 1. A Fig. 16.6 resume os resultados de combinar dois bits com o operador AND sobre bits. \line Erro comum de programa\'e7\'e3o 16.5 \line Usar o operadorAND l\'f3gico (&&) como o operadorAND sobre bits (&), e vice-versa. \par
CAP\'cdTULO 16- BIT5, CARACTERES, STRINGS E ESTRUTURAS 817 \par
Fig. 16.6 Resultados de combinar dois bits com o operador AND sobre bits (&). \line O programa da Fig. 16.7 demonstra o uso do operador AND sobre bits, o operador OR inclusivo sobre bits, o operador OR exclusivo sobre bits e o operador complemento sobre bits. A fun\'e7\'e3o displayBits imprime os valores inteiros unsigned. A sa\'edda \'e9 mostrada na Fig. 16.8. \line 1 II Fig. 16.7: figl6_07.cpp \line 2 // Usando os operadores sobre bits AND, OR inclusivo, \line 3 II OR exclusivo e complemento. \line 4 #include <iostream> \line 5 \line 6 using std::cout; \line 7 using std::cin; \line 8 \line 9 #include <iomanip> \line 10 \line 11 using std: :endl; \line 12 using std::setw; \line 13 \line 14 void displayBits ( unsigned ); \line 15 \line 16 int main() \line 17 \line 18 unsigned numberl, number2, mask, setBits; \line 19 \line 20 nuxnberl = 2179876355; \line 21 mask = 1; \line 22 cout \'ab \ldblquote O resultado de combinar os seguintes\\n\rquote ; \line 23 displayBits( nuitiberl ); \line 24 displayBits ( mask ); \line 25 cout \'ab \lquote usando o operador AND sobre bits, & \'e9\\n\rdblquote ; \line 26 displayBits( numberl & mask ); \line 27 \line 28 nuniberi = 15; \line 29 setBits = 241; \line 30 cout \'ab \ldblquote\\nO resultado de combinar os seguintes\\n\rdblquote ; \line 31 displayBits ( nuinberl ); \line 32 displayBits ( setBits ); \line 33 cout \'ab \ldblquote usando o operador OR inclusivo sobre bits, l \'e9\\n\rdblquote ; \line 34 displayBits( numberl setBits ); \line 35 \line 36 nuinberl = 139; \line 37 number2 = 199; \line 38 cout \'ab \ldblquote\\nO resultado de combinar os seguintes\\n\rdblquote ; \line 39 displayBits( numberl ); \line 40 displayBits ( number2 ); \line Fig. 16.7 Usando os operadores sobre bits AND, OR inclusivo, OR exclusivo e complemento (parte 1 de 2). \par
\pard\par
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx464\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1036\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2193\pard\intbl Bil 1 \cell Bit 2 \cell Bit 1 & Bit 2 \cell\row
\intbl o \cell o \cell o \cell\row
\intbl 1 \cell O \cell O \cell\row
\intbl O \cell 1 \cell 1 \cell\row
\intbl 1 \cell 1 \cell 1 \cell\row
\pard\par
\pard\sb100\sa240 818 C++ COMO PROGRAMAR \line 41 cout \'ab \ldblquote usando o operador OR exclusivo sobre bits, \ldblquote  \'e9\\n\rquote ; \line 42 displayBits ( numberl A nuniber2 ); \line 43 \line 44 numberl = 21845; \line 45 cout \'ab \ldblquote\\nO complemento de um de\\n\rquote ; \line 46 displayBits( numberi ); \line 47 cout \'ab \ldblquote\'e9 \'ab endl; \line 48 displayBits( -number1 ); \line 49 \line 50 return 0; \line 51 \line 52 \line 53 void displayBits( unsigned value \line 54 \{ \line 55 const int SHIFT = 8 * sizeof( unsigned ) - 1; \line 56 const unsigned MASK = 1 \'ab SHIFT; \line 57 \line 58 cout \'ab setw( 10 ) \'ab value \'ab = \line 59 \line 60 for ( unsigned c = 1; c <= SHIFT + 1; c++ ) \{ \line 61 cout \'ab ( value & MASK ? 1 : \lquote 0\rquote  ); \line 62 value \'ab= 1; \line 63 \line 64 if(c%8==0) \line 65 cout\'ab \line 66 ) \line 67 \line 68 cout \'ab endl; \line 69 \} \line Fig. 16.7 Usando os operadores sobre bits AND, OR inclusivo, OR exclusivo e complemento (parte 2 de 2). \line O resultado de combinar os seguintes \line 2179876355 = 10000001 11101110 01000110 00000011 \line 1 = 00000000 00000000 00000000 00000001 \line usando o operador AND sobre bits, & \'e9 \line 1 = 00000000 00000000 00000000 00000001 \line O resultado de combinar os seguintes \line 15 = 00000000 00000000 00000000 00001111 \line 241 = 00000000 00000000 00000000 11110001 \line usando o operador OR inclusivo sobre bits, 1 \'e9 \line 255 = 00000000 00000000 00000000 11111111 \line O resultado de combinar os seguintes \line 139 = 00000000 00000000 00000000 10001011 \line 199 = 00000000 00000000 00000000 11000111 \line usando o operador OR exclusivo sobre bits, A \line 76 = 00000000 00000000 00000000 01001100 \line O complemento de um de \line 21845 = 00000000 00000000 01010101 01010101 \line e \line 4294945450 = 11111111 11111111 10101010 10101010 \line Fig. 16.8 Sa\'edda do programa da Fig. 16.7. \par
CAP\'cdTULO 16- BITs, CARACTERES, STRINGS E ESTRUTURAS 819 \line Na Fig. 16.7, o valor 1 (00000000 00000000 00000000 00000001) \'e9 atribu\'eddo \'e0 vari\'e1vel niask e o valor \line 2179876355(10000001 11101110 01000110 00000001)\'e9 atribu\'eddo \'e0vari\'e1vel nuniberi. Quando mask \line e nuxnberl s\'e3o combinados usando-se o operador AND sobre bits (&), na express\'e3o nuxnberl & mask. o resultado\'e9 00000000 00000000 00000000 00000001.Todososbits,excetoobitdeordemmaisbaixanavari\'e1vel \line numberi, s\'e3o \ldblquote mascarados\rdblquote  (escondidos) pela opera\'e7\'e3o de AND com a constante MASK. \line O operador sobre bits OR inclusivo \'e9 usado para colocar bits espec\'edficos de um operando em 1. Na Fig. 16.7, \'e9 atribu\'eddo 15 (00000000 00000000 00000000 00001111) \'e0 vari\'e1vel nuniberle\'e9 atribu\'eddo 241 (00000000 00000000 00000000 11110001)\'e0vari\'e1velsetBits.QuandonumberlesetBitss\'e3ocombinadosusando- seooperadorsobrebits ORnaexpress\'e3onuxnberl 1 setBits, oresultado\'e9255 (00000000 00000000 00000000 11111111). A Fig. 16.9 resume os resultados de combinar dois bits com o operador sobre bits OR inclusivo. \par
Bit 1 Bit 2 Bit 1 1 Bit 2 \par
Fig. 16.9 Resultados de combinar dois bits com o operador sobre bits OR inclusivo (1). \line Erro comum de programa\'e7\'e3o 16.6 \line Usar o operador OR l\'f3gico (1 1) em vez do operador OR sobre bits (1) e vice-versa. \line O operador sobre bits OR exclusivo (\ldblquote ) coloca cada bit no resultado em 1 se exatamente um dos bits correspondentes em seus dois operandos for 1. NaFig. 16.7, s\'e3o atribu\'eddos os valores 139 (00000000 00000000 00000000 10001011) e199 (00000000 00000000 00000000 11000111) \'e0svari\'e1veisnuniberlenumber2. Quando estas vari\'e1veis forem combinadas com o operador OR exclusivo na express\'e3o nuniberi number2, o resultado \'e9 00000000 00000000 00000000 01001100. A Fig. 16.10 resume os resultados de combinar dois bits com o operador sobre bits OR exclusivo. \par
Bit 1 Bit 2 Bit 1 A Bit 2 \par
Fig. 16.10 Resultados de combinar dois bits com o operador sobre bits OR exclusivo (A). \par
O operador sobre bits complemento (-) muda todos os bits 1 em seu operando para O no resultado e muda todos os bits O no resultado para 1- tamb\'e9m chamado de \ldblquote complementar para um o valor\rdblquote . Na Fig. 16.7, \'e0 vari\'e1vel nuniberi \'e9atribu\'eddoovalor2l845 (00000000 00000000 01010101 01010101).Quandoaexpress\'e3o -numberi \'e9avaliada,oresultado\'e9(11111111 11111111 10101010 10101010). \line O programa da Fig. 16.11 demonstra o operador de deslocamento \'e0 esquerda (\'ab) e o operador de deslocamento \'e0 direita (\'bb).A fun\'e7\'e3o displayBits \'e9 usada para imprimir os valores inteiros unsigned. \line 1 // Fig. 16.11: figl6_11.cpp \line 2 II Usando os operadores de deslocamento sobre bits \line 3 #irzclude <iostream> \par
Fig. 16.11 Usando os operadores de deslocamento sobre bits (parte 1 de 2). \par
820 C++ COMO PROGRAMAR \line 4 \line 5 using std::cout; \line 6 using std::cin; \line 7 using std::endl; \line 8 \line 9 #include <iomanip> \line 10 \line 11 using std::setw; \line 12 \line 13 void displayBits( unsigned ); \line 14 \line 15 int main() \line 16 \line 17 unsigned numberi = 960; \line 18 \line 19 cout \'ab \lquote O resultado de deslocar para a esquerda\\n\rdblquote ; \line 20 displayBits( numberl ); \line 21 cout \'ab \ldblquote 8 bits usando o operador de \line 22 \'ab deslocamento para a esquerda \'e9\\n; \line 23 displayBits ( nuinberl \'ab 8 ); \line 24 cout \'ab \ldblquote\\nO resultado de deslocar para a direita\\n; \line 25 displayBits( numberi ); \line 26 cout \'ab \ldblquote 8 bits usando o operador de \line 27 \'ab \ldblquote deslocamento para a esquerda \'e9\\n\rdblquote ; \line 28 displayBits ( numberi \'bb 8 ); \line 29 return 0; \line 30 \} \line 31 \line 32 void displayBits( unsigned value \line 33 \line 34 const int SHIFT = 8 * sizeof( unsigned ) - 1; \line 35 const unsigned MASK = 1 \'ab SHIFT; \line 36 \line 37 cout \'ab setw( 7 ) \'ab value \'ab \ldblquote  = \line 38 \line 39 for ( unsigned c = 1; c <= SHIFT + 1; c++ \line 40 cout \'ab ( value & MASK ? \lquote 1\rquote  : \lquote 0\rquote  ); \line 41 value \'ab= 1; \line 42 \line 43 if(c%8==0) \line 44 cout\'ab \lquote  \line 45 \} \line 46 \line 47 cout \'ab endl; \line 48 \line O resultado de deslocar para a esquerda \line 960 = 00000000 00000000 00000011 11000000 \line 8 bits usando o operador de deslocamento para a esquerda \'e9 \line 245760 = 00000000 00000011 11000000 00000000 \line O resultado de deslocar para a direita \line 960 = 00000000 00000000 00000011 11000000 \line 8 bits usando o operador de deslocamento para a direita \'e9 \line 3 = 00000000 00000000 00000000 00000011 \line Fig. 16.11 Usando os operadores de deslocamento sobre bits (parte 2 de 2). \par
CAP\'cdTULO 16 BITs, CARACTERES, STRINGS E ESTRUTURAS 821 \par
O operador de deslocamento \'e0 esquerda (\'ab) desloca os bits de seu operando esquerdo para a esquerda pelo n\'famero \line de bits especificados em seu operando direito. Os bits liberados \'e0 direita s\'e3o substitu\'eddos com Os; os bits \'e0 esquerda \line deslocados parafora s\'e3o perdidos. No programadafig. 16.11,0 valor 960 (00000000 00000000 00000011 \line 11000000) \'e9 atribu\'eddo \'e0 vari\'e1vel nuiTiberi. O resultado de deslocar a vari\'e1vel numberi \'e0 esquerda 8 bits na \line express\'e3onumberl \'ab 8\'e9245760 (00000000 00000011 11000000 00000000). \line O operador de deslocamento \'e0 direita (\'bb) desloca os bits de seu operando esquerdo para a direita pelo n\'famero de bits especificados em seu operando direito. Executar um deslocamento \'e0 direita em um inteiro unsigned faz com que os bits desocupados na esquerda sejam substitu\'eddos por Os; os is deslocados para fora \'e0 direita s\'e3o perdidos. No programa da Fig. 16.11, o resultado de fazer um deslocamento \'e0 direita de nuiriberi na express\'e3o nuniberl \'bb 8\'e93 (00000000 00000000 00000000 00000011). \line Erro comum de programa\'e7\'e3o 16.7 \line O resultado de fazer um deslocamento de um valor \'e9 indefinido se o operando direito for negativo ou se o operando direito for maior que o n\'famero de bits em que o operando esquerdo est\'e1 armazenado. \line Dica de portabilidade 16.4 \line ______ O resultado de fazer um deslocamento \'e0 direita de um valor com sinal \'e9 dependente de m\'e1quina. Algumas m\'e1quinas preenchem com zero e outras usam o bit de sinal. \line Cada operador sobre bits (exceto o operador de complemento) tem um operador de atribui\'e7\'e3o correspondente. Estes operadores de atribui\'e7\'e3o sobre bits s\'e3o mostrados na Fig. 16.12 e s\'e3o usados de maneira semelhante aos operadores de atribui\'e7\'e3o aritm\'e9ticos introduzidos no Cap\'edtulo 2. \par
Fig. 16.12 Os operadores de atribui\'e7\'e3o sobre bits. \par
A Fig. 16.13 mostra a preced\'eancia e associatividade dos v\'e1rios operadores introduzidos at\'e9 aqui no texto. Eles s\'e3o mostrados, de cima para baixo, em ordem decrescente de preced\'eancia. \par
Fig. 16.13 Preced\'eancia e associatividade de operadores (parte 1 de 2). \par
\pard\par
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1119\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx6548\pard\intbl Operadores \cell de atribui\'e7\'e3o sobre bits \cell\row
\intbl & \cell Operador de atribui\'e7\'e3o AND sobre bits. \cell\row
\intbl\cell Operador de atribui\'e7\'e3o OR inclusivo sobre bits. \cell\row
\intbl A \cell Operador de atribui\'e7\'e3o OR exclusivo sobre bits. \cell\row
\intbl\'ab \cell Operador de atribui\'e7\'e3o de deslocamento \'e0 esquerda. \cell\row
\intbl\'bb= \cell Operador de atribui\'e7\'e3o de deslocamento \'e0 direita com extens\'e3o de sinal. \cell\row
\pard\sa240\par
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2282\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4817\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx6658\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx8219\pard\intbl Operadores \cell\cell Associatividade \cell Tipo \cell\row
\intbl (un\'e1rio; direita para esquerda) \cell : (bin\'e1rio; esquerda para direita) \cell esquerda para a direita \cell mais alta \cell\row
\intbl O [1 . -> ++ -- \cell\cell esquerda para a direita \cell express\'e3o p\'f3s-fixa \cell\row
\intbl static_cast<!ype> O \cell\cell\cell\cell\row
\intbl ++ -- + - ! delete \cell sizeof \cell direita para a esquerda \cell un\'e1rio \cell\row
\intbl * & new \cell\cell\cell\cell\row
\intbl * / % \cell\cell esquerda para a direita \cell multiplicativo \cell\row
\intbl + - \cell\cell esquerda para a direita \cell aditivo \cell\row
\intbl\'ab \'bb \cell\cell esquerda para a direita \cell deslocamento \cell\row
\intbl < <= > >= \cell\cell esquerda para a direita \cell relacional \cell\row
\intbl == = \cell\cell esquerda para a direita \cell igualdade \cell\row
\pard\par
\pard\sb100\sa240 822 C++ COMO PROGRAMAR \par
Fig. 16.13 Preced\'eancia e associatividade de operadores (parte 2 de 2). \line 16.8 Campos de bits \line C\'f7+ fornece a possibilidade de especificar o n\'famero de bits no qual um membro unsigned ou int de uma classe ou uma estrutura (ou uma uni\'e3o - ver Cap\'edtulo 18) \'e9 armazenado. Tal membro \'e9 chamado de campo de bits. Os campos de bits possibitam uma melhor utiliza\'e7\'e3o de mem\'f3ria, armazenando dados no n\'famero m\'ednimo de bits exigidos. Os membros de um campo de bits devem ser declarados como int ou unsigned. \line\ul 1 \ulnone Dica de desempenho 16.2 \line f Campos de bits ajudam a economizar mem\'f3ria. \line Considere a seguinte defini\'e7\'e3o de estrutura: \line struct BitCard \{ \line unsigned face 4; \line unsigned suit : 2; \line unsigned color : 1; \line A defini\'e7\'e3o cont\'e9m tr\'eas campos de bits uns igned - face. suit e color - usados para representar uma carta de um baralho de 52 cartas. Um campo de bits \'e9 declarado seguindo-se um membro unsigned ou int por um dois-pontos (:) e uma constante inteira representando o comprimento do campo (i.e., o n\'famero de bits em que o membro \'e9 armazenado). O comprimento deve ser uma constante do tipo inteiro entre O e o n\'famero total de bits usados para armazenar um int em seu sistema. \line A defini\'e7\'e3o de estrutura precedente indica que o membro face \'e9 armazenado em 4 bits, o membro suit \'e9 \line armazenado em 2 bits e o membro color \'e9 armazenado em 1 bit. O n\'famero de bits se baseia no intervalo desejado \line de valores para cada membro da estrutura. O membro face armazena valores entre O (As) e 12 (Rei) - 4 bits \line podem armazenar um valor entre De 15. O membro suit armazena valores entre O e 3 (O = Ouros, 1 = Copas, 2 = \line Paus, 3 = Espadas) -2 bits podem armazenar um valor entre O e 3. Finalmente, o membro color armazena ou O \line (vermelho) ou 1 (preto) - 1 bit pode armazenar ou O ou 1. \line O programa na Fig. 16.14 (sa\'edda mostrada na Fig. 16.15) cria o array deck, que cont\'e9m 52 estruturas bitCard. A fun\'e7\'e3o fillDeck insere as 52 cartas no array deck e a fun\'e7\'e3o deal imprime as 52 cartas. Note que membros campos de bits de estruturas s\'e3o acessados exatamente como qualquer outro membro de uma estrutura. O membro color \'e9 inclu\'eddo como um meio de indicar a cor da carta em um sistema que permite exibir cores. \par
\pard\par
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1119\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1440\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1938\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2374\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4215\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx5561\pard\intbl Operadores \cell\cell\cell\cell Associatividade \cell Tipo \cell\row
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx368\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx766\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1119\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1440\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1938\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2374\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4215\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx5561\pard\intbl & \cell\cell\cell\cell\cell\cell esquerda para a direita \cell AND sobre bits \cell\row
\intbl A \cell\cell\cell\cell\cell\cell esquerda para a direita \cell XOR sobre bits \cell\row
\intbl 1 \cell\cell\cell\cell\cell\cell esquerda para a direita \cell OR sobre bits \cell\row
\intbl && \cell\cell\cell\cell\cell\cell esquerda para a direita \cell AND l\'f3gico \cell\row
\intbl 1 \cell\cell\cell\cell\cell\cell esquerda para a direita \cell OR l\'f3gico \cell\row
\intbl ?: \cell\cell\cell\cell\cell\cell direita para a esquerda \cell condicional \cell\row
\intbl\cell += \cell - \cell = \cell 1= \cell %= \cell direita para a esquerda \cell atribui\'e7\'e3o \cell\row
\intbl &= \cell = \cell A... \cell\'ab. \cell\'bb. \cell\cell\cell\cell\row
\intbl , \cell\cell\cell\cell\cell\cell esquerda para a direita \cell v\'edrgula \cell\row
\pard\par
\pard\sb100\sa240 CAP\'cdTULO 16- BIT5, CARACTERES, STR1NGS E ESTRUTURAS 823 \line 1 II Fig. 16.14: figl6_14.cpp \line 2 II Exemplo usando um campo de bits \line 3 #include <iostream> \line 4 \line 5 using std::cout; \line 6 using std::endl; \line 7 \line 8 #include <iomanip> \line 9 \line 10 using std: :setw; \line 11 \line 12 struct BitCard \{ \line 13 unsigned face : 4; II 4 bits; 0-15 \line 14 unsigned suit : 2; II 2 bits; 0-3 \line 15 unsigned color : 1; II 1 bit; 0-1 \line 16 \line 17 \line 18 void fillDeck( BitCard * const ); \line 19 void deal( const BitCard * const ); \line 20 \line 21 int main() \line 22 \{ \line 23 BitCard deck[ 52 ]; \line 24 \line 25 fillDeck( deck ); \line 26 deal( deck ); \line 27 return 0; \line 28 \} \line 29 \line 30 void filloeck( BitCard * const wDeck \line 31 \{ \line 32 for ( inti=0; i<51; i++) \{ \line 33 wDeck[ i ].face = i % 13; \line 34 wDeck[ i ] .suit = i / 13; \line 35 wDeck[ i ].color = i / 26; \line 36 \line 37 ) \line 38 \line 39 // Exibe as cartas em formato de duas colunas. Cartas O a 25 com subscrito \line 40 // kl (coluna 1) . Cartas 26 a 51 com subscrito k2 (coluna 2) \line 41 void deal( const BitCard * const wDeck \line 42 \{ \line 43 for ( mntkl = 0, k2 =kl +26; kl <= 25; kl++, k2++ \line 44 cout \'ab \ldblquote Carta:\rdblquote  \'ab setw( 3 ) \'ab wDeck[ kl ).face \line 45 \'ab Naipe:\rdblquote  \'ab setw( 2 ) \'ab wDeck[ kl ].suit \line 46 \'ab \ldblquote  Cor:\rdblquote  \'ab setw( 2 ) \'ab wDeck[ kl ].color \line 47 \'ab \ldblquote  \ldblquote  \'ab \ldblquote Carta:\rdblquote  \'ab setw( 3 ) \'ab wDeck[ k2 ].face \line 48 \'ab \ldblquote  Naipe:\rdblquote  \'ab setw( 2 ) \'ab woeck[ k2 ] .suit \line 49 \'ab \ldblquote  Cor:\rdblquote  \'ab setw( 2 ) \'ab woeck[ k2 ].color \line 50 \'ab endl; \line 51 \} \line 52 \line Fig. 16.14 Usando campos de bits para armazenar um baralho. \par
Fig. 16.15 Sa\'edda do programa da Fig. 16.14 (parte 1 de 2). \par
\pard\par
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx685\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx998\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1791\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2104\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2705\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx3018\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx3811\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4124\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4917\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx5230\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx5831\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx6144\pard\intbl Carta: \cell O \cell Naipe: \cell O \cell Cor: \cell O \cell Carta: \cell O \cell Naipe: \cell 2 \cell Cor: \cell 1 \cell\row
\intbl Carta: \cell 1 \cell Naipe: \cell O \cell Cor: \cell O \cell Carta: \cell 1 \cell Naipe: \cell 2 \cell Cor: \cell 1 \cell\row
\intbl Carta: \cell 2 \cell Naipe: \cell O \cell Cor: \cell O \cell Carta: \cell 2 \cell Naipe: \cell 2 \cell Cor: \cell 1 \cell\row
\intbl Carta: \cell 3 \cell Naipe: \cell O \cell Cor: \cell O \cell Carta: \cell 3 \cell Naipe: \cell 2 \cell Cor: \cell 1 \cell\row
\pard\par
\pard\sb100\sa240 824 C++ COMO PROGRAMAR \par
Carta: 4 Naipe: O Cor: O Carta: 4 Naipe: 2 Cor: 1 \line Carta: 5 Naipe: O Cor: O Carta: 5 Naipe: 2 Cor: 1 \line Carta: 6 Naipe: O Cor: O Carta: 6 Naipe: 2 Cor: 1 \line Carta: 7 Naipe: O Cor: O Carta: 7 Naipe: 2 Cor: 1 \line Carta: 8 Naipe: O Cor: O Carta: 8 Naipe: 2 Cor: 1 \line Carta: 9 Naipe: O Cor: O Carta: 9 Naipe: 2 Cor: 1 \line Carta: 10 Naipe: O Cor: O Carta: 10 Naipe: 2 Cor: 1 \line Carta: 11 Naipe: O Cor: O Carta: 11 Naipe: 2 Cor: 1 \line Carta: 12 Naipe: O Cor: O Carta: 12 Naipe: 2 Cor: 1 \line Carta: O Naipe: 1 Cor: O Carta: O Naipe: 3 Cor: 1 \line Carta: 1 Naipe: 1 Cor: O Carta: 1 Naipe: 3 Cor: 1 \line Carta: 2 Naipe: 1 Cor: O Carta: 2 Naipe: 3 Cor: 1 \line Carta: 3 Naipe: 1 Cor: O Carta: 3 Naipe: 3 Cor: 1 \line Carta: 4 Naipe: 1 Cor: O Carta: 4 Naipe: 3 Cor: 1 \line Carta: 5 Naipe: 1 Cor: O Carta: 5 Naipe: 3 Cor: 1 \line Carta: 6 Naipe: 1 Cor: O Carta: 6 Naipe: 3 Cor: 1 \line Carta: 7 Naipe: 1 Cor: O Carta: 7 Naipe: 3 Cor: 1 \line Carta: 8 Naipe: 1 Cor: O Carta: 8 Naipe: 3 Cor: 1 \line Carta: 9 Naipe: 1 Cor: O Carta: 9 Naipe: 3 Cor: 1 \line Carta: 10 Naipe: 1 Cor: O Carta: 10 Naipe: 3 Cor: 1 \line Carta: 11 Naipe: 1 Cor: O Carta: 11 Naipe: 3 Cor: 1 \line Carta: 12 Naipe: 1 Cor: O Carta: 12 Naipe: 3 Cor: 1 \line Fig. 16.15 Sa\'edda do programa da Fig. 16.14 (parte 2 de 2). \line\'c9 poss\'edvel se especificar um campo de bits sem nome, caso em que o campo \'e9 usado como enchimento na estrutura. Por exemplo, a defini\'e7\'e3o de estrutura usa um campo de 3 bits sem nome como enchimento - nada pode ser armazenado naqueles tr\'eas bits. O membro b \'e9 armazenado em outra unidade de mem\'f3ria. \line struct Example \{ \line unsigned a : 13; \line unsigned : 3; \line unsigned b : 4; \line Um campo de bits sem nome com um comprimento zero \'e9 usado para alinhar o pr\'f3ximo campo de bits de uma unidade mem\'f3ria em um novo limite. Por exemplo, a defini\'e7\'e3o de estrutura \line struct Exaxnple \{ \line unsigned a : 13; \line unsigned : 0; \line unsigned b : 4; \line usa um campo de bits O sem nome - para saltar os bits restantes (tantos quantos existirem) da unidade de mem\'f3ria em que a \'e9 armazenado e alinhar b no pr\'f3ximo limite de unidade de mem\'f3ria. \line Dica de portabilidade 16.5 \line ______ As manipula\'e7\'f5es de campos de bit s\'e3o dependentes de m\'e1quina. Por exemplo, alguns computadores permitem que campos de bits cruzem limites de palavra, enquanto outros n\'e3o. \line Erro comum de programa\'e7\'e3o 16.8 \line Tentar acessar bits individuais de um campo de bits como se fossem elementos de um array. Campos de bits n\'e3o s\'e3o \ldblquote array de bits\rdblquote . \par
826 C++ COMO PROGRAMAR \par
Conforme isdigit: \line 8 \'e9 um d\'edgito \line # n\'e3o \'e9 um d\'edgito \par
A Fig. 16.17 demonstra as fun\'e7\'f5es isdigit, isalpha, isainume isxdigit. A fun\'e7\'e3o isdigit determina \line se seu argumento \'e9 um d\'edgito (0-9). A fun\'e7\'e3o isalpha determina se seu argumento \'e9 uma letra mai\'fascula (A-Z) \line ou uma letra min\'fascula (a-z). A fun\'e7\'e3o isalnum determina se seu argumento \'e9 uma letra mai\'fascula, uma letra \line min\'fascula ou um d\'edgito. A fun\'e7\'e3o isxdigit determina se seu argumento \'e9 um d\'edgito hexadecimal (A-F. a-f. 0- \line 9). \par
1 \line 2 \line 3 \line 4 \par
1 \par
II Fig. 16.17: figl6l7.cpp \line II Usando as fun\'e7\'f5es isdigit, isalpha, isainum e isxdigit #include <iostream> \line using std::cout; \line using std::endl; \line #include <cctype> \line int main() \par
um\rdblquote  : \ldblquote 8 n\'e3o \'e9 um\rdblquote  um\rdblquote  : \ldblquote # n\'e3o \'e9 um\rdblquote  \par
1 \par
uma\rdblquote  : \ldblquote A n\'e3o \'e9 uma\rdblquote  uma\rdblquote  : \ldblquote b n\'e3o \'e9 uma\rdblquote  uma\rdblquote  : \ldblquote & n\'e3o \'e9 uma\rdblquote  uma\rdblquote  : \ldblquote 4 n\'e3o \'e9 uma\rdblquote  \par
um\rdblquote  : \ldblquote A n\'e3o \'e9 um\rdblquote  \line\ldblquote 8 n\'e3o \'e9 um\rdblquote  \line\lquote  n\'e3o \'e9 um\rdblquote  \line um\rdblquote  : \ldblquote F n\'e3o \'e9 um\rdblquote  \line um\rdblquote  : \ldblquote J n\'e3o \'e9 um\rdblquote  um\rdblquote  : \ldblquote 7 n\'e3o \'e9 um\rdblquote  um\rdblquote  : \ldblquote $ n\'e3o \'e9 um\rdblquote  \par
\ldblquote f n\'e3o \'e9 um\rdblquote  \par
Fig. 16.17 Usando isdigit, isalpha, isainum e isxdigit (parte 1 de 2). \par
\pard\par
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx301\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4537\pard\intbl 5 \cell\cell\row
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4537\pard\intbl 6 \cell\row
\intbl 7 \cell\row
\intbl 8 \cell\row
\intbl 9 \cell\row
\intbl 10 \cell\row
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx301\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx604\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1397\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1806\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4537\pard\intbl 11 \cell\{ \cell\cell\cell\cell\row
\intbl 12 \cell\cell cout \cell\'ab \cell\ldblquote Conforme isdigit:\\n\rquote  \cell\row
\intbl 13 \cell\cell\cell\'ab \cell ( isdigit( \lquote 8\rquote  ) ? \ldblquote 8 \'e9 \cell\row
\intbl 14 \cell\cell\cell\'ab \cell\ldblquote  d\'edgito\\n\rdblquote  \cell\row
\intbl 15 \cell\cell\cell\'ab \cell ( isdigit( \lquote #\lquote  ) ? \ldblquote # \'e9 \cell\row
\intbl 16 \cell\cell\cell\'ab \cell\ldblquote  d\'edgito\\n\rdblquote ; \cell\row
\intbl 17 \cell\cell cout \cell\'ab \cell\ldblquote\\nConforme isalpha:\\n\rdblquote  \cell\row
\intbl 18 \cell\cell\cell\'ab \cell ( isalpha( \lquote A\rquote  ) ? \ldblquote A \'e9 \cell\row
\intbl 19 \cell\cell\cell\'ab \cell\ldblquote  letra\\n\rdblquote  \cell\row
\intbl 20 \cell\cell\cell\'ab \cell ( isalpha( \lquote b\rquote  ) ? \ldblquote b \'e9 \cell\row
\intbl 21 \cell\cell\cell\'ab \cell\ldblquote  letra\\n\rdblquote  \cell\row
\intbl 22 \cell\cell\cell\'ab \cell ( isalpha( \lquote &\lquote  ) ? \ldblquote & \'e9 \cell\row
\intbl 23 \cell\cell\cell\'ab \cell\ldblquote  letra\\n\rdblquote  \cell\row
\intbl 24 \cell\cell\cell\'ab \cell ( isalpha( \lquote 4\rquote  ) ? \ldblquote 4 \'e9 \cell\row
\intbl 25 \cell\cell\cell\'ab \cell\ldblquote  letra\\n\rdblquote ; \cell\row
\intbl 26 \cell\cell cout \cell\'ab \cell\ldblquote\\nConforme isalnum:\\n\rdblquote  \cell\row
\intbl 27 \cell\cell\cell\'ab \cell ( isalnum( \lquote A\rquote  ) ? \ldblquote A \'e9 \cell\row
\intbl 28 \cell\cell\cell\'ab \cell\ldblquote  d\'edgito ou uma letra\\n\rdblquote  \cell\row
\intbl 29 \cell\cell\cell\'ab \cell ( isalnum( \lquote 8\rquote  ) ? \ldblquote 8 \'e9 um\rdblquote  \cell\row
\intbl 30 \cell\cell\cell\'ab \cell\ldblquote  d\'edgito ou uma letra\\n\rdblquote  \cell\row
\intbl 31 \cell\cell\cell\'ab \cell ( isalnum( \lquote #\lquote  ) ? \ldblquote # \'e9 um\rdblquote  \cell\row
\intbl 32 \cell\cell\cell\'ab \cell\ldblquote  d\'edgito ou uma letra\\n\rdblquote ; \cell\row
\intbl 33 \cell\cell cout \cell\'ab \cell\ldblquote\\nConforme isxdigit:\\n\rdblquote  \cell\row
\intbl 34 \cell\cell\cell\'ab \cell ( isxdigit( \lquote F\rquote  ) ? \ldblquote F \'e9 \cell\row
\intbl 35 \cell\cell\cell\'ab \cell\ldblquote  d\'edgito hexadecimal\\n\rdblquote  \cell\row
\intbl 36 \cell\cell\cell\'ab \cell ( isxdigit( \lquote J\rquote  ) ? \ldblquote J \'e9 \cell\row
\intbl 37 \cell\cell\cell\'ab \cell\ldblquote  d\'edgito hexadecimal\\n\rdblquote  \cell\row
\intbl 38 \cell\cell\cell\'ab \cell ( isxdigit( \lquote 7\rquote  ) ? \ldblquote 7 \'e9 \cell\row
\intbl 39 \cell\cell\cell\'ab \cell\ldblquote  d\'edgito hexadeciinal\\n\rdblquote  \cell\row
\intbl 40 \cell\cell\cell\'ab \cell ( isxdigit( \lquote $\lquote  ) ? \ldblquote $ \'e9 \cell\row
\intbl 41 \cell\cell\cell\'ab \cell\ldblquote  d\'edgito hexadecimal\\n\rdblquote  \cell\row
\intbl 42 \cell\cell\cell\'ab \cell ( isxdigit( \lquote f\rquote  ) ? \ldblquote f \'e9 um\rdblquote  \cell\row
\intbl 43 \cell\cell\cell\'ab \cell\ldblquote  d\'edgito hexadecimal\rdblquote  \'ab endi; \cell\row
\intbl 44 \cell\cell return \cell 0; \cell\cell\row
\intbl 45 \cell\} \cell\cell\cell\cell\row
\pard\par
\pard\sb100\sa240 CAP\'cdTULO 16- BITs, CARACTERES, STRINGS E ESTRUTURAS 827 \line Conforme isalpha: \line A \'e9 uma letra \line b \'e9 uma letra \line & n\'e3o \'e9 uma letra \line 4 n\'e3o \'e9 uma letra \line Conforme isalnum: \line A \'e9 um d\'edgito ou uma letra \line 8 \'e9 um d\'edgito ou uma letra \line # n\'e3o \'e9 um d\'edgito ou uma letra \line Conforme isxdigit: \line F \'e9 um d\'edgito hexadecimal \line J n\'e3o \'e9 um d\'edgito hexadecimal \line 7 \'e9 um d\'edgito hexadecimal \line $ n\'e3o \'e9 um d\'edgito hexadecimal \line f \'e9 um d\'edgito hexadecimal \line Fig. 16.17 Usando isdigit, isalpha, isalnume isxdigit (parte 2 de 2). \line O programa da Fig. 16.17 usa o operador condicional (?:)com cada fun\'e7\'e3o para determinar se o string \'e9 um\rdblquote  ou o string \ldblquote  n\'e3o \'e9 um \ldblquote  deve ser impresso na sa\'edda para cada caractere testado. Por exemplo, a express\'e3o \line isdigit( \lquote 8\rquote  ) ? \ldblquote 8 \'e9 um \ldblquote  : \ldblquote 8 n\'e3o \'e9 um \line indica que se \lquote 8\rquote  \'e9 um d\'edgito (i.e., isdigit retorna um valor verdadeiro (n\'e3o-zero)), o string \ldblquote 8 \'e9 um \ldblquote  \'e9 impresso e se \lquote 8\rquote  n\'e3o \'e9 um d\'edgito (i.e., isdigit retorna O), o string \ldblquote 8 n\'e3o \'e9 um \ldblquote  \'e9 impresso. \line O programa da Fig. 16.18 demonstra as fun\'e7\'f5es islower, isupper, tolower e toupper. A fun\'e7\'e3o islower determina se seu argumento \'e9 uma letra min\'fascula (a- z). A fun\'e7\'e3o isupper determina se seu par\'e2metro \'e9 uma letra mai\'fascula (A-Z). A fun\'e7\'e3o tolower converte uma letra mai\'fascula em uma letra min\'fascula e retorna a letra min\'fascula. Se o argumento n\'e3o \'e9 uma letra mai\'fascula, tolower retorna o argumento inalterado. A fun\'e7\'e3o toupper converte uma letra min\'fascula em uma letra mai\'fascula e retorna a letra mai\'fascula. Se o argumento n\'e3o \'e9 uma letra min\'fascula, toupper retorna o argumento inalterado. \line 1 // Fig. 16.18: figl6l8.cpp \line 2 // Usando as fun\'e7\'f5es islower, isupper, tolower e toupper \line 3 #include <iostream> \line 4 \line 5 using std::cout; \line 6 using std::endl; \line 7 \line 8 #include <cctype> \line 9 \line 10 int main() \line 11 \line 12 cout \'ab \ldblquote Conforme islower:n \line 13 \'ab ( islower( \lquote p\rquote  ) ? \ldblquote p \'e9 uma\rdblquote  : \ldblquote p n\'e3o \'e9 uma\rdblquote  \line 14 \'ab \ldblquote  letra min\'fascula\\n\rdblquote  \line 15 \'ab ( islower( \lquote P\rquote  ) ? \ldblquote p \'e9 uma\rdblquote  : \ldblquote P n\'e3o \'e9 uma\rdblquote  \line 16 \'ab \ldblquote  letra min\'fascula\\n\rdblquote  \line 17 \'ab ( islower( \lquote 5\rquote  ) ? \ldblquote 5 \'e9 uma\rdblquote  : \ldblquote 5 n\'e3o \'e9 uma\rdblquote  \line 18 \'ab \ldblquote  letra min\'fascula\\n\rdblquote  \line 19 \'ab ( islower( \lquote  ! \lquote  ) ? \ldblquote ! \'e9 uma\rdblquote  : \ldblquote  n\'e3o \'e9 uma\rdblquote  \line 20 \'ab \ldblquote  letra min\'fascula\\n\rdblquote ; \line 21 cout \'ab \ldblquote\\nConforme isupper:\\n\rdblquote  \line Fig. 16.18 Usando islower, isupper, tolower e toupper (parte 1 de 2). \par
828 C++ COMO PROGRAMAR \par
Conforme islower: \line p \'e9 uma letra min\'fascula \line P n\'e3o \'e9 urna letra min\'fascula \line 5 n\'e3o \'e9 urna letra min\'fascula \line n\'e3o \'e9 uma letra min\'fascula \line Conforme isupper: \line D \'e9 urna letra mai\'fascula \line d n\'e3o \'e9 urna letra mai\'fascula \line 8 n\'e3o \'e9 uma letra mai\'fascula \line $ n\'e3o \'e9 urna letra mai\'fascula \line u convertido para mai\'fascula \'e9 U \line 7 convertido para mai\'fascula \'e9 7 \line $ convertido para mai\'fascula \'e9 $ \line L convertido para min\'fascula \'e9 1 \line Fig. 16.18 Usando islower, isupper, tolower e toupper (parte 2 de 2). \line A Fig. 16.19 demonstra as fun\'e7\'f5es isspace, iscntrl, ispunct, isprint e isgraph. A fun\'e7\'e3o isspace detennina se seu argumento \'e9 um caractere de espa\'e7o em branco - tal como espa\'e7o (1 1), avan\'e7o de formul\'e1rio .\lquote  \\f\rquote , nova hnha (\lquote\\n\rquote ), retorno de carro (T \\r\rquote ), tabula\'e7\'e3o horizontal (\lquote  \\t\rquote ) ou marca de tabula\'e7\'e3o vertical (\lquote  \\v\rquote  ). A fun\'e7\'e3o iscntrl determina se seu argumento \'e9 um caractere de controle, tal como uma marca de tabula\'e7\'e3o horizontal, uma marca de tabula\'e7\'e3o vertical, um avan\'e7o de formul\'e1rio, alarme (\lquote  \\a T ), retrocesso (\lquote  \\b T ), retorno do carro ou nova linha. A fun\'e7\'e3o ispunct determina se seu par\'e2metro \'e9 um caractere de impress\'e3o diferente de um espa\'e7o, d\'edgito ou letra, talcomo$, #. , [, J, \{, \}, ;, :, %,etc.Afun\'e7\'e3oisprintdeterminaseseupar\'e2metro\'e9umcaracterequepode ser exibido na tela (inclusive o caractere espa\'e7o). A fun\'e7\'e3o isgraph testa os mesmos caracteres que isprint: por\'e9m, o caractere espa\'e7o n\'e3o est\'e1 inclu\'eddo. \par
39 \line 40 \par
return 0; \par
Fig. 16.19 Usando isspace, iscntrl, ispunct, isprint e isgraph (parte 1 de 3). \par
\pard\par
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx205\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2246\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx6591\pard\intbl 1 \cell // Fig. 16.19: figl6 \cell 19.cpp \cell\row
\intbl 2 \cell // Usando as fun\'e7\'f5es \cell isspace, iscntrl, ispunct, isprint, isgraph \cell\row
\intbl 3 \cell #include <iostream> \cell\cell\row
\intbl 4 \cell\cell\cell\row
\intbl 5 \cell using std: :cout; \cell\cell\row
\pard\sa240\par
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx301\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx902\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1215\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4879\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx5634\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx5917\pard\intbl 22 \cell\cell\'ab \cell ( isupper( \lquote D\rquote  ) ? \ldblquote D \'e9 uma\rquote  : \ldblquote D n\'e3o \cell\'e9 uma\rdblquote  \cell ) \cell\row
\intbl 23 \cell\cell\'ab \cell\ldblquote  letra mai\'fascula\\n\rdblquote  \cell\cell\cell\row
\intbl 24 \cell\cell\'ab \cell ( isupper( \lquote d\rquote  ) ? \ldblquote d \'e9 urna\rdblquote  : \ldblquote d n\'e3o \cell\'e9 uma\rdblquote  \cell ) \cell\row
\intbl 25 \cell\cell\'ab \cell\ldblquote  letra mai\'fascula\\n\rdblquote  \cell\cell\cell\row
\intbl 26 \cell\cell\'ab \cell ( isupper( \lquote 8\rquote  ) ? \lquote 8 \'e9 urna\rdblquote  : \ldblquote 8 n\'e3o \cell\'e9 uma\rdblquote  \cell ) \cell\row
\intbl 27 \cell\cell\'ab \cell\ldblquote  letra mai\'fascula\\n\rdblquote  \cell\cell\cell\row
\intbl 28 \cell\cell\'ab \cell ( isupper(\rquote $\rquote ) ? \ldblquote $ \'e9 urna\rdblquote  : \ldblquote $ n\'e3o \'e9 \cell urna\rdblquote  \cell\cell\row
\intbl 29 \cell\cell\'ab \cell\ldblquote  letra mai\'fascula\\n\rdblquote ; \cell\cell\cell\row
\intbl 30 \cell cout \cell\'ab \cell\ldblquote\\nu convertido para mai\'fascula \'e9 \cell\cell\cell\row
\intbl 31 \cell\cell\'ab \cell static_cast< char >( toupper( \lquote u\rquote  \cell\cell\cell\row
\intbl 32 \cell\cell\'ab \cell\ldblquote\\n7 convertido para mai\'fascula \'e9 \cell\cell\cell\row
\intbl 33 \cell\cell\'ab \cell static_cast< char >( toupper( \lquote 7\rquote  \cell\cell\cell\row
\intbl 34 \cell\cell\'ab \cell\ldblquote\\n$ convertido para mai\'fascula \'e9 \cell\cell\cell\row
\intbl 35 \cell\cell\'ab \cell static_cast< char >( toupper( \lquote $\lquote  \cell\cell\cell\row
\intbl 36 \cell\cell\'ab \cell\lquote\\nL convertido para min\'fascula \'e9 \cell\cell\cell\row
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx301\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx902\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1215\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4879\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx5917\pard\intbl 37 \cell\cell\'ab \cell static_cast< char >( tolower( \lquote L\rquote  ) ) \cell\'ab endl; \cell\row
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx301\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx902\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1215\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4879\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx5634\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx5917\pard\intbl 38 \cell\cell\cell\cell\cell\cell\row
\pard\par
\pard\sb100\sa240 CAP\'cdTULO 16 - BITs, CARACTERES, STRINGS E ESTRUTURAS 829 \line 6 using std: :endl; \line 7 \line 8 #include <cctype> \line 9 \line 10 int main() \line 11 \line 12 cout \'ab \ldblquote Conforme isspace:\\nNova linha \line 13 \'ab ( isspace( \lquote\\n\rquote  ) ? \ldblquote\'e9 um\rdblquote  : \ldblquote n\'e3o \'e9 um\rdblquote  \line 14 \'ab \ldblquote  caractere de espa\'e7amento \\nTabula\'e7\'e3o horizontal \line 15 \'ab ( isspace( \lquote\\t\rquote  ) ? \ldblquote\'e9 um\rdblquote  \ldblquote n\'e3o \'e9 um\rdblquote  \line 16 \'ab \ldblquote  caractere de espa\'e7amento \\n\rdblquote  \line 17 \'ab ( isspace( \lquote %\lquote  ) ? \ldblquote % \'e9 um\rdblquote  : \lquote % n\'e3o \'e9 um\rdblquote  \line 18 \'ab \ldblquote  caractere de espa\'e7amento \\n\rdblquote ; \line 19 \line 20 cout \'ab \ldblquote\\nConforme iscntrl:\\nNova linha \line 21 \'ab ( iscntrl( \lquote\\n\rquote  ) ? \ldblquote\'e9 um\rdblquote  \ldblquote n\'e3o \'e9 um\rdblquote  \line 22 \'ab \ldblquote  caractere de controle\\n\rdblquote  \line 23 \'ab ( iscntrl ( $\lquote  ) ? \ldblquote $ \'e9 um\rdblquote  : \ldblquote $ n\'e3o \'e9 um\rdblquote  \line 24 \'ab \ldblquote  caractere de controle\\n\rdblquote ; \line 25 \line 26 cout \'ab \ldblquote\\nConforme ispunct:\\n\rdblquote  \line 27 \'ab ( ispunct ( \lquote  ;\lquote  ) ? \ldblquote ; \'e9 um\rdblquote  : \ldblquote ; n\'e3o \'e9 um\rdblquote  \line 28 \'ab \ldblquote  caractere de pontua\'e7\'e3o\\n\rdblquote  \line 29 \'ab ( ispunct( \lquote Y\rquote  ) ? \ldblquote Y \'e9 um\rdblquote  \ldblquote Y n\'e3o \'e9 um\rdblquote  \line 30 \'ab \ldblquote  caractere de pontua\'e7\'e3o\\n\rdblquote  \line 31 \'ab ( ispunct(\rquote #\rquote ) ? \lquote 1 \'e9 um\rdblquote  : \ldblquote # n\'e3o \'e9 um\rdblquote  \line 32 \ldblquote  caractere de pontua\'e7\'e3o\\n\rdblquote ; \line 33 \line 34 cout \'ab \ldblquote\\nConforme isprint:\\n\rdblquote  \line 35 \'ab ( isprint( \lquote $\lquote  ) ? \ldblquote $ \'e9 um\rdblquote  : \ldblquote $ n\'e3o \'e9 um\rdblquote  \line 36 \'ab \ldblquote  caractere de impress\'e3o\\nAlert \line 37 \'ab ( isprmnt( \lquote\\a\rquote  ) ? \ldblquote\'e9 um\rdblquote  \ldblquote n\'e3o \'e9 um\rdblquote  \line 38 \'ab \ldblquote  caractere de impress\'e3o\\n\rdblquote ; \line 39 \line 40 cout \'ab \ldblquote\\nConforme isgraph:\\n\rdblquote  \line 41 \'ab ( isgraph( \lquote Q\rquote  ) ? \ldblquote Q \'e9 um\rdblquote  \ldblquote  n\'e3o \'e9 um\rdblquote  \line 42 \'ab \ldblquote  caractere de impress\'e3o diferente de espa\'e7o\\nEspa\'e7o \line 43 \'ab ( isgraph(\rquote  \lquote ) ? \ldblquote\'e9 um\rdblquote  : \ldblquote n\'e3o \'e9 um\rdblquote  \line 44 \'ab \lquote  caractere de impress\'e3o diferente de espa\'e7o\rdblquote  \'ab endl; \line 45 \line 46 return 0; \line 47 \par
F\'edg. 16.19 Usando isspace, iscntrl, ispunct, isprint e isgraph (parte 2 de 3). \par
\pard\par
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx3661\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4704\pard\intbl Conforme isspace: \cell\cell\row
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4704\pard\intbl Nova linha \'e9 um caractere de espa\'e7amento \cell\row
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx3661\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4704\pard\intbl Tabula\'e7\'e3o horizontal \'e9 um caractere de \cell espa\'e7amento \cell\row
\intbl % n\'e3o \'e9 um caractere de espa\'e7amento \cell\cell\row
\intbl Conforme iscntrl: \cell\cell\row
\intbl Nova linha \'e9 um caractere de controle \cell\cell\row
\intbl $ n\'e3o \'e9 um caractere de controle \cell\cell\row
\intbl Conforme ispunct: \cell\cell\row
\intbl\'e9 um caractere de pontua\'e7\'e3o \cell\cell\row
\intbl Y n\'e3o \'e9 um caractere de pontua\'e7\'e3o \cell\cell\row
\intbl # \'e9 um caractere de pontua\'e7\'e3o \cell\cell\row
\pard\par
\pard\sb100\sa240 830 C++ COMO PROGRAMAR \line Conforme isprint: \line $ \'e9 um caractere de impress\'e3o \line Alert n\'e3o \'e9 um caractere de impress\'e3o \line Conforme isgraph: \line\'e9 um caractere de impress\'e3o diferente de espa\'e7o \line Espa\'e7o n\'e3o \'e9 um caractere de impress\'e3o diferente de espa\'e7o \line Fig. 16.19 Usando isspace, iscntrl, ispunct, isprint e isgraph (parte 3 de 3). \line 16.10 Fun\'e7\'f5es de convers\'e3o de strings \line No Cap\'edtulo 5, discutimos v\'e1rias fun\'e7\'f5es de manipula\'e7\'e3o de strings de caracteres, a maioria popular em C++. Nas pr\'f3ximas se\'e7\'f5es, cobriremos as fun\'e7\'f5es restantes, inclusive fun\'e7\'f5es para converter strings em valores num\'e9ricos, fun\'e7\'f5es para pesquisar strings e fun\'e7\'f5es para manipular. comparar e pesquisar blocos de mem\'f3ria. \line Esta se\'e7\'e3o apresenta as fun\'e7\'f5es de convers\'e3o de strings da biblioteca de utilit\'e1rios gerais <cstdlib>. Estas fun\'e7\'f5es convertem strings de d\'edgitos para valores inteiros e em ponto flutuante. A Fig. 16.20 resume as fun\'e7\'f5es de convers\'e3o de strings. Note o uso de const para declarar a vari\'e1vel nPtr nos cabe\'e7alhos de fun\'e7\'e3o (lido da direita para a esquerda como \ldblquote nPtr \'e9 um ponteiro para uma constante do tipo caractere\rquote ); const declara que o valor do argumento n\'e3o ser\'e1 modificado. Quando usar fun\'e7\'f5es da biblioteca de utilit\'e1rios gerais, n\'e3o deixe de incluir o arquivo de cabe\'e7alho <cstdlib>. \par
Fig. 16.20 Resumo das fun\'e7\'f5es de convers\'e3o de strings da biblioteca de utilit\'e1rios gerais. \line A fun\'e7\'e3o atof (Fig. 16.21) converte seu argumento - um string que representa um n\'famero em ponto flutuante - em \line um valor double. A fun\'e7\'e3o retorna o valor double. Se o string n\'e3o pode ser convertido - por exemplo, se o \line primeiro caractere do string n\'e3o \'e9 um d\'edgito - a fun\'e7\'e3o atof retoma 0. \line 1 // Fig. 16.21: figl6_21.cpp \line 2 // Usando atof \line 3 #include <iostream> \line 4 \line Fig. 16.21 Usando atof (parte 1 de 2). \par
\pard\par
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx7837\pard\intbl Prot\'f3tipo Descri\'e7\'e3o \cell\row
\intbl double atof ( const char *nptr) Converte o string nPtr para double. \cell\row
\intbl int atoi ( const char *nPtr) Converte o string nPtr para int. \cell\row
\intbl long atol ( const char *nptr) Converte o string nPtr para long int. \cell\row
\intbl double strtod( const char *nptr, char **endptr)  Converte o string nPtr para double. \cell\row
\intbl long strtol ( const char *nptr, char **endptr, int base) Converte o string nPtr para long. \cell\row
\intbl unsigned long strtoul ( const char *nptr, char **endptr, int base) Converte o string nPtr para unsigned long. \cell\row
\pard\par
\pard\sb100\sa240 CAP\'cdTULO 16- BIT5, CARACTERES, STR!NGS E ESTRUTURAS 831 \par
5 using std::cout; \line 6 using std: :endl; \line 7 \line 8 #include <cstdlib> \line 9 \line 10 int main() \line 11 \line 12 double d = atof( \lquote 99.0\rdblquote  ); \line 13 \line 14 cout \'ab \ldblquote O string \\\ldblquote 99.0\\\rdblquote  convertido para double \'e9 \line 15 \'ab d \'ab \ldblquote\\nO valor convertido dividido por 2 \'e9 \line 16 \'abd/2.0\'abendl; \line 17 return 0; \line 18 \line O string \ldblquote 99.0\rdblquote  convertido para double \'e9 99 \line O valor convertido dividido por 2 \'e9 49.5 \line Fig. 16.21 Usando atof (parte 2 de 2). \line A fun\'e7\'e3o atoi (Fig. 16.22) converte seu argumento - um string de d\'edgitos que representa um inteiro - em um valor int. A fun\'e7\'e3o retorna o valor int. Se o string n\'e3o pode ser convertido, a fun\'e7\'e3o atoi retoma zero. \line 1 II Fig. 16.22: figl6_22.cpp \line 2 // Usando atoi \line 3 #include <iostream> \line 4 \line 5 using std: :cout; \line 6 using std: :endl; \line 7 \line 8 #include <cstdlib> \line 9 \line int main() \line int i = atoi( \ldblquote 2593\rdblquote  ); \line cout \'ab \ldblquote O string \\\ldblquote 2593\\\rdblquote  convertido para int \'e9 \ldblquote  \'ab i \line\'ab \ldblquote\\nO valor convertido menos 593 \'e9 \ldblquote  \'ab i - 593 \line\'ab endl; \line return 0; \line A fun\'e7\'e3o atol (Fig. 16.23) converte seu argumento - um string de d\'edgitos representando um inteiro longo - em um \line valor long. A fun\'e7\'e3o retoma o valor long. Se o string n\'e3o pode ser convertido, a fun\'e7\'e3o atol retoma zero. Se int \line e long s\'e3o ambos armazenados em 4 bytes, a fun\'e7\'e3o atoi e a fun\'e7\'e3o atol funcionam de forma id\'eantica. \line 1 II Fig. 16.23: fig1623.cpp \line 2 // Usando atol \line 3 #include <iostream> \line 4 \par
1 \par
Nas \line [C05, \par
.b>. \line e as \par
lido que e de \par
10 \line 11 \line 12 \line 13 \line 14 \line 15 \line 16 \line 17 \line 18 \par
O \line O \par
string \ldblquote 2593\rdblquote  convertido para int \'e9 2593 valor convertido menos 593 \'e9 2000 \par
em \par
Fig. 16.22 Usando atoi. \par
Fig. 16.23 Usando atol (parte 1 de 2). \par
832 C++ COMO PROGRAMAR \line 5 using std: :cout; \line 6 using std::endl; \line 7 \line 8 #include <cstdlib> \line 9 \line 10 int main() \line 11 \line 12 long x = atol( \ldblquote 1000000\rdblquote  ); \line 13 \line 14 cout \'ab \ldblquote o string \\\ldblquote lOOOOOO\\\rdblquote  convertido para long \'e9 \ldblquote  \'ab x \line 15 \'ab \ldblquote\\nO valor convertido dividido por 2 \'e9 \ldblquote  \'ab x / 2 \line 16 \'ab endl; \line 17 return 0; \line 18 \line O string \ldblquote 1000000\rdblquote  convertido para long \'e9 1000000 \line O valor convertido dividido por 2 \'e9 500000 \line Fig. 16.23 Usando atol (parte 2 de 2). \line A fun\'e7\'e3o strtod (Fig. 16.24) converte uma seq\'fc\'eancia de caracteres representando um valor em ponto flutuante para double. A fun\'e7\'e3o strtod recebe dois argumentos - um string (char *) e um ponteiro para um string (i.e., um char **). O string cont\'e9m a seq\'fc\'eancia de caracteres a ser convertida em double. O segundo argumento \'e9 atribu\'eddo \'e0 posi\'e7\'e3o do primeiro caractere depois da parte convertida do string. O comando \line d = strtod( string, &stringPtr ); \line do programa da Fig. 16.24 indica que ad \'e9 atribu\'eddo o valor double convertido de string e a & stringPtr \'e9 atribu\'edda a posi\'e7\'e3o do primeiro caractere depois do valor convertido (51 . 2) em string. \line 1 // Fig. 16.24: fig1624.cpp \line 2 // Usando strtod \line 3 #include <iostreaxn> \line 4 \line 5 using std::cout; \line 6 using std::endl; \line 7 \line 8 #include <cstdlib> \line 9 \line 10 int main() \line 11 \{ \line 12 double d; \line 13 const char *string = \ldblquote 51.2% s\'e3o admitidos\rdblquote ; \line 14 char *stringptr; \line 15 \line 16 d = strtod( string, &stringPtr ); \line 17 cout \'ab \ldblquote O string \\\ldblquote  \'ab string \line 18 \'ab \ldblquote\ldblquote  \'e9 convertido para o\\nvalor double \ldblquote  \'ab d \line 19 \'ab \ldblquote  e o string \\\ldblquote  \'ab stringPtr \'ab \ldblquote\\\ldblquote  \'ab endl; \line 20 return 0; \line 21 \line O string \ldblquote 51.2% s\'e3o admitidos\rdblquote  \'e9 convertido para o \line valor double 51.2 e o string \ldblquote % s\'e3o admitidos\rdblquote  \line Fig. 16.24 Usando strtod. \par
CAP\'cdTULO 16 - BIT5, CARACTERES, STRINGS E ESTRUTURAS 833 \line A fun\'e7\'e3o strtol (Fig. 16.25) converte para long uma seq\'fc\'eancia de caracteres representando um inteiro. A fun\'e7\'e3o recebe tr\'eas argumentos - um string (char* ), um ponteiro para um string e um inteiro, O string cont\'e9m a seq\'fc\'eancia de caracteres a ser convertida. Ao segundo argumento \'e9 atribu\'edda a localiza\'e7\'e3o do primeiro caractere depois da parte convertida do string. O inteiro especifica a base do valor a ser convertido. O comando \line x = strtol( string, &remainderPtr, O ); \line indica que o valor long convertido do string \'e9 atribu\'eddo a x. Ao segundo argumento, & reniainderptr. \'e9 atribu\'eddo \line o resto do string ap\'f3s a convers\'e3o. Usar NULL como o segundo argumento faz com que o resto do string seja \line ignorado. O terceiro argumento, O, indica que o valor a ser convertido poder estar em octal (base 8), decimal (base \line 10) ou hexadecimal (base 16). \line Em uma chamada para a fun\'e7\'e3o strtol, a base pode ser especificada como zero ou qualquer valor entre 2 e \line 36 (ver Ap\'eandice C, \ldblquote Sistemas de numera\'e7\'e3o\rdblquote , para uma explica\'e7\'e3o detalhada dos sistemas de numera\'e7\'e3o octal, \line decimal, hexadecimal e bin\'e1rio). As representa\'e7\'f5es num\'e9ricas de inteiros nas bases 11 a 36 usam os caracteres de A \line a Z para representar os valores 10 a 35. Por exemplo, valores hexadecimais podem consistir nos d\'edgitos 0-9 e os \line caracteres A-F. Um inteiro na base II pode consistir nos d\'edgitos 0-9 e o caractere A. Um inteiro na base 24 pode \line consistir nos d\'edgitos 0-9 e os caracteres A-N. Um inteiro na base 36 pode consistir nos d\'edgitos 0-9 e os caracteres A z. lante 1 II Fig. 16.25: figl6_25.cpp \line (i.e., 2 II Usando strtol \line nto\'e9 3 #include <iostream> \line 4 \line 5 using std::cout; \line 6 using std::endl; \line 7 \line 8 #include <cstdlib> \line re \line 10 int main() \line 11 \{ \line - 12 longx; \line 13 const char *string = \ldblquote -1234567abc\rdblquote ; \line 14 char *remajnderptr; \line 15 \line 16 x = strtol( string, &remainderptr, O ); \line 17 cout \'ab \ldblquote O string original \'e9 \\\ldblquote  \'ab string \line 18 \'ab \ldblquote\\\ldblquote\\nO valor convertido \'e9 \'ab x \line 19 \'ab \ldblquote\\nO resto do string original \'e9 \\\ldblquote  \line 20 \'ab remainderPtr \line 21 \'ab \ldblquote\\\ldblquote\\nO valor convertido mais 567 \'e9 \line 22 \'ab x + 567 \'ab endl; \line 23 return 0; \line 24 \} \line O string original \'e9 \ldblquote -l234567abc\rdblquote  \line O valor convertido \'e9 -1234567 \line O resto do string original \'e9 \ldblquote abc\rdblquote  \line O valor convertido mais 567 \'e9 -1234000 \line Fig. 16.25 Usando strtol. \line A fun\'e7\'e3o strtoul (Fig. 16.26) converte para uns igned long uma seq\'fc\'eancia de caracteres representando um inteiro unsigned long. A fun\'e7\'e3o funciona da mesma maneira que a fun\'e7\'e3o strtol. O comando \line x = strtoul( string, &remainderPtr. O ); \par
834 C++ COMO PROGRAMAR \line no programa da Fig. 16.26 indica que a x \'e9 atribu\'eddo o valor unsigned long convertido do string. Ao segundo argumento, & remainderPtr, \'e9 atribu\'eddo o restante do string depois da convers\'e3o, O terceiro argumento, 0, indica que o valor a ser convertido pode estar em formato octal, decimal ou hexadecimal. \line 1 II Fig. 16.26: fig1626.cpp \line 2 // Usando strtoul \line 3 #include <iostream> \line 4 \line 5 using std::cout; \line 6 using std::endl; \line 7 \line 8 #include <cstdlib> \line 9 \line 10 int main() \line 11 \line 12 unsigned long x; \line 13 const char *string = \ldblquote 1234567abc\rquote ; \line 14 char *remajnderptr; \line 15 \line 16 x = strtoul( string, &remainderptr, O ); \line 17 cout \'ab \ldblquote O string original \'e9 \\\ldblquote\ldblquote  \'ab string \line 18 \'ab \\\ldblquote\\nO valor convertido \'e9 \ldblquote  \'ab x \line 19 \'ab \lquote\\nO resto do string original \'e9 \\\ldblquote  \line 20 \'ab remainderptr \line 21 \'ab \ldblquote\\\ldblquote\\nO valor convertido menos 567 \'e9 \line 22 \'abx-567\'abendl; \line 23 return 0; \line 24 \} \line O string original \'e9 \ldblquote 1234567abc\rdblquote  \line O valor convertido \'e9 1234567 \line O resto do string original \'e9 \ldblquote abc\rdblquote  \line O valor convertido menos 567 \'e9 1234000 \line Fig. 16.26 Usando strtoul. \line 16.11 Fun\'e7\'f5es de pesquisa da biblioteca de manipula\'e7\'e3o de strings \line Esta se\'e7\'e3o apresenta as fun\'e7\'f5es da biblioteca de manipula\'e7\'e3o de strings usadas para procurar caracteres e outros strings em um string. As fun\'e7\'f5es est\'e3o resumidas na Fig. 16.27. Note que as fun\'e7\'f5es strcspn e strspn especificam o tipo de retorno size-t. O tipo size-t \'e9 um tipo definido pelo padr\'e3o como o tipo integral do valor retornado pelo operador sizeof. \line Dica de portabilidade 16.6 \line O tipo si zet \'e9 um sin\'f4nimo dependente de sistema ou para um tipo unsigned long ou para um tipo unsigned int. \par
Fig. 16.27 Fun\'e7\'f5es de pesquisa da biblioteca de manipula\'e7\'e3o de strings (parte 1 de 2). \par
\pard\par
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1194\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx8130\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx8946\pard\intbl Prot\'f3tipo \cell Descri\'e7\'e3o \cell\cell\row
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx418\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1194\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx8130\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx8946\pard\intbl char \cell *strchr( \cell const char *s, int c ) \cell\cell\row
\intbl\cell\cell Localiza a primeira ocorr\'eancia do caractere c no string s. Se c \'e9 encontrado, um para c em s \'e9 retornado. Caso contr\'e1rio, um ponteiro NULL \'e9 retornado. \cell ponteiro \cell\row
\pard\par
\pard\sb100\sa240 CAP\'cdTULO 16 - BIT5, CARACTERES, STRINGS E ESTRUTURAS 835 \line char *Strrchr( const char *, int c \line Localiza a \'faltima ocorr\'eancia de c no string s. Se c \'e9 encontrado, um ponteiro para c no \line string s \'e9 retornado. Caso contr\'e1rio, \'e9 retornado um ponteiro NULL. \line size_t strspn( const char *si, const char *s2 \line Determina e retorna o comprimento do segmento inicial do string si consistindo somente \line em caracteres contidos no string s2. \line char *strpbrk( const char *si, const char *s2 \line Localiza a primeira ocorr\'eancia no string si de qualquer caractere no string s2. Se um caractere do string s2 \'e9 encontrado, \'e9 retornado um ponteiro para o caractere no string si. Caso contr\'e1rio, \'e9 retornado um ponteiro NULL. \line size_t strcspn( const char *si, const char *s2 \line Determina e retorna o comprimento do segmento inicial do string si que consiste em \line caracteres n\'e3o-contidos no string s2. \line char *strstr( const char *sl, const char *s2 ) \line Localiza a primeira ocorr\'eancia no string si do string s2. Se o string \'e9 encontrado, um \line ponteiro para o string em si \'e9 retornado. Caso contr\'e1rio, um ponteiro NULL \'e9 retornado. \line Fig. 16.27 Fun\'e7\'f5es de pesquisa da biblioteca de manipula\'e7\'e3o de strings (parte 2 de 2). \line A fun\'e7\'e3o strchr procura a primeira ocorr\'eancia de um caractere em um string. Se o caractere \'e9 encontrado, \line strchr retorna um ponteiro para o caractere no string; caso contr\'e1rio, strchr retorna NULL. O programa da Fig. \line 16.28 usa strchr para procurar as primeiras ocorr\'eancias de \lquote u\rquote  e \lquote z no string \ldblquote Isto \'e9 um teste\rdblquote . \line i II Fig. i6.28: figi6_28.cpp \line 2 1/ Usando strchr \line 3 #inciude <iostream> \line 4 \line 5 using std: :cout; \line 6 using std::endi; \line 7 \line 8 #inciude <cstring> \line 9 \line iO int main() \line ii \{ \line i2 const char *string = \ldblquote Isto \'e9 um teste\rdblquote ; \line i3 char characteri = \lquote u\rquote , character2 = \line 14 \line i5 if ( strchr( string, characteri ) != NULL \line i6 cout \'ab \lquote\\\lquote  \lquote  \'ab characteri \'ab \ldblquote\lquote  foi encontrado em \\\ldblquote  \line i7 \'ab string \'ab \ldblquote\\\ldblquote .\\n\rdblquote ; \line i8 eise \line 19 cout \'ab \lquote\\\lquote\lquote  \'ab characteri \'ab \ldblquote\lquote  n\'e3o foi encontrado em \\\ldblquote  \line 20 \'ab string \'ab \ldblquote\\\ldblquote .\\n\rdblquote ; \line 21 \line 22 if ( strchr( string, character2 ) ! NULL \line 23 cout \'ab \lquote\\\lquote\lquote  \'ab character2 \'ab \ldblquote\lquote  foi encontrado em \\\ldblquote  \line 24 \'ab string \'ab \ldblquote\\\ldblquote .\\n\rdblquote ; \line 25 eise \line 26 cout \'ab \lquote\\\lquote  \lquote  \'ab character2 \'ab \ldblquote\lquote  n\'e3o foi encontrado em \\\ldblquote  \line 27 \'ab string \'ab \ldblquote\\\ldblquote .\ldblquote  \'ab endi; \line 28 return 0; \line 29 \} \line Fig. 16.28 Usando strchr (parte 1 de 2). \par
836 C++ COMO PROGRAMAR \line\lquote u\rquote  foi encontrado em \ldblquote Isto \'e9 uni teste\rdblquote . \line\ul Lz n\'e3o foi encontrado em \ldblquote Isto \'e9 um teste\rdblquote . \ulnone\line Fig. 16.28 Usando strchr (parte 2 de 2). \line A fun\'e7\'e3o strcspn (Fig. 16.29) determina o comprimento da parte inicial do string em seu primeiro argumento que n\'e3o cont\'e9m quaisquer caracteres do string em seu segundo argumento. A fun\'e7\'e3o retorna o comprimento do segmento. \line 1 II Fig. 16.29: fig1629.cpp \line 2 // Usando strcspn \line 3 #include <iostream> \line 4 \line 5 using std::cout; \line 6 using std: :endl; \line 7 \line 8 #include <cstring> \line 9 \line 10 int main() \line 11 \{ \line 12 const char *stringl = \ldblquote O valor \'e9 3.14159\rdblquote ; \line 13 const char *string2 = \ldblquote 1234567890\rdblquote ; \line 14 \line 15 cout \'ab \ldblquote stringl = \ldblquote  \'ab stringl \'ab \ldblquote\\nstring2 = \ldblquote  \'ab string2 \line 16 \'ab \lquote\\n\\nO tamanho do segmento inicial de stringl\rquote  \line 17 \'ab \ldblquote\\nque n\'e3o cont\'e9m nenhum caractere de string2 = \line 18 \'ab strcspn( stringl, string2 ) \'ab endl; \line 19 return O; \line 20 \} t \line stringl = O valor \'e9 3.14159 \line string2 = 1234567890 \line O tamanho do segmento inicial de stringl \line que n\'e3o cont\'e9m nenhum caractere de string2 = 10 \line Fig. 16.29 Usando strcspn. \line A fun\'e7\'e3o strpbrk procura a primeira ocorr\'eancia em seu primeiro argumento string de qualquer caractere em seu \line segundo argumento srring. Se um caractere do segundo argumento \'e9 encontrado, strpbrk retorna um ponteiro \line para o caractere no primeiro argumento; caso contr\'e1rio, strpbrk retorna NULL. O programa da Fig. 16.30 localiza \line a primeira ocorr\'eancia em stringl de qualquer caractere de string2. \line 1 // Fig. 16.30: figl63O.cpp \line 2 // Usando strpbrk \line 3 #include <iostream> \line 5 using std::cout; \line 6 using std::endl; \line 7 \line 8 #include <cstring> \line Fig. 16.30 Usando strpbrk (parte 1 de 2). 4 \par
CAP\'cdTULO 16 - BIT5, CARACTERES, STRINGS E ESTRUTURAS 837 \line 9 \line 10 int main() \line 11 \line 12 const char *stringl = \ldblquote Isto \'e9 um teste\rdblquote ; \line 13 const char *string2 = \ldblquote cuidado\rdblquote ; \line 14 \line 15 cout \'ab \ldblquote Dos caracteres em \\\ldblquote  \'ab string2 \'ab \ldblquote\\\ldblquote\\n\rquote\rdblquote  \line 16 \'ab *trpbk( stringl, string2 ) \'ab \lquote\\\lquote\lquote  \line 17 \'ab \ldblquote  \'e9 o primeiro caractere que aparece em\\n\\\rdblquote  \line 18 \'ab stringl \'ab \lquote\\\ldblquote\lquote  \'ab endl; \line 19 return 0; \line 20 \line Dos caracteres em \ldblquote cuidado\rdblquote  \line\lquote o\rquote  \'e9 o primeiro caractere que aparece em \line\ldblquote Isto \'e9 um teste\rdblquote  \line Fig. 16.30 Usando strpbrk (parte 2 de 2). \line A fun\'e7\'e3o strrchr procura a \'faltima ocorr\'eancia do caractere especificado em um string. Se o caractere \'e9 encontrado, strrchr retorna um ponteiro para o caractere no string; caso contr\'e1rio, strrchr retorna 0. O programa da Fig. 16.3 1 procura pela \'faltima ocorr\'eancia do caractere \lquote z\rquote  no string \ldblquote Um zool\'f3gico tem muitos animais inclusive zebras\rdblquote . \line 1 II Fig. 16.31: figl63l.cpp \line 2 // Usando strrchr \line 3 #include <iostream> \line 4 \line 5 using std: :cout; \line 6 using std::endl; \line 7 \line 8 #include <cstring> \line 9 \line 10 int main() \line 11 \{ \line 12 const char *stringl = \ldblquote Um zool\'f3gico tem muitos animais\rdblquote  \line 13 \ldblquote inclusive zebras\rdblquote ; \line 14 int c = \line 15 \line 16 cout \'ab \ldblquote O resto do stringl come\'e7ando com a\\n\rdblquote  \line 17 \'ab \ldblquote\'faltima ocorr\'eancia do caractere \line 18 \'ab static_cast< char >( c \line 19 \'ab \ldblquote\lquote  is: \\\ldblquote  \'ab strrchr( stringl, c ) \'ab \lquote\\\ldblquote\lquote  \'ab endl; \line 20 return 0; \line 21 \} \line O resto do stringl come\'e7ando com a \line\'faltima ocorr\'eancia do caractere \lquote z\rquote  \'e9: \ldblquote zebras\rdblquote  \line Fig. 16.31 Usando strrchr. \line A fun\'e7\'e3o strspn (Fig. 16.32) determina o comprimento da parte inicial do string em seu primeiro argumento que cont\'e9m somente caracteres do string em seu segundo argumento. A fun\'e7\'e3o retorna o comprimento do segmento. \par
838 C++ COMO PROGRAMAR \line 1 II Fig. 16.32: figl6_32.cpp \line 2 II Usando strspn \line 3 #include <iostream> \line 4 \line 5 using std: :cout; \line 6 using std::endl; \line 7 \line 8 #include <cstring> \line 9 \line 10 int main() \line 11 \line 12 const char *stringl = \ldblquote 0 valor \'e9 3.14159; \line 13 const char *string2 = \ldblquote ar\'e9l 00v\rdblquote ; \line 14 \line 15 cout \'ab \ldblquote stringl = \ldblquote  \'ab stringl \line 16 \'ab \ldblquote\\nstring2 = \ldblquote  \'ab string2 \line 17 \'ab \ldblquote\\n\\nO tamanho do segmento inicial de stringl\\n\rdblquote  \line 18 \'ab \ldblquote que cont\'e9m somente caracteres de string2 = \line 19 \'ab strspn( stringl, string2 ) \'ab endi; \line 20 return 0; \line 21 \} \line stringl = O valor \'e9 3.14159 \line string2 = ar\'e9l 00v \line O tamanho do segmento inicial de stringl \line que cont\'e9m somente caracteres de string2 = 10 \line Fig. 16.32 Usando strspn. \line A fun\'e7\'e3o strstr procura a primeira ocorr\'eancia do seu segundo argumento string no seu primeiro argumento string. Se o segundo string \'e9 encontrado no primeiro string, um ponteiro para a localiza\'e7\'e3o do string no primeiro argumento \'e9 retornado, O programa da Fig. 16.33 usa strstr para encontrar o string \lquote def\rdblquote  no string \ldblquote abcdefabcdef\rquote . \line 1 II Fig. 16.33: figl6_33.cpp \line 2 // Usando strstr \line 3 #include <iostream> \line 4 \line 5 using std::cout; \line 6 using std: :endl; \line 7 \line 8 #include <cstring> \line 9 \line 10 int main() \line 11 \line 12 const char *stringl = \ldblquote abcdefabcdef\rdblquote ; \line 13 const char *string2 \line 14 \line 15 cout \'ab \ldblquote stringl = \ldblquote  \'ab stringl \'ab \lquote\\nstring2 = \ldblquote  \'ab string2 \line 16 \'ab \ldblquote\\n\\nO resto de stringl come\'e7ando com a\\n\rdblquote  \line 17 \'ab \ldblquote primeira ocorr\'eancia de string2 \'e9: \line 18 \'ab strstr( stringl, string2 ) \'ab endi; \line 19 return 0; \line 20 ) \line Fig. 16.33 Usando strstr (parte 1 de 2). \par
CAP\'cdTULO 16- BITS, CARACTERES, STRINGS E ESTRUTURAS 839 \line stringl = abcdefabcdef \line string2 = def \line O resto de stringl come\'e7ando com a \line primeira ocorr\'eancia de string2 \'e9: defabcdef \line Fig. 16.33 Usando strstr (parte 2 de 2). \line 16.12 Fun\'e7\'f5es de mem\'f3ria da biblioteca de manipula\'e7\'e3o de strings \line As fun\'e7\'f5es da biblioteca de manipula\'e7\'e3o de strings apresentadas nesta se\'e7\'e3o facilitam a manipula\'e7\'e3o, a compara\'e7\'e3o e a pesquisa de blocos de mem\'f3ria. As fun\'e7\'f5es tratam blocos de mem\'f3ria como arrays de caracteres. Estas fun\'e7\'f5es podem manipular qualquer bloco de dados. A Fig. 16.34 resume as fun\'e7\'f5es de mem\'f3ria da biblioteca de manipula\'e7\'e3o de strings. Nas discuss\'f5es das fun\'e7\'f5es, \ldblquote objeto\rdblquote  refere-se a um bloco de dados. \par
Prot\'f3tipo Descri\'e7\'e3o \par
void *memcpy( void *si, const void*s2, size_t n \line Copia n caracteres do objeto apontado por s2 para o objeto apontado por si. Retorna um \line ponteiro para o objeto resultante. \line void *memmove( void *si, const void *s2, sizet n \line Copia n caracteres do objeto apontado por s2 para o objeto apontado por si. A c\'f3pia \'e9 executada como se os caracteres fossem primeiro copiados do objeto apontado por s2 para um array tempor\'e1rio e, ent\'e3o, do array tempor\'e1rio para o objeto apontado por si. E retomado um ponteiro para o objeto resultante. \line int memcmp( const void *si, const void *s2, size_t n \line Compara os primeiros n caracteres dos objetos apontados por si e s2. A fun\'e7\'e3o retorna O, \line menor que O ou maior que O se si \'e9 igual, menor do que ou maior do que s2. \line void *memchr( const void *5 int c, sizet n \line Localiza a primeira ocorr\'eancia de c (convertido para unsigned char) nos primeiros n \line caracteres do objeto apontado por s. Se c \'e9 encontrado, \'e9 retornado um ponteiro para o \line objeto c. Caso contr\'e1rio, \'e9 retomado O. \line void *memset( void *, int c, sizet n \line Copia c (convertido para uns igned char) para os primeiros n caracteres do objeto apontado por s. Retoma um ponteiro para o resultado. \line Fig. 16.34 Fun\'e7\'f5es de mem\'f3ria da biblioteca de manipula\'e7\'e3o de strings. \line Os par\'e2metros ponteiros destas fun\'e7\'f5es s\'e3o declarados void*. No Cap\'edtulo 5, vimos que um ponteiro para qualquer tipo de dados pode ser diretamente atribu\'eddo a um ponteiro do tipo void*. Por essa raz\'e3o, estas fun\'e7\'f5es podem receber ponteiros para qualquer tipo de dados. Lembre-se de que um ponteiro de tipo void* n\'e3o pode ser diretamente atribu\'eddo a um ponteiro para qualquer tipo de dados. Como um ponteiro void* n\'e3o pode ser derreferenciado, cada fun\'e7\'e3o recebe um par\'e2metro de tamanho que especifica o n\'famero de caracteres (bytes) que a fun\'e7\'e3o processar\'e1. Para simplificar, os exemplos nesta se\'e7\'e3o manipulam arrays de caracteres (blocos de caracteres). \line A fun\'e7\'e3o memcpy copia um n\'famero especificado de caracteres (bytes) do objeto apontado por seu segundo par\'e2metro para o objeto apontado por seu primeiro par\'e2metro. A fun\'e7\'e3o pode receber um ponteiro para qualquer tipo de objeto. O resultado desta fun\'e7\'e3o \'e9 indefinido se os dois objetos se sobrep\'f5em na mem\'f3ria, i.e., eles s\'e3o partes do mesmo objeto. O programa da Fig. 16.35 usa memcpy para copiar o string no array s2 para o array si. \par
840 C++ COMO PROGRAMAR \line 1 II Fig. 16.35: figl6_35.cpp \line 2 II Usando memcpy \line 3 #include <iostream> \line 4 \line 5 using std: :cout; \line 6 using std: :endl; \line 7 \line 8 #inciude <cstring> \line 9 \line 10 int main() \line 11 \line 12 char sl[ 17 ), s2[] = \ldblquote Copie este string\rdblquote ; \line 13 \line 14 memcpy( si, s2, 17 \line 15 cout \'ab \lquote Depois que s2 \'e9 copiado para si com memcpy,\\n\rdblquote  \line 16 \'ab si cont\'e9m \\\ldblquote\ldblquote  \'ab si \'ab \\\ldblquote\lquote  \'ab endi; \line 17 return O; \line 18 \par
Fig. 16.35 Usando memcpy. \line A fun\'e7\'e3o memmove, como memcpy. copia um n\'famero especificado de bytes do objeto apontado por seu segundo \line argumento para o objeto apontado por seu primeiro argumento. A c\'f3pia \'e9 executada como se os bytes fossem \line copiados do segundo argumento para um array tempor\'e1rio de caracteres e, ent\'e3o, copiados do array tempor\'e1rio para \line o primeiro argumento. Isto permite que caracteres de uma parte de um string possam ser copiados para outra parte \line do mesmo string. \line Erro de programa\'e7\'e3o comum 16.10 \line As fun\'e7\'f5es de manipula\'e7\'e3o de strings que copiam caracteres, exceto memmove, t\'eam resultados indefinidos quando a c\'f3pia ocorre entre partes do mesmo string. \line O programa na Fig. 16.36 usa memmove para copiar os \'faltimos 8 bytes do array x para os primeiros 8 bytes do array x. \line 1 II Fig. 16.36: fig1636.cpp \line 2 // Usando memmove \line 3 #include <iostream> \line 4 \line 5 using std: :cout; \line 6 using std: :endi; \line 7 \line 8 #inciude <cstring> \line 9 \line 10 int main() \line ii \line 12 char x[] = \ldblquote Lar Doce Lar\rdblquote ; \line 13 \line 14 cout \'ab \ldblquote 0 string no array x antes de memmove \'e9: \ldblquote  \'ab x; \line 15 cout \'ab \ldblquote\\nO string no array x depois de memmove \'e9: \par
Fig. 16.36 Usando meinmove (parte 1 de 2). \par
\pard\par
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1069\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1518\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1862\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4671\pard\intbl Depois que \cell s2 \cell\'e9 \cell copiado para si com memcpy, \cell\row
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1069\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1862\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4671\pard\intbl si cont\'e9m \cell\ldblquote Copie \cell este string\rquote  \cell\row
\pard\par
\pard\sb100\sa240 CAP\'cdTULO 16- BITs, CARACTERES, STRINGS E ESTRUTURAS 841 \line 16 \'ab static cast<char *>( memmove( x, &x[ 4 ], 8 \line 17 \'ab endi; \line 18 return O; \line 19 \line O string no array x antes de memmove \'e9: Lar Doce Lar \line O string no array x depois de mexnmove \'e9: Doce Lar Lar \line Fig. 16.36 Usando mexnmove (parte 2 de 2). \line A fun\'e7\'e3o mexncmp (F\rquote ig. 16.37) compara o n\'famero de caracteres especificado em seu primeiro argumento com os caracteres correspondentes de seu segundo argumento. A fun\'e7\'e3o retorna um valor maior do que zero se o primeiro par\'e2metro \'e9 maior do que o segundo argumento, retorna zero se os argumentos s\'e3o iguais e retorna um valor menor do que zero se o primeiro argumento \'e9 menor do que o segundo argumento. \line 1 II Fig. 16.37: figi6_37.cpp \line 2 II Usando memcinp \line 3 #inciude <iostreani> \line 4 \line 5 using std::cout; \line 6 using std::endl; \line 7 \line 8 #inciude <iomanip> \line 9 \line 10 using std::setw; \line ii \line 12 flinclude <cstring> \line 13 \line 14 int main() \line 15 \{ \line 16 char si[) = \'b0ABCDEFG\rdblquote , s2[) = \ldblquote ABCDXYZ\rdblquote ; \line 17 \line 18 cout \'ab \ldblquote si = \ldblquote  \'ab si \'ab \ldblquote\\ns2 = \ldblquote  \'ab s2 \'ab endi \line 19 \'ab \ldblquote\\nmemcmp(sl, s2, 4) = \ldblquote  \'ab setw( 3 \line 20 \'ab memcmp( si, s2, 4 ) \'ab \ldblquote\\nmemcmp(sl, s2, 7) \line 21 \'ab setw( 3 ) \'ab memcmp ( si, s2, 7 \line 22 \'ab \ldblquote\\nmemcmp(s2, si, 7) \ldblquote  \'ab setw( 3 \line 23 \'ab memcmp( s2, si, 7 ) \'ab endi; \line 24 return 0; \line 25 \line si = ABCDEFG \line s2 = ABCDXYZ \line memcmp (si, s2, 4) = O \line niemcmp(sl, s2, 7) = -19 \line memcmp(s2, si, 7) = 19 \line Fig. 16.37 Usando memcmp. \line A fun\'e7\'e3o memchr procura a primeira ocorr\'eancia de um byte, representado como um unsigned char, no n\'famero especificado de bytes de um objeto. Se o byte \'e9 encontrado, um ponteiro para o byte no objeto \'e9 retornado; caso contr\'e1rio, \'e9 retornado NULL. O programa da Fig. 16.38 procura o caractere (byte) \lquote S no string \ldblquote Leila, Gal e Simorie\rdblquote . \par
S42 C++ COMO PROGRAMAR \line 1 II Fig. 16.38: figl6_38.cpp \line 2 // Usando memchr \line 3 #include <iostream> \line 4 \line 5 using std: :cout; \line 6 using std: :endl; \line 7 \line 8 #include <cstring> \line 9 \line 10 int main() \line 11 \{ \line 12 char s[] = Leila, Gal e Simone\rdblquote ; \line 13 \line 14 cout \'ab \ldblquote O resto de s depois que o caractere \lquote S\rquote  \line 15 \'ab \'e9 encontrado \'e9 \\\ldblquote\ldblquote  \line 16 \'ab static_cast<char *>( memchr( s, \lquote S\rquote , 19 \line 17 \'ab \\\ldblquote  \'ab endi; \line 18 return O; \line 19 \} \par
O resto de s depois que o caractere \lquote s\rquote  \'e9 encontrado \'e9 Simone\rdblquote  \par
Fig. 16.38 Usando memchr. \line A fun\'e7\'e3o memset copia o valor do byte em seu segundo argumento para um n\'famero especificado de bytes do objeto apontado por seu primeiro argumento. O programa na Fig. 16.39 usa memset para copiar \lquote b para os primeiros 7 bytes de stringl. \line 1 II Fig. 16.39: fig1639.cpp \line 2 // Usando memset \line 3 #include <iostream> \line 4 \line 5 using std: :cout; \line 6 using std: :endi; \line 7 \line 8 #include <cstring> \line 9 \line 10 int main() \line 11 \{ \line 12 char stringl[ 15 ] = BBBBBBBBBBBBBB\rdblquote ; \line 13 \line 14 cout \'ab stringl = \'ab stringl \'ab endi; \line 15 cout \'ab \ldblquote stringl depois de memset = \line 16 \'ab static cast<char *>( memset( stringl, b, 7 ) \line 17 \'ab endi; \line 18 return 0; \line 19 \} \line stringl = BBBBBBBBBBBBBB \line stringl depois de memset = bbbbbbbBBBBBBB \line Fig. 16.39 Usando memset. \par
CAP\'cdTULO 16 - BIT5, CARACTERES, STRINGS E ESTRUTURAS 843 \par
16.13 Uma outra fun\'e7\'e3o da biblioteca de manipula\'e7\'e3o de strings \par
A fun\'e7\'e3o restante da biblioteca de manipula\'e7\'e3o de strings \'e9 strerror. A Fig. 16.40 resume a fun\'e7\'e3o strerror. \line A fun\'e7\'e3o strerror recebe um n\'famero de erro e cria um string com uma mensagem de erro. Um ponteiro para o \line string \'e9 retornado, O programa da Fig. 16.41 demonstra strerror. \par
Dica de portabilidade 16.7 \line _____ A mensagem gerada por strerror \'e9 dependente do sistema. \par
j Prot\'f3tipo Descri\'e7\'e3o \par
Fig. 16.40 Uma outra fun\'e7\'e3o de manipula\'e7\'e3o de strings da biblioteca de manipula\'e7\'e3o de strings. \line 1 II Fig. 16.41: figl64l.cpp \line 2 // Usando strerror \line 3 #include <iostream> \line 4 \line 5 using std: :cout; \line 6 using std::endl; \line 7 \line 8 #include <cstring> \line 9 \line 10 int main() \line 11 \{ \line 12 cout \'ab strerror( 2 ) \'ab endi; \line 13 return O; \line 14 \} \line No such file or directory \line Fig. 16.41 Usando strerror. \line Resumo \line\bullet  Estruturas s\'e3o cole\'e7\'f5es de vari\'e1veis relacionadas, \'e0s vezes chamadas de agregados, com um nome. \line\bullet  Estruturas podem conter vari\'e1veis de tipos de dados diferentes. \line\bullet  Toda defini\'e7\'e3o de estrutura come\'e7a com a palavra-chave struct. Dentro das chaves da defini\'e7\'e3o de estrutura est\'e3o as declara\'e7\'f5es de membros da estrutura. \line\bullet  Membros da mesma estrutura devem ter nomes \'fanicos. \line\bullet  Uma defini\'e7\'e3o de estrutura cria um novo tipo de dados que pode ser usado para declarar vari\'e1veis. \line\bullet  Uma estrutura pode ser inicializada com uma lista de inicializadores, colocando-se em seguida \'e0 vari\'e1vel na declara\'e7\'e3o um sinal de igual e uma lista de inicializadores separados por v\'edrgulas, entre chaves. Se existem menos inicializadores na lista do que membros na estrutura, os membros restantes s\'e3o automaticamente inicializados com zero (ou NULL para membros do tipo ponteiro). \par
\pard\par
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx7688\pard\intbl char*strerror( interrornum \cell\row
\intbl Mapeia errornum para um string de texto de uma maneira dependente do sistema. Retorna \cell\row
\intbl um ponteiro para o string. \cell\row
\pard\par
\pard\sb100\sa240 844 C++ COMO PROGRAMAR \line\bullet  Vari\'e1veis estruturas inteiras podem ser atribu\'eddas a vari\'e1veis estrutura do mesmo tipo. \line\bullet  Uma vari\'e1vel estrutura pode ser inicializada com uma vari\'e1vel estrutura do mesmo tipo. \line\bullet  Vari\'e1veis estruturas e membros individuais de estruturas s\'e3o passados para fun\'e7\'f5es por chamada por valor. Os membros array s\'e3o, naturalmente, passados por refer\'eancia. \line\bullet  Para passar uma estrutura atrav\'e9s de uma chamada por refer\'eancia, passe o endere\'e7o da vari\'e1vel estrutura. Um array de estruturas \'e9 passado automaticamente atrav\'e9s de chamada por refer\'eancia. Para passar um array atrav\'e9s de chamada por valor, crie uma estrutura com o array como um membro. \line\bullet  Criar um novo nome com typedef n\'e3o cria um novo tipo; cria um nome que \'e9 sin\'f4nimo de um tipo definido previamente. \line\bullet  O operador AND sobre bits (&) aceita dois operandos integrais. Um bit no resultado \'e9 mudado para um se os bits correspondentes em cada um do operandos s\'e3o um. \line\bullet  As m\'e1scaras s\'e3o usadas para esconder alguns bits enquanto preservam outros. \line\bullet  O operador sobre bits OR inclusivo (1) aceita dois operandos. Um bit no resultado \'e9 colocado em um se o bit correspondente em um ou outro dos operandos for um. \line\bullet  Cada um dos operadores sobre bits (exceto complemento) tem um operador de atribui\'e7\'e3o correspondente. \line\bullet  O operador sobre bits OR exclusivo (A) aceita dois operandos. Um bit no resultado \'e9 colocado em um se exatamente um dos bits correspondentes nos dois operandos tem valor um. \line\bullet  O operador deslocamento \'e0 esquerda (\'ab) desloca os bits de seu operando esquerdo para a esquerda pelo n\'famero de bits especificados por seu operando direito. Os bits desocupados \'e0 direita s\'e3o substitu\'eddos por Os. \line\bullet  O operador de deslocamento \'e0 direita (\'bb) desloca os bits de seu operando esquerdo para a direita pelo n\'famero de bits especificados em seu operando direito. Executar um deslocamento \'e0 direita sobre um inteiro unsigned faz com que os bits desocupados na esquerda sejam substitu\'eddos por zeros. Os bits desocupados em inteiros signed podem ser substitu\'eddos por zeros ou uns - isso \'e9 dependente de m\'e1quina. \line\bullet  O operador sobre bits complemento () recebe um operando e inverte seus bits - isso produz o complemento de um do operando. \line\bullet  Campos de bits reduzem o uso de mem\'f3ria armazenando dados no n\'famero m\'ednimo de bits necess\'e1rios. Os membros de campos de bits devem ser declarados como int ou unsigned. \line\bullet  Um campo de bits \'e9 declarado seguindo-se um nome de membro unsigned ou int com um dois-pontos e o comprimento do campo de bits. \line\bullet  O comprimento do campo de bits deve ser uma constante inteira entre zero e o n\'famero total de bits usados para armazenar um vari\'e1vel int em seu sistema. \line\bullet  Se um campo de bits \'e9 especificado sem um nome, o campo \'e9 usado como preenchimento na estrutura. \line\bullet  Um campo de bits sem nome com comprimento O alinha o pr\'f3ximo campo de bits em um novo limite de palavra de m\'e1quina. \line\bullet  A fun\'e7\'e3o islower determina se seu argumento \'e9 uma letra min\'fascula (a-z). A fun\'e7\'e3o isupper determina se seu argumento \'e9 uma letra mai\'fascula (A-Z). \line\bullet  A fun\'e7\'e3o isdigit determina se seu argumento \'e9 um d\'edgito (0-9). \line\bullet  A fun\'e7\'e3o isalpha determina se seu argumento \'e9 uma letra mai\'fascula (A-Z) ou uma letra min\'fascula (a-z). \line\bullet  A fun\'e7\'e3o isainum determina se seu argumento \'e9 uma letra mai\'fascula (A-Z), uma letra min\'fascula (a-z), ou um d\'edgito (O- \line 9). \line\bullet  A fun\'e7\'e3o isxdigit determina se seu argumento \'e9 um d\'edgito hexadecimal (A-F. a-f, 0-9). \line\bullet  A fun\'e7\'e3o toupper converte uma letra min\'fascula em uma letra mai\'fascula. A fun\'e7\'e3o tolower converte uma letra mai\'fascula em uma letra min\'fascula. \line\bullet  A fun\'e7\'e3o isspace determina se seu argumento \'e9 um dos seguintes caracteres impressos como caracteres de espa\'e7o em branco: (espa\'e7o), \lquote\\f\rquote , \lquote\\n, \lquote\\r\rquote . \lquote\\t\rquote  ou \line\bullet  A fun\'e7\'e3o iscntrl determina se seu argumento \'e9 um dos seguintes caracteres de controle: \lquote\\t\rquote , \\v , \\f , \lquote\\a\rquote . \lquote\\b\rquote , \lquote\\r\rquote  ou \par
CAP\'cdTULO 16 - BIT5, CARACTERES, STRINGS E ESTRUTURAS 845 \line\bullet  A fun\'e7\'e3o ispunct determina se seu argumento \'e9 um caractere de impress\'e3o diferente de um espa\'e7o, um d\'edgito ou uma letra. \line\bullet  A fun\'e7\'e3o isprint determina se seu argumento \'e9 qualquer caractere imprim\'edvel, inclusive o caractere espa\'e7o. \line\bullet  A fun\'e7\'e3o isgraph determina se seu argumento \'e9 um caractere de impress\'e3o diferente do caractere espa\'e7o. \line\bullet  A fun\'e7\'e3o atof converte seu argumento - um string que come\'e7a com uma s\'e9rie de d\'edgitos que representa um n\'famero de ponto flutuante - em um valor double. \line\bullet  A fun\'e7\'e3o atoi converte seu argumento - um string que come\'e7a com uma s\'e9rie de d\'edgitos que representa um inteiro - em um valor int. \line\bullet  A fun\'e7\'e3o atol converte seu argumento - um string que come\'e7a uma s\'e9rie de d\'edgitos que representa um inteiro long - em um valor long. \line\bullet  A fun\'e7\'e3o strtod converte uma seq\'fc\'eancia de caracteres representando um valor de ponto flutuante para double. A fun\'e7\'e3o recebe dois argumentos - um string (char *) e um ponteiro para char*. O string cont\'e9m a seq\'fc\'eancia de caracteres a serem convertidos e ao ponteiro para char* \'e9 atribu\'eddo o restante do string depois da convers\'e3o. \line\bullet  A fun\'e7\'e3o strtol converte uma seq\'fc\'eancia de caracteres representando um inteiro long. A fun\'e7\'e3o recebe tr\'eas argumentos - um string (char* ). um ponteiro para char* e um inteiro, O .string cont\'e9m a seq\'fc\'eancia de caracteres a ser convertida, ao ponteiro para char* \'e9 atribu\'eddo o restante do string depois da convers\'e3o e o inteiro especifica a base do valor que est\'e1 sendo convertido. \line\bullet  A fun\'e7\'e3o strtoul converte uma seq\'fc\'eancia de caracteres representando um inteiro para unsigned long. A fun\'e7\'e3o recebe tr\'eas argumentos - um string (char *), um ponteiro para char* e um inteiro, O string cont\'e9m a seq\'fc\'eancia de caracteres a ser convertida, ao ponteiro para char* \'e9 atribu\'eddo o restante do string depois da convers\'e3o e o inteiro especifica a base do valor que est\'e1 sendo convertido. \line\bullet  A fun\'e7\'e3o strchr procura a primeira ocorr\'eancia de um caractere em um string. Se o caractere \'e9 encontrado, strchr retorna um ponteiro para o caractere no string; caso contr\'e1rio, strchr retoma NULL. \line\bullet  A fun\'e7\'e3o strcspn determina o comprimento da parte inicial do srring em seu primeiro argumento que n\'e3o cont\'e9m quaisquer caracteres do string em seu segundo argumento. A fun\'e7\'e3o retoma o comprimento do segmento. \line\bullet  A fun\'e7\'e3o strpbrk procura a primeira ocorr\'eancia em seu primeiro argumento de qualquer caractere que aparece em seu segundo argumento. Se um caractere do segundo argumento \'e9 encontrado, strpbrk retoma um ponteiro para o caractere; caso contr\'e1rio, strpbrk retorna NULL. \line\bullet  A fun\'e7\'e3o strrchr procura a \'faltima ocorr\'eancia de um caractere em um string. Se o caractere \'e9 encontrado, strrchr retorna um ponteiro para o caractere no string; caso contr\'e1rio, ela retoma NULL. \line\bullet  A fun\'e7\'e3o strspn determina o comprimento da parte inicial do string em seu primeiro argumento que cont\'e9m somente caracteres do string em seu segundo argumento. A fun\'e7\'e3o retoma o comprimento do segmento. \line\bullet  A fun\'e7\'e3o strstr procura a primeira ocorr\'eancia de seu segundo argumento string em seu primeiro argumento string. Se o segundo string \'e9 encontrado no primeiro string, \'e9 retornado um ponteiro para a localiza\'e7\'e3o do string no primeiro argumento. \line\bullet  A fun\'e7\'e3o memcpy copia um n\'famero especificado de caracteres do objeto para o qual seu segundo argumento aponta para o objeto que seu primeiro argumento aponta. A fun\'e7\'e3o pode receber um ponteiro para qualquer tipo de objeto. Os ponteiros s\'e3o recebidos por memcpy como ponteiros void e convertidos em ponteiros char para uso na fun\'e7\'e3o. A fun\'e7\'e3o memcpy manipula os bytes do argumento como caracteres. \line\bullet  A fun\'e7\'e3o memmove copia um n\'famero especificado de bytes do objeto apontado por seu segundo argumento para o objeto apontado por seu primeiro argumento. A c\'f3pia \'e9 realizada como se os bytes fossem copiados do segundo argumento para um array de caracteres tempor\'e1rio e, ent\'e3o, copiados do array tempor\'e1rio para o primeiro argumento. \line\bullet  A fun\'e7\'e3o memcmp compara o n\'famero especificado de caracteres de seu primeiro e segundo argumentos. \line\bullet  A fun\'e7\'e3o memchr procura a primeira ocorr\'eancia de um byte, representado como urisigned char, no n\'famero especificado de bytes de um objeto. Se o byte \'e9 encontrado, um ponteiro para o byte \'e9 retomado; caso contr\'e1rio, um ponteiro NULL \'e9 retornado. \line\bullet  A fun\'e7\'e3o memset copia seu segundo argumento, tratado como um unsigned char, para um n\'famero especificado de bytes do objeto apontado pelo primeiro argumento. \line\bullet  A fun\'e7\'e3o strerror mapeia um n\'famero de erro de tipo inteiro para um string de texto, de uma maneira dependente de sistema. E retornado um ponteiro para o string. \par
846 C++ COMO PROGRAMAR \line Terminologia \line & operador AND sobre bits isalpha \line &= operador de atribui\'e7\'e3o AND sobre bits iscntrl \line operador OR exclusivo sobre bits isdigit \line A= operador de atribui\'e7\'e3o OR exclusivo sobre bits isgraph \line 1 operador OR inclusivo sobre bits islower \line = operador de atribui\'e7\'e3o OR inclusivo sobre bits isprint \line operador complemento de 1 ispunct \line\'aboperador de atribui\'e7\'e3o de deslocamento \'e0 esquerda isspace \line\'aboperador de deslocamento \'e0 esquerda isupper \line <cctype> isxdigit \line <cstdlib> literal \line <string> m\'e1scara \line\'bb operador de atribui\'e7\'e3o de deslocamento \'e0 direita mascarando bits \line\'bb operador de deslocamento \'e0 direita memchr \line array de estruturas memcmp \line ASCII memcpy \line atof memmove \line atoi memset \line atol operadores sobre bits \line atribui\'e7\'e3o de estrutura ponteiro para uma estrutura \line bibliotecade utilit\'e1rios gen\'e9ricos preenchimento \line campo de bits processamento de strings \line campo de bits de comprimento zero processamento de texto \line campo de bits sem nome registro \line caractere de controle strchr \line caractere imprim\'edvel strcspn \line caracteres de espa\'e7o em branco strerror \line c\'f3digo de caractere string \line complementando string de procura \line complemento de 1 string literal \line comprimento de um campo de bits strpbrk \line conjunto de caracteres strrchr \line constante de caractere strspn \line constante do tipo string strstr \line delimitador strtod \line deslocamento \'e0 direita strtol \line deslocamento \'e0 esquerda strtoul \line d\'edgitos hexadecimais struct \line estrutura auto-referente tipo de uma estrutura \line fazer um deslocamento tolower \line fun\'e7\'f5es de convers\'e3o de strings toupper \line inicializa\'e7\'e3o de estrutura troca espa\'e7o versus tempo de execu\'e7\'e3o \line inicializa\'e7\'e3o de estruturas typedef \line isainum \line Erros comuns de programa\'e7\'e3o \line 16.1 Esquecer o ponto-e-v\'edrgula que termina uma defini\'e7\'e3o de estrutura. \line 16.2 Comparar estruturas \'e9 um erro de sintaxe por causa dos diferentes requisitos de alinhamento nos diversos sistemas. \line 16.3 Assumir que estruturas, como arrays, s\'e3o passados atrav\'e9s de chamadas por refer\'eancia e tentar modificar os valores da estrutura do chamador na fun\'e7\'e3o chamada. \line 16.4 Esquecer de incluir o \'edndice de array quando referenciar estruturas individuais em um array de estruturas. \line 16.5 Usar o operador AND l\'f3gico (&&) como o operador AND sobre bits (&), e vice-versa. \line 16.6 Usar o operador OR l\'f3gico (1 1) em vez do operador OR sobre bits (1), e vice-versa. \line 16.7 O resultado de fazer um deslocamento de um valor \'e9 indefinido se o operando direito for negativo ou se o operando direito for maior que o n\'famero de bits em que o operando esquerdo est\'e1 armazenado. \line 16.K Tentar acessar bits individuais de um campo de bits como se fossem elementos de um array. Campos de bits n\'e3o s\'e3o \ldblquote array de bits\rdblquote . \par
CAPITULO 16 - Brrs, CARACTERES, STR\'cdNGS E ESTRUTURAS 847 \par
16.9 Tentar pegar o endere\'e7o de um campo de bits (o operador& n\'e3o pode ser usado com campos de bits porque eles n\'e3o t\'eam endere\'e7os). \line 16.10 As fun\'e7\'f5es de manipula\'e7\'e3o de strings que copiam caracteres, exceto memmove. t\'eam resultados indefinidos quando a c\'f3pia ocorre entre partes do mesmo string. \line Boas pr\'e1ticas de programa\'e7\'e3o \line 16.1 Forne\'e7a um nome de estrutura quando criar um tipo de estrutura. O nome de estrutura \'e9 conveniente para declarar novas vari\'e1veis do tipo da estrutura mais \'e0 frente no programa e \'e9 obrigat\'f3rio se a estrutura for passada como um par\'e2metro para uma fun\'e7\'e3o. \line 16.2 Comece nomes typedef com mai\'fasculas, para enfatizar que estes nomes s\'e3o sin\'f4nimos de outros nomes de tipo. \line Dicas de desempenho \line 16.1 Passar estruturas (especialmente estruturas grandes) atrav\'e9s de chamada por refer\'eancia \'e9 mais eficiente do que passar estruturas atrav\'e9s de chamadas por valor (o que exige a c\'f3pia da estrutura inteira). \line 16.2 Campos de bits ajudam a economizar mem\'f3ria. \line 16.3 Embora campos de bits economizem espa\'e7o, us\'e1-los pode fazer com que o compilador gere c\'f3digo de linguagem de m\'e1quina de execu\'e7\'e3o mais lenta. Isto acontece porque s\'e3o necess\'e1rias opera\'e7\'f5es adicionais em linguagem de m\'e1quina para acessar somente partes de uma unidade de mem\'f3ria endere\'e7\'e1vel. Este \'e9 um dos muitos exemplos dos tipos de trocas de espa\'e7o versus tempo de execu\'e7\'e3o que acontecem em Ci\'eancia da Computa\'e7\'e3o. \line Dicas de portabil\'eddade \line 16.1 Como o tamanho dos itens de dados de um tipo particular \'e9 dependente de m\'e1quina e como considera\'e7\'f5es de alinhamento de mem\'f3ria s\'e3o dependentes de m\'e1quina, assim tamb\'e9m o \'e9 a representa\'e7\'e3o de uma estrutura. \line 16.2 Usar typedef pode ajudar a tomar um programa mais port\'e1vel. \line 16.3 As manipula\'e7\'f5es de dados sobre bits s\'e3o dependentes de m\'e1quina. \line 16.4 O resultado de fazer um deslocamento \'e0 direita de um valor com sinal \'e9 dependente de m\'e1quina. Algumas m\'e1quinas preenchem com zero e outras usam o bit de sinal. \line 16.5 As manipula\'e7\'f5es de campos de bit s\'e3o dependentes de m\'e1quina. Por exemplo, alguns computadores permitem que campos de bits cruzem limites de palavra, enquanto outros n\'e3o. \line 16.6 O tipo size_t \'e9 um sin\'f4nimo dependente de sistema ou para um tipo unsigned long ou para um tipo unsigned int. \line 16.7 A mensagem gerada por strerror \'e9 dependente do sistema. \line Exerc\'edcios de auto-revis\'e3o \line 16.1 Preencha os espa\'e7os em branco em cada um dos seguintes itens: \line a) Uma ___________ \'e9 uma cole\'e7\'e3o de vari\'e1veis relacionadas com um nome. \line b) Os bits no resultado de uma express\'e3o usando o operador s\'e3o colocados em um se os bits correspondentes em cada operando s\'e3o iguais a um. Caso contr\'e1rio, os bits s\'e3o colocados em zero. \line c) As vari\'e1veis declaradas em uma defini\'e7\'e3o de estrutura s\'e3o chamadas de seus ___________ \line d) Os bits no resultado de uma express\'e3o que usa o operador s\'e3o colocados em um se pelo menos um dos bits correspondentes em um ou outro operando tem o valor um. Caso contr\'e1rio, os bits s\'e3o colocados em zero. \line e) A palavra-chave inicia uma declara\'e7\'e3o de estrutura. \line f) A palavra-chave \'e9 usada para criar um sin\'f4nimo para um tipo de dados previamente definido. \line g) Os bits no resultado de uma express\'e3o usando o operador s\'e3o colocados em um se exatamente um dos bits correspondentes em um ou outro operando tem o valor um. Caso contr\'e1rio, os bits s\'e3o colocados em zero. \line h) O operador AND sobre bits & \'e9 usado freq\'fcentemente para bits (i.e., para selecionar certos bits de um string de bits enquanto zera outros). \line i) O nome da estrutura \'e9 chamado de ___________ da estrutura. \line j) Um membro de estrutura \'e9 acessado tanto com o operador como com o operador \line k) Os operadores e ___________ s\'e3o usados para deslocar os bits de um valor para a esquerda ou para a direita, respectivamente. \par
848 C++ COMO PROGRAMAR \line 16.2 Diga se cada um dos seguintes itens \'e9 verdadeiro ou falso. Se falso, explique por qu\'ea. \line a) Estruturas podem conter somente um tipo de dados. \line b) Os membros de estruturas diferentes devem ter nomes \'fanicos. \line e) A palavra-chave typedef \'e9 usada para definir novos tipos de dados. \line d) Estruturas s\'e3o sempre passadas para fun\'e7\'f5es por chamadas por refer\'eancia. \line 16.3 Escreva um comando \'fanico ou um conjunto de comandos para realizar cada um dos seguintes: \line a) Defina uma estrutura chamada Part que cont\'e9m a vari\'e1vel int partNumber e o array char partNa!ne cujos valores podem ser t\'e3o longos quanto 25 caracteres. \line b) Defina PartPtr como um sin\'f4nimo para o tipo Part . \line c) Declare a vari\'e1vel a como sendo do tipo Part. o array b [ 10 ] como sendo do tipo Part e a vari\'e1vel ptr como sendo um ponteiro para o tipo Part. \line d) Leia um n\'famero de pe\'e7a (partNumber) e um nome de pe\'e7a (partName) do teclado para os membros da vari\'e1vel \line a. \line e) Atribua os valores dos membros da vari\'e1vel a ao elemento tr\'eas do array b. \line f) Atribua o endere\'e7o do array b \'e0 vari\'e1vel ponteiro ptr. \line g) Imprima os valores dos membros do elemento tr\'eas do array b usando a vari\'e1vel ptr e o operador de ponteiro de estrutura para se referir aos membros. \line 16.4 Encontre o erro em cada um dos seguintes itens: \line a) Assuma que a struct Card foi definida contendo dois ponteiros para o tipo char, isto \'e9, face e suit. Al\'e9m disso, a vari\'e1vel c foi declarada como sendo do tipo Card e a vari\'e1vel cPtr foi declarada como sendo um ponteiro para o tipo Card. \'c0 vari\'e1vel cPtr foi atribu\'eddo o endere\'e7o de c. \line cout \'ab *cptr face \'ab endi; \line b) Assuma que a struct Card foi definida contendo dois ponteiros para o tipo char. isto \'e9, face e suit. Al\'e9m disso, o array hearts [13] foi declarado como sendo do tipo Card. O comando seguinte deveria imprimir o membro face do elemento lOdo array. \line cout \'ab hearts.face \'ab endi; \line e) struct Pessoa \line char sobreNome [ 15 ]; \line char primeiroNome[ 15 ]; \line int idade; \line d) Assuma que a vari\'e1vel p foi declarada como do tipo Pessoa e a vari\'e1vel c foi declarada como do tipo Card. p = c; \line 16.5 Escreva um \'fanico comando para realizar cada um dos seguintes. Assuma que as vari\'e1veis c (que armazena um caractere), \line x, y e z s\'e3o do tipo int, as vari\'e1veis d, e e f s\'e3o do tipo fioat, a vari\'e1vel ptr \'e9 do tipo char * e os arrays si [ 100 ] e \line s2 [ 100 ] s\'e3o do tipo char. \line a) Converta o caractere armazenado na vari\'e1vel c para uma letra mai\'fascula. Atribua o resultado \'e0 vari\'e1vel c. \line b) Determine se o valor da vari\'e1vel c \'e9 um d\'edgito. Use o operador condicional como mostrado nas Figs. 16.17, 16.18 e 16.19 para imprimir \ldblquote\'e9 um\rquote  ou \ldblquote n\'e3o \'e9 um\rdblquote  quando o resultado \'e9 exibido. \line e) Converta o string \ldblquote 1234567\rdblquote  para long e imprima o valor. \line d) Determine se o valor da vari\'e1vel c \'e9 um caractere de controle. Use o operador condicional para imprimir \ldblquote\'e9 um\rdblquote  ou \ldblquote n\'e3o \'e9 um\rdblquote  quando o resultado for exibido. \line e) Atribua a ptr a posi\'e7\'e3o da \'faltima ocorr\'eancia de cem si. \line f) Converta o string \ldblquote 8. 63582\rdblquote  para doubie e imprima o valor. \line g) Determine se o valor de c \'e9 uma letra. Use o operador condicional para imprimir \ldblquote\'e9 uma \ldblquote  ou \ldblquote n\'e3o \'e9 uma quando o resultado for exibido. \line h) Atribua a ptr a posi\'e7\'e3o da primeira ocorr\'eancia de s2 em si. \line i) Determine se o valor da vari\'e1vel c \'e9 um caractere impr\'edmivel. Use o operador condicional para imprimir \ldblquote\'e9 um ou \ldblquote n\'e3o \'e9 um\rdblquote  quando o resultado for exibido. \line j) Atribua a ptr a posi\'e7\'e3o da primeira ocorr\'eancia em si de qualquer caractere de s2. \line k) Atribua a ptr a posi\'e7\'e3o da primeira ocorr\'eancia de c em si. \line 1) Converta o string \ldblquote - 21\rdblquote  para int e imprima o valor. \par
CAP\'cdTULO 16 - BIT5, CARACTERES, STRJNGS E ESTRUTURAS 849 \line Respostas aos exerc\'edcios de auto-revis\'e3o \line 16.1 a) estrutura. b) AND(&) sobre bits. c) membros. d) OR inclusivo (1) sobre bits. e) struct. f) typedef. g) OR exclusivo (A) sobre bits. h) m\'e1scara. i) identificador. j) membro de estrutura (.), ponteiro de estrutura (- \line >). k) operador de deslocamento \'e0 esquerda (\'ab), operador de deslocamento \'e0 direita (\'bb). \line 16.2 a) Falso. Uma estrutura pode conter muitos tipos de dados. \line b) Falso. Os membros de estruturas separadas podem ter os mesmos nomes, mas os membros da mesma estrutura deve ter nomes \'fanicos. \line e) Falso. typedef \'e9 usado para definir nomes alternativos para tipos de dados previamente definidos. \line d) Falso. As estruturas s\'e3o sempre passadas para fun\'e7\'f5es por chamadas por valor. \line 16.3 a) struct Part \line int partNumber; \line char partName[ 26 ]; \line b) typedef Part * PartPtr; \line e) Part a, b[ 10 ], *ptr; \line d) cm \'bb a.partNu!nber \'bb a.partNaxne; \line e) b[ 3 ] = a; \line f) ptr = \line g) cout \'ab ( ptr + 3 )->partNuriber \'ab \line\'ab ( ptr + 3 )->partName \'ab endi; \line 16.4 a) Erro: os par\'eanteses que deveriam incluir *cPtr foram omitidos, fazendo com que a ordem Ue avalia\'e7ao Ga expressao fique incorreta. \line b) Erro: o \'edndice do array foi omitido. A express\'e3o deveria ser hearts [ 10 ] . face. \line e) Erro: \'e9 necess\'e1rio um ponto-e-v\'edrgula para terminar uma defini\'e7\'e3o de estrutura. \line d) Erro: vari\'e1veis de diferentes tipos de estrutura n\'e3o podem ser atribu\'eddas umas \'e0s outras. \line 16.5 a) c = toupper( c ); \line b) cout \'ab \lquote\\\lquote\lquote  \'ab c \'ab \ldblquote\\\lquote  \line\'ab ( isdigit( c ) ? \ldblquote\'e9 um \ldblquote  \ldblquote n\'e3o \'e9 um \line\'ab \ldblquote d\'edgito\rdblquote  \'ab endi; \line e) cout \'ab atol( \ldblquote 1234567\rdblquote  ) \'ab endi; \line d) cout \'ab \lquote\\\lquote\lquote  \'ab c \'ab \ldblquote\\\lquote  \line\'ab ( iscntrl ( e ) ? \ldblquote\'e9 um \ldblquote  : \ldblquote n\'e3o \'e9 um \line\'ab \ldblquote caractere de controle\rdblquote  \'ab endl; \line e) ptr = strrchr( si, c ); \line f) out \'ab atof( \ldblquote 8.63582\rdblquote  ) \'ab endi; \line g) cout \'ab \lquote\\\lquote\lquote  \'ab c \'ab \ldblquote\\\lquote  \line\'ab ( isalpha ( e ) ? \ldblquote\'e9 uma \ldblquote  : \ldblquote n\'e3o \'e9 uma \line\'ab \ldblquote letra\rdblquote  \'ab endi; \line h) ptr = strstr( si, s2 ); \line i) cout \'ab \lquote\\\lquote  \lquote  \'ab c \'ab \ldblquote\\\lquote  \line\'ab ( isprint( c ) ? \ldblquote\'e9 um \ldblquote : \lquote n\'e3o \'e9 um \line\'ab \ldblquote caractere imprim\'edvei\rdblquote  \'ab endi; \line j) ptr = strpbrk( si, s2 ); \line k) ptr = strchr( si, e \line 1) cout \'ab atoi( \ldblquote -21\rdblquote  ) \'ab endi; \line Exerc\'edcios \line 16.6 Forne\'e7a a defini\'e7\'e3o para cada uma das estruturas e uni\'f5es seguintes: \line a) Estrutura Inventory que cont\'e9m o array de caracteres partName [ 30 ]. o inteiro partNumber, o ponto flutuante price. o inteiro stock e o inteiro reorder. \line b) Uma estrutura chamada Endereco que cont\'e9m os arrays de caracteres enderecoNaRua [25 ], cidade [ 20 ]. estado[ 3] ecep[ 6]. \par
850 C++ COMO PROGRAMAR \par
e) Estrutura Estudante que cont\'e9m os arrays primeiroNome [ 15 e sobreNome [ 15 ], e a vari\'e1vel enderecoResidencial do tipo Endereco da parte (b). \line d) Estrutura Teste que cont\'e9m 16 campos de bits com comprimentos de 1 bit. Os nomes dos campos de bits s\'e3o as letras de a a p. \line 16.7 Considere as seguintes defini\'e7\'f5es de estrutura e declarn\'e7\'f5es de vari\'e1veis: \line struct \line Customer \{ \\\\ Cliente \line char lastName[ 15 1; \\\\ sobrenome \line char firstName[ 15 ]; \\\\ primeiro nome \line int customerNumber; \\\\ n\'famero do cliente \line struct \line char phoneNumber[ 11 ]; \\\\ n\'famero do telefone \line char address[ 50 ]; \\\\ endere\'e7o \line char city[ 15 ]; \\\\ cidade \line char state[ 3 ]; \\\\ estado \line char zipCode[ 6 1; \\\\ CEP \line personal; \\\\ dados pessoais \line\} customerRecord, *customerptr; \line customerPtr = &customerRecord; \line Escreva uma express\'e3o separada que acesse cada uma das seguintes partes dos membros da estrutura: \line a) Membro lastName da estrutura customerRecord. \line b) Membro las tName da estrutura apontada por customerPtr. \line c) Membro firstName da estrutura customerRecord. \line d) Membro firstName da estrutura apontada por customerPtr. \line e) Membro customerNumber da estrutura customerRecord. \line f) Membro customerNumber da estrutura apontada por customerPtr. \line g) Membro phoneNumber do membro personal da estrutura customerRecord. \line h) Membro phoneNuniber do membro personal da estrutura apontada por customerPtr. \line i) Membro address do membro personal da estrutura customerRecord. \line j) Membro adress do membro personal da estrutura apontada por customerPtr. \line k) Membro city de membro personal da estrutura customerRecord. \line 1) Membro city do membro personal da estrutura apontada por customerPtr. \line m) Membro state do membro personal da estrutura customerRecord. \line n) Membro state do membro personal da estrutura apontada por customerPtr. \line o) Membro zipcode do membro personal da estrutura customerRecord. \line p) Membro zipCode do membro personal da estrutura apontada por customerPtr. \line 16.8 Modifique o programa para embaralhamento de cartas da Fig. 16.14 usando uma fun\'e7\'e3o shuffle de alto desempenho \line comomostrado na Fig. 16.2. Imprima o baralho resultante em um formato de duas colunas, como na Fig. 16.3. Preceda cada carta com sua cor. \line 16.9 Escreva um programa que desloca para a direita uma vari\'e1vel inteira de 4 bits. O programa deve imprimir o inteiro em bin\'e1rio antes e depois da opera\'e7\'e3o de deslocamento. O seu sistema coloca zeros ou uns nos bits desocupados? \line 16.10 Se seu computador usa inteiros de 4 bytes, modifique o programa da Fig. 16.5 de forma que ele trabalhe com inteiros de \line 4 bytes. \line 16.11 Fazer um deslocamento \'e0 esquerda de um inteiro unsigned por 1 bit \'e9 equivalente a multiplicar o valor por 2. Escreva a fun\'e7\'e3o power2 que recebe dois argumentos inteiros number e pow e calcula \line nuniber * 2P0 \line Use um operador de deslocamento para calcular o resultado. O programa deve imprimir os valores como inteiros em decimal e \par
em bin\'e1rio. \par
CAP\'cdTULO 16 BITS, CARACTERES, STRJNGS E ESTRUTURAS 851 \line 16.12 O operador de deslocamento \'e0 esquerda pode ser usado para agrupar dois valores do tipo caractere em uma vari\'e1vel inteira uns igned de 2 bytes. Escreva um programa que recebe como entrada dois caracteres do teclado e passa-os para a fun\'e7\'e3o packCharacters. Para empacotar dois caracteres em uma vari\'e1vel inteira unsigned. atribua o primeiro caractere \'e0 vari\'e1vel unsigned, desloque a vari\'e1vel unsigned para a esquerda 8 posi\'e7\'f5es de bit e combine a vari\'e1vel unsigned com o segundo caractere usando o operador sobre bits 0k inclusivo. O programa deve exibir os caracteres em seu formato bin\'e1rio antes e depois de serem agrupados no inteiro unsigned, para provar que os caracteres foram de fato agrupados corretamente na vari\'e1vel uns igned. \line 16.13 Usando o operador de deslocamento \'e0 direita, o operador AND sobre bits e uma m\'e1scara, escreva a fun\'e7\'e3o unpackCharacters que recebe o inteiro unsigned do Exerc\'edcio 16.12 e desempacota o mesmo em dois caracteres. Para desempacotar dois caracteres de um inteiro de 2 bytes unsigned, combine o inteiro unsigned com a m\'e1scara 65280 (1111111100000000) e desloque o resultado 8 bits \'e0 direita. Atribua o valor resultante a uma vari\'e1vel char. Ent\'e3o, combine o inteiro unsigned com a m\'e1scara 255 (0000000011111111). Atribua o resultado a uma outra vari\'e1vel char. O programa deve imprimir o inteiro unsigned em bin\'e1rio antes de ser desempacotado e, ent\'e3o, imprimir os caracteres em bin\'e1rio para confirmar que eles foram corretamente desempacotados. \line 16.14 Se seu sistema usa inteiros de 4 bytes, rescreva o programa do Exerc\'edcio 16.12 para empacotar 4 caracteres. \line 16.15 Se seu sistema usa inteiros de 4 bytes, rescreva a fun\'e7\'e3o unpackCharacters do Exerc\'edcio 16.13 para desempacotar \line 4 caracteres. Crie as m\'e1scaras de que voc\'ea necessita para desempacotar os 4 caracteres fazendo um deslocamento \'e0 esquerda do \line valor 255 na vari\'e1vel m\'e1scara por 8 bits O, 1, 2, ou 3 vezes (dependendo do byte que voc\'ea est\'e1 desempacotando). \line 16.16 Escreva um programa que inverte a ordem dos bits em um valor inteiro unsigned. O programa deve receber como entrada o valor do usu\'e1rio e chamar a fun\'e7\'e3o reverseBits para imprimir os bits em ordem inversa. Imprima o valor em bin\'e1rio tanto antes como depois dos bits serem invertidos, para confirmar que os bits s\'e3o invertidos corretamente. \line 16.17 Escreva um programa que demonstre a passagem de um array por valor (dica: use uma struct). Prove que uma c\'f3pia foi passada modificando-se a c\'f3pia do array na fun\'e7\'e3o chamada. \line 16.18 Escreva um programa que l\'ea um caractere do teclado e testa o caractere com cada uma das fun\'e7\'f5es da biblioteca de manipula\'e7\'e3o de caracteres. O programa deve imprimir o valor retomado por cada fun\'e7\'e3o. \line 16.19 O programa seguinte usa a fun\'e7\'e3o multiple para determinar se o inteiro lido do teclado \'e9 um m\'faltiplo de algum inteiro X. Examine a fun\'e7\'e3o multiple e, ent\'e3o, determine o valor dcx. \line 1 /1 ex1619.cpp \line 2 // Este programa determina se um valor \'e9 um m\'faltiplo de X \line 3 #include <iostream> \line 4 \line 5 using std::cout; \line 6 using std::cin; \line 7 using std::endl; \line 8 \line 9 bool multiple( int ); \line 10 \line 11 int main() \line 12 \line 13 int y; \line 14 \line 15 cout \'ab \lquote Digite um inteiro entre 1 e 32000: ; \line 16 cm \'bb y; \line 17 \line 18 if ( multiple( y ) \line 19 cout \'ab y \'ab \ldblquote  \'e9 um m\'faltiplo de X\rdblquote  \'ab endl; \line 20 else \line 21 cout \'ab y \'ab n\'e3o \'e9 um m\'faltiplo de X\rdblquote  \'ab endl; \line 22 \line 23 return 0; \par
852 C++ COMO PROGRAMAR \line 24 \} \line 25 \line 26 bool multiple( int num \line 27 \{ \line 28 bool mult = true; \line 29 \line 30 for ( int i = 0, mask = 1; i < 10; i++, mask \'ab= 1 \line 31 if ( ( num & mask ) != O ) \{ \line 32 mult = false; \line 33 break; \line 34 ) \line 35 \line 36 return mult; \line 37 ) \line 16.20 O que faz o programa a seguir? \line 1 II ex1620.cpp \line 2 #include <iostream> \line 3 \line 4 using std: :cout; \line 5 using std::cin; \line 6 using std: :endl; \line 7 \line 8 int mystery( unsigned ); \line 9 \line 10 int main() \line 11 \{ \line 12 unsigned x; \line 13 \line 14 cout \'ab \ldblquote Digite um inteiro: \line 15 cm \'bb x; \line 16 cout \'ab \ldblquote O resultado \'e9 \ldblquote  \'ab mystery( x ) \'ab endl; \line 17 return 0; \line 18 \line 19 \line 20 int mystery( unsigned bits \line 21 \{ \line 22 const int SHIFT = 8 * sizeof( unsigned ) - 1; \line 23 const unsigned MASK = 1 \'ab SHIFT; \line 24 unsigned total = 0; \line 25 \line 26 for ( int i = 0; i < SHIFT + 1; i++, bits \'ab= 1 \line 27 if ( ( bits & MASK ) == MASK \line 28 ++total; \line 29 \line 30 return ! ( total % 2 ); \line 31 \line 16.21 Escreva um programa que l\'ea uma linha de texto com a fun\'e7\'e3o membro getline de istream (ver Cap\'edtulo 11) para o array de caracteres s [ 100 J. Imprima a linha em letras mai\'fasculas e letras min\'fasculas. \line 16.22 Escreva um programa que l\'ea quatro strings que representam inteiros, converte os strings em inteiros, soma os valores e imprime o total dos quatro valores. \par
CAP\'cdTULO 16 - BITs, CARACTERES, STRINGS E ESTRUTURAS 853 \line 16.23 Escreva um programa que l\'ea quatro strings que representam valores em ponto flutuante, converte os strings para valores double. soma os valores e imprime o total dos quatro valores. \line 16.24 Escreva um programa que l\'ea uma linha de texto e um string para busca pelo teclado. Usando a fun\'e7\'e3o strstr, localize a primeira ocorr\'eancia do string para busca na linha de texto e atribua esta posi\'e7\'e3o \'e0 vari\'e1vel searchPtr do tipo char*. Se o string para busca for encontrado, imprima o restante da linha de texto, come\'e7ando com o string para busca. Ent\'e3o, use strstr novamente para localizar a pr\'f3xima ocorr\'eancia do string para busca na linha de texto. Se uma segunda ocorr\'eancia for encontrada. imprima o restante da linha de texto come\'e7ando com a segunda ocorr\'eancia. (Dica: a segunda chamada de strstr deve conter searchPtr+1 como seu primeiro argumento). \line 16.25 Escreva um programa baseado no programa do Exerc\'edcio 16.24 que l\'ea v\'e1rias linhas de texto e um string para busca e usa a fun\'e7\'e3o strstr para determinar o n\'famero total de ocorr\'eancias do string nas linhas de texto. Imprima o resultado. \line 16.26 Escreva um programa que l\'ea v\'e1rias linhas de texto e um caractere de busca e usa a fun\'e7\'e3o strchr para determinar o n\'famero total de ocorr\'eancias do caractere nas linhas de texto. \line 16.27 Escreva um programa baseado no Exerc\'edcio 16.26 que l\'ea v\'e1rias linhas de texto e usa a fun\'e7\'e3o strchr para determinar o n\'famero total de ocorr\'eancias de cada letra do alfabeto no texto. Letras mai\'fasculas e min\'fasculas devem ser contadas juntas. Armazene os totais para cada letra em um array e imprima os valores em formato de tabela ap\'f3s terem sido determinados os totais. \line 16.28 A tabela no Ap\'eandice B mostra as representa\'e7\'f5es em c\'f3digos num\'e9ricos dos caracteres do conjunto ASCII de caracteres. Estude essa tabela e, ent\'e3o, diga qual das seguintes afirma\'e7\'f5es \'e9 verdadeira ou falsa. \line a) A letra \lquote A\rquote  vem antes da letra \ldblquote B\rdblquote . \line b) O d\'edgito \ldblquote 9\rdblquote  vem antes do d\'edgito \ldblquote O\rdblquote . \line e) Os s\'edmbolos comumente usados para adi\'e7\'e3o, subtra\'e7\'e3o, multiplica\'e7\'e3o e divis\'e3o v\'eam todos antes dos d\'edgitos. \line d) Os d\'edgitos v\'eam antes das letras. \line e) Se um programa de classifica\'e7\'e3o classifica strings em ordem ascendente, ent\'e3o o programa colocar\'e1 o s\'edmbolo para um par\'eantese \'e0 direita antes do s\'edmbolo para um par\'eantese \'e0 esquerda. \line 16.29 Escreva um programa que l\'ea uma s\'e9rie de strings e imprime somente aqueles strings come\'e7ando com a letra \ldblquote b\rdblquote . \line 16.30 Escreva um programa que l\'ea uma s\'e9rie de strings e imprime somente aqueles strings que terminam com as letras \ldblquote ADO\rdblquote . \line 16.31 Escreva um programa que l\'ea um c\'f3digo ASCII e imprime o caractere correspondente. Modifique este programa de maneira que ele gere todos os c\'f3digos de tr\'eas d\'edgitos poss\'edveis, no intervalo de 000 a 255, e tente imprimir os caracteres correspondentes. O que acontece quando este programa \'e9 executado? \line 16.32 Usando a tabela de caracteres ASCH do Ap\'eandice B como guia, escreva suas pr\'f3prias vers\'f5es das fun\'e7\'f5es de manipula\'e7\'e3o de caracteres da Fig. 16.16. \line 16.33 Escreva suas pr\'f3prias vers\'f5es das fun\'e7\'f5es da Fig. 16.20 para convers\'e3o de strings em n\'fameros. \line 16.24 Escreva suas vers\'f5es das fun\'e7\'f5es da Fig. 16.27 para pesquisa em strings. \line 16.35 Escreva suas pr\'f3prias vers\'f5es das fun\'e7\'f5es da Fig. 16.34 para manipula\'e7\'e3o de blocos de mem\'f3ria. \line 16.36 (Projeto:um verificador ortogr\'e1fico) Muitos pacotes de software para processamento de texto populares t\'eam verificadores ortogr\'e1ficos incorporados. Usamos recursos de verifica\'e7\'e3o ortogr\'e1fica na prepara\'e7\'e3o deste livro e descobrimos que, n\'e3o importando o cuidado que pens\'e1vamos ter usado na prepara\'e7\'e3o de um cap\'edtulo, o software sempre era capaz de encontrar mais alguns erros de ortografia al\'e9m dos que hav\'edamos descoberto manualmente. \line Neste projeto, \'e9-lhe pedido que voc\'ea desenvolva o seu pr\'f3prio utilit\'e1rio de verifica\'e7\'e3o ortogr\'e1fica. Fazemos sugest\'f5es \line para ajud\'e1-lo a come\'e7ar. Voc\'ea deve ent\'e3o pensar em adicionar mais recursos. Voc\'ea pode achar \'fatil usar um dicion\'e1rio computadorizado como fonte de palavras. \line Por que digitamos tantas palavras com erros de ortografia? Em alguns casos, simplesmente n\'e3o conhecemos a grafia correta e, assim, \ldblquote damos o chute que parace mais razo\'e1vel\rdblquote . Em alguns casos, trocamos duas letras (p. ex., \ldblquote pard\'e3o\rdblquote  em vez de \ldblquote padr\'e3o\rdblquote ). Algumas vezes, digitamos duas vezes a mesma letra acidentalmente (p. ex., \ldblquote dooce\rdblquote  em vez de \ldblquote doce\rdblquote ). Algumas vezes, tocamos uma tecla pr\'f3xima daquela que quer\'edamos (p. ex., \ldblquote anibers\'e1rio\rdblquote  em vez de \ldblquote anivers\'e1rio\rdblquote ). E assim por diante. \line Projete e implemente um programa de verifica\'e7\'e3o ortogr\'e1fica. O seu programa mant\'e9m um array wordList de strings \line de caracteres. Voc\'ea pode digitar estes strings ou obt\'ea-los de um dicion\'e1rio computadorizado. \line O seu programa solicita ao usu\'e1rio que forne\'e7a uma palavra. O programa ent\'e3o procura aquela palavra no array wordList. Se a palavra consta no array, o seu programa deve imprimir \ldblquote Palavra est\'e1 grafada corretamente\rdblquote . \par
854 C++ COMO PROGRAMAR \line Se a palavra n\'e3o consta no array, seu programa deve imprimir \ldblquote Palavra n\'e3o est\'e1 grafada corretamente\rdblquote . Ent\'e3o, seu programa deveria procurar outras palavras em wordList, uma das quais pode ser a palavra que o usu\'e1rio pretendia digitar. Por exemplo, voc\'ea pode tentar todas as trocas simples de letras adjacentes no teclado para descobrir que a palavra \ldblquote padr\'e3o\rdblquote  corresponde exatamente a uma das palavras em wordList. Naturalmente, isso implicaria que seu programa testasse todas as trocas simples, como \ldblquote apdr\'e3o\rdblquote , \ldblquote pdar\'e3o\rdblquote , \ldblquote pard\'e3o\rdblquote , \ldblquote pad\'e3ro\rdblquote  e \ldblquote padr\'e3o\rdblquote . Quando voc\'ea encontra uma nova palavra igual a uma em wordList, imprima aquela palavra em uma mensagem tal como \ldblquote Voc\'ea quis dizer \ldblquote padr\'e3o\rdblquote  ?\ldblquote . \line Implemente outros testes, tais como substituir cada letra duplicada por uma \'fanica letra e quaisquer outros testes que voc\'ea \line possa desenvolver para aumentar a utilidade do seu verificador ortogr\'e1fico. \par
\pard\lang1033\f1\fs20\par
}
 