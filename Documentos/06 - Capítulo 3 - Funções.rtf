{\rtf1\ansi\ansicpg1252\deff0\deflang1033{\fonttbl{\f0\froman\fprq2\fcharset0 Times New Roman;}{\f1\froman\fcharset0 Helvetica Narrow;}{\f2\froman\fcharset0 Helvetica, sans-serif;}{\f3\fmodern\fprq1\fcharset0 Courier;}{\f4\froman\fcharset0 Times New Roman;}}
\viewkind4\uc1\pard\sb100\sa240\lang2070\f0\fs24\par
\ul\b\f1\fs146 3 \ulnone\line\f0\fs68 Fun\'e7\'f5es \line\f2\fs22 Objetivos \line\b0\f0\fs20\bullet  Entender como construir programas modularmente a partir de pequenas partes chamadas fun\'e7\'f5es. \line\bullet  Ser capaz de criar novas fun\'e7\'f5es. \line\bullet  Entender os mecanismos usados para passar informa\'e7\'f5es entre fun\'e7\'f5es. \line\bullet  Apresentar t\'e9cnicas de simula\'e7\'e3o usando gera\'e7\'e3o aleat\'f3ria de n\'fameros. \line\bullet  Entender como a visibilidade dos identificadores limitada a regi\'f5es espec\'edficas dos programas. \line\bullet  Entender como escrever e usar fun\'e7\'f5es que chamam a si pr\'f3prias. \line\i\fs18 A forma nunca segue afun\'e7\'e3o. \line\i0\fs20 Louis Henri Suilivan \line\i\fs18 E pluribus unum. \line (Um composto por muitos.) \line\i0\fs20 Virgil \line\i\fs18 Chama o dia de ontem, faze com que o tempo atr\'e1s \line retorne. \line\i0\fs20 William Shakespeare \line\i\fs18 Richard II \line Chamem-me Ismael. \line\i0\fs20 Herman Melvilie \line\i\fs18 Moby Dick \i0\fs24\par
\i\fs18 Quando voc\'ea me chamar assim, sorria. \line\i0\fs20 Owen Wister \fs24\par
\b\f2 190 C++ \fs14 COMO PROGRAMAR \line\ul\fs30 Vis\'e3o Geral \ulnone\line\fs20 3.1 Introdu\'e7\'e3o \line 3.2 Componentes de programas em C+\'f7 \line 3.3 Fun\'e7\'f5es da biblioteca matem\'e1tica \line 3.4 Fun\'e7\'f5es \line 3.5 Defini\'e7\'f5es de fun\'e7\'f5es \line 3.6 Prot\'f3tipos de fun\'e7\'f5es \line 3.7 Arquivos de cabe\'e7alho \line 3.8 Gera\'e7\'e3o de n\'fameros aleat\'f3rios \line 3.9 Exemplo: um jogo de azar e apresentando \b0\fs18 enum \line\b\fs20 3.10 Classes de armazenamento \line 3.11 Regras de escopo \line 3.12 Recurs\'e3o \line 3.13 Exemplo usando recurs\'e3o: a s\'e9rie de Fibonacci \line 3.14 Recurs\'e3o \i versus \i0 itera\'e7\'e3o \line 3.15 Fun\'e7\'f5es com listas de par\'e2metros vazias \line 3.16 Fun\'e7\'f5es \i mime \line\i0 3.17 Refer\'eancias e par\'e2metros por refer\'eancia \line 3.18 Argumentos default \line 3.19 Operador un\'e1rio de resolu\'e7\'e3o de escopo \line 3.20 Sobrecarga de fun\'e7\'f5es \line 3.21 Gabaritos de fun\'e7\'f5es \line 3.22 (Estudo de caso opcional) Pensando em objetos: identificando \line os atributos de uma classe \line\b0\i\f0\fs18 Resumos Terminologia Erros comuns de programa\'e7\'e3o Boas pr\'e1ticas de programa\'e7\'e3o Dicas de desempenho Dicas de portabilidade Dicas de teste e depura \'e7\'e3o. Observa\'e7\'f5es de engenharia de software. Exerc\'edcios de auto-revis\'e3o \i0\f2\fs12 . \i\f0\fs18 Respostas dos exerc\'edcios de auto-revis\'e3o \i0\f2\fs12\bullet  \i\f0\fs18 Exerc\'edcios \line\b\i0\f2\fs24 3.1 Introdu\'e7\'e3o \line\b0\f0\fs18 A maioria dos programas de computador que resolvem problemas do mundo real s\'e3o muito maiores do que os programas apresentados nestes primeiros cap\'edtulos. A experi\'eancia tem mostrado que a melhor maneira de desenvolver e manter um programa grande \'e9 constru\'ed-lo a partir de pequenas partes ou componentes, sendo cada uma delas mais f\'e1cil de manipular que o programa original. Essa t\'e9cnica \'e9 chamada de \i dividir para conquistar. \i0 Este cap\'edtulo descreve os recursos da linguagem C++ que facilitam o projeto, a implementa\'e7\'e3o, a opera\'e7\'e3o e a manuten\'e7\'e3o de programas grandes. \line\b\f2\fs26 3.2 Componentes de programas em C++ \line\b0\f0\fs18 Os m\'f3dulos em C\'f7+ s\'e3o chamados de \i fun\'e7\'f5es \i0 e \i classes. \i0 Os programas em C++ s\'e3o escritos tipicamente combinando- se fun\'e7\'f5es novas que o programador escreve com \ldblquote fun\'e7\'f5es pr\'e9-empacotadas\rdblquote  dispon\'edveis na \i biblioteca padr\'e3o de C++ \i0 e combinando-se classes novas que o programador escreve com \ldblquote classes pr\'e9-empacotadas\rdblquote , dispon\'edveis em v\'e1rias bibliotecas de classes. Neste cap\'edtulo, vamos nos concentrar em fun\'e7\'f5es; discutiremos classes em detalhes a partir do Cap\'edtulo 6. \fs24\par
\b\f2\fs22 192 C++ \fs16 COMO PROGRAMAR \b0\f0\fs24\par
\f1\fs56 1 \line\fs86 1 \f0\fs24\par
\fs16 As \f2\fs18 fun\'e7\'f5es s\'e3o \f0\fs16 normalmente chamadas em um programa escrevendo-se o nome da fun\'e7\'e3o seguido pelo par\'eantese esquerdo, seguido pelo \i\fs18 argumento \i0\fs16 (ou uma lista de argumentos separados por v\'edrgulas) da fun\'e7\'e3o, seguido pelo par\'eantese direito. Por exemplo, um programador que desejasse calcular e imprimir a raiz quadrada de 900 \f2\fs8 . \f0\fs16 O poderia escrever \line cout \f2\fs24\'ab \f3\fs20 sqrt \b\f2\fs22 ( \b0\f0\fs16 900.0 ); \line Quando este comando \'e9 executado, a fun\'e7\'e3o sqrt da biblioteca matem\'e1tica \'e9 chamada para calcular a raiz quadra- dado n\'famero contido entre os par\'eanteses (900 \f2\fs8 . \f0\fs16 0). O n\'famero 900 .0 \'e9 o \i\fs18 argumento \i0\fs16 da fun\'e7\'e3o sqrt. O comando anterior imprimiria 30 \f2\fs8 . \f0\fs16 00. A fun\'e7\'e3o sqrt recebe um argumento do tipo double e retorna um resultado do tipo double. Todas as fun\'e7\'f5es da biblioteca matem\'e1tica retornam o tipo de dado double. Para usar as fun\'e7\'f5es da biblioteca matem\'e1tica, inclua o arquivo de cabe\'e7alho <cmath>. \line\i\fs18 Erro de comum programa\'e7\'e3o \f2 3.1 \line\f0 Esquecer de incluir o arquivo de cabe\'e7alho \i0\fs16 <cmath> \i\fs18 ao usar fun\'e7\'f5es da biblioteca matem\'e1tica \f2\'e9 \f0 um erro de sintaxe. Para cada fun\'e7\'e3o da biblioteca padr\'e3o usada em um programa deve ser inclu\'eddo um arquivo de cabe\'e7alho padr\'e3o. \line\i0\fs16 Os argumentos de fun\'e7\'f5es podem ser constantes, vari\'e1veis ou express\'f5es. Se cl \f2\fs12 = \f3\fs16 13 \f2\fs8 . \f3\fs20 0. d \f2\fs12 = \f3\fs20 3 \f2\fs8 . \f3\fs20 O e f \f2\fs12 = \i\fs18 4 \i0\fs8 . \f3\fs16 0. \f0 o comando \line\f3\fs20 cout \f2\fs24\'ab \f3\fs20 sqrt( cl \i\f2\fs18 + \i0\f3\fs16 d \f2\fs12 * \b\f3\fs16 f ); \line\b0\fs20 calcula e imprime a raiz quadrada de 13 \f2\fs8 . \b\f3\fs16 O + 3 \b0\f2\fs8 . \fs28 o \fs12 * \f0\fs16 4 \f2\fs28 o \fs12 = \f3\fs20 25 \f2\fs8 . \f3\fs20 0, ou seja, \f0\fs16 5 (porque C++ normalmente n\'e3o introduz zeros \i\fs18\'e0 \i0\f3\fs20 direita nem a casa decimal, em um \f0\fs16 n\'famero em \f3\fs20 ponto flutuante que n\'e3o tem parte fracion\'e1ria). \line\f0\fs16 Algumas fun\'e7\'f5es da biblioteca matem\'e1tica de C++ est\'e3o resumidas na Fig. 3.2. Na figura, as vari\'e1veis x e y s\'e3o do tipo double. \fs24\par
\f1\fs216 1 \f0\fs24\par
\b\f2\fs20 Fig. 3.2 \b0 Fun\'e7\'f5es comumente usadas da biblioteca matem\'e1tica. \f0\fs24\par
\pard\par
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1129\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4620\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx8381\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx8617\pard\intbl\b\f2\fs20 M\'e9todo \b0\f0\fs24\cell\b\f2\fs20 Descri\'e7\'e3o \b0\f0\fs24\cell\b\f2\fs20 Exemplo \b0\f0\fs24\cell\cell\fs20\row
\fs16\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1129\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4620\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx8381\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx8617\intbl ceil ( \b\f3 x \b0\f0 ) \fs24\cell\fs16 arredondax para o menor inteiro n\'e3o menorquex \fs24\cell\fs16 ceil ( \b\f3 9.2 ) \'e9 \b0\f0 10.0  ceil( -9.8 ) \i\f2\fs18\'e9 \i0\f0\fs16 -9.0 \fs24\cell\cell\fs20\row
\fs16\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1129\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4620\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx8381\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx8617\intbl cos ( \b\f2 x \b0\f0 ) \fs24\cell\fs16 co-seno trigonom\'e9trico de x (x em radianos) \fs24\cell\fs14 cos ( \b\f3\fs16 O \b0\f2\fs8 . \b\f3\fs16 O \b0\f0\fs14 ) \'e9 1. O \fs24\cell\cell\fs20\row
\fs16\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1129\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4620\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx8381\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx8617\intbl exp ( \b\f3 x \b0\f0 ) \fs24\cell\fs16 fun\'e7\'e3o exponencial e \fs24\cell\fs16 exp ( 1.0 ) \'e9 2 .71828 exp( 2.0 ) \'e9 \b\f3 7.38906 \b0\f0\fs24\cell\cell\fs20\row
\fs16\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1129\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4620\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx8381\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx8617\intbl fabs ( \b\f3 x ) \b0\f0\fs24\cell\fs16 valor absoluto de x \fs24\cell\fs16 fabs ( \b\f3 5. 1 ) \'e9 5 \b0\f2\fs8 . \b\f3\fs16 1  \b0\f0 fabs( 0.0 ) \'e9 \b\f3 0.0  \b0\f0 fabs( -8.76 ) \b\f3\'e9 8.76 \b0\f0\fs24\cell\cell\fs20\row
\fs16\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1129\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4620\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx8381\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx8617\intbl floor ( \b\f3 x \b0\f0 ) \fs24\cell\fs16 arredonda x para o maior inteiro n\'e3o maiorquex \fs24\cell\fs16 floor ( 9 .2 ) \b\f3\'e9 9 \b0\f0 .0 floor( -9.8 ) \b\f3\'e9 \b0\f0 -10.0 \fs24\cell\cell\fs20\row
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1129\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4620\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx8617\pard\intbl\b\f3\fs16 fmod( x, \b0\f0 y \fs24\cell\fs16 ) \f3 restodex/ycomon\'famerode \f0 ponto flutuante \fs24\cell\f3\fs16 fmod( 13.657, 2.333 \f0\fs18 ) \'e9 \b\f3\fs16 1.992 \b0\f0\fs24\cell\fs20\row
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1129\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4620\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx8381\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx8617\pard\intbl\b\f3\fs16 log \b0\f0 ( \b\f3 x \b0\f0 ) \fs24\cell\fs16 logaritmo natural de x (base \i\f2 e) \i0\f0\fs24\cell\b\f3\fs14 log \b0\f0\fs18 ( \b\f3\fs14 2 \b0\f2\fs8 . \b\f3\fs14 718282 \b0\f0\fs18 ) \b\f3\fs14\'e9 1 \b0\f2\fs8 . \b\f3\fs14 O log( 7.389056 \b0\f0\fs18 ) \'e9 \b\f3\fs14 2.0 \b0\f0\fs24\cell\cell\fs20\row
\fs16\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1129\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4620\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx8381\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx8617\intbl loglO ( \b\f3 x \b0\f0 ) \fs24\cell\fs16 logaritmo de x (base 10) \fs24\cell\fs14 10gb ( \b\f3\fs16 10 \b0\f2\fs8 . \f0\fs14 O ) \'e9 \b\f3\fs16 1 \b0\f2\fs8 . \b\f3\fs16 O \b0\f0\fs14 loglO( 100.0 ) \'e9 \b\f3\fs16 2.0 \b0\f0\fs24\cell\cell\fs20\row
\b\f3\fs16\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1129\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4620\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx8381\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx8617\intbl pow( x, y \b0\f0\fs18 ) \fs24\cell\fs18 x elevado \'e0 pot\'eancia dey \f2 (xY) \f0\fs24\cell\b\f3\fs16 pow( \f2\fs14 2, \f3\fs16 7 \b0\f0\fs18 ) \'e9 \b\f3\fs16 128 pow( 9, .5 \b0\f0\fs18 ) \b\f3\fs16\'e9 3 \b0\f0\fs24\cell\cell\fs20\row
\fs16\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1129\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4620\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx8381\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx8617\intbl sin ( \b\f3 x \b0\f0 ) \fs24\cell\fs16 seno trigonom\'e9trico dcx (x em radianos) \fs24\cell\fs16 sin ( \b\f3 0.0 \b0\f0 ) \'e9 \b\f3 O \b0\f0\fs24\cell\cell\fs20\row
\fs16\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1129\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4620\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx8381\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx8617\intbl sqrt( x ) \fs24\cell\fs18 raizquadradadex \fs24\cell\fs16 sqrt( 900.0 ) \b\f3\'e9 \b0\f0 30.0 sqrt( 9.0 ) \'e9 \b\f3 3.0 \b0\f0\fs24\cell\cell\fs20\row
\fs16\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1129\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4620\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx8381\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx8617\intbl tan ( \b\f2 x \b0\f0 ) \fs24\cell\fs16 tangente trigonom\'e9trica de x (x em radianos) \fs24\cell\fs14 tan ( \b\f3\fs16 O \b0\f2\fs8 . \b\f3\fs16 O \b0\f0\fs14 ) \'e9 \b\f3\fs16 O \b0\f0\fs24\cell\cell\fs20\row
\pard\fs24\par
\pard\sb100\sa240\b\f2\fs20 224 C++ \fs14 COMO PROGRAMAR \line\f3\fs16 12 int main() \line 13 \line 14 cout \'ab \ldblquote Digite o comprimento do lado do seu cubo: \line 15 \line 16 double side; \line 17 \line 18 cm \'bb side; \line 19 cout \'ab \lquote Volume do cubo com lado \line 20 \'ab side \'ab \b0\f2\fs8\ldblquote  \b\f0\fs18\'e9 \b0\f2\fs8\ldblquote  \b\f3\fs16\'ab cube( side \b0\f0\fs18 ) \b\f3\fs16\'ab endl; \line 21 \line 22 return 0; \line 23 \line Digite o comprimento do lado do seu cubo: \f0\fs18 3.5 \line\f3\fs16 Volume do cubo com lado 3.5 \'e9 42.875 \line\f2\fs20 Figura \f3\fs16 3.19 \b0\f2\fs20 Usando uma fun\'e7\'e3o \b\f0\fs18 inline \b0\f2\fs20 para calcular o volume de um cubo (parte 2 de 2). \line\b\fs26 3.17 Refer\'eancias e par\'e2metros por refer\'eancia \line\b0\f0\fs18 Duas maneiras de invocar fun\'e7\'f5es, em muitas linguagens de programa\'e7\'e3o, s\'e3o \i chamadas por valor \i0 e \i chamadas por refer\'eancia. \i0 Quando os argumentos s\'e3o passados atrav\'e9s de uma chamada por valor, \'e9 feita uma \i c\'f3pia \i0 do valor dos argumentos e a mesma \'e9 passada para a fun\'e7\'e3o chamada. Modifica\'e7\'f5es na c\'f3pia n\'e3o afetam o valor original da vari\'e1vel, na fun\'e7\'e3o que realizou a chamada. Quando um argumento \'e9 passado atrav\'e9s de uma chamada por refer\'eancia, a fun\'e7\'e3o chamadora permite que a fun\'e7\'e3o chamada realmente modifique o valor original da vari\'e1vel. Isso evita os \i efeitos colaterais \i0 acidentais que t\'e3o freq\'fcentemente atrapalham e retardam o desenvolvimento de sistemas corretos e confi\'e1veis de software. At\'e9 aqui, neste cap\'edtulo, os argumentos nos programas mostrados foram passados atrav\'e9s de chamadas por valor. \line\i Dica de desempenho 3.10 \line Uma desvantagem da chamada por valor \'e9 que, se um grande item de dados est\'e1 sendo passado, copiar \line esses dados pode consumir um tempo de processamento consider\'e1vel. \line\i0 Nesta se\'e7\'e3o, introduzimos \i par\'e2metros refer\'eancia \i0\f2\fs8 - \f0\fs18 o primeiro de dois modos que C++ oferece para executar uma chamada por refer\'eancia. Com uma chamada por refer\'eancia, a fun\'e7\'e3o que chama d\'e1 \'e0 fun\'e7\'e3o chamada a possibilidade de acessar e modificar os dados da fun\'e7\'e3o que chamou, caso a fun\'e7\'e3o chamada assim o queira. \line\i Dica de desempenho \b\fs20 3.11 \line\b0\fs18 Chamada por refer\'eancia \b\i0\'e9 \b0\i bom sob o ponto de vista do desempenho porque elimina o \i0 overhead \i de copiar \line grandes volumes de dados. \line Observa\'e7\'e3o de engenharia de software 3.18 \line\i0\f2\fs8 ______ \i\f0\fs18 Chamada por refer\'eancia pode diminuir a seguran\'e7a porque afun\'e7\'e3o chamada pode corromper os dados da fun\'e7\'e3o que chamou. \line\i0 Agora, mostraremos como obter as vantagens de desempenho de uma chamada por valor ao mesmo tempo que obtemos os benef\'edcios importantes, sob o ponto de vista da engenharia de software, da prote\'e7\'e3o dos dados da fun\'e7\'e3o que chamou de uma poss\'edvel corrup\'e7\'e3o. \line Um par\'e2metro passado por refer\'eancia \'e9 um \i alias \i0 do seu argumento correspondente. Para indicar que um par\'e2metro \line\'e9 passado por refer\'eancia, simplesmente coloque um \ldblquote e comercial\rdblquote  (&) depois do tipo do par\'e2metro, no prot\'f3tipo da fun\'e7\'e3o; use a mesma conven\'e7\'e3o quando listar o tipo do par\'e2metro no cabe\'e7alho da fun\'e7\'e3o. Por exemplo, a declara\'e7\'e3o \line int &count \fs24\par
\fs18 CAPITULO 3 \f2\fs8 - \f0\fs18 FUN\'c7\'d5ES 223 \line Agora que estamos discutindo a omiss\'e3o de algumas coisas, deve ser observado que a fun\'e7\'e3o definida em um arquivo antes de qualquer chamada \'e0 fun\'e7\'e3o n\'e3o requer um prot\'f3tipo de fun\'e7\'e3o separado. Neste caso, o cabe\'e7alho da fun\'e7\'e3o funciona como o prot\'f3tipo da fun\'e7\'e3o. \line\b\i\fs20 Erro comum de programa\'e7\'e3o 3.25 \line A \b0\fs18 menos que sejam fornecidos prot\'f3tipos de fun\'e7\'e3o para todas as fun\'e7\'f5es ou, ent\'e3o, que cada fun\'e7\'e3o seja \line definida antes de ser usada, os programas em C+ \i0 + \i n\'e3o s\'e3o compilados. \line\b\i0\f2\fs24 3.16 \i\fs26 Fun\'e7\'f5es mime \line\b0\i0\f0\fs18 Implementar um programa como um conjunto de fun\'e7\'f5es \'e9 bom sob o ponto de vista de engenharia de software, mas chamadas a fun\'e7\'f5es envolvem um \i overhead \i0 durante a execu\'e7\'e3o. C++ prov\'ea \i fun\'e7\'f5es mIme \i0 para ajudar a reduzir o \i overheadda \i0 chamada a uma fun\'e7\'e3o, especialmente para pequenas fun\'e7\'f5es. O qualificador mime antes do tipo de retorno da fun\'e7\'e3o na defini\'e7\'e3o da fun\'e7\'e3o \ldblquote aconselha\rdblquote  o compilador a gerar uma c\'f3pia do c\'f3digo da fun\'e7\'e3o no pr\'f3prio local (quando apropriado), para evitar uma chamada de fun\'e7\'e3o. A desvantagem \'e9 que m\'faltiplas c\'f3pias da fun\'e7\'e3o s\'e3o inseridas no programa (tornando, assim, o programa maior) em vez de ter uma \'fanica c\'f3pia da fun\'e7\'e3o para a qual o controle \'e9 passado cada vez que \'e9 chamada a fun\'e7\'e3o. O compilador pode ignorar o qualificador mime e, normalmente, faz isto para todas as fun\'e7\'f5es, exceto as menores. \line\b\i\fs20 Observa\'e7\'e3o de engenharia de software 3.16 \line\b0\fs18 Qualquer mudan\'e7a em uma em uma fun\'e7\'e3o \i0\fs24 mime \i\fs18 pode exigir que todos os clientes da fun\'e7\'e3o sejam recompilados. Isso pode ser relevante em algumas situa\'e7\'f5es de desenvolvimento e manuten\'e7\'e3o de programas. \line\b\fs20 Boa pr\'e1tica de programa\'e7\'e3o 3.11 \line\b0\fs18 O qualificador \i0\fs24 mime \i\fs18 deveria ser usado somente com fun\'e7\'f5es pequenas, freq\'fcentemente usadas. \line\b\fs20 Dica de desempenho 3.9 \line\b0\i0\f2\fs30 f \i\f0\fs18 Usar fun\'e7\'f5es \i0\fs24 mime \i\fs18 pode reduzir o tempo de execu\'e7\'e3o, mas pode aumentar o tamanho do programa. \line\i0 A Fig. 3.19 usa a fun\'e7\'e3o \i\fs24 mime \i0\fs18 cube para calcular o volume de um cubo de lado s. A palavra-chave cons t na lista \line de par\'e2metros da fun\'e7\'e3o cube diz ao compilador que a fun\'e7\'e3o n\'e3o modifica a vari\'e1vel s. Isto garante que o valor de \line s n\'e3o seja alterado pela fun\'e7\'e3o quando o c\'e1lculo \'e9 executado. A palavra-chave const \'e9 discutida em detalhes nos \line Cap\'edtulos 4, 5 e 7. \line\i Observa\'e7\'e3o de engenharia de software 3.17 \line\i0\f2\fs8 ______ \i\f0\fs18 Muitos programadores n\'e3o se preocupam em declarar par\'e2metros passados por valor como \i0 const, \i ainda que a fun\'e7\'e3o chamada n\'e3o deva modificar o argumento passado. A palavra-chave \i0 const \i est\'e1 \line somente protegendo uma c\'f3pia do argumento original, n\'e3o o pr\'f3prio argumento original. \i0\fs24\par
\b\f2\fs18 Fig. 3.19 \b0 Usando \f0\fs20 uma \f2\fs18 fun\'e7\'e3o \f0 mime \f2 para calcular o volume de um cubo (parte 1 de 2). \f0\fs24\par
\pard\par
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx301\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4413\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4795\pard\intbl\b\f3\fs16 1 \b0\f0\fs24\cell\b\i\fs20 II \i0\f3\fs16 Fig. 3.19: figO3l9.cpp \b0\f0\fs24\cell\cell\fs20\row
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx301\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4795\pard\intbl\b\f3\fs16 2 \b0\f0\fs24\cell\b\i\fs20 II \i0\f3\fs16 Usando \b0\f0 uma \b\f3 fun\'e7\'e3o mime para calcular \b0\f0\fs24\cell\fs20\row
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx301\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4413\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4795\pard\intbl\b\f3\fs16 3 \b0\f0\fs24\cell\fs20 // \b\f3\fs16 o volume de um \b0\f0 cubo. \fs24\cell\cell\fs20\row
\b\f3\fs16\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx301\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4413\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4795\intbl 4 \b0\f0\fs24\cell\b\f3\fs16 #include <iostreain> \b0\f0\fs24\cell\cell\fs20\row
\fs18\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx301\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4413\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4795\intbl 5 \fs24\cell\cell\cell\fs20\row
\b\f3\fs16\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx301\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4413\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4795\intbl 6 \b0\f0\fs24\cell\b\f3\fs16 using std::cout; \b0\f0\fs24\cell\cell\fs20\row
\b\f3\fs16\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx301\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4413\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4795\intbl 7 \b0\f0\fs24\cell\b\f3\fs16 using std::cin; \b0\f0\fs24\cell\cell\fs20\row
\b\f3\fs16\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx301\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4413\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4795\intbl 8 \b0\f0\fs24\cell\b\f3\fs16 using std::endi; \b0\f0\fs24\cell\cell\fs20\row
\b\f3\fs16\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx301\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4413\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4795\intbl 9 \b0\f0\fs24\cell\cell\cell\fs20\row
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx301\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4795\pard\intbl\b\f3\fs16 10 \b0\f0\fs24\cell\b\f3\fs14 mime doubie cube( const double s \b0\f0\fs20 ) \{ \b\f3\fs14 return s \b0\f2\fs10 * \b\f3\fs14 s \b0\f2\fs10 * \b\f3\fs14 s;  \b0\f2\fs8\lquote  \f0\fs24\cell\fs20\row
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4795\pard\intbl\b\f3\fs16 11 \b0\f0\fs24\cell\fs20\row
\pard\fs24\par
\pard\sb100\sa240\fs18 222 C++ COMO PROGRAMAR \line\b\f2\fs26 3.15 Fun\'e7\'f5es com listas de par\'e2metros vazias \line\b0\f0\fs18 Em C++, uma listas de par\'e2metros vazia \i\fs20\'e9 \i0 especificada escrevendo-se \b\f3\fs16 void. \b0\f0\fs20 ou simplesmente nada, entre os par\'eanteses. A declara\'e7\'e3o \line void print \line especifica que a fun\'e7\'e3o print n\'e3o recebe quaisquer argumentos e n\'e3o retorna um valor. A Fig. 3.18 mostra as duas maneiras de declarar e usar, em C++, fun\'e7\'f5es que n\'e3o recebem argumentos. \line\b\f3\fs16 1 \b0\i\f0\fs20 II \b\i0\f3\fs16 Fig. 3.18: \b0\f0\fs18 figO3l8.cpp \line\b\f3\fs16 2 \b0\i\f0\fs20 II \b\i0\f3\fs16 Fun\'e7\'f5es \b0\f0\fs18 que \b\f3\fs16 n\'e3o recebem argumentos \line 3 #include <iostreain> \line 4 \line 5 using std: :cout; \line 6 us\'b1ng std: :endl; \line 7 \line 8 void functionlQ; \line 9 void function2 \b0\f0\fs18 ( \b\f3\fs16 void ); \line 10 \line 11 int main \b0\f0\fs18 O \line\b\f3\fs16 12 \line 13 functionlO; \line 14 function2O; \line 15 \line 16 return 0; \line 17 \line 18 \line 19 void functionl() \line 20 \line 21 cout \'ab \ldblquote functionl n\'e3o recebe argumentos\rdblquote  \'ab endl; \line 22 \line 23 \line 24 void function2( void \line 25 \line 26 cout \'ab \ldblquote function2 \b0\f0\fs14 tamb\'e9m n\'e3o recebe argumentos\rdblquote  \'ab \b\f3\fs16 endl; \line 27 \b0\f0\fs24\par
\b\f2\fs18 Fig. 3.18 \b0\f0\fs20 Duas maneiras \f2 de declarar e usar fun\'e7\'f5es que n\'e3o recebem argumentos. \line\i\f0\fs18 Boa pr\'e1tica de programa\'e7\'e3o 3.10 \line Sempre inclua prot\'f3tipos de fun\'e7\'e3o, ainda que seja poss\'edvel omiti-los quando as fun\'e7\'f5es s\'e3o definidas antes que sejam usadas. Incluir os prot\'f3tipos evita amarrar o c\'f3digo \'e0 ordem na qual as fun\'e7\'f5es s\'e3o definidas (que pode facilmente mudar \'e0 medida que um programa evolui). \line Dica de portabilidade 3.3 \line\i0\f2\fs8 _____ \i\f0\fs18 O significado de uma lista de par\'e2metros de fun\'e7\'e3o vazia em C++ \'e9 completamente diferente do que em C. Em C, significa que toda a verifica\'e7\'e3o de argumentos \'e9 desativada (i.e., a chamada dafirn\'e7\'e3o pode passar quaisquer argumentos que queira). Em C++, significa que afun\'e7\'e3o n\'e3o recebe argumentos. Assim, a compila\'e7\'e3o em C+ \i0\fs14 + \i\fs18 de programas escritos em C que usam este recurso pode acusar erros de sintaxe. \i0\fs24\par
\pard\par
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx973\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2150\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx3892\pard\intbl\b\f3\fs16 functionl \b0\f0\fs24\cell\b\f3\fs16 n\'e3o recebe \b0\f0\fs24\cell\b\f3\fs16 argumentos \b0\f0\fs24\cell\fs20\row
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx973\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2150\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2836\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx3892\pard\intbl\fs18 furzction2 \fs24\cell\fs18 tamb\'e9m n\'e3o \fs24\cell\fs18 recebe \fs24\cell\fs18 argumentos \fs24\cell\fs20\row
\pard\fs24\par
\pard\sb100\sa240\fs16 CAP\'cdTULO 3 \f2\fs8 - \f0\fs16 FUN\'c7\'d5ES \f2\fs22 221 \f0\fs24\par
\b\f2\fs20 Fig. 3.17 Resumo dos exemplos e \b0 exerc\'edcios sobre recurs\'e3o no livro. \line\f0\fs16 Vamos reiterar algumas observa\'e7\'f5es que fazemos repetidamente ao longo do livro. A boa engenharia de software \'e9 importante. O desempenho elevado \'e9 importante. Infelizmente, estes objetivos freq\'fcentemente s\'e3o conflitantes. A boa engenharia de software \'e9 fundamental para tornar administr\'e1vel a tarefa de desenvolvimento dos sistemas de software maiores e mais complexos de que necessitamos. Um alto desempenho destes sistemas \'e9 fundamental para concretizar os sistemas do futuro, que exigir\'e3o capacidades de computa\'e7\'e3o do hardware cada vez maiores. Onde se encaixam as fun\'e7\'f5es neste cen\'e1rio? \line\i\fs18 Observa\'e7\'e3o de engenharia de software \b 3.15 \line\b0\i0\f2\fs8 ______ \i\f0\fs18 Funcionalizar programas de maneira clara e hier\'e1rquica promove a boa engenharia de software. Mas isso tem um pre\'e7o. \line\b Dica de desempenho 3.8 \line\b0\i0\f2\fs8 ______ \i\f0\fs18 Um programa muito dividido em fun\'e7\'f5es \i0\f2\fs8 - \i\f0\fs18 em compara\'e7\'e3o com um programa monol\'edtico, n\'e3o dividido em fun\'e7\'f5es (i.e., composto de um \'fanico m\'f3dulo) \i0\f2\fs8 - \i\f0\fs18 executa um n\'famero potencialmente maior de chamadas de fun\'e7\'f5es e isto consome tempo de execu\'e7\'e3o e espa\'e7o do(s) processador(es) de um computador Por\'e9m, programas monol\'edticos s\'e3o dif\'edceis de programai testa,\'e7 depuran manter e de acrescentar novas funcionalidades. \line\i0\fs16 Assim, divida seus programas em fun\'e7\'f5es de forma criteriosa, sempre tendo em mente o delicado equil\'edbrio entre desempenho e a boa engenharia de software. \fs24\par
\pard\par
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx964\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4970\pard\intbl\b\f2\fs20 Cap\'edtulo \b0\f0\fs24\cell\b\f2\fs20 Exemplos e exerc\'edcios de recurs\'e3o \b0\f0\fs24\cell\fs20\row
\i\fs18\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx964\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4970\intbl Cap\'edtulo 3 \i0\fs24\cell\fs18 Fun\'e7\'e3o fatorial  Fun\'e7\'e3o de Fibonacci  M\'e1ximo divisor comum  Soma de dois inteiros  Multiplica\'e7\'e3o de dois inteiros  Elevar um inteiro a uma pot\'eancia inteira  Torres de Han\'f3i  Imprimir dados udos do teclado na ordem inversa  Visualizar a recurs\'e3o \fs24\cell\fs20\row
\i\fs18\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx964\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4970\intbl Cap\'edtulo 4 \i0\fs24\cell\fs18 Soma dos elementos de um array  Imprimir um array  Imprimir um array na ordem inversa  Imprimir um \i string \i0 na ordem inversa  Verificar se um \i string \b\'e9 \b0\i0 um pal\'edndromo  Valor m\'ednimo em um array  Classifica\'e7\'e3o seletiva (\ldblquote sort de sele\'e7\'e3o\rdblquote )  \i Eight Queens \i0 (\ldblquote Oito Damas\rdblquote )  Pesquisa linear  Pesquisa bin\'e1ria \fs24\cell\fs20\row
\b\i\fs18\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx964\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4970\intbl Cap\'edtulo 5 \b0\i0\fs24\cell\b\i\fs18 Quicksort  \b0\i0 Percorrer um labirinto  Imprimir na ordem inversa um \i string \i0 lido do teclado \fs24\cell\fs20\row
\i\fs18\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx964\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4970\intbl Cap\'edtulo \b 15 \b0\i0\fs24\cell\fs18 Inser\'e7\'e3o em uma lista encadeada  Exclus\'e3o de uma lista encadeada  Pesquisa em uma lista encadeada  Imprimir uma lista encadeada na ordem inversa  Inser\'e7\'e3o em uma \'e1rvore bin\'e1ria  Percorrer uma \'e1rvore bin\'e1ria no modo \i preorder  \i0 Percorrer uma \'e1rvore bin\'e1ria no modo \i morder  \i0 Percorrer uma \'e1rvore bin\'e1ria no modo \i postorder \i0\fs24\cell\fs20\row
\pard\fs24\par
\pard\sb100\sa240\fs18 220 \b\fs20 C++ \f2\fs16 COMO \f0\fs14 PROGRAMAR \line\b0\fs18 chamadas, ou seja, o n\'famero de chamadas recursivas que ser\'e3o executadas para calcular o n-\'e9simo n\'famero de Fibonacci \'e9 da ordem de 2\rquote . Isso foge rapidamente do controle. Calcular apenas o 20\'b0 n\'famero de Fibonacci exigiria na ordem de 220 ou cerca de um milh\'e3o de chamadas, calcular o \b\fs14 300 \b0\fs18 n\'famero de Fibonacci exigiria na ordem de 2\'b0 ou cerca de um bilh\'e3o de chamadas, e assim por diante. Os cientistas da computa\'e7\'e3o chamam isso de \i\fs20 complexidade exponencial. \i0\fs18 Problemas dessa natureza humi Iham at\'e9 mesmo os computadores mais poderosos! Quest\'f5es de complexidade em geral e complexidade exponencial em particular s\'e3o analisados detalhadamente em uma disciplina avan\'e7ada de Ci\'eancia da Computa\'e7\'e3o chamada \ldblquote Complexidade de algoritmos\rdblquote . \line\i Dica de desempenho 3.6 \line\ul\i0\f2\fs32 f \i\f0\fs18 .z \ulnone Evite programas recursivos semelhantes ao da fun\'e7\'e3o \i0 fibonacci \i que resultem em uma \ldblquote explos\'e3o\rdblquote  exponencial de chamadas. \line\b\i0\f2\fs26 3.14 Recurs\'e3o \i versus \i0 itera\'e7\'e3o \line\b0\f0\fs18 Nas se\'e7\'f5es anteriores, estudamos duas fun\'e7\'f5es que podem ser facilmente implementadas, tanto de uma maneira recursiva como iterativa. Nesta se\'e7\'e3o, comparamos os dois m\'e9todos e analisamos os motivos que levam o programador a escolher um m\'e9todo em detrimento do outro para uma determinada situa\'e7\'e3o. \line Tanto a itera\'e7\'e3o como a recurs\'e3o se baseiam em uma estrutura de controle; a itera\'e7\'e3o usa uma estrutura de repeti\'e7\'e3o; a recurs\'e3o usa uma estrutura de sele\'e7\'e3o. Tanto a itera\'e7\'e3o como a recurs\'e3o envolvem repeti\'e7\'f5es: a itera\'e7\'e3o usa explicitamente uma estrutura de repeti\'e7\'e3o; a recurs\'e3o obt\'e9m repeti\'e7\'e3o por interm\'e9dio de chamadas repetidas de fun\'e7\'f5es. A itera\'e7\'e3o e a recurs\'e3o envolvem um teste de encerramento: a itera\'e7\'e3o termina quando uma condi\'e7\'e3o de continua\'e7\'e3o do la\'e7o se torna falsa; a recurs\'e3o termina quando um caso b\'e1sico \'e9 reconhecido. Tanto a itera\'e7\'e3o com repeti\'e7\'e3o controlada por contador quanto a recurs\'e3o chegam gradualmente ao fim: a itera\'e7\'e3o fica modificando um contador at\'e9 que ele assuma um valor que fa\'e7a a condi\'e7\'e3o de continua\'e7\'e3o do la\'e7o se tomar falsa; a recurs\'e3o fica produzindo vers\'f5es mais simples do problema original at\'e9 chegar ao caso b\'e1sico. Tanto a itera\'e7\'e3o como a recurs\'e3o podem ocorrer infinitamente: ocorre um la\'e7o infinito com a itera\'e7\'e3o se o teste de continua\'e7\'e3o do la\'e7o nunca se tomar falso; ocorre um la\'e7o infinito com a recurs\'e3o se a etapa de recurs\'e3o n\'e3o reduzir gradualmente o problema de forma que ele convirja para o caso b\'e1sico. \line A recurs\'e3o apresenta muitos aspectos negativos. Ela usa repeticlamente o mecanismo e, em conseq\'fc\'eancia, o \i overhead, \i0 de chamada de fun\'e7\'f5es. Isso pode custar caro, tanto em tempo do processador como em espa\'e7o de mem\'f3ria. Cada chamada recursiva faz com que outra c\'f3pia da fun\'e7\'e3o (na realidade, apenas as vari\'e1veis da fun\'e7\'e3o) seja criada; isso pode consumir mem\'f3ria de forma consider\'e1vel. Normalmente, a itera\'e7\'e3o ocorre dentro de uma fun\'e7\'e3o, e assim, o \i overhead \i0 de repetidas chamadas de fun\'e7\'f5es e a aloca\'e7\'e3o de mais mem\'f3ria n\'e3o existe. Ent\'e3o, por que escolher a recurs\'e3o? \line\i\fs20 Observa\'e7\'e3o de engenharia de software \b 3.14 \line\b0\i0\f2\fs8 _______ \i\f0\fs18 Qualquer problema que pode ser resolvido recursivamente tamb\'e9m pode ser resolvido interativamente (n\'e3o recursivamente). Uma abordagem recursiva \'e9 escolhida em detrimento de uma abordagem iterativa, quando ela reflete o problema de modo mais natural, resultando em programa mais f\'e1cil de compreender e depurar Outra raz\'e3o para se optar por uma solu\'e7\'e3o recursiva \'e9 quando uma solu\'e7\'e3o iterativa n\'e3o \'e9 f\'e1cil de ser encontrada. \line\b\fs20 Dica de desempenho 3.7 \line\b0\i0\f2\fs8 ______ \i\f0\fs18 Evite usar a recurs\'e3o em situa\'e7\'f5es que exigem um alto desempenho. Chamadas recursivas consomem tempo e exigem mais mem\'f3ria. \line Erro comum de \b\fs20 programa\'e7\'e3o \b0 3.24 \line Fazer uma fun\'e7\'e3o n\'e3o-recursiva chamar acidentalmente a si mesma, tanto direta como indiretamente \line (atrav\'e9s de outra fun\'e7\'e3o), \'e9 um erro de l\'f3gica. \line\i0\fs18 A maioria dos livros sobre programa\'e7\'e3o introduzem a recurs\'e3o muito mais \'e0 frente do que fizemos neste. Achamos que a recurs\'e3o \'e9 um t\'f3pico t\'e3o rico e complexo que \'e9 melhor ser apresentado mais cedo e espalhar os exemplos pelo restante do texto. A Fig. 3.17 apresenta um resumo dos exemplos e exerc\'edcios de recurs\'e3o neste livro. \fs24\par
\b\f2\fs16 CAP\'cdTULO \b0\fs20 3 \fs8 - \b\fs16 FUN\'c7\'d5ES \f0\fs22 219 \b0\fs24\par
\fs18 a chamada original a fibonacci. A Fig. 3.16 mostra como a fun\'e7\'e3o fibonacci calcularia fibonacci (3) \f2\fs8 - \f0\fs18 abreviamos fibonacci simplesmente como f para tornar a figura mais leg\'edvel. \line Essa figura traz \'e0 tona algumas quest\'f5es interessantes sobre a ordem na qual os compiladores da linguagem \b\fs22 C++ \b0\fs18 calcular\'e3o os operandos dos operadores. Essa \'e9 uma quest\'e3o diferente da ordem na qual os operadores s\'e3o aplicados a seus operandos, ou seja, a ordem estabelecida pelas regras de preced\'eancia entre operadores. Na Fig. 3.16. parece que. ao calcular f ( 3 \b\fs22 ) \b0\f2\fs8 . \f0\fs18 ser\'e3o feitas duas chamadas recursivas. a saber. f \b\fs22 ( \b0\fs18 2 \b\fs22 ) \b0\fs18 e f ( 1 \b\fs22 ). \b0\fs18 Mas, em que ordem ser\'e3o feitas essas chamadas? \fs24\par
\b\f2\fs20 Fig \b0\fs18 3.16 Conjunto de chamadas recursivas \'e0 fun\'e7\'e3o \b\fs16 fibonacci. \b0\f0\fs24\par
\fs18 A maioria dos programadores simplesmente considera que os operandos ser\'e3o calculados da esquerda para a direita. Estranhamente, a liguagem C++ n\'e3o especifica a ordem na qual os operandos da maioria dos operadores (incluindo +) devem ser calculados. Portanto, o programador n\'e3o pode presumir a ordem na qual ser\'e3o feitas essas chamadas. Na realidade, poderia ser executada inicialmente a chamada para f \b\fs22 ( \b0\fs18 2 \b\fs22 ) \b0\fs18 e depois a chamada para f \b\fs22 ( \b0\fs18 1 \b\fs22 ) \b0\f2\fs8 , \f0\fs18 ou as chamadas poderiam ser executadas na ordem inversa. Neste programa e na maioria dos outros programas, o resultado final seria o mesmo. Mas, em alguns programas, o c\'e1lculo de um operando pode causar \i efeitos colaterais \i0 que poderiam afetar o resultado final da express\'e3o. \line A linguagem C++ especifica a ordem de avalia\'e7\'e3o de somente quatro operadores, a saber: \b\f2\fs16 &&, \b0\fs8 , \f0\fs18 o operador v\'edrgula \b\fs22 (,) \b0\fs18 e ?: Os tr\'eas primeiros s\'e3o operadores bin\'e1rios, cujos dois operandos, com certeza, s\'e3o avaliados da esquerda para a direita. O \'faltimo operador \'e9 o \'fanico operador tern\'e1rio de C++. Seu operando da extremidade esquerda \'e9 sempre avaliado em primeiro lugar: se o operando da extremidade esquerda levar a um valor diferente de zero, o operando do meio \'e9 avaliado a seguir e o \'faltimo operando \'e9 ignorado; se o operando da extremidade esquerda levar ao valor zero, o operando da extremidade direita \'e9 avaliado a seguir e o operando do meio \'e9 ignorado. \fs24\par
\i\fs18 Erro comum de programa\'e7\'e3o 3.23 \i0\fs24\par
\i\fs18 Escrever programas que dependam da ordem de c\'e1lculo dos operandos de operadores diferentes de \b\i0\f2\fs16 &&, \b0\f0\fs20 1 \i\fs18 ?: e o operador v\'edrgula (,)pode levar a erros, porque os compiladores poderiam n\'e3o calcular necessariamente os operandos na ordem em que o programador espera. \i0\fs24\par
\i\fs16 Dica de portabilidade 3.2 \line\i0\f2\fs8 _____ \i\f0\fs16 Programas que dependem da ordem de c\'e1lculo de operandos de operadores diferentes de \b\i0 &&, \fs22 1 1,?: \b0\i\fs16 e o operador virgula (,)podem funcionar de modo distinto em sistemas com compiladores diferentes. \i0\fs24\par
\fs20 Uma palavra de advert\'eancia deve ser dita a respeito de programas recursivos, como o que usamos aqui para gerar os n\'fameros de Fibonacci. Cada n\'edvel de recurs\'e3o na fun\'e7\'e3o fibonacci tem um efeito de duplica\'e7\'e3o do n\'famero de \fs24\par
\fs18 returnf_( \b\f2\fs16 1 + f \b0\f0\fs18 ( O \line\f2\fs38\lquote Ir \fs8 _________ \line\f0\fs18 return \b\fs16 1 \b0\fs18 return O \fs24\par
\f2\fs22 21X C++ \fs16 COMO PROGRAMAR \f0\fs24\par
\f3\fs14 13 unsigned long result, number; \line 14 \line 15 cout \'ab \ldblquote Digite um inteiro: \line 16 cm \'bb nuxnber; \line 17 result \f2\fs10 = \f3\fs14 fibonacci \f2\fs22 ( \f3\fs14 nuxnber ); \line 18 cout \'ab \ldblquote Fibonacci (\ldblquote  \'ab number \f0\fs20\'ab \f2\fs14\ldblquote ) = \fs8\ldblquote  \f3\fs14\'ab result \'ab endi; \line 19 return 0; \line 20 \line 21 \line 22 \i\f2\fs20 II \i0\f3\fs14 Defini\'e7\'e3o recursiva da fun\'e7\'e3o fibonacci \line 23 unsigned long fibonacci( unsigned long n \line 24 \line 25 if \f2\fs22 ( \f3\fs14 n \f2\fs10 == \f3\fs14 O \f0\fs20 1 \f3\fs14 n \f2\fs10 == \f3\fs14 1 \f2\fs22 ) \i II \i0\f3\fs14 caso base \line 26 return n; \line 27 else \f2\fs22 // \f3\fs14 caso recursivo \line 28 return fibonacci( n \f2\fs8 - \f3\fs14 1 \f2\fs22 ) \f3\fs14 + fibonacci( n \f2\fs8 - \f3\fs14 2 ); \line 29 \f0\fs24\par
\f3\fs16 Digite um inteiro : 5 \line Fibonacci (5) \f2\fs10 = \f3\fs16 5 \line Digite um inteiro: 6 \line Fibonacci (6) \f2\fs10 = \f3\fs16 8 \line Digite um inteiro: 10 \line Fibonacci (10) 55 \line Digite um inteiro: 20 \line Fibonacci (20) \f2\fs10 = \f3\fs16 6765 \line Digite um inteiro: 30 \line Fibonacci (30) 832040 \line Digite um inteiro: 35 \line Fibonacci (35) \f2\fs10 = \f3\fs16 9227465 \line\f2\fs20 Fig. 3.15 Gerando os n\'fameros de Fibonacci recursivamente (parte 2 de 2). \line\f0\fs18 A chamada a fibonacci a partir de main n\'e3o \'e9 uma chamada recursiva, mas \f2\fs20 todas \f0\fs18 as chamadas \f2\fs20 subseq\'fcentes \f0\fs18 a \line fibonacci s\'e3o recursivas. Cada vez que fibonacci \'e9 chamada, o caso b\'e1sico \'e9 testado imediatamente \f2\fs8 - \f0\fs18 se n \line\'e9 igual a O ou 1. Se isso for verdadeiro, o valor de n \'e9 retornado. E interessante observar que, se n for maior do que \line 1, a etapa de recurs\'e3o gera \i duas \i0 chamadas recursivas, cada uma delas para um problema ligeiramente menor do que \fs24\par
\f2\fs10 a \f0\fs24\par
\pard\par
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx973\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2615\pard\intbl\f3\fs16 Digite um  Fibonacci \f0\fs24\cell\f3\fs14 inteiro: O (0) \f2\fs10 = \f3\fs14 O \f0\fs24\cell\fs20\row
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx973\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2215\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2615\pard\intbl\f3\fs16 Digite um  Fibonacci \f0\fs24\cell\f3\fs14 inteiro:  (1) \f2\fs10 = \f3\fs14 1 \f0\fs24\cell\f3\fs16 1 \f0\fs24\cell\fs20\row
\f3\fs16\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx973\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2215\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2615\intbl Digite um  Fibonacci \f0\fs24\cell\f3\fs14 inteiro :  (2) \f2\fs10 = \f3\fs14 1 \f0\fs24\cell\f3\fs16 2 \f0\fs24\cell\fs20\row
\f3\fs16\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx973\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2215\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2615\intbl Digite um  Fibonacci \f0\fs24\cell\f3\fs14 inteiro :  (3) \f2\fs10 = \f3\fs14 2 \f0\fs24\cell\f3\fs16 3 \f0\fs24\cell\fs20\row
\f3\fs16\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx973\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2215\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2615\intbl Digite um  Fibonacci \f0\fs24\cell\f3\fs14 inteiro :  (4) \f2\fs10 = \f3\fs14 3 \f0\fs24\cell\f3\fs16 4 \f0\fs24\cell\fs20\row
\pard\fs24\par
\pard\sb100\sa240\fs18 CAPITULO 3 \f2\fs8 - \f0\fs18 FUN\'c7\'d5ES \b\f2\fs22 217 \line\b0\f0\fs18 seja, a de que a linguagem n\'e3o \'e9 facilmente estendida para atender \'e0s exig\'eancias especiais de v\'e1rias aplica\'e7\'f5es. Como veremos na se\'e7\'e3o do livro dedicada \'e0 programa\'e7\'e3o orientada a objetos, C++ \'e9 uma linguagem extens\'edvel, que permite a cria\'e7\'e3o de inteiros arbitrariamente grandes, se assim desejarmos. \line\i Erro comum de programa\'e7\'e3o 3.21 \line Esquecer-se de retornar um valor de uma fun\'e7\'e3o recursiva, quando isto \'e9 necess\'e1rio, far\'e1 com que a \line maioria dos compiladores produza uma mensagem de advert\'eancia. \line Erro comum de programa\'e7\'e3o 3.22 \line Omitir o caso b\'e1sico, ou escrever incorretamente a etapa de recurs\'e3o, deforma que ela n\'e3o convirja para o caso b\'e1sico, ocasionar\'e1 uma recurs\'e3o infinita, o que pode eventualmente esgotar a mem\'f3ria. Isso \'e9 an\'e1logo ao problema de um la\'e7o infinito em uma solu\'e7\'e3o iterativa (n\'e3o-recursiva). A recurs\'e3o infinita tamb\'e9m pode ser causada pelo fornecimento de um dado incorreto de entrada. \line\b\i0\f2\fs26 3.13 Exemplo usando recurs\'e3o: a s\'e9rie de Fibonacci \line\b0\f0\fs18 A s\'e9rie de Fibonacci \line O, 1, 1,2, 3,5, 8, 13, 21, \line come\'e7a comO e 1 e tem a propriedade de que cada n\'famero subseq\'fcente de Fibonacci \'e9 a soma dos dois n\'fameros de Fibonacci anteriores. \line A s\'e9rie ocorre na natureza e, em particular, descreve uma forma de espiral. A raz\'e3o (rela\'e7\'e3o produzida pela divis\'e3o do maior, o sucessor, pelo menor, o predecessor imediato) dos n\'fameros sucessivos de Fibonacci converge para um valor constante de 1,618.... Esse n\'famero tamb\'e9m ocorre repetidamente na natureza e foi chamado de \i rela\'e7\'e3o \'e1urea \i0 ou \i propor\'e7\'e3o \'e1urea. \i0 As pessoas tendem a achar a rela\'e7\'e3o \'e1urea esteticamente agrad\'e1vel. Os arquitetos freq\'fcentemente \b\f3\fs16 projetam \b0\f0\fs18 janelas, quartos e edif\'edcios cujos comprimentos e larguras est\'e3o nas propor\'e7\'f5es da rela\'e7\'e3o \'e1urea. Muitas vezes, os cart\'f5es postais s\'e3o criados com propor\'e7\'f5es de altura/largura respeitando a rela\'e7\'e3o \'e1urea. \line A s\'e9rie de Fibonacci pode ser definida recursivamente como segue: \line\i flbonacci( O) \i0\f2\fs12 = \i\f0\fs18 O \line fibonacci( 1) =1 \line fibonacci( n) -flbonacci( n \i0\f2\fs8 - \i\f0\fs18 1) +flbonacci( n -2) \line\i0 O programa da Fig. 3.15 calcula recursivamente o \i i-\'e9simo \i0 n\'famero de Fibonacci usando a fun\'e7\'e3o fibonacci. Note que os n\'fameros de Fibonacci tendem a crescer rapidamente. Portanto, escolhemos o tipo de dados unsigned long para o tipo do par\'e2metro e do valor de retomo na fun\'e7\'e3o fibonacci. Na Fig. 3.15, cada par de linhas de sa\'edda mostra uma execu\'e7\'e3o distinta do programa. \fs24\par
\b\f2\fs18 Fig. 3.15 \b0 Gerando os n\'fameros de Fibonacci recursivamente (parte 1 de 2). \f0\fs24\par
\pard\par
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx301\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx3903\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4504\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4913\pard\intbl\b\f3\fs16 1 \b0\f0\fs24\cell\i\fs18 II \b\i0\f3\fs16 Fig. 3.15: figO3_15.cpp \b0\f0\fs24\cell\cell\cell\fs20\row
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx301\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2822\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx3903\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4504\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4913\pard\intbl\b\f3\fs16 2 \b0\f0\fs24\cell\b\i\f2\fs22 II \i0\f3\fs16 Fun\'e7\'e3o recursiva para \b0\f0\fs24\cell\b\f3\fs16 fibonacci \b0\f0\fs24\cell\cell\cell\fs20\row
\b\f3\fs16\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx301\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2822\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx3903\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4504\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4913\intbl 3 \b0\f0\fs24\cell\b\f3\fs16 #include <iostreaxn> \b0\f0\fs24\cell\cell\cell\cell\fs20\row
\b\f3\fs16\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx301\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2822\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx3903\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4504\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4913\intbl 4 \b0\f0\fs24\cell\cell\cell\cell\cell\fs20\row
\b\f3\fs16\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx301\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2822\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx3903\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4504\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4913\intbl 5 \b0\f0\fs24\cell\b\f3\fs16 using std: :cout; \b0\f0\fs24\cell\cell\cell\cell\fs20\row
\b\f3\fs16\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx301\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2822\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx3903\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4504\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4913\intbl 6 \b0\f0\fs24\cell\b\f3\fs16 using std::cin; \b0\f0\fs24\cell\cell\cell\cell\fs20\row
\b\f3\fs16\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx301\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2822\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx3903\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4504\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4913\intbl 7 \b0\f0\fs24\cell\b\f3\fs16 using std::endl; \b0\f0\fs24\cell\cell\cell\cell\fs20\row
\b\f3\fs16\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx301\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2822\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx3903\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4504\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4913\intbl 8 \b0\f0\fs24\cell\cell\cell\cell\cell\fs20\row
\b\f3\fs16\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx301\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2822\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx3903\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4504\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4913\intbl 9 \b0\f0\fs24\cell\b\f3\fs16 unsigned long fibonacci( \b0\f0\fs24\cell\b\f3\fs16 unsigned \b0\f0\fs24\cell\b\f3\fs16 long \b0\f0\fs24\cell\b\f3\fs16 ); \b0\f0\fs24\cell\fs20\row
\b\f3\fs16\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx301\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2822\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx3903\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4504\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4913\intbl 10 \b0\f0\fs24\cell\cell\cell\cell\cell\fs20\row
\b\f3\fs16\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx301\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2822\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx3903\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4504\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4913\intbl 11 \b0\f0\fs24\cell\b\f3\fs16 int main \b0\f0\fs20 O \fs24\cell\cell\cell\cell\fs20\row
\b\f3\fs16\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx301\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2822\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx3903\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4504\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4913\intbl 12 \b0\f0\fs24\cell\fs20\{ \fs24\cell\cell\cell\cell\fs20\row
\pard\fs24\par
\pard\sb100\sa240\b\f2\fs22 216 \b0\f0\fs18 C++ \b\fs12 COMO \f2\fs14 PROGRAMAR \line\f3\fs16 1 \b0\i\f2\fs20 II \b\i0\f3\fs16 Fig. 3.14: fig03_14.cpp \line 2 \b0\i\f2\fs20 /1 \b\i0\f3\fs16 Fun\'e7\'e3o recursiva para c\'e1lculo de fatoriais \line 3 #include <iostream> \line\f0\fs12 4 \line\f3\fs16 5 using std::cout; \line 6 using std: :endl; \line\f2\fs18 7 \line\f3\fs16 8 #include <iomanip> \line 9 \line 10 using std::setw; \line 11 \line 12 unsigned long factorial( unsigned long ); \line 13 \line 14 int main \f2\fs22 () \line\f3\fs16 15 \line 16 for \f2\fs22 ( \f3\fs16 int i \b0\f2\fs12 = \b\f3\fs16 0; i \f0\fs12 <= \f3\fs16 10; i++ \line 17 cout \'ab setw \f2\fs22 ( \f3\fs16 2 \f2\fs22 ) \b0\f0\fs18\'ab \b\fs12 i \b0\fs18\'ab \f2\fs12\ldblquote ! \b\f0 = \b0\f2\fs8\lquote  \b\f3\fs16\'ab factorial( i \f2\fs22 ) \b0\f0\fs18\'ab \b\f3\fs16 endl; \line 18 \line 19 return 0; \line 20 \line 21 \line 22 \f2\fs22 // \f3\fs16 Defini\'e7\'e3o recursiva da fun\'e7\'e3o factorial \line 23 unsigned long factorial (unsigned long number) \line 24 \f2\fs22\{ \line\f3\fs16 25 if (number \f0\fs12 <= \f3\fs16 1) \f2\fs22 // \f3\fs16 caso base \line 26 return 1; \line 27 else \b0\i\f2\fs20 II \b\i0\f3\fs16 caso recursivo \line 28 return number \b0\f2\fs12 * \b\f3\fs16 factorial( nuniber \b0\f2\fs8 - \b\f3\fs16 1); \line 29 \line 0! \f0\fs12 = 1 \line\f3\fs16 1! \f0\fs12 = \f3\fs16 1 \line 2! \f0\fs12 = \f3\fs16 2 \line 3! \f0\fs12 = \f3\fs16 6 \line 4! \f0\fs12 = \f3\fs16 24 \line 5! \f0\fs12 = \f3\fs16 120 \line 6! \f0\fs12 = \f3\fs16 720 \line 7! \f0\fs12 = \f3\fs16 5040 \line 8! \f0\fs12 = \f3\fs16 40320 \line 9\rquote  \f0\fs12 = \f3\fs16 362880 \line 10! \f0\fs12 = \f3\fs16 3628800 \line\f2\fs18 Fig. \b0\fs20 3.14 C\'e1lculo de fatoriais com uma fun\'e7\'e3o recursiva. \line\f0\fs18 A fun\'e7\'e3o factorial foi declarada de modo a receber um par\'e2metro do tipo uns igned long e retornar um resultado do tipo unsigned long. Isso \'e9 uma abrevia\'e7\'e3o de unsigned long int. A especifica\'e7\'e3o de C++ determina que uma vari\'e1vel do tipo unsigned long int seja armazenada em pelo menos 4 bytes (32 bits), podendo assim conter um valor no intervalo O a 4294967295. (O tipo de dados long int tamb\'e9m \'e9 armazenado em pelo menos 4 bytes e pode armazenar um valor de pelo menos -2147483648 a 2147483647). Como pode ser observado na Fig. 3.14, os valores dos fatoriais se tornam grandes rapidamente. Escolhemos o tipo de dados unsigned long para que o programa possa calcular fatoriais maiores que 7! em computadores com inteiros pequenos (como 2 hytes, por exemplo). Infelizmente, a fun\'e7\'e3o factorial produz valores grandes t\'e3o rapidamente que at\'e9 mesmo unsigned long n\'e3o nos ajuda a calcular muitos valores de fatoriais antes de o valor m\'e1ximo poss\'edvel de uma vari\'e1vel uns igned long ser superado. \line Como exploramos nos exerc\'edcios, double pode ser necess\'e1rio em \'faltimo caso para o usu\'e1rio que deseje \line calcular fatoriais de n\'fameros grandes fsso indica uma defici\'eancia da maioria das linguagens de programa\'e7\'e3o. ou \fs24\par
\b\fs16 CAP\'cdTULO \b0\fs14 3 \f2\fs8 - \b\f0\fs16 FUN\'c7\'d5ES \b0\fs14 215 \fs24\par
\fs16 com 1! igual a 1 e 0! igual a 1 por defini\'e7\'e3o. Por exemplo, \i\fs18 5! \i0\fs16\'e9 o produto \i\fs18 5 .4. \i0\fs16 3 \f2\fs8 . \f0\fs16 2. 1, que \'e9 igual a 120. O fatorial de um inteiro, number. maior ou igual a 0, pode ser calculado \i\fs18 iterativamente \i0\fs16 (n\'e3o-recursivamente) \line usando for como se segue: \line factorial \f2\fs10 = \b\f0\fs16 1; \line\b0 for (int counter \f2\fs10 = \f0\fs16 nuniber; counter \b >= 1; \b0 counter--) \line factorial \f2\fs10 *= \f0\fs16 counter; \line Chega-se a uma defini\'e7\'e3o recursiva para a fun\'e7\'e3o fatorial observando-se o seguinte relacionamento: \line\i\fs18 n! =n.(n-])! \line\i0\fs16 Por exemplo, \i\fs18 5! \'e9 \i0\fs16 claramente igual aS \f2\fs12 * \i\f0\fs18 4!, \i0\fs16 como \'e9 mostrado a seguir: \line 5! \b = \b0 5.4.3.2. \line 5! 5. (4.3.2.1) \line\i\fs18 5! 5(4!) \line\i0\fs16 O c\'e1lculo de \i\fs18 5! \i0\fs16 prosseguiria da forma mostrada na Fig. 3.13. A Fig. 3.13a mostra como a sucess\'e3o de chamadas recursivas se processaria at\'e9 1! ser calculado como 1, o que encerraria a recurs\'e3o. A Fig. 3.13b mostra os valores enviados de volta \'e0 fun\'e7\'e3o chamadora em cada chamada recursiva, at\'e9 que o valor final seja calculado e retornado. \line\f2\fs18 Valor final \fs10 = \fs18 120 \line\f1\fs52 r \line\f2\fs18 5!=5*24_120 \'e9 o valor retornado \line\b 5 \b0\fs10 * \b\f0\fs16 4! \line\b0\f2\fs18 41=4*6=24 \'e9 o valor retornado \line\b\f0\fs16 4 \b0\f2\fs10 * \b\f0\fs16 3! \line\b0\f2\fs18 3!=3*2=6 \'e9 o valor retornado \line\b\f0\fs16 3 \b0\f2\fs10 * \b\f0\fs16 2\rquote  \line\b0\f2\fs18 2 \fs10 * = \fs18\'e9 o valor retornado \line 1 \'e9o valor retornado \line\b\f0\fs16 1 \line\b0\f2\fs18 a) Processamento de chamadas b) Valores retornados de cada chamada recursiva. \line recursivas \line\b Fig. 3.13 \b0 C\'e1lculo recursivo de \b\i 5!. \line\b0\i0\f0\fs16 O programa da Fig. 3.14 usa a recurs\'e3o para calcular e imprimir fatoriais de inteiros de O a 10 (a escolha do tipo de \line dado unsigned long ser\'e1 explicada em breve). A fun\'e7\'e3o recursiva factorial inicialmente verifica se uma \line condi\'e7\'e3o de t\'e9rmino \'e9 true (verdadeira), i.e., se nuxnber \'e9 menor ou igual a 1. Se number for menor ou igual a \line 1. factorial retorna 1, nenhuma recurs\'e3o se faz mais necess\'e1ria e o programa \'e9 encerrado. Se nuniber for \line maior do que 1, o comando \line return number \f2\fs10 * \f0\fs16 factorial ( \b nuinber \b0\f2\fs8 - \b\f0\fs16 1) \line\b0 expressa o problema como o produto de number por uma chamada recursiva a factorial calculando o fatorial de number \f2\fs8 - \f0\fs16 1. Observe que factorial ( nuiriber \f2\fs8 - \f0\fs16 i \'e9 um problema ligeiramente mais simples do que o c\'e1lculo original factorial \f2\fs24 ( \f0\fs16 number \f2\fs8 ). \f0\fs24\par
\b\f2\fs20 214 C++ \fs14 COMO \f0 PROGRAMAR \line\b0\fs18 Uma vari\'e1vel global x \'e9 declarada e inicializada com o valor \b\f2\fs20 1. \b0\f0 Essa \fs18 vari\'e1vel global fica oculta em qualquer bloco (ou fun\'e7\'e3o) que declare uma vari\'e1vel x. Em main. a vari\'e1vel local x \'e9 declarada e inicializada com o valor 5. A seguir, essa vari\'e1vel \'e9 impressa para mostrar que a vari\'e1vel global x \'e9 ignorada em main. Em seguida, \'e9 definido um novo bloco em main, com outra vari\'e1vel local x inicializada com o valor 7. Essa vari\'e1vel \'e9 impressa para mostrar que x do bloco externo de main \'e9 ignorada. A vari\'e1vel x com o valor 7 \'e9 eliminada automaticamente, depois da execu\'e7\'e3o do bloco, e a vari\'e1vel local x do bloco externo de main \'e9 impressa novamente para mostrar que n\'e3o est\'e1 mais sendo ignorada. O programa define tr\'eas fun\'e7\'f5es que n\'e3o utilizam nenhum argumento e n\'e3o retornam nenhum valor. A fun\'e7\'e3o a define uma vari\'e1vel autom\'e1tica x e a inicializa como \fs20 25. \fs18 Quando a \'e9 chamada, a vari\'e1vel \'e9 impressa, incrementada e impressa novamente, antes do t\'e9rmino da fun\'e7\'e3o. Cada vez que essa fun\'e7\'e3o \'e9 chamada, a vari\'e1vel autom\'e1tica x \'e9 reinicializada como 25. A fun\'e7\'e3o b declara uma vari\'e1vel x static e a inicializa como \line 50. As vari\'e1veis locais declaradas como static conservam seus valores, mesmo quando est\'e3o fora do escopo. Quando b \'e9 chamada, a vari\'e1vel x \'e9 impressa, incrementada e impressa novamente antes do t\'e9rmino da fun\'e7\'e3o. Na pr\'f3xima chamada a essa fun\'e7\'e3o, a vari\'e1vel static local x ter\'e1 o valor 51. A fun\'e7\'e3o c n\'e3o declara vari\'e1vel alguma. Portanto, quando ela faz refer\'eancia \'e0 vari\'e1vel x, o x global \'e9 utilizado. Quando c \'e9 chamada, a vari\'e1vel global \'e9 impressa, multiplicada por 10 e impressa novamente antes do t\'e9rmino da fun\'e7\'e3o. Na pr\'f3xima vez que a fun\'e7\'e3o e for chamada, a vari\'e1vel global ainda ter\'e1 seu valor modificado, 10. Finalmente, o programa imprime mais uma vez a vari\'e1vel local x, em main, para mostrar que nenhuma das chamadas de fun\'e7\'f5es modificou o valor de x, porque todas as fun\'e7\'f5es faziam refer\'eancia a vari\'e1veis em outros escopos. \line\b\f2\fs26 3.12 Recurs\'e3o \line\b0\f0\fs18 Geralmente, os programas que analisamos s\'e3o estruturados como fun\'e7\'f5es que fazem chamadas entre si de uma maneira disciplinada, hier\'e1rquica. Para alguns tipos de problemas, \'e9 \'fatil ter fun\'e7\'f5es que chamem a si mesmas. Uma \i fun\'e7\'e3o recursiva \i0\'e9 uma fun\'e7\'e3o que chama a si mesma, direta ou indiretamente (por meio de outra fun\'e7\'e3o). A recurs\'e3o \'e9 um t\'f3pico complexo, analisado exaustivamente em cursos avan\'e7ados de Ci\'eancia da Computa\'e7\'e3o. Nesta se\'e7\'e3o e na se\'e7\'e3o seguinte, s\'e3o apresentados exemplos simples de recurs\'e3o. Este livro cont\'e9m um tratamento abrangente da recurs\'e3o. A Fig. 3.17 (no final da Se\'e7\'e3o 3.14) resume os exemplos e exerc\'edcios de recurs\'e3o do livro. \line Em primeiro lugar, vamos analisar a recurs\'e3o conceitualmente e depois examinaremos v\'e1rios programas contendo fun\'e7\'f5es recursivas. Os m\'e9todos recursivos para solu\'e7\'e3o de problemas possuem v\'e1rios elementos em comum. Uma fun\'e7\'e3o recursiva \'e9 chamada para resolver um problema. Na realidade, a fun\'e7\'e3o s\'f3 sabe resolver o(s) caso(s) mais simples, ou o(s) chamado(s) \i caso(s) b\'e1sico(s). \i0 Se a fun\'e7\'e3o for chamada com um caso b\'e1sico, ela simplesmente retorna um resultado. Se a fun\'e7\'e3o for chamada com um problema mais complexo, ela divide o problema em duas partes conceituais: uma parte que a fun\'e7\'e3o sabe como resolver e outra que ela n\'e3o sabe. Para viabilizar a recurs\'e3o, a segunda parte deve ser parecida com o problema original, mas ser uma vers\'e3o um pouco mais simples ou menor do que ele. Por esse novo problema ser parecido com o problema original, a fun\'e7\'e3o dispara (chama) uma nova c\'f3pia de si mesma para lidar com o problema menor \f2\fs8 - \f0\fs18 o que \'e9 conhecido por \i chamada recursiva \i0 ou \i etapa de recurs\'e3o. \i0 A etapa de recurs\'e3o tamb\'e9m inclui a palavra-chave return, porque seu resultado ser\'e1 combinado com a parte do problema que a fun\'e7\'e3o sabe como resolver para formar um resultado que ser\'e1 enviado de volta para a fun\'e7\'e3o original de chamada, possivelmente main. \line A etapa de recurs\'e3o \'e9 executada enquanto a chamada original para a fun\'e7\'e3o estiver ativa, i.e., ainda n\'e3o tiver sido conclu\'edda. A etapa de recurs\'e3o pode levar a outras chamadas recursivas, \'e0 medida que a fun\'e7\'e3o continuar a dividir cada problema em duas partes conceituais. Para a recurs\'e3o chegar ao fim, cada vez que a fun\'e7\'e3o chamar a si mesma com uma vers\'e3o ligeiramente mais simples do problema original, essa seq\'fc\'eancia de problemas cada vez menores deve finalmente convergir para o caso b\'e1sico. Nesse instante, a fun\'e7\'e3o reconhece o caso b\'e1sico, envia um resultado de volta para a c\'f3pia anterior da fun\'e7\'e3o e ocorre uma seq\'fc\'eancia de passagem de resultados na ordem inversa, at\'e9 que a chamada original da fun\'e7\'e3o envie, finalmente, o resultado final para main. Tudo isso parece um tanto esquisito, se comparado com a maneira convencional de resolver problemas que usamos at\'e9 aqui. Na verdade, \'e9 necess\'e1rio muita pr\'e1tica com programas recursivos antes de o processo parecer natural. Como exemplo da utiliza\'e7\'e3o desses conceitos, vamos escrever um programa recursivo para realizar um conhecido c\'e1lculo da matem\'e1tica. \line O fatorial de um inteiro n\'e3o-negativo \i n, \i0 escrito \i n! \i0 (e pronunciado \ldblquote fatorial de \i n \i0\f2\fs12\ldblquote ), \f0\fs18\'e9 o produto \line\i n \i0\fs24\par
\fs16 CAP\'cdTULO \f2\fs20 3 \fs8 - \f0\fs16 FUN\'c7\'d5ES \f2\fs22 213 \line\f3\fs16 32 b \f2\fs22 O; // \f3\fs16 x local est\'e1tico conserva seu valor anterior \line 33 c \f0\fs30 o; \i\f2\fs22 II \i0\f3\fs16 x global tamb\'e9m conserva seu valor \line 34 \line 35 cout \'ab \ldblquote x local em main \'e9 \f2\fs8\ldblquote  \f0\fs16\'ab \f3 x \'ab endl; \line 36 \line 37 return 0; \line 38 \line 39 \line 40 void a( void \line 41 \line 42 int x \f2\fs12 = \f3\fs16 25; \i\f2\fs22 II \i0\f3\fs16 inicializada sempre \f0\fs18 que \f3\fs16 a \'e9 chamada \line 43 \line 44 cout \'ab endl \'ab \lquote x local em a \'e9 \f2\fs8\ldblquote  \f0\fs16\'ab \b x \line\b0\f3 45 \f2\fs8\ldblquote  \f3\fs16 depois de entrar em a\rdblquote  \'ab endl; \line 46 ++x; \line 47 cout \'ab \b\f0 x \b0\f3 local em a \'e9 \'ab x \line 48 \'ab \f2\fs8\ldblquote  \f3\fs16 antes de sair de a\rdblquote  \'ab endl; \line 49 \line 50 \line 51 void b( void \line 52 \f2\fs22\{ \line\f3\fs16 53 static int x \f2\fs12 = \f3\fs16 50; \i\f2\fs20 II \i0\f3\fs16 somente inicializa\'e7\'e3o est\'e1tica \line 54 \f2\fs22 // \f3\fs16 na primeira vez \f0\fs18 que \f3\fs16 b \'e9 chamada \line 55 cout \'ab endl\'ab \ldblquote x local est\'e1tico \'e9 \'ab x \line 56 \'ab \f2\fs8\ldblquote  \f3\fs16 ao entrar em b\rdblquote  \'ab endl; \line 57 \line 58 cout \'ab \lquote x local est\'e1tico \'e9 \f2\fs8\ldblquote  \f0\fs16\'ab \b x \line\b0\f3 59 \'ab \f2\fs8\ldblquote  \f3\fs16 ao sair de b\rdblquote  \'ab x \'ab endl; \line 60 \line 61 \line 62 void c( void \line 63 \line 64 cout \'ab endl \'ab \ldblquote x global \'e9 \'ab x \line 65 \'ab \f2\fs8\ldblquote  \f3\fs16 ao entrar em c\rdblquote  \'ab endl; \line 66 x*10; \line 67 cout \'ab \ldblquote x global \'e9 \'ab x \'ab ao sair de c\rdblquote  \f0\'ab \f3 endi; \line 68 \line x local no escopo externo de main \'e9 5 \line x local no escopo interno de main \'e9 7 \line x local no escopo externo de main \'e9 5 \line x local em a \'e9 25 depois de entrar em a \line x local em a \'e9 26 antes de sair de a \line x local est\'e1tico \'e9 50 ao entrar em b \line x local est\'e1tico \'e9 51 ao sair de b \line x global \'e9 1 ao entrar em c \line x global \'e9 10 ao sair de c \line x local em a \'e9 25 depois de entrar em a \line x local em a \'e9 26 antes de sair de a \line x local est\'e1tico \'e9 51 ao entrar em b \line x local est\'e1tico \'e9 52 ao sair de b \line x global \'e9 10 ao entrar em c \line x global \'e9 100 ao sair de c \line x local em main \'e9 5 \line\f2\fs20 Fig. 3.12 Um exemplo de escopos (parte 2 de 2). \f0\fs24\par
\fs18 212 C++ \b\f2\fs16 COMO \f3 PROGRAMAR \b0\f0\fs24\par
\fs18 de vari\'e1veis. Quando os blocos est\'e3o aninhados e um identificador em um bloco externo tem o mesmo nome de um identificador em um bloco interno, o identificador no bloco externo \'e9 \ldblquote escondido\rdblquote  at\'e9 que o bloco interno seja encerrado. Durante a execu\'e7\'e3o de um bloco interno, este v\'ea o valor de seu pr\'f3prio identificador local e n\'e3o o valor do identificador de mesmo nome no bloco externo. As vari\'e1veis locais declaradas static tamb\'e9m possuem escopo de bloco, muito embora existam desde o instante em que o programa come\'e7ou a ser executado. Dessa maneira, a classe de armazenamento n\'e3o afeta o escopo de um identificador. \line Os \'fanicos identificadores com \i\fs20 escopo de prot\'f3tipo de fun\'e7\'e3o \i0\fs18 s\'e3o os utilizados na lista de par\'e2metros de um prot\'f3tipo de fun\'e7\'e3o. Como \f1\fs24 j\'e1 \f0\fs18 mencionado, os prot\'f3tipos de fun\'e7\'e3o n\'e3o necessitam de nomes em suas listas de par\'e2metros \f2\fs8 - \f0\fs18 apenas os tipos s\'e3o exigidos. Se um nome foi usado na lista de par\'e2metros de um prot\'f3tipo de fun\'e7\'e3o, ele ser\'e1 ignorado pelo compilador. Os identificadores usados em um prot\'f3tipo de fun\'e7\'e3o podem ser reutilizados em qualquer lugar do programa sem ambig\'fcidade. \line\i Erro comum de programa\'e7\'e3o 3.20 \line Usar acidentalmente, em um bloco interno, o mesmo nome que \'e9 usado para um identificador em um bloco mais externo, quando, na realidade, o programador quer que o identificador do bloco externo esteja ativo durante o processamento do bloco interno, geralmente causa um erro de l\'f3gica. \line Boa pr\'e1tica de programa\'e7\'e3o 3.9 \line Evite nomes de vari\'e1veis que escondam nomes em escopos mais externos, isso pode ser conseguido simplesmente evitando-se, em um programa, o uso de identificadores duplicados. \line\i0 O programa da Fig. 3.12 demonstra aspectos de escopo com vari\'e1veis globais, vari\'e1veis locais autom\'e1ticas e vari\'e1veis locais static. \line\b\f3\fs16 1 \b0\i\f0\fs18 II \b\i0\f3\fs16 Fig. 3.12: figO3l2.cpp \line 2 \b0\i\f0\fs18 II \b\i0\f3\fs16 Um exemplo de escopos \line 3 #include <iostreaxu> \line 4 \line 5 using std: :cout; \line 6 using std::endl; \line\f2\fs18 7 \line\f3\fs16 8 void a( void ); \b0\i\f0\fs18 II \b\i0\f3\fs16 prot\'f3tipo de fun\'e7\'e3o \line 9 void b( void ); \b0\i\f0\fs18 II \b\i0\f3\fs16 prot\'f3tipo de fun\'e7\'e3o \line 10 void c( void ); \b0\i\f0\fs18 II \b\i0\f3\fs16 prot\'f3tipo de fun\'e7\'e3o \line 11 \line 12 int x \b0\f2\fs10 = \b\f3\fs16 1; \b0\i\f0\fs18 II \b\i0\f3\fs16 vari\'e1vel global \line 13 \line 14 int main \b0\f0\fs18 O \line\b\f3\fs16 15 \line 16 int x \b0\f2\fs10 = \b\f3\fs16 5; \b0\i\f0\fs18 II \b\i0\f3\fs16 vari\'e1vel local para main \line 17 \line 18 cout \'ab \f0\ldblquote x \f3 local no escopo externo de main \'e9 \'ab x \'ab endl; \line 19 \line 20 \b0\f0\fs18 ( \i II \b\i0\f3\fs16 inicia novo escopo \line 21 intx=7; \line 22 \line 23 cout \'ab \f0\ldblquote x \f3 local no escopo interno de main \'e9 \b0\f2\fs8\ldblquote  \f0\fs18\'ab \b\f3\fs16 x \'ab endl; \line 24 \b0\f0\fs18\} \i 1/ \b\i0\f3\fs16 encerra novo escopo \line 25 \line 26 cout \'ab \ldblquote x local no escopo externo de main \'e9 \b0\f2\fs8\ldblquote  \b\f3\fs16\'ab x \'ab endl; \line 27 \line 28 a \b0\f0\fs18 O; // \b\f3\fs16 a tem x local autom\'e1tico \line 29 b \b0\f0\fs18 O; \i II \b\i0\f3\fs16 b tem x local est\'e1tico \line 30 c \b0\f0\fs18 O; \i II \b\i0\f3\fs16 c usa x global \line 31 a \b0\f0\fs18 O; // \b\f3\fs16 a reinicializa x local autom\'e1tico \b0\f0\fs24\par
\b\f2\fs18 Fig. 3.12 \b0 Um exemplo de escopos (parte 1 de 2). \f0\fs24\par
\b\fs16 CAP\'cdTULO \b0\f2\fs22 3 \fs8 - \fs16 FUN\'c7\'d5ES \b\fs22 211 \line\b0\f0\fs18 tado, isso n\'e3o significa que esses identificadores possam ser usados em todo o programa. A classe de armazenamento e o escopo (onde um nome pode ser usado) s\'e3o aspectos diferentes, como veremos na Se\'e7\'e3o 3.11. \line H\'e1 dois tipos de identificadores com classe de armazenamento est\'e1tica: identificadores externos (como vari\'e1veis globais e nomes de fun\'e7\'e3o) e vari\'e1veis locais declaradas com o especificador de classe de armazenamento s tatic.As vari\'e1veis globais e nomes de fun\'e7\'e3o pertencem, por default, \'e0 classe de armazenamento extern. As vari\'e1veis globais s\'e3o criadas colocando-se declara\'e7\'f5es de vari\'e1veis fora de qualquer defini\'e7\'e3o de fun\'e7\'e3o e conservam seus valores ao longo de toda a execu\'e7\'e3o do programa. As refer\'eancias a vari\'e1veis e fun\'e7\'f5es globais podem ser feitas em qualquer fun\'e7\'e3o que venha ap\'f3s suas declara\'e7\'f5es ou defini\'e7\'f5es no arquivo. \line\b\i\f2\fs20 Observa\'e7\'e3o de engenharia de software 3.12 \line\b0\f0\fs18 Declarar uma vari\'e1vel como global em vez de local permite que ocorram efeitos colaterais indesej\'e1veis quando uma fun\'e7\'e3o que n\'e3o necessita de acesso \'e0 vari\'e1vel modifica, acidental ou intencionalmente, essa vari\'e1vel, Em geral, o uso de vari\'e1veis globais deveria ser evitado, exceto em certas situa\'e7\'f5es com exig\'eancias especiais de desempenho. \line\b\f2\fs20 Observa\'e7\'e3o de engenharia de software 3.13 \line\b0\i0\fs8 ______ \i\f0\fs18 As vari\'e1veis usadas apenas em uma determinada fun\'e7\'e3o devem ser declaradas como vari\'e1veis locais naquela fun\'e7\'e3o, em vez de serem declaradas como vari\'e1veis globais. \line\i0 Vari\'e1veis locais declaradas com a palavra-chave static s\'e3o conhecidas apenas na fun\'e7\'e3o na qual s\'e3o definidas, mas, diferentemente das vari\'e1veis autom\'e1ticas, as vari\'e1veis locais static conservam seus valores quando a fun\'e7\'e3o \'e9 encerrada. Na pr\'f3xima vez em que a fun\'e7\'e3o for chamada, a vari\'e1vel local static conter\'e1 o valor que tinha quando a fun\'e7\'e3o foi executada pela \'faltima vez. O comando seguinte declara a vari\'e1vel local count como static e a inicializa com o valor 1. \line static int count \f2\fs12 = \b\f0\fs16 1; \line\b0\fs18 Todas as vari\'e1veis num\'e9ricas da classe de armazenamento est\'e1tica s\'e3o inicializadas com o valor zero, se n\'e3o forem inicializadas explicitamente pelo programador. (As vari\'e1veis est\'e1ticas ponteiros, discutidas no Capitulo \i 5, \i0 tamb\'e9m s\'e3o inicializadas com o valor zero). \line Os especificadores de classes de armazenamento extern e static possuem significado especial quando \line aplicados explicitamente a identificadores externos. No Cap\'edtulo 18, \ldblquote T\'f3picos sobre c\'f3digo legado em C\rdblquote , discutiremos o uso de \b extern e static \b0 com identificadores externos e programas com m\'faltiplos arquivos-fonte. \line\b\f2\fs26 3.11 Regras de escopo \line\b0\f0\fs18 A parte do programa na qual um identificador tem significado \'e9 conhecida como seu \i escopo. \i0 Por exemplo, quando \line declaramos uma vari\'e1vel local em um bloco, podem ser feitas refer\'eancias a ela apenas naquele bloco ou em blocos \line aninhados naquele bloco. Os quatro escopos de um identificador s\'e3o \i escopo de fun\'e7\'e3o, escopo de arquivo, escopo \line de bloco \i0 e \i escopo de prot\'f3tipo de fun\'e7\'e3o. \i0 Mais tarde, veremos dois outros escopos \f2\fs8 - \i\f0\fs18 escopo de classe \i0 (Cap\'edtulo 6) \line e \i escopo de ambiente de nomes \i0 (Cap\'edtulo 21). \line Um identificador declarado fora de qualquer fun\'e7\'e3o tem \i escopo de arquivo. \i0 Tal identificador \'e9 \ldblquote conhecido\rdblquote  \line por todas as fun\'e7\'f5es desde o local onde \'e9 declarado at\'e9 o final do arquivo. Vari\'e1veis globais, defini\'e7\'f5es de fun\'e7\'f5es e prot\'f3tipos de fun\'e7\'f5es colocados fora de uma fun\'e7\'e3o possuem escopo de arquivo. \line\i R\'f3tulos \i0 (identificadores seguidos de dois pontos, como inicio:) s\'e3o os \'fanicos identificadores com \i escopo defun\'e7\'e3o. \i0 Os r\'f3tulos podem ser usados em qualquer lugar de uma fun\'e7\'e3o na qual aparecem, mas n\'e3o pode ser feita qualquer refer\'eancia a eles fora do corpo da fun\'e7\'e3o. Os r\'f3tulos s\'e3o usados em estruturas switch (como r\'f3tulos de case) e em comandos goto (ver Cap\'edtulo 18). Os r\'f3tulos s\'e3o detalhes de implementa\'e7\'e3o que as fun\'e7\'f5es ocultam umas das outras. Essa oculta\'e7\'e3o \f2\fs8 - \f0\fs18 chamada mais formalmente de \i oculta\'e7\'e3o de informa\'e7\'f5es \i0\f2\fs8 - \f0\fs18\'e9 um dos princ\'edpios mais importantes da boa engenharia de software. \line Os identificadores declarados dentro de um bloco possuem \i escopo de bloco. \i0 O escopo de bloco termina na \line chave \'e0 direita final \b\f2\fs22 (\}) \b0\f0\fs18 do bloco. As vari\'e1veis locais declaradas no in\'edcio de uma fun\'e7\'e3o possuem escopo de bloco, assim como os par\'e2metros da fun\'e7\'e3o, que tamb\'e9m s\'e3o vari\'e1veis locais dela. Qualquer bloco pode conter declara\'e7\'f5es \fs24\par
\fs18 210 C++ \b\fs14 COMO PROGRAMAR \line\b0\fs18 Apenas vari\'e1veis podem ter classe de armazenamento autom\'e1tica. As vari\'e1veis locais de uma fun\'e7\'e3o (as declaradas na lista de par\'e2metros ou no corpo da fun\'e7\'e3o) s\'e3o normalmente da classe de armazenamento autom\'e1tica. A palavra-chave auto declara explicitamente vari\'e1veis da classe de armazenamento autom\'e1tica. Por exemplo, a declara\'e7\'e3o a seguir indica que as vari\'e1veis x e y, do tipo double. s\'e3o vari\'e1veis locais autom\'e1ticas e existem apenas no corpo da fun\'e7\'e3o na qual a declara\'e7\'e3o aparece: \line auto double x, y; \line As vari\'e1veis locais possuem classe de armazenamento autom\'e1tico por default; portanto, a palavra-chave auto raramente \'e9 usada. No restante do texto, vamos nos referir a vari\'e1veis com classe de armazenamento autom\'e1tica simplesmente como vari\'e1veis autom\'e1ticas. \line\b\i\fs20 Dica de desempenho 3.3 \line\b0\i0\f2\fs8 ______ \i\f0\fs18 O armazenamento autom\'e1tico \'e9 um meio de economizar mem\'f3ria porque as vari\'e1veis autom\'e1ticas s\'e3o criadas quando o bloco na qual s\'e3o declaradas \'e9 ativado e s\'e3o destru\'eddas quando o bloco \'e9 deixado. \line Observa\'e7\'e3o de engenharia de software 3.11 \line\i0\f2\fs8 ______ \i\f0\fs18 O armazenamento autom\'e1tico \'e9 mais um exemplo do princ\'edpio do menor pri vil\'e9gio. Por que armazenar vari\'e1veis na mem\'f3ria e deix\'e1-las dispon\'edveis, quando na realidade n\'e3o s\'e3o mais necess\'e1rias? \line\i0 Os dados, na vers\'e3o de um programa em linguagem de m\'e1quina, s\'e3o normalmente carregados em registradores para c\'e1lculos e outros processamentos. \line\b\i\fs20 Dica de desempenho 3.4 \line\b0\i0\f2\fs8 _____ \i\f0\fs18 O especificador de classe de armazenamento \b\i0 regis \b0 ter \i pode ser colocado antes de uma declara\'e7\'e3o de vari\'e1vel autom\'e1tica para sugerir que o compilador mantenha a vari\'e1vel em um dos registradores de hardware de alta velocidade do computador em vez de na mem\'f3ria. Se as vari\'e1veis forem usadas freq\'fcentemente como contadores ou para c\'e1lculo de totais, elas podem ser conservadas em registradores de hardware, e o overhead de carregar repetidamente as vari\'e1veis da mem\'f3ria para os registradores e armazenar os resultados novamente na mem\'f3ria pode ser eliminado. \line Erro comum de programa\'e7\'e3o \b\fs20 3.19 \line\b0\fs18 Usar diversos especcadores de classe de armazenamento para o mesmo idenaficador \'e9 um erro de sintaxe. Somente um especificador de classe de arinazenamento pode ser aplicado a um identificador Por exemplo, se voc\'ea incluir \b\i0 regis ter, \b0\i n\'e3o inclua tamb\'e9m \b\i0 auto. \line\b0 O compilador pode ignorar as declara\'e7\'f5es regis ter. Por exemplo, pode n\'e3o haver n\'famero suficiente de registradores dispon\'edveis para uso pelo compilador. A declara\'e7\'e3o a seguir indica que a vari\'e1vel inteira contador pode ser colocada em um dos registradores do computador e inicializada com 1: \line\b register int contador \b0\f2\fs12 = \b\f0\fs14 1; \line\b0\fs18 A palavra-chave regis ter s\'f3 pode ser usada com vari\'e1veis da classe de armazenamento autom\'e1tica. \line\b\i\fs20 Dica de desempenho 3.5 \line\b0\fs18 Freq\'fcentemente, as declara\'e7\'f5es \b\i0 regis ter \b0\i s\'e3o desnecess\'e1rias. Os atuais compiladores otimizadores s\'e3o capazes de reconhecer as vari\'e1veis usadas repetidamente e podem decidir coloc\'e1-las em registradores sem que haja a necessidade de o programador incluir uma declara\'e7\'e3o \b\i0 regis ter. \line As palavras-chave extern e static \b0 s\'e3o usadas para declarar identificadores para vari\'e1veis e fun\'e7\'f5es da classe de armazenamento est\'e1tica. Os identificadores da classe de armazenamento est\'e1tica existem desde o instante em que o programa come\'e7a a ser executado. Para vari\'e1veis, o armazenamento \'e9 alocado e inicializado uma vez, quando o programa come\'e7a a ser executado. Para fun\'e7\'f5es, o nome da fun\'e7\'e3o existe quando o programa come\'e7a a ser executado. Entretanto, muito embora as vari\'e1veis e os nomes das fun\'e7\'f5es existam quando o programa come\'e7a a ser execu \fs24\par
\b\f2\fs16 CAP\'cdTULO 3 \b0\fs8 - \b\fs16 FUN\'c7\'d5ES 209 \line\i\f0\fs20 Erro comum de programa\'e7\'e3o 3.18 \line\b0\fs18 Ap\'f3s uma constante de enumera\'e7\'e3o ter sido definida, tentar atribuir outro valor para a constante de \line enumera\'e7\'e3o \'e9 um erro de sintaxe. \line\b\fs20 Boa pr\'e1tica \b0\fs18 de \b\fs20 programa\'e7\'e3o 3.7 \line\b0\fs18 Use somente letras mai\'fasculas nos nomes de constantes de enumera\'e7\'e3o. Isto \i0 faz \i com que estas constantes \line se destaquem no programa, lembrando ao programador que constantes de enumera\'e7\'e3o n\'e3o s\'e3o vari\'e1veis. \line\b\fs20 Boa \b0\fs18 pr\'e1tica de \b\fs20 programa\'e7\'e3o \b0\fs18 3.8 \line Usar constantes de enumera\'e7\'e3o em vez de constantes inteiras torna um programa mais compreens\'edvel. \line\i0 Depois do primeiro lan\'e7amento, se o jogo terminar, a estrutura while \b\i\fs20\'e9 \b0\i0\fs18 ignorada porque gameStatus n\'e3o ser\'e1 igual a CONTINUE. O programa prossegue para a estrutura if/else que imprime \ldblquote Jogador ganha\rdblquote  se ganeS tatus for igual a WON e \ldblquote Jogador perde\rdblquote  se ganeS tatus for igual a LOST. \line Depois do primeiro lan\'e7amento, se o jogo n\'e3o terminar, a soma (sun) \'e9 armazenada na vari\'e1vel myPoint (\ldblquote meu ponto\rdblquote ). A execu\'e7\'e3o prossegue com a estrutura while porque gameStatus \'e9 O. Cada vez que a estrutura while \'e9 percorrida, roliDice \b\i\fs20\'e9 \b0\i0\fs18 chamada para produzir uma nova vari\'e1vel sum. Se sum for igual a inyPoint, gaineStatus \b\i\fs20\'e9 \b0\i0\fs18 definido com o valor WON para indicar que o jogador ganhou, a condi\'e7\'e3o no while torna-se falsa, a estrutura if/else imprime \ldblquote Jogador ganha\rdblquote  e a execu\'e7\'e3o termina. Se sum for igual a \b\f2\fs20 7, \b0\f0\fs18 ganeStatus \b\i\fs20\'e9 \b0\i0\fs18 definido com o valor LOST para indicar que o jogador perdeu, a condi\'e7\'e3o no whiJ.e toma-se falsa, o comando if/ else imprime \ldblquote Jogador perde\rdblquote  e a execu\'e7\'e3o \b\i\fs20\'e9 \b0\i0\fs18 encerrada. \line Observe a interessante estrutura de controle do programa. Usamos duas fun\'e7\'f5es \f2\fs8 - \f0\fs18 main e roliDice \f2\fs8 - \f0\fs18 e as \line estruturas switch. while. if/else e estruturas if aninhadas. Nos exerc\'edcios, examinaremos v\'e1rias caracter\'edsticas interessantes do jogo de \i craps. \line\b\i0\f2\fs26 3.10 Classes de armazenamento \line\b0\f0\fs18 Nos Cap\'edtulos 1 a 3, usamos identificadores para nomes de vari\'e1veis. Os atributos de vari\'e1veis incluem nome, tipo e valor. Neste cap\'edtulo, tamb\'e9m usamos identificadores como nomes de fun\'e7\'f5es definidas pelo usu\'e1rio. Na realidade, cada identificador em um programa tem outros atributos, incluindo \i classe de armazenamento, escopo \i0 e \i liga\'e7\'e3o. \line\i0 C++ fornece cinco classes de armazenamento, indicadas pelos \i especificadores de classes de armazenamento: \line\i0 auto, register, extern, mutable e static. O especificador da classe de armazenamento de um identificador ajuda a determinar sua classe de armazenamento, escopo e liga\'e7\'e3o. Esta se\'e7\'e3o discute os especificadores de classe de armazenamento auto, register. \b\fs20 extern e static. \b0\fs18 O especificador de classe de armazenamento mutable (discutido em detalhes no Cap\'edtulo 21) \'e9 usado exclusivamente com os tipos definidos pelo usu\'e1rio de C++ chamados de \i classes \i0 (apresentados nos Cap\'edtulos 6 e \b\i\fs20 7). \line\b0\i0\fs18 A \i classe de armazenamento \i0 de um identificador determina o per\'edodo durante o qual aquele identificador existe na mem\'f3ria. Alguns identificadores existem durante pouco tempo, alguns s\'e3o repetidamente criados e eliminados e outros existem durante toda a execu\'e7\'e3o do programa. Nesta se\'e7\'e3o, discutimos duas classes de armazenamento: \line est\'e1tica e autom\'e1tica. \line O \i escopo \i0 de um identificador \'e9 onde se pode fazer refer\'eancia \'e0quele identificador dentro de um programa. Pode-se fazer refer\'eancia a alguns identificadores ao longo de todo o programa; outros podem ser referenciados apenas a partir de partes limitadas de um programa. A Se\'e7\'e3o 3.11 discute o escopo dos identificadores. \line A \i liga\'e7\'e3o \i0 de um identificador determina, para um programa com v\'e1rios arquivos-fonte, se um identificador \'e9 \line conhecido apenas no arquivo-fonte atual ou em qualquer arquivo-fonte com as declara\'e7\'f5es adequadas. \line Os especificadores de classes de armazenamento dos identificadores podem ser divididos em duas classes de armazenamento: \i classe de armazenamento autom\'e1tica \i0 e \i classe de armazenamento est\'e1tica. \i0 As palavras-chave auto e register s\'e3o utilizadas para declarar vari\'e1veis da classe de armazenamento autom\'e1tica. As vari\'e1veis da classe de armazenamento autom\'e1tica s\'e3o criadas quando o bloco no qual s\'e3o declaradas \'e9 ativado e existem enquanto o bloco estiver ativo, sendo destru\'eddas quando a execu\'e7\'e3o do programa sai do bloco. \fs24\par
\f2\fs22 208 \b\fs20 C++ \fs14 COMO PROGRAMAR \line\b0\f0\fs18 valor 2. Os identificadores em uma enum devem ser \'fanicos; no entanto, constantes de enumera\'e7\'e3o separadas podem ter o mesmo valor inteiro. \line Jogador jogou \b\f3 6 + 5 \line Jogador vence \line Jogador jogou 6 + 5 \line Jogador vence \line Jogador jogou 4 + 6 \b0\f2\fs12 = \b\f3\fs18 10 \line Ponto \'e9 10 \line Jogador jogou 2 + 4 \b0\f2\fs12 = \b\f3\fs18 6 \line Jogador jogou 6 + 5 \b0\f2\fs12 = \b\f3\fs18 11 \line Jogador jogou 3 4 3 6 \line Jogador jogou 6 + 4 10 \line Jogador vence \line Jogador jogou 1 + 3 \b0\f2\fs12 = \b\f3\fs18 4 \line Ponto \'e9 4 \line Jogador jogou 1 + 4 \b0\f2\fs12 = \b\f3\fs18 5 \line Jogador jogou 5 + 4 \b0\f2\fs12 = \b\f3\fs18 9 \line Jogador jogou 4 + 6 \b0\f2\fs12 = \b\f3\fs18 10 \line Jogador jogou 6 + 3 \b0\f2\fs12 = \b\f3\fs18 9 \line Jogador jogou 1 \b0\f2\fs14 + \b\f3\fs18 2 \b0\f2\fs12 = \b\f3\fs18 3 \line Jogador jogou 5 + 2 \b0\f2\fs12 = \b\f3\fs18 7 \line Jogador perde \line\f2\fs20 Fig. 3.11 \b0 Exemplos de resultados do jogo de \i craps. \line\f0\fs18 IBoa pr\'e1tica de programa\'e7\'e3o \b\f2\fs20 3.6 \line\b0\f0\fs18 Use mai\'fascula na primeira letra de um identificador usado como o nome de um tipo definido pelo usu\'e1rio. \line\i0 Vari\'e1veis do tipo Status definidas pelo \i usu\'e1rio \i0 somente podem receber a atribui\'e7\'e3o de um dos tr\'eas valores definidos na enumera\'e7\'e3o. Quando o jogo \'e9 \b\f3 vencido, gameStatus recebe \b0\f0 o valor WON \f2\fs8 . \f0\fs18 Quando o jogo \'e9 perdido, gameStatus recebe o valor LOST. Caso contr\'e1rio. ganieStatus recebe o valor CONTINUE, de maneira que os dados possam ser lan\'e7ados novamente. \line\i Erro comum de programa\'e7\'e3o 3.17 \line Atribuir o inteiro equivalente a uma constante de enumera\'e7\'e3o a uma vari\'e1vel do tipo da enumera\'e7\'e3o \'e9 um \line erro de sintaxe. \line\i0\f3 Uma outra \f0 enumera\'e7\'e3o popular \'e9 \line\f3 enum Meses \{ JA \f2\fs12 = \f3\fs18 1, FEV, MAR, ABR, MAl, JUN, JUL, AGO, \line\b SET, OUT, NOV, DEZ \}; \line\b0 que cria um tipo definido pelo usu\'e1rio chamado \b\f0 Meses \b0\f3 com \f0 constantes \f3 de enumera\'e7\'e3o representando os meses do ano. Como o primeiro \f0 valor na enumera\'e7\'e3o precendente \'e9 inicializado explicitamente com 1. \f3 os demais s\'e3o \f0 incrementados por 1, resultando nos valores 1 a \b 12. \b0\f3 Qualquer constante de enumera\'e7\'e3o pode ter atribu\'eddo a ela um \f0 valor inteiro na defini\'e7\'e3o da enumera\'e7\'e3o e cada uma das constantes de enumera\'e7\'e3o subseq\'fcentes ter\'e3o um valor que \'e9 1 a mais que a constante precedente. \fs24\par
\b\f2\fs14 CAP\'cdTULO \b0\fs20 3 \fs8 - \b\fs14 FUN\'c7\'d5ES \b0\fs22 207 \line\f0\fs16 ero adicio 2 \line\b\f3 case 11: \b0\i\f0\fs18 II \b\i0\f3\fs16 vence na primeira jogada \line 28 gameStatus \b0\f2\fs10 = \b\f3\fs18 WON; \line 29 break; \line 30 case 2: \line 31 case 3: \line nsecutivOs \line 32 case 12: \b0\i\f0 II \b\i0\f3\fs16 perde na primeira jogada \line desejado). 33 gameStatus \b0\f2\fs10 = \f0\fs16 LOST; \line es \b\f3 que n\'e3o 34 break; \line 35 default: \b0\i\f0\fs18 II \b\i0\f3\fs16 memoriza o \ldblquote Ponto \line 36 gameStatus \b0\f2\fs10 = \b\f0\fs16 CONTINUE; \line\f3 37 myPoint \b0\f2\fs10 = \b\f3\fs16 sum; \line 38 cout \'ab \ldblquote Ponto \'e9 \b0\f2\fs8\ldblquote  \b\f3\fs16\'ab myPoint \'ab endi; \line\b0\i\f0\fs18 eafun\'e7\'e3o \b\i0\fs16 39 break; \b0\i\fs18 II \b\i0\f3\fs16 otiona1 \line 40 \b0\f0\} \line 41 \line\b\f3 42 while \b0\f0 ( \b\f3 gameStatus ==CONTINUE \b0\f0 ) \{ \i\fs18 II \b\i0\f3\fs16 continua jogando \line\f0 43 \b0 sum \f2\fs10 = \f0\fs16 roliDiceO; \line\b 44 \line\f3 45 if \b0\f0 ( sum \b\f3 =myPoint \b0\f0 ) \i\fs18 II \b\i0\f3\fs16 vence fazendo o ponto \line\b0\f0 nOS e salas \b\f3 46 gaineStatus \b0\f2\fs10 = \b\f0\fs16 WON; \line 47 else \line\f3 48 if \b0\f0 ( suin \b ==7 \b0 ) \i\fs18 II \b\i0\f3\fs16 perde obtendo o valor 7 \line 49 gameStatus \b0\f2\fs10 = \f0\fs16 LOST; \line\i\fs18 tos. Depois \b\i0\f3\fs16 50 \line\b0\i\f0\fs18 7ou 11 no \b\i0\f3\fs16 51 \line\b0\i\f0\fs18 ido craps), \b\i0\f3 52 if \b0\f0\fs16 ( \b\f3 gameStatus =WON \b0\f0 ) \line\i\fs18 esta soma \b\i0\f3\fs16 53 cout \'ab \ldblquote Jogador ganha\rdblquote  \'ab endi; \line 54 \f0 else \line\b0\i\fs18 eu ponto \i0\f2\fs8 . \b\f0\fs16 55 cout \'ab \ldblquote Jogador perde\rdblquote  \'ab endi; \line\f3 56 \line\f0 57 return 0; \line\f3 58 \b0\f0\} \line\b\f3 59 \line 60 int rollDice( void \line\b0\f0 61 \line\b\f3 62 int diel, die2, workSum; \line 63 \line 64 diel \b0\f2\fs10 = \b\f0\fs16 1 + \f3 rand() % 6; \line 65 die2 \b0\f2\fs10 = \b\f0\fs16 1 + \f3 rand() % 6; \line 66 workSum \b0\f2\fs10 = \b\f3\fs16 diel + die2; \line 67 cout \'ab \ldblquote Jogador fez \b0\f2\fs8\ldblquote  \b\f3\fs16\'ab diel \'ab + \b0\f2\fs8\ldblquote  \b\f3\fs16\'ab die2 \line 68 \'ab \b0\f2\fs8\ldblquote  = \ldblquote  \b\f3\fs16\'ab workSum \'abendl; \line 69 \line 70 return workSum; \line 71 \line\f2\fs18 Fig. \b0\fs20 3.10 Programa para simular o jogo de \i craps \i0 (parte 2 de 2). \line\f0\fs16 Observe que o jogador deve lan\'e7ar dois dados no primeiro lan\'e7amento e deve fazer isso em todos os lan\'e7amentos subseq\'fcentes. Definimos uma fun\'e7\'e3o rollDice para lan\'e7ar os dados e calcular e imprimir a soma dos pontos de suas faces. A fun\'e7\'e3o rollDice \f2\fs22\'e9 \f0\fs16 definida apenas uma vez, mas \'e9 chamada em dois locais no programa. E interessante observar \b\f3 que rollDice n\'e3o \b0\f0 recebe argumentos, portanto indicamos void na lista de par\'e2metros. A fun\'e7\'e3o roilDice retorna a soma dos dois dados; assim, um tipo de retorno int \'e9 indicado no cabe\'e7alho da fun\'e7\'e3o. \line O jogo \'e9 razoaveiniente complicado. O jogador pode vencer ou perder no primeiro lan\'e7amento ou pode vencer ou perder em qualquer lan\'e7amento subseq\'fcente. A vari\'e1vel gaineStatus \'e9 usada para controlar isso. A linha \line enum Status \{ CONTINUE, WON, LOST \}; \line cria um \i\fs18 tipo definido pelo usu\'e1rio \i0\fs16 chamado de \i\fs18 enumera\'e7\'e3o. \i0\fs16 Uma enumera\'e7\'e3o, introduzida pela palavra-chave enum e seguida por um \i\fs18 nome de tipo \i0\fs16 (neste caso Status), \'e9 um conjunto de constantes inteiras representadas por identificadores. Os valores destas \i\fs18 constantes de enumera\'e7\'e3o \i0\fs16 come\'e7am em \b\f3 0. \b0\f0 a menos que especificado de outra forma, e s\'e3o incrementados por \b\f3 1. \b0\f0 Na enumera\'e7\'e3o precente, CONTINUE recebe o valor O, \b WON. \b0 o valor 1 e LOST, o \fs24\par
\b\f2\fs22 206 \b0\f0\fs18 C++ \b\f2\fs14 COMO PROGRAMAR \line\b0\f0\fs18 ajustar a escala de rand com o operador m\'f3dulo (i.e., 6) e o n\'famero inicial do intervalo \'e9 igual ao n\'famero adicionado a rand % 6 (i.e., 1). Podemos generalizar esse resultado, como segue \line\b\fs16 n \b0\f2\fs10 = \b\f0\fs16 a +rand \b0\fs18 O \b\fs16 % b; \line\b0\fs18 onde a \'e9 \b\f3\fs16 o \b0\i\f2\fs18 valor de deslocamento da escala \i0\f0 (que \'e9 igual ao primeiro n\'famero do intervalo de inteiros consecutivos desejado) e b \'e9 o fator de ajuste de escala (que \'e9 igual \'e0 amplitude do intervalo de inteiros consecutivos desejado). Nos exerc\'edcios, veremos que \'e9 poss\'edvel escolher inteiros aleatoriamente a partir de conjuntos de valores que n\'e3o sejam intervalos de inteiros consecutivos. \line\i\f2\fs20 IErro comum de programa\'e7\'e3o 3.16 \line Usar \b\i0\f3\fs16 srand \b0\i\f2\fs18 no lugar de \b\i0\f3\fs16 rand \b0\i\f2\fs18 para gerar n\'fameros aleat\'f3rios \'e9 um erro de sintaxe, porque a fun\'e7\'e3o \i0\f0 srand \i\f2 n\'e3o retorna um valor \line\b\i0\fs26 3.9 Exemplo: um jogo de azar e apresentando \b0\fs20 enum \line\f0\fs18 Um dos jogos de azar mais populares \'e9 um jogo de dados conhecido como \i\f2\fs20 craps, \i0\f0\fs18 que \'e9 jogado em cassinos e salas de jogos de todo o mundo. As regras do jogo s\'e3o simples: \line\i\f2 Um jogador joga dois dados. Cada dado tem seis faces. Essas faces cont\'e9m 1, \i0\fs20 2, \i\fs18 3, 4, 5 ou 6 pontos. Depois de os dados pararem, a soma dos pontos nas faces superiores \'e9 calculada. Se a soma for 7 ou 11 no primeiro lan\'e7amento, o jogador vence. Se a soma for 2, 3 ou 12 no primeiro lan\'e7amento (chamado craps), ojogadorperde (i. e., a \ldblquote banca\rdblquote  vence). Sea somafor4, 5,6,8, 9ou lOno primeiro lan\'e7amento, esta soma se torna o \ldblquote ponto\rdblquote  do jogador Para vencer voc\'ea deve continuar lan\'e7ando os dados at\'e9 \ldblquote fazer seu ponto\rdblquote . O jogador perde se tirar um 7 antes de fazer o ponto. \line\i0\f0 O programa da Fig. 3.10 simula o jogo de \i\f2 craps. \i0\f0 A Fig. 3.11 mostra v\'e1rios exemplos de execu\'e7\'e3o. \line\b\f3\fs16 1 \b0\i\f2\fs20 II \b\i0\f3\fs16 Fig. 3.10: figO3lO.cpp \line 2 \b0\i\f2\fs20 II \b\i0\f3\fs16 Craps \line 3 #include <iostream> \line\f0 4 \line\f3 5 using std::cout; \line 6 using std::endl; \line\f0 7 \line\f3 8 #include <cstdlib> \line 9 \line 10 #include <ctime> \line 11 \line 12 using std::time \line 13 \line 14 int rollDice( void ); \b0\i\f2\fs20 II \b\i0\f3\fs16 Prot\'f3tipo da fun\'e7\'e3o \line 15 \line 16 int main() \line 17 \line 18 enum Status \b0\f0\fs18\{ \b\f3\fs16 CONTINUE, WON, LOST \}; \line 19 int sum, myPoint; \line 20 Status gameStatus; \line 21 \line 22 srand( time( O \b0\f0\fs18 ) ); \line\b\f3\fs16 23 \b0\f0\fs18 sum \f2\fs10 = \b\f3\fs16 roilDiceO; \b0\i\f2\fs20 II \b\i0\f3\fs16 primeira jogada dos dados \line 24 \line 25 switch \b0\f0\fs18 ( sum ) \{ \line\b\f3\fs16 26 case 7: \line\b0\f0\fs18 Fig. 3.10 Programa para \b\f3\fs16 simular o jogo \b0\f2\fs20 de \i craps \i0\f0\fs18 (parte \f2\fs20 1 de \b\f3\fs16 2). \b0\f0\fs24\par
\f2\fs16 CAP\'cdTULO 3 \fs8 - \fs16 FUN\'c7\'d5ES \b\fs20 205 \b0\f0\fs24\par
\f2\fs16 12 \line\b\f3 13 #include <cstdlib> \b0\f0\fs24\par
\b\f3\fs16 14 \b0\f0\fs24\par
\b\f3\fs16 int main \b0\f0\fs24\par
\b\f3\fs16 unsigned seed; \b0\f0\fs24\par
\b\f3\fs14 cout \'ab \ldblquote Forne\'e7a a semente: \b0\f2\fs10\ldblquote ; \b\f3\fs14 cm \'bb seed; \line srand( seed \b0\f0\fs24\par
\b\f3\fs16 for \f2\fs20 ( \f3\fs16 int i \b0\f2\fs12 = \b\f3\fs16 1; i \b0\f2\fs14 < \b\f3\fs16 10; i++ \line cout \'ab setw \f2\fs20 ( \f3\fs16 10 \f2\fs20 ) \f3\fs16\'ab 1 + rand \f2\fs20 () \f3\fs16 % 6; \b0\f0\fs24\par
\b\f3\fs16 if \f2\fs20 ( \f3\fs16 i % 5 \b0\f2\fs14 == \f0\fs24 o \line\b\f3\fs16 cout \'ab endi; \b0\f0\fs24\par
\b\f2\fs20\} \b0\f0\fs24\par
\b\f3\fs16 30 return 0; \line 31 \b0\f0\fs24\par
\fs20 Isso faz com que o computador leia seu rel\'f3gio para obter automaticamente o valor da semente. A fun\'e7\'e3o time (com o argumento 0, como escrito no comando precedente) retoma a \ldblquote hora de calend\'e1rio\rdblquote  atual do dia, em segundos. Esse valor \'e9 convertido para um inteiro unsigned e \'e9 usado como a semente para o gerador de n\'fameros aleat\'f3rios, O prot\'f3tipo de fun\'e7\'e3o para time est\'e1 em <ctime>. \fs24\par
\i\fs18 Dica de desempenho 3.2 \line\i0\f2\fs30 f \i\f0\fs18 Afimn\'e7\'e3o \i0\fs20 srand \i\fs18 necessita ser chamada somente uma vez em um programa para obter o efeito de randomiza\'e7\'e3o desejado. Cham\'e1-la mais de uma vez \i0\fs20\'e9 \i\fs18 redundante e, portanto, reduz o desempenho do programa. \i0\fs24\par
\fs20 Os valores produzidos diretamente por rand sempre est\'e3o no intervalo: \fs24\par
\b\f3\fs16 O rand \f2\fs20 O \b0\fs14\'11 RAND MAX \f0\fs24\par
\fs20 Mostramos anteriormente como escrever um \'fanico comando em C++ para simular o lam\'e7amento de um dado de seis lados, com o seguinte comando: \fs24\par
\b\f3\fs16 face \b0\f2\fs14 = \b\f3\fs16 1 + rand \b0\f0\fs20 O % 6; \fs24\par
\fs20 que sempre atribui (aleatoriamente) \'e0 vari\'e1vel face um valor inteiro, no intervalo 1 \'11 \b face \b0\'11 6. Observe que a amplitude desse intervalo (i.e., o n\'famero de inteiros consecutivos no intervalo) \'e9 6 e o n\'famero inicial do intervalo \'e9 Examinando o comando anterior, vemos que o comprimento do intervalo \'e9 determinado pelo n\'famero usado para \fs24\par
\b\f3\fs16 15 \line 16 \line 17 \line 18 \line 19 \line 20 \line 21 \line 22 \line 23 \line 24 \line 25 \line 26 \line 27 \line 28 \line 29 \b0\f0\fs24\par
\b\f2\fs20 Fig. 3.9 \b0 Randomizando o programa de lan\'e7amento de um dado (parte 2 de 2). \f0\fs24\par
\pard\par
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2126\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2439\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2752\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx3065\pard\intbl\b\f3\fs16 Forne\'e7a a semente: 67 \b0\f0\fs24\cell\cell\cell\cell\fs20\row
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1009\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2126\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2439\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2752\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx3065\pard\intbl\b\f3\fs16 1 \b0\f0\fs24\cell\b\f3\fs16 6 \b0\f0\fs24\cell\b\f3\fs16 5 \b0\f0\fs24\cell\b\f3\fs16 1 \b0\f0\fs24\cell\b\f3\fs16 4 \b0\f0\fs24\cell\fs20\row
\b\f3\fs16\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1009\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2126\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2439\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2752\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx3065\intbl 5 \b0\f0\fs24\cell\b\f3\fs16 6 \b0\f0\fs24\cell\b\f3\fs16 3 \b0\f0\fs24\cell\b\f3\fs16 1 \b0\f0\fs24\cell\b\f3\fs16 2 \b0\f0\fs24\cell\fs20\row
\pard\sa240\fs24\par
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2222\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2535\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2848\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx3161\pard\intbl\b\f3\fs16 Forne\'e7a a semente: 432 \b0\f0\fs24\cell\cell\cell\cell\fs20\row
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1057\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2222\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2535\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2848\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx3161\pard\intbl\b\f3\fs16 4 \b0\f0\fs24\cell\b\f3\fs16 2 \b0\f0\fs24\cell\b\f3\fs16 6 \b0\f0\fs24\cell\b\f3\fs16 4 \b0\f0\fs24\cell\b\f3\fs16 3 \b0\f0\fs24\cell\fs20\row
\b\f3\fs16\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1057\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2222\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2535\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2848\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx3161\intbl 2 \b0\f0\fs24\cell\b\f3\fs16 5 \b0\f0\fs24\cell\b\f3\fs16 1 \b0\f0\fs24\cell\b\f3\fs16 4 \b0\f0\fs24\cell\b\f3\fs16 4 \b0\f0\fs24\cell\fs20\row
\pard\sa240\fs24\par
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2126\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2439\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2752\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx3065\pard\intbl\b\f3\fs16 Forne\'e7a a semente: 67 \b0\f0\fs24\cell\cell\cell\cell\fs20\row
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1009\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2126\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2439\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2752\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx3065\pard\intbl\b\f3\fs16 1 \b0\f0\fs24\cell\b\f3\fs16 6 \b0\f0\fs24\cell\b\f3\fs16 5 \b0\f0\fs24\cell\b\f3\fs16 1 \b0\f0\fs24\cell\b\f3\fs16 4 \b0\f0\fs24\cell\fs20\row
\b\f3\fs16\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1009\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2126\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2439\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2752\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx3065\intbl 5 \b0\f0\fs24\cell\b\f3\fs16 6 \b0\f0\fs24\cell\b\f3\fs16 3 \b0\f0\fs24\cell\b\f3\fs16 1 \b0\f0\fs24\cell\b\f3\fs16 2 \b0\f0\fs24\cell\fs20\row
\pard\fs24\par
\pard\sb100\sa240\b\fs16 204 C++ COMO PROGRAMAR \b0\fs24\par
\fs18 Como mostra a sa\'edda do programa, ao fazer o ajuste e o deslocamento da escala, utilizamos a fun\'e7\'e3o rand para simular realisticamente o lan\'e7amento de um dado de seis faces. Note que o programa nunca deveria passar pelo caso default na estrutura switch; por\'e9m, inclu\'edmos este caso por raz\'f5es de boa pr\'e1tica de programa\'e7\'e3o. Depois de estudarmos arrays no Cap\'edtulo 4, mostraremos como substituir elegantemente toda a estrutura switch por um comando em uma \'fanica linha. \line\f1\fs80\'ae \i\f0\fs18 Dica de teste e depura \'e7\'e3o 3.1 \line Inclua um caso \b\i0\f3\fs16 default \b0\i\f0\fs18 em uma estrutura \b\i0\f3\fs16 switch \b0\i\f0\fs18 para detectar erros mesmo que voc\'ea esteja absolutamente seguro de que n\'e3o h\'e1 erros. \line\i0 Executar novamente o programa da Fig. 3.7 produz \line\f2\fs20 5 5 3 5 5 \line\b\f0 2 4 2 5 5 \line\b0\f2 5 3 2 2 1 \line 5 1 4 6 4 \line\f0\fs18 Observe que foi impressa exatamente a mesma seq\'fc\'eancia de valores. Como esses n\'fameros podem ser aleat\'f3rios? Ironicamente, essa repeti\'e7\'e3o de valores \'e9 uma caracter\'edstica importante da fun\'e7\'e3o rand. Ao depurar um programa, essa repeti\'e7\'e3o \'e9 essencial para assegurar que corre\'e7\'f5es feitas no programa funcionam adequadamente. \line Na realidade, a fun\'e7\'e3o rand gera \i n\'fameros pseudo-aleat\'f3rios. \i0 Chamar rand repetidamente produz uma seq\'fc\'eancia de n\'fameros que parece ser aleat\'f3ria. Entretanto, a seq\'fc\'eancia se repete cada vez que o programa \'e9 executado. Depois de o programa ser completamente depurado, ele pode ser condicionado de modo a produzir uma seq\'fc\'eancia diferente de n\'fameros em cada execu\'e7\'e3o. Isso \'e9 chamado de \i randomiza\'e7\'e3o \i0 e \'e9 realizado com a fun\'e7\'e3o srand da biblioteca padr\'e3o. A fun\'e7\'e3o srand utiliza um argumento inteiro unsigned para ser a \i semente \i0 da fun\'e7\'e3o rand. de forma que seja produzida uma seq\'fc\'eancia diferente de n\'fameros aleat\'f3rios a cada execu\'e7\'e3o do programa. \line O uso de srand \'e9 demonstrado na Fig. 3.9. No programa, usamos o tipo de dado unsigned, que \'e9 uma abrevia\'e7\'e3o de uns igned int. Um int \'e9 armazenado em pelo menos dois bytes de mem\'f3ria e pode ter valores positivos e negativos. Uma vari\'e1vel do tipo unsigned int tamb\'e9m \'e9 armazenada em pelo menos dois bytes de mem\'f3ria. Um uns igned int de dois bytes s\'f3 pode ter valores n\'e3o-negativos, no intervalo de O a 65535. Um uns igned int de quatro bytes s\'f3 pode ter valores n\'e3o-negativos, no intervalo de O a 4294967295. A fun\'e7\'e3o srand recebe um valor unsigned int como argumento. O prot\'f3tipo de fun\'e7\'e3o para a fun\'e7\'e3o srand \'e9 encontrado no arquivo de cabe\'e7alho <cstdlib>. \line Vamos executar o programa v\'e1rias vezes e observar os resultados. Observe que uma seq\'fc\'eancia \i diferente \i0 de \line n\'fameros aleat\'f3rios \'e9 obtida cada vez que o programa \'e9 executado, desde que, em cada execu\'e7\'e3o, seja fornecida uma semente diferente. \line Se desej\'e1ssemos randomizar sem necessidade de fornecer uma semente a cada vez, poder\'edamos usar um \line comando como \line srand( time( O ) ); \fs24\par
\b\f2\fs18 Fig. \b0 3.9 Random\'edzando o programa de lan\'e7amento de um dado (parte 1 de 2). \f0\fs24\par
\pard\par
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx301\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx5291\pard\intbl\b\f3\fs16 1 \b0\f0\fs24\cell\i\fs18 II \b\i0\f3\fs16 Fig. 3.9: figO3O9.cpp \b0\f0\fs24\cell\fs20\row
\b\f3\fs16\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx301\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx5291\intbl 2 \b0\f0\fs24\cell\i\fs18 II \b\i0\f3\fs16 Randomizando o programa de lan\'e7amento de um dado \b0\f0\fs24\cell\fs20\row
\b\f3\fs16\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx301\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx5291\intbl 3 \b0\f0\fs24\cell\b\f3\fs16 #include <iostream.h> \b0\f0\fs24\cell\fs20\row
\b\f3\fs16\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx301\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx5291\intbl 4 \b0\f0\fs24\cell\cell\fs20\row
\b\f3\fs16\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx301\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx5291\intbl 5 \b0\f0\fs24\cell\b\f3\fs16 using std::cout; \b0\f0\fs24\cell\fs20\row
\b\f3\fs16\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx301\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx5291\intbl 6 \b0\f0\fs24\cell\b\f3\fs16 using std::cin; \b0\f0\fs24\cell\fs20\row
\b\f3\fs16\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx301\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx5291\intbl 7 \b0\f0\fs24\cell\b\f3\fs16 using std: :endl; \b0\f0\fs24\cell\fs20\row
\b\f3\fs16\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx301\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx5291\intbl 8 \b0\f0\fs24\cell\cell\fs20\row
\b\f3\fs16\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx301\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx5291\intbl 9 \b0\f0\fs24\cell\b\f3\fs16 #include <iomanip> \b0\f0\fs24\cell\fs20\row
\b\f3\fs16\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx301\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx5291\intbl 10 \b0\f0\fs24\cell\cell\fs20\row
\b\f3\fs16\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx301\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx5291\intbl 11 \b0\f0\fs24\cell\b\f3\fs16 using std::setw; \b0\f0\fs24\cell\fs20\row
\pard\fs24\par
\pard\sb100\sa240\fs16 CAPfTULO \f2\fs18 3 \f0\fs16 FUN\'c7\'d5ES \f2\fs18 203 \f0\fs24\par
\f3\fs14 7 \line 8 \line 9 \line\f0\fs16 10 \line 11 \line 12 \line\f3\fs14 13 \line\f0\fs16 14 \line\f3\fs14 15 \line 16 int frequencyl \f2\fs12 = \f0\fs16 0, \line\f3\fs14 17 frequency3 \f2\fs12 = \f3\fs14 0, \line 18 frequency5 \f2\fs12 = \f3\fs14 0, \line 19 face; \line 20 \line 21 \line 22 \line 23 \line 24 switch \f2\fs20 ( \f3\fs14 face \line 25 case 1: \line 26 ++frequencyl; \line 27 break; \line 28 case 2: \line 29 ++frequency2; \line 30 break; \line 31 case 3: \line 32 ++frequency3; \line 33 break; \line 34 case 4: \line 35 ++frequency4; \line 36 break; \line 37 case 5: \line 38 ++frequency5; \line 39 break; \line 40 case 6: \line 41 ++frequency6; \line 42 break; \line 43 default: \line 44 cout \'ab \lquote N\'e3o deve chegar aqui nunca \f2\fs10\ldblquote ; \line\f3\fs14 45 \line 46 \line 47 \line 48 cout \f0\fs16\'ab \f3\fs14\lquote Face\rdblquote  \'ab setw( 13 \line 49 \'ab \ldblquote\\n 1\rdblquote  \'ab setw( \line 50 \'ab \ldblquote\\n 2\rdblquote  \'ab setw( \line 51 \'ab \ldblquote\\n 3\rdblquote  \'ab setw( \line 52 \f0\fs16\'ab \f3\fs14\ldblquote\\n 4\rdblquote  \f0\fs16\'ab \f3\fs14 setw( \line 53 \f0\fs16\'ab \f3\fs14\ldblquote\\n 5\rdblquote  \'ab setw( \line 54 \'ab \ldblquote\\n 6\rdblquote  \'ab setw( \line 55 \line 56 return O \line 57 \f0\fs24\par
\f3\fs16 #include <iomanip> using std::setw; #include <cstdlib> int main() \f0\fs24\par
\f3\fs14 frequency2 \f2\fs12 = \f3\fs14 0, \line frequency4 \f2\fs12 = \f3\fs14 0, \line frequency6 \f2\fs12 = \f3\fs14 0, \f0\fs24\par
\f3\fs14 for \f2\fs20 ( \f3\fs14 int roli \f2\fs12 = \f3\fs14 1; roil \f2\fs12 <= \f3\fs14 6000; face \f2\fs12 = \f3\fs14 1 + rand() % 6; \f0\fs24\par
\f3\fs16 roll++ \f2\fs18 ) \{ \f0\fs24\par
\f2\fs20\} \f0\fs24\par
\fs16\'ab \ldblquote Freq\'fc\'eancia\rdblquote  \line 13 \f2\fs20 ) \f0\fs16\'ab \f3 frequencyl \line 13 \f2\fs20 ) \f0\fs16\'ab \f3 frequency2 \line 13 \f2\fs20 ) \f0\fs16\'ab \f3 frequency3 \line 13 \f2\fs20 ) \f0\fs16\'ab \f3 frequency4 \line 13 \f2\fs20 ) \f0\fs16\'ab \f3 frequency5 \line 13 \f2\fs20 ) \f3\fs16\'ab frequency6 \'ab endl; \f0\fs24\par
\f3\fs16 Face Freq\'fc\'eancia \line 1 987 \line 2 984 \line 3 1029 \line 4 \line 5 \line 6 \f0\fs24\par
\f3\fs16 974 \line 1004 \line 1022 \f0\fs24\par
\f2\fs18 Fig. 3.8 Lan\'e7ando um dado de seis faces 6000 vezes (parte 2 de 2). \f0\fs24\par
\f2\fs18 202 C++ COMO PROGRAMAR \f0\fs24\par
\fs20 <cstdlib>. Para produzir inteiros no intervalo de 0 a \i 5, \i0 usamos o operador m\'f3dulo \i (%) \i0 juntamente com rand, como segue \fs24\par
\fs20 rand() \b\f3\fs16 % 6 \b0\f0\fs24\par
\fs20 Isso \'e9 chamado de \i ajuste de escala. \i0 O n\'famero 6 \'e9 chamado \i de fator de escala. \i0 A seguir, \i deslocamos \i0 a escala dos n\'fameros produzidos adicionando 1 ao nosso resultado anterior. A Fig. 3.7 confirma que os resultados est\'e3o contidos no intervalo de 1 a 6. \fs24\par
\b\f3\fs16 1 \b0\i\f2\fs22 II \b\i0\f3\fs16 Fig. 3.7: f\'edgO3_07.cpp \line 2 \b0\i\f0\fs20 II \b\i0\f3\fs16 Inteiros em \b0\f0\fs18 uma \b\f3\fs16 escala ajustada e deslocada gerados \line 3 #include <iostreani> \b0\f0\fs24\par
\b\f3\fs16 4 \b0\f0\fs24\par
\b\f3\fs16 using std::cout; \line using std::endl; \b0\f0\fs24\par
\b\f3\fs16 8 #incJ-ude <iomanip> \b0\f0\fs24\par
\b\f3\fs16 9 \b0\f0\fs24\par
\b\f3\fs16 10 using std::setw; \line 11 \b0\f0\fs24\par
\b\f3\fs16 12 #include <cstdlib> \b0\f0\fs24\par
\b\f3\fs16 13 \b0\f0\fs24\par
\b\f3\fs16 int main \b0\f0\fs20 Q \fs24\par
\fs20 Para mostrar que esses n\'fameros ocorrem com probabilidades aproximadamente iguais, vamos simular 6000 lan\'e7amentos de um dado com o programa da Fig. 3.8. Cada inteiro de 1 a 6 deve ser obtido aproximadamente 1000 \fs24\par
\fs20 vezes. \fs24\par
\fs18 de nuxi o c\'e1lcul \fs24\par
\b\f3\fs16 5 \line 6 \line 7 \b0\f0\fs24\par
\b\f3\fs16 por 1+randO%6 \b0\f0\fs24\par
\b\f3\fs16 14 \line 15 \line 16 \line 17 \line 18 \line 19 \line 20 \line 21 \line 22 \b0\f0\fs24\par
\b\f3\fs16 for \b0\f0\fs20 ( \b\f3\fs16 nt i \b0\f0 = \b\f3 1; i \b0\f0 <= \b\f3 20; i++ \line cout \'ab setw( 10 \b0\f0\fs20 ) \b\f3\fs16\'ab \b0\f0\fs20 ( \b\f3\fs16 1 + (rand \b0\f0\fs20 () \b\f3\fs16 % 6 \line\b0\f0 if ( i % 5 == O \line\b\f3 cout \'ab endl; \b0\f0\fs24\par
\b\f3\fs16 23 return 0; \line 24 \b0\f0\fs20 ) \fs24\par
\f2\fs16 4 \f0\fs24\par
\fs16 4 \fs24\par
\b\f3\fs16 4 \b0\f0\fs24\par
\b\f3\fs16 4 \line 4t \line 4 \line\b0\f2 47 \f0\fs24\par
\f2\fs16 48 \line\b\f3 49 \b0\f0\fs24\par
\fs16 50 \fs24\par
\f2\fs18 Fig. 3.7 Inteiros em uma escala ajustada e deslocada produzidos por 1 + rand ( ) % 6. \f0\fs24\par
\b\f3\fs16 51 \line\b0\f0 52 \fs24\par
\fs16 53 \fs24\par
\fs16 54 \line 55 \line\b\f3 56 \line\b0\f2 Lac \b\i\fs18 Fig. \b0\i0\fs16 3.1 \f0\fs24\par
\f2\fs20 Fig. 3.8 Lan\'e7ando um dado de seis faces 6000 vezes (parte 1 de 2). \f0\fs24\par
\pard\par
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx205\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4588\pard\intbl\b\f3\fs16 1 \b0\f0\fs24\cell\i\fs20 II \b\i0\f3\fs16 Fig. 3.8: figo3_08.cpp \b0\f0\fs24\cell\fs20\row
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx205\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2355\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4588\pard\intbl\b\f3\fs16 2 \b0\f0\fs24\cell\i\fs20 1/ \b\i0\f3\fs16 Lan\'e7ar uni dado de \b0\f0\fs24\cell\b\f3\fs16 seis faces 6000 vezes \b0\f0\fs24\cell\fs20\row
\b\f3\fs16\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx205\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2355\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4588\intbl 3 \b0\f0\fs24\cell\b\f3\fs16 #include <iostreani> \b0\f0\fs24\cell\cell\fs20\row
\b\f3\fs16\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx205\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2355\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4588\intbl 4 \b0\f0\fs24\cell\cell\cell\fs20\row
\b\f3\fs16\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx205\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2355\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4588\intbl 5 \b0\f0\fs24\cell\b\f3\fs16 using std: :cout; \b0\f0\fs24\cell\cell\fs20\row
\b\f3\fs16\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx205\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2355\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4588\intbl 6 \b0\f0\fs24\cell\b\f3\fs16 using std::endl; \b0\f0\fs24\cell\cell\fs20\row
\pard\fs24\par
\pard\sb100\sa240\b\f2\fs14 CAP\'cdTULO \b0\fs20 3 \fs8 - \b\fs14 FUN\'c7\'d5ES \fs20 201 \b0\f0\fs24\par
\b\f2\fs20 Fig. 3.6 Arquivos de \b0 cabe\'e7alho da biblioteca padr\'e3o (parte 2 de 2). \line\b\fs26 3.8 Gera\'e7\'e3o de n\'fameros aleat\'f3rios \line\b0\f0\fs18 Vamos agora fazer um breve e, esperamos, divertido desvio para uma aplica\'e7\'e3o popular de programa\'e7\'e3o que \'e9 a dos jogos e simula\'e7\'f5es. Nesta se\'e7\'e3o e na pr\'f3xima, desenvolveremos um programa de jogo bem-estruturado que inclui m\'faltiplas fun\'e7\'f5es. O programa utiliza a maioria das estruturas de controle que \fs22 j\'e1 \fs18 estudamos. \line H\'e1 algo no ambiente de um cassino que estimula todos os tipos de pessoas, desde os jogadores profissionais nas suntuosas mesas de mogno e feltro para o jogo de dados \i craps, \i0 at\'e9 os pequenos apostadores em m\'e1quinas ca\'e7a-n\'edqueis. E \i ofator sorte, \i0 a possibilidade de que a sorte converta um punhadinho de dinheiro em uma montanha de riqueza. O fator sorte pode ser introduzido em aplica\'e7\'f5es de computador usando a fun\'e7\'e3o da biblioteca padr\'e3o rand. \line Considere o seguinte comando: \line i \f2\fs12 = \f0\fs18 rand \line A fun\'e7\'e3o rand gera um inteiro entre O e \f2\fs16 RAND \f0\fs18 MAX (uma constante simb\'f3lica definida no arquivo de cabe\'e7alho <cstdlib>) \f2\fs8 . \f0\fs18 O valor de \f2\fs16 RAND_MAX \f0\fs18 deve ser pelo menos 32767, que \'e9 o valor m\'e1ximo de um inteiro de dois bytes (i.e., 16 bits). Se rand produz inteiros verdadeiramente aleat\'f3rios, todos os n\'fameros entre O e \f2\fs16 RAND_MAX \f0\fs18 ter\'e3o a mesma \i chance \i0 ou \i probabilidade \i0 de serem escolhidos cada vez que rand \'e9 chamada. \line Freq\'fcentemente, o conjunto de valores produzido por rand \'e9 diferente do necess\'e1rio para uma aplica\'e7\'e3o espec\'edfica. Por exemplo, um programa que simula o lan\'e7amento de uma moeda pode exigir apenas O para \ldblquote cara\rdblquote  e 1 para \ldblquote coroa\rdblquote . Um programa de jogo de dados que simula um dado de seis faces exigiria inteiros aleat\'f3rios no intervalo de 1 a 6. Um programa que prev\'ea o pr\'f3ximo tipo de espa\'e7onave (entre quatro possibilidades) que surgir\'e1 no horizonte em um videogame pode exigir n\'fameros aleat\'f3rios no intervalo de 1 a 4. \line Para demonstrar rand, vamos desenvolver um programa para simular 20 lan\'e7amentos de um dado de seis \line faces e imprimir o valor de cada lan\'e7amento. O prot\'f3tipo de fun\'e7\'e3o para a fun\'e7\'e3o rand pode ser encontrado em \fs24\par
\pard\par
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1950\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx8946\pard\intbl\b\f2\fs20 Arquivo de cabe\'e7alho da biblioteca padr\'e3o \b0\f0\fs24\cell\b\f2\fs20 Explica\'e7\'e3o \b0\f0\fs24\cell\fs20\row
\fs18\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1950\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx8946\intbl <functional> \fs24\cell\fs18 Cont\'e9m classes e fun\'e7\'f5es usadas por algoritmos da biblioteca padr\'e3o. \fs24\cell\fs20\row
\fs18\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1950\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx8946\intbl <memory> \fs24\cell\fs18 Cont\'e9m classes e fun\'e7\'f5es usadas pela biblioteca padr\'e3o para alocar mem\'f3ria para os cont\'eaineres da biblioteca padr\'e3o. \fs24\cell\fs20\row
\fs18\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1950\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx8946\intbl <iterator> \fs24\cell\fs18 Cont\'e9m classes para acessar dados nos cont\'eaineres da biblioteca padr\'e3o. \fs24\cell\fs20\row
\fs18\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1950\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx8946\intbl <algorithm> \fs24\cell\fs18 Cont\'e9m fun\'e7\'f5es para manipular dados nos cont\'eaineres da biblioteca padr\'e3o. \fs24\cell\fs20\row
\fs18\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1950\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx8946\intbl <exception> <stdexcept> \fs24\cell\fs18 Estes arquivos de cabe\'e7alho cont\'eam classes que s\'e3o usadas para tratamento de exce\'e7\'f5es (discutidas no Cap\'edtulo 13). \fs24\cell\fs20\row
\fs18\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1950\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx8946\intbl <string> \fs24\cell\fs18 Cont\'e9m a defini\'e7\'e3o da classe string da biblioteca padr\'e3o (discutida no Cap\'edtulo 19, \i\ldblquote Strings\rdblquote ). \i0\fs24\cell\fs20\row
\fs18\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1950\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx8946\intbl <sstreaxn> \fs24\cell\fs18 Cont\'e9m prot\'f3tipos de fun\'e7\'f5es para fun\'e7\'f5es que realizam opera\'e7\'f5es de entrada e sa\'edda para strings na mem\'f3ria (discutidas no Cap\'edtulo 14). \fs24\cell\fs20\row
\fs18\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1950\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx8946\intbl <locale> \fs24\cell\fs18 Cont\'e9m prot\'f3tipos de classes e fun\'e7\'f5es normalmente usadas para o processamento de \i streams \i0 para processar dados na forma natural para diferentes idiomas (por exemplo, formatos de moedas, classifica\'e7\'e3o de \i strings, \i0 apresenta\'e7\'e3o de caracteres, etc). \fs24\cell\fs20\row
\fs18\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1950\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx8946\intbl <limits> \fs24\cell\fs18 Cont\'e9m classes para definir os limites de tipos de dados num\'e9ricos em diferentes plataformas computacionais. \fs24\cell\fs20\row
\fs18\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1950\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx8946\intbl <typeinfo> \fs24\cell\fs18 Cont\'e9m classes para a identifica\'e7\'e3o de tipos em tempo de execu\'e7\'e3o (determinar os tipos de dados em tempo de execu\'e7\'e3o). \fs24\cell\fs20\row
\pard\fs24\par
\pard\sb100\sa240\b\f2\fs22 200 \b0\f0\fs18 C++ COMO PROGRAMAR \line ser inclu\'eddo usando-se a diretiva de pr\'e9-processador #include. Por exemplo, o arquivo de cabe\'e7alho square h pode ser inclu\'eddo em nosso programa atrav\'e9s da diretiva \line #include \lquote square .h\rquote  \line no in\'edcio do programa. A Se\'e7\'e3o 17.2 apresenta informa\'e7\'f5es adicionais sobre como incluir arquivos de cabe\'e7alho. \fs24\par
\i\fs16 <cassert> \i0 Cont\'e9m macros e informa\'e7\'f5es para adicionar diagn\'f3sticos que ajudam o programador a realizar depura\'e7\'e3o. A vers\'e3o antiga deste arquivo de cabe\'e7alho \'e9 <assert h>. \line <cctype> Cont\'e9m prot\'f3tipos para fun\'e7\'f5es que examinam caracteres em busca de determinadas propriedades dos caracteres e para fun\'e7\'f5es que podem ser usadas para converter letras min\'fasculas em maidsculas e vice-versa. Este arquivo de cabe\'e7alho substitui o arquivo de cabe\'e7alho <ctype h>. \line <cfloat> Cont\'e9m limites do sistema para o tamanho dos n\'fameros de ponto flutuante. Este arquivo de cabe\'e7alho substitui o arquivo de cabe\'e7alho <float h>. \line <climits> Cont\'e9m os limites do sistema para os tamanhos dos n\'fameros inteiros. Este arquivo de cabe\'e7alho substitui o arquivo de cabe\'e7alho <limits h>. \line <crnath> Cont\'e9m prot\'f3tipos de fun\'e7\'f5es da biblioteca matem\'e1tica. Este arquivo de cabe\'e7alho substitui o arquivo de cabe\'e7alho <math h>. \line <cstdio> Cont\'e9m prot\'f3tipos de fun\'e7\'f5es da biblioteca padr\'e3o de entrada/sa\'edda e as informa\'e7\'f5es utilizadas por elas. Este arquivo de cabe\'e7alho substitui o arquivo de cabe\'e7alho \line <stdio \f2\fs8 . \f0\fs16 h>. \line <cstdiib> Cont\'e9m prot\'f3tipos de fun\'e7\'f5es para convers\'e3o de n\'fameros em texto e texto em n\'fameros, aloca\'e7\'e3o de mem\'f3ria, n\'fameros aleat\'f3rios e outras fun\'e7\'f5es com v\'e1rias finalidades. Este arquivo de cabe\'e7alho substitui o arquivo de cabe\'e7alho <stdlib \f2\fs8 . \f0\fs16 h>. \line <cstring> Cont\'e9m prot\'f3tipos de fun\'e7\'f5es para processamento de strings. Este arquivo de cabe\'e7alho substitui o arquivo de cabe\'e7alho <string h>. \line <ctime> Cont\'e9m prot\'f3tipos e tipos de fun\'e7\'f5es para manipular hor\'e1rios e datas. Este arquivo de cabe\'e7alho substitui o arquivo de cabe\'e7alho <time h>. \line <iostream> Cont\'e9m prot\'f3tipos de fun\'e7\'e3o para as fun\'e7\'f5es padr\'f5es de entrada e sa\'edda. Este arquivo de cabe\'e7alho substitui o arquivo de cabe\'e7alho <iostream. h>. \line <iomanip> Cont\'e9m prot\'f3tipos de fun\'e7\'e3o para os manipuladores de \i streams \i0 que permitem formata\'e7\'e3o de \i streams \i0 de dados. Este arquivo de cabe\'e7alho substitui o arquivo de \line cabe\'e7alho <iomanip h>. \line\i <fstream> \i0 Cont\'e9m prot\'f3tipos de fun\'e7\'e3o para fun\'e7\'f5es que executam opera\'e7\'f5es de entrada a partir de arquivos em disco e sa\'edda para arquivos em disco (discutidos no Cap\'edtulo \line 14). Este arquivo de cabe\'e7alho substitui o arquivo de cabe\'e7alho <fstream. h>. \line <utility> Cont\'e9m classes e fun\'e7\'f5es que s\'e3o usadas por muitos arquivos de cabe\'e7alho da biblioteca padr\'e3o. \line <vector>,<list>, Os arquivos de cabe\'e7alho cont\'eam classes que implementam cont\'eajneres da biblioteca <deqiie>,<qiieue>, padr\'e3o. Cont\'eaineres s\'e3o usados para armazenar dados durante a execu\'e7\'e3o de um <stack>,<zmap>, programa. Discutimos estes arquivos de cabe\'e7alho no cap\'edtulo intitulado \ldblquote A <set>,<bitset> biblioteca padr\'e3o de gabaritos\rdblquote . \line F\'edg. 3.6 Arquivos de cabe\'e7alho da biblioteca padr\'e3o (parte 1 de 2). \fs24\par
\pard\par
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2848\pard\intbl\b\f2\fs20 Arquivo de cabe\'e7alho \b0\f0\fs24\cell\fs20\row
\b\f2\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2848\intbl da biblioteca padr\'e3o Explica\'e7\'e3o \b0\f0\fs24\cell\fs20\row
\pard\fs24\par
\pard\sb100\sa240\b\fs16 CAP\'cdTULO \b0\fs20 3 \f2\fs8 - \b\f0\fs16 FUN\'c7\'d5ES \f2\fs22 199 \b0\f0\fs24\par
\fs20 quando o tipo de um argumento n\'e3o corresponde ao tipo do par\'e2metro especificado na defini\'e7\'e3o da fun\'e7\'e3o. A Fig. 3.5 lista os tipos de dados, classificados do \ldblquote maior tipo\rdblquote  para o \ldblquote menor tipo\rdblquote . \line\f2 Tipos de dados \f0\fs24\par
\f2\fs20 Fig. 3.5 Hierarquia de promo\'e7\'e3o para os tipos de dados primitivos. \line\f0\fs18 Converter valores para tipos inferiores pode resultar em valores incorretos. Portanto, um valor s\'f3 pode ser convertido para um tipo inferior atribuindo-se explicitamente o valor a uma vari\'e1vel do tipo inferior ou usando-se um operador de coer\'e7\'e3o. Os valores dos argumentos da fun\'e7\'e3o s\'e3o convertidos para os tipos dos par\'e2metros de seu prot\'f3tipo se forem atribu\'eddos diretamente a vari\'e1veis daqueles tipos. Se nossa fun\'e7\'e3o square que usa um par\'e2metro inteiro (Fig. 3.3) fosse chamada com um argumento de ponto flutuante, este seria convertido para int (um tipo inferior), e normalmente square retornaria um valor incorreto. Por exemplo, square ( 4 \f2\fs8 . \b\f3\fs18 5 \b0\f0 ) retornaria 16 e n\'e3o 20.25. \line\b\i\fs20 Erro comum de programa\'e7\'e3o 3.14 \line Converter \b0\fs18 de um tipo superior de dados em uma hierarquia de promo\'e7\'e3o para um tipo inferior pode modificar o valor dos dados. \line\b\fs20 Erro comum de programa\'e7\'e3o 3.15 \line\b0\fs18 Esquecer um prot\'f3tipo de fun\'e7\'e3o causa um erro de sintaxe se a defini\'e7\'e3o daquela fun\'e7\'e3o aparecer depois de sua chamada no programa. \line Observa\'e7\'e3o de engenharia de software 3.10 \line\i0\f2\fs8 ______ \i\f0\fs18 Um prot\'f3tipo de fun\'e7\'e3o colocado fora de qualquer defini\'e7\'e3o de fun\'e7\'e3o se aplica a todas as chamadas daquela fun\'e7\'e3o que aparecem depois de seu prot\'f3tipo no arquivo. Um prot\'f3tipo de fun\'e7\'e3o colocado dentro de uma fun\'e7\'e3o se aplica somente \'e0s chamadas realizadas naquela fun\'e7\'e3o. \line\b\i0\f2\fs26 3.7 Arquivos de cabe\'e7alho \line\b0\f0\fs18 Cada biblioteca padr\'e3o tem um \i arquivo de cabe\'e7alho \i0 correspondente, contendo os prot\'f3tipos de todas as fun\'e7\'f5es daquela biblioteca e defini\'e7\'f5es dos v\'e1rios tipos de dados e constantes necess\'e1rios por elas. A Fig. 3.6 lista alguns arquivos de cabe\'e7alho comuns da biblioteca padr\'e3o C++ que poderiam ser inclu\'eddos em programas C++. O termo \ldblquote macros\rdblquote , que \'e9 usado diversas vezes na Fig. 3.6, \'e9 discutido em detalhes no Cap\'edtulo 17, \ldblquote O pr\'e9-processador\rdblquote . Os arquivos de cabe\'e7alho que terminam em \f2\fs8 . \f0\fs18 h s\'e3o arquivos de cabe\'e7alho no \ldblquote estilo antigo\rdblquote , que foram substitu\'eddos pelos arquivos de cabe\'e7alho da biblioteca padr\'e3o C++. \line O programador pode criar arquivos de cabe\'e7alho personalizados. Os nomes dos arquivos de cabe\'e7alho definidos pelo programador tamb\'e9m devem terminar com h. Um arquivo de cabe\'e7alho definido pelo programador pode \fs24\par
\pard\par
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1194\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1597\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx3758\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4835\pard\intbl\b\fs16 long double \b0\fs24\cell\cell\cell\cell\fs20\row
\b\fs16\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1194\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1597\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx3758\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4835\intbl double \b0\fs24\cell\cell\cell\cell\fs20\row
\b\f3\fs18\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1194\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1597\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx3758\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4835\intbl float \b0\f0\fs24\cell\cell\cell\cell\fs20\row
\b\fs16\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1194\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1597\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx3758\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4835\intbl unsigned long \b0\fs24\cell\b\fs16 int \b0\fs24\cell\b\fs16 (sin\'f4nimo de unsigned \b0\fs24\cell\b\fs16 long) \b0\fs24\cell\fs20\row
\b\f3\fs18\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1194\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1597\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx3758\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4835\intbl long int \b0\f0\fs24\cell\cell\b\f3\fs18 (sin\'f4nimo de long) \b0\f0\fs24\cell\cell\fs20\row
\b\fs16\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1194\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1597\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx3758\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4835\intbl unsigned int \b0\fs24\cell\cell\b\fs16 (sin\'f4nimo de unsigned) \b0\fs24\cell\cell\fs20\row
\b\fs16\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1194\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1597\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx3758\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4835\intbl int \b0\fs24\cell\cell\cell\cell\fs20\row
\b\fs16\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1194\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1597\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx3758\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4835\intbl uns igned short \b0\fs24\cell\b\fs16 int \b0\fs24\cell\b\fs16 (sin\'f4nimo de unsigned \b0\fs24\cell\b\fs16 short) \b0\fs24\cell\fs20\row
\b\fs16\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1194\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1597\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx3758\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4835\intbl short int \b0\fs24\cell\cell\b\fs16 (sin\'f4nimo de short) \b0\fs24\cell\cell\fs20\row
\b\fs16\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1194\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1597\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx3758\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4835\intbl unsigned \f3\fs18 char \b0\f0\fs24\cell\cell\cell\cell\fs20\row
\b\f3\fs18\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1194\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1597\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx3758\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4835\intbl char \b0\f0\fs24\cell\cell\cell\cell\fs20\row
\intbl bool \fs24\cell\cell\b\f3\fs18 (false \b0\f0 toma-se O, true \fs24\cell\fs20 torna-se 1) \fs24\cell\fs20\row
\pard\fs24\par
\pard\sb100\sa240\b\f2\fs18 198 C++ COMO PROGRAMAR \b0\f0\fs24\par
\fs18 O prot\'f3tipo da fun\'e7\'e3o maximum na Fig. 3.4 \'e9 \line int maximum( int, int, \b\f3\fs16 int ); \line\b0\f0\fs18 Esse prot\'f3tipo de fun\'e7\'e3o declara que maximum utiliza tr\'eas argumentos do tipo int e retorna um resultado do tipo int. Observe que o prot\'f3tipo da fun\'e7\'e3o \'e9 id\'eantico \'e0 primeira linha da defini\'e7\'e3o da fun\'e7\'e3o maximum, exceto pelo fato de que os nomes dos par\'e2metros (x, y e z) n\'e3o s\'e3o inclu\'eddos. \line\b\i\fs20 Boa pr\'e1tica de programa\'e7\'e3o 3.5 \line\b0\fs18 Muitos programadores usam nomes de par\'e2metros nos prot\'f3tipos de fun\'e7\'e3o para fins de documenta\'e7\'e3o. O \line compilador ignora esses nomes. \line\b\fs20 Erro \b0\fs18 comum de programa\'e7\'e3o 3.11 \line Esquecer o ponto-e-v\'edrgula no final de um prot\'f3tipo defin\'e7\'e3o causa um erro de sintaxe. \line\i0 A parte do prot\'f3tipo de uma fun\'e7\'e3o que inclui o nome da fun\'e7\'e3o e os tipos dos seus argumentos \'e9 chamada de \i assinatura da fun\'e7\'e3o \i0 ou, simplesmente, \i assinatura. \i0 A assinatura da fun\'e7\'e3o n\'e3o inclui o tipo do valor devolvido pela fun\'e7\'e3o. \line\b\i\fs20 IErro comum de programa\'e7\'e3o 3.12 \line\b0\fs18 Uma chamada de fun\'e7\'e3o que n\'e3o corresponde ao prot\'f3tipo da fun\'e7\'e3o \'e9 um erro de sintaxe. \line\b\fs20 Erro comum de programa\'e7\'e3o 3.13 \line\b0\i0\f1\fs24\'c9 \i\f0\fs18 um erro de sintaxe se o prot\'f3tipo da fun\'e7\'e3o e a defini\'e7\'e3o da mesma estiverem em desacordo. \line\i0 Por exemplo, na Fig. 3.4, se o prot\'f3tipo da fun\'e7\'e3o tivesse sido escrito como \line\b\f3\fs16 void rnaximum( int, int, int ); \line\b0\f0\fs18 o compilador acusaria um erro, porque o tipo de retorno void no prot\'f3tipo da fun\'e7\'e3o difere do tipo de retorno int no cabe\'e7alho da fun\'e7\'e3o. \line Outro recurso importante dos prot\'f3tipos de fun\'e7\'f5es \'e9 a \i coer\'e7\'e3o de argumentos, \i0 ou seja, a imposi\'e7\'e3o do tipo apropriado aos argumentos. Por exemplo, a fun\'e7\'e3o sqrt da biblioteca matem\'e1tica pode ser chamada com um argumento inteiro e a fun\'e7\'e3o funcionar\'e1 corretamente, embora o prot\'f3tipo da fun\'e7\'e3o em <cmath> especifique um argumento double. O comando \line\b\f3\fs16 cout \b0\f0\fs18\'ab \b\f3\fs16 sqrt( 4 ); \line\b0\f0\fs18 calcula corretamente sqrt \b\i\fs20 ( 4 ) \b0\i0\fs18 e imprime o valor 2. O prot\'f3tipo da fun\'e7\'e3o faz com que o compilador converta o valor do argumento inteiro \b\i\fs20 4 \b0\i0\fs18 para o valor double \b\i\fs20 4 \b0\i0\f2\fs8 . \f0\fs18 O antes do mesmo ser passado para sqrt \f2\fs8 . \f0\fs18 Em geral, os valores de argumentos que n\'e3o correspondem precisamente aos tipos de par\'e2metros no prot\'f3tipo da fun\'e7\'e3o s\'e3o convertidos para o tipo apropriado antes de a fun\'e7\'e3o ser chamada. Essas convers\'f5es podem levar a resultados incorretos se as \i regras de promo\'e7\'e3o \i0 de C++ n\'e3o forem obedecidas. As regras de promo\'e7\'e3o especificam como tipos de dados podem ser convertidos para outros tipos sem perda dos dados. Em nosso exemplo sqrt anterior, um int \'e9 convertido automaticamente em double sem modifica\'e7\'e3o de seu valor. Entretanto, um double convertido a um int trunca a parte fracion\'e1ria do valor double. Converter tipos inteiros grandes para tipos inteiros pequenos (p.ex., long para short) tamb\'e9m pode resultar em valores modificados. \line As regras de promo\'e7\'e3o s\'e3o aplicadas automaticamente a express\'f5es que cont\'eam valores de dois ou mais tipos \line de dados (tamb\'e9m chamadas de \i express\'f5es de tipo misto). \i0 O tipo de cada valor em uma express\'e3o de tipo misto \'e9 \line promovido automaticamente para o tipo m\'e1ximo na express\'e3o (na realidade, uma vers\'e3o tempor\'e1ria de cada valor \'e9 \line criada e usada na express\'e3o \f2\fs8 - \f0\fs18 os valores originais permanecem inalterados). Um outro uso comum da promo\'e7\'e3o \'e9 \fs24\par
\b\fs16 CAP\'cdTULO \b0\fs20 3 \f2\fs8 - \b\f0\fs16 FUN\'c7\'d5ES \f2\fs20 197 \b0\f0\fs24\par
\b\f3\fs16 int max \b0\f2\fs12 = \f0\fs24\par
\b\f3\fs16 if \f2\fs20 ( \f3\fs16 y > max max \b0\f2\fs12 = \f0\fs24\par
\b\f3\fs18 if \f2\fs20 ( \f3\fs18 z > maz) max z; \b0\f0\fs24\par
\b\f3\fs18 38 return max; \b0\f0\fs24\par
\b\fs16 39 \f2\fs18\} \b0\f0\fs24\par
\f2\fs14 [ \f0\fs24\par
\fs18 Os tr\'eas inteiros s\'e3o digitados. A seguir. os inteiros s\'e3o passados para \b maximum. \b0 que determina o maior inteiro. Este valor \'e9 devolvido a \b\f3 main \b0\f0 pelo comando return em maximurn. O valor devolvido \'e9, ent\'e3o, impresso. \fs24\par
\b\f2\fs26 3.6 Prot\'f3tipos de fun\'e7\'f5es \b0\f0\fs24\par
\fs18 Um dos recursos mais importantes de C+\'f7 \b\'e9 \b0 o \i prot\'f3tipo de fun\'e7\'e3o. \i0 Um prot\'f3tipo de fun\'e7\'e3o diz ao compilador o nome da fun\'e7\'e3o, o tipo dos dados retornados pela fun\'e7\'e3o, o n\'famero de par\'e2metros que a fun\'e7\'e3o espera receber, os tipos dos par\'e2metros e a ordem na qual esses par\'e2metros s\'e3o esperados. O compilador usa prot\'f3tipos de fun\'e7\'f5es para validar as chamadas de fun\'e7\'f5es. As vers\'f5es anteriores de C++ n\'e3o realizavam esse tipo de verifica\'e7\'e3o; portanto, era poss\'edvel chamar fun\'e7\'f5es de forma inadequada sem que o compilador detectasse os erros. Tais chamadas poderiam levar a erros fatais durante a execu\'e7\'e3o ou a erros n\'e3o-fatais que causavam erros l\'f3gicos sutis e dif\'edceis de detectar. Os prot\'f3tipos de fun\'e7\'f5es corrigem essa defici\'eancia. \fs24\par
\i\fs18 seiva \'e7\'e3o le adesoftware38 \i0\fs24\par
\i\fs18 Prot\'f3tipos de fun\'e7\'f5es s\'e3o obrigat\'f3rios em C++. Use diretivas \b\i0 #include \b0\i dopr\'e9-processadorpara obter prot\'f3tipos de todas as fun\'e7\'f5es da biblioteca padr\'e3o a partir dos arquivos de cabe\'e7alho das bibliotecas apropriadas. Use tamb\'e9m \b\i0 #include \b0\i para obter os arquivos de cabe\'e7alho que cont\'eam os prot\'f3tipos de fun\'e7\'f5es usados por voc\'ea ou pelos membros de sua equipe. \i0\fs24\par
\i\fs16 Observa\'e7\'e3o de engenharia de software \b\f2\fs20 3.9 \line\b0\i0\fs14 ______ \i\f0\fs16 Um prot\'f3tipo de fun\'e7\'e3o n\'e3o \'e9 obrigat\'f3rio se a defini\'e7\'e3o da fun\'e7\'e3o aparece antes do primeiro uso da fun\'e7\'e3o no programa. Em tal caso, a defini\'e7\'e3o da fun\'e7\'e3o tamb\'e9m serve como o prot\'f3tipo da fun\'e7\'e3o. \i0\fs24\par
\b\f2\fs20 // \f3\fs18 Defini\'e7\'e3o da fun\'e7\'e3o maximuiu \line\i\f2\fs20 1/ \i0\f3\fs18 x, y e z, abaixo, s\'e3o par\'e2metros \line\b0\i\f0 li \b\i0\f3 para a defini\'e7\'e3o da fun\'e7\'e3o maximum \line int maximum( int x, int y, int z \b0\f0\fs24\par
\b\fs16 25 \line 26 \line\f3\fs18 27 \line 28 \line 29 \line 30 \line\f0\fs16 31 \line\b0\fs20 32 \line\b\fs16 33 \line 34 \line 35 \line 36 \line 37 \b0\fs24\par
\b\f2\fs18 Fg. \b0 3.4 \b\f0 Fun\'e7\'e3o maximum \b0\f2 definida pelo programador (parte 2 de 2). \f0\fs24\par
\pard\par
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx974\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx3676\pard\intbl\b\f3\fs18 Forne\'e7a \b0\f0\fs24\cell\b\f3\fs18 tr\'eas inteiros: 22 85 17 \b0\f0\fs24\cell\fs20\row
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx217\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx974\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2325\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx3676\pard\intbl\b\f3\fs18 O \b0\f0\fs24\cell\b\f3\fs18 maior \b0\f0\fs24\cell\b\f3\fs18\'e9: \b0\f0\fs24\cell\b\f3\fs18 85 \b0\f0\fs24\cell\fs20\row
\pard\sa240\fs24\par
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx974\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx3676\pard\intbl\b\f3\fs18 Forne\'e7a \b0\f0\fs24\cell\b\f3\fs18 tr\'eas inteiros: 92 35 14 \b0\f0\fs24\cell\fs20\row
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx217\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx974\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2325\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx3676\pard\intbl\b\f3\fs18 O \b0\f0\fs24\cell\b\f3\fs18 maior \b0\f0\fs24\cell\b\f3\fs18\'e9: \b0\f0\fs24\cell\b\f3\fs18 92 \b0\f0\fs24\cell\fs20\row
\pard\sa240\fs24\par
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx974\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx3676\pard\intbl\b\f3\fs18 Forne\'e7a \b0\f0\fs24\cell\b\f3\fs18 tr\'eas inteiros: 45 19 98 \b0\f0\fs24\cell\fs20\row
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx217\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx974\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2325\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx3676\pard\intbl\b\f3\fs18 O \b0\f0\fs24\cell\b\f3\fs18 maior \b0\f0\fs24\cell\b\f3\fs18\'e9: \b0\f0\fs24\cell\b\f3\fs18 98 \b0\f0\fs24\cell\fs20\row
\pard\fs24\par
\pard\sb100\sa240\b\f2\fs22 196 C++ \fs14 COMO PROGRAMAR \line\b0\i\fs20 Observa\'e7\'e3o de \f0\fs16 engenharia \f2\fs20 de \f0\fs16 software 3.6 \line\i0\f2\fs8 _______ \i\fs20 Os \f0\fs16 programas devem ser escritos como conjuntos de pequenas fun\'e7\'f5es. Isso torna os programas mais f\'e1ceis de escrever; depurar manter e modificar \line\f2\fs20 Observa\'e7\'e3o de \f0\fs16 engenharia \f2\fs20 de software 3.7 \line\f0\fs16 Uma fun\'e7\'e3o que exige um grande n\'famero de par\'e2metros pode estar realizando tarefas demais. Pense na possibilidade de dividir a fun\'e7\'e3o em fun\'e7\'f5es menores, que realizem tarefas separadas. O cabe\'e7alho da fun\'e7\'e3o deveria estar contido em uma linha, se poss\'edvel. \line Erro comum de programa\'e7\'e3o 3.10 \line\i0\f1\fs26\'c9 \i\f0\fs16 um erro de sintaxe se o prot\'f3tipo da fun\'e7\'e3o, o arquivo de cabe\'e7alho e as chamadas da fun\'e7\'e3o n\'e3o concordarem quanto ao n\'famero, tipo e ordem dos argumentos e par\'e2metros e quanto ao tipo do valor de retorno. \line\i0\fs18 H\'e1 tr\'eas maneiras de retomar controle para o ponto no qual uma fun\'e7\'e3o foi chamada. Se a fun\'e7\'e3o n\'e3o fornecer um valor como resultado, o controle \'e9 retomado simplesmente quando a chave que indica o t\'e9rmino da fun\'e7\'e3o \'e9 alcan\'e7ada, ou ao se executar o comando \line return; \line Se a fun\'e7\'e3o fomecer um valor como resultado, o comando \line return \i\fs16 express\'e3o; \line\i0\fs18 retorna o valor de \i\fs16 express\'e3o \i0\fs18 para a fun\'e7\'e3o que realizou a chamada. \line Nosso segundo exemplo utiliza uma fun\'e7\'e3o definida pelo programador, denominada \b maximum, \b0 para determinar e devolver o maior entre tr\'eas inteiros (Fig. 3.4). \line\b\f3\fs16 1 \b0\i\f0 II \b\i0\f3 Fig. 3.4: figO3O4.cpp \line 2 \b0\i\f0 /1 \b\i0\f3 Encontrar o maior de tr\'eas inteiros \line 3 #include <iostreaxn> \line 4 \line 5 using std: :cout; \line 6 using std: :cin; \line 7 using std: :endl; \line 8 \line 9 int maximum \b0\i\f0 ( \b\i0\f3 int, int, int ); \b0\i\f0 II \b\i0\f3 prot\'f3tipo da fun\'e7\'e3o \line 10 \line 11 int main \f0\fs18 O \line\f3\fs16 12 \line 13 int a, b, c; \line 14 \line 15 cout \'ab Forne\'e7a tr\'eas inteiros: \line 16 cin\'bba\'bbb\'bbc; \line 17 \line 18 \b0\i\f0 II \b\i0\f3 a, b e c, abaixo, s\'e3o argumentos \line 19 \b0\i\f0 II \b\i0\f3 para a chamada da fun\'e7\'e3o maximum \line 20 cout \'ab \ldblquote O maior \'e9: \b0\f2\fs8\ldblquote  \b\f3\fs16\'ab maximum( a, b, c \b0\i\f0 ) \b\i0\f3\'ab endi; \line 21 \line 22 return 0; \line 23 \b0\i\f0\} \line\b\i0\f3 24 \line\f2\fs18 Fig. 3.4 \f0 Fun\'e7\'e3o maximum \b0\f2\fs20 definida pelo programador (parte 1 de 2). \f0\fs24\par
\b\fs14 CAP\'cdTULO \b0\fs20 3 \f2\fs8 - \b\f0\fs14 FUN\'c7\'d5ES \f2\fs22 195 \line\b0\i\f0\fs18 Erro comum de programa\'e7\'e3o 3.3 \line Esquecer de retornar um valor de uma fun\'e7\'e3o que deve faz\'ea-lo \'e9 erro de sintaxe. \line Erro comum de programa\'e7\'e3o \b\f2\fs20 3.4 \line\b0\f0\fs18 Retornar um valor de uma fun\'e7\'e3o cujo tipo de retorno foi declarado \i0\fs20 void \i\fs18 causa um erro de sintaxe. \line\i0\fs20 A \i\fs18 lista de par\'e2metros \i0\fs20\'e9 uma lista separada por v\'edrgulas, contendo as declara\'e7\'f5es dos par\'e2metros recebidos pela fun\'e7\'e3o quando ela \'e9 chamada. Se uma fun\'e7\'e3o n\'e3o recebe nenhum valor, a \i\fs18 lista de par\'e2metros \i0\fs20\'e9 void ou simplesmente \'e9 deixada vazia. Deve ser listado, explicitamente, um tipo para cada par\'e2metro na lista de par\'e2metros de uma fun\'e7\'e3o. \line\i\fs18 Erro comum de programa\'e7\'e3o 3.5 \line Declarar par\'e2metros da fun\'e7\'e3o do mesmo tipo como \i0\fs20 float x, y \i\fs18 em vez de \i0\fs20 float x, float y. A \i\fs18 declara\'e7\'e3o de par\'e2metros \i0\fs20 float \i\fs18 x, y geraria na realidade um erro de compila\'e7\'e3o, porque os tipos s\'e3o obrigat\'f3rios para cada par\'e2metro na lista de par\'e2metros. \line Erro comum de \b\fs20 programa\'e7\'e3o \b0\fs18 3.6 \line Colocar um ponto e v\'edrgula ap\'f3s o par\'eantese direito, ao encerrar a lista de par\'e2metros de uma defini\'e7\'e3o \line de fun\'e7\'e3o, \'e9 um erro de sintaxe. \line\b\fs20 Erro comum de programa\'e7\'e3o 3.7 \line\b0\fs18 Definir um par\'e2metro de fun\'e7\'e3o novamente como vari\'e1vel local dentro da fun\'e7\'e3o \'e9 um erro de sintaxe. \line\b\fs20 Boa pr\'e1tica de programa\'e7\'e3o 3.3 \line\b0\fs18 Embora n\'e3o seja incorreto faz\'ea-lo, n\'e3o use os mesmos nomes para os argumentos passados para uma \line fun\'e7\'e3o e os par\'e2metros correspondentes na defini\'e7\'e3o da fun\'e7\'e3o. Isso ajuda a evitar ambig\'fcidades. \line Erro \b\fs20 comum de programa\'e7\'e3o \b0\fs18 3.8 \line Os O em uma chamada de fun\'e7\'e3o s\'e3o, na realidade, um operador de C++. Eles fazem com que afun\'e7\'e3o seja chamada. Esquecer os O em uma chamada de fun\'e7\'e3o que n\'e3o aceita argumentos n\'e3o \'e9 um erro de sintaxe. A fun\'e7\'e3o n\'e3o \'e9 invocada quando voc\'ea provavelmente pretendia que ela fosse. \line As declara\'e7\'f5es \i0\fs20 e os \i\fs18 comandos \i0\fs20 entre chaves formam o \i\fs18 corpo da fun\'e7\'e3o, \i0\fs20 tamb\'e9m chamado de \i\fs18 bloco. \i0\fs20 Um bloco \'e9 simplesmente um comando composto que inclui declara\'e7\'f5es. As vari\'e1veis podem ser declaradas em qualquer bloco e os blocos podem estar aninhados. \i\fs18 Uma fim\'e7\'e3o n\'e3o pode ser definida no interior de outra fun\'e7\'e3o sob quaisquer circunst\'e2ncias. \line\ul Erro comum de programa\'e7\'e3o \b\fs20 3.9 \ulnone\line\b0\fs18 Definir uma fun\'e7\'e3o dentro de outra fun\'e7\'e3o \'e9 um erro de sintaxe. \line Boa pr\'e1tica de programa\'e7\'e3o \b\fs20 3.4 \line\b0\fs18 Escolher nomes significativos para fun\'e7\'f5es e par\'e2metros torna os programas mais leg\'edveis e ajuda a \line evitar o uso excessivo de coment\'e1rios. \line Observa\'e7\'e3o de engenharia de software \b\fs20 3.5 \line\b0\fs18 Uma fun\'e7\'e3o deveria caber inteira na janela de um editor. Independentemente de qu\'e3o longa seja \line uma fun\'e7\'e3o, ela deveria executar bem uma tarefa. Fun\'e7\'f5es pequenas favorecem a reutiliza\'e7\'e3o do software. \i0\fs24\par
\b\f2\fs22 194 \b0\fs20 C++ \f0\fs16 COMO \b\f2\fs14 PROGRAMAR \line\f3\fs16 16 return 0; \line 17 \line 18 \line 19 \b0\i\f0\fs18 /1 \b\i0\f3\fs16 Defini\'e7\'e3o da fun\'e7\'e3o \line 20 int square( int y \line 21 \f2\fs22\{ \line\f3\fs16 22 return y \b0\f2\fs12 * \b\f3\fs16 y; \line 23 \f2\fs22\} \b0\f0\fs24\par
\b\f3\fs16 1 4 9 16 25 36 49 64 81 100 \b0\f0\fs24\par
\f2\fs20 Fig. 3.3 Criando e usando uma fun\'e7\'e3o definida pelo programador (parte 2 de 2). \line\i\f0\fs18 Boa pr\'e1tica de programa\'e7\'e3o 3.2 \line Coloque uma linha em branco entre as defini\'e7\'f5es das fun\'e7\'f5es para separ\'e1-las e melhorar a legibilidade \line do programa. \line\i0 A fun\'e7\'e3o square \i\'e9 chamada \i0 ou \i invocada \i0 em main com o comando \line square( \b\f3\fs16 x \line\b0\f0\fs18 A fun\'e7\'e3o square recebe uma c\'f3pia do valor de x no \i par\'e2metro \i0 y. Ent\'e3o, square calcula y \f2\fs12 * \f0\fs18 y. O resultado \'e9 \line passado de volta para o ponto em main onde square foi chamada. Esse processo \'e9 repetido dez vezes, usandos-se \line a estrutura de repeti\'e7\'e3o for. \line A defini\'e7\'e3o de square mostra que ela espera receber um par\'e2metro inteiro y. A palavra- chave int antes do \line nome da fun\'e7\'e3o indica que square retorna um resultado inteiro, O comando return em square passa o resultado do c\'e1lculo de volta para a fun\'e7\'e3o chamadora. \line A linha 8 \line int square(int); \i II \i0 prot\'f3tipo da fun\'e7\'e3o \line\'e9 um \i prot\'f3tipo de fun\'e7\'e3o. \i0 O tipo de dados int entre par\'eanteses informa ao compilador que \b square \b0 espera receber um valor inteiro da fun\'e7\'e3o que faz a chamada. O tipo de dados int \'e0 esquerda do nome da fun\'e7\'e3o square informa ao compilador que square retorna um resultado inteiro \'e0 fun\'e7\'e3o que faz a chamada. O compilador consulta o prot\'f3tipo da fun\'e7\'e3o para verificar se as chamadas de square cont\'eam o tipo correto do valor de retorno, o n\'famero correto de argumentos e os tipos corretos dos argumentos e se os argumentos est\'e3o na ordem correta, O prot\'f3tipo da fun\'e7\'e3o n\'e3o \'e9 requerido se a defini\'e7\'e3o da fun\'e7\'e3o aparece antes do primeiro uso da fun\'e7\'e3o no programa. Em um caso assim, a defini\'e7\'e3o da fun\'e7\'e3o tamb\'e9m funciona \line como prot\'f3tipo da fun\'e7\'e3o. Se as linhas 20 a 23, na Fig. 3.3, estivessem antes de main, o prot\'f3tipo da fun\'e7\'e3o \i de \line\i0 na linha 8 seria desnecess\'e1rio. Os prot\'f3tipos de fun\'e7\'f5es s\'e3o analisados com mais detalhes na Se\'e7\'e3o 3.6. slmpl( \line O formato de uma defini\'e7\'e3o de fun\'e7\'e3o \'e9 eos bI \line\i circun \line tipo do valor de retorno nome da fun\'e7\'e3o (lista de par\'e2metros) \line declara\'e7\'f5es e comandos \line\i0 O \i nome da fun\'e7\'e3o \i0\'e9 qualquer identificador v\'e1lido. O \i tipo do valor de retorno \i0\'e9 o tipo de dado do resultado devolvido pela fun\'e7\'e3o que fez a chamada. Um \i tipo do valor de retorno \i0 void indica que a fun\'e7\'e3o n\'e3o retorna um valor. \line\i Erro comum de programa\'e7\'e3o 3.2 \line Omitir o tipo do valor de retorno em uma defini\'e7\'e3o de fun\'e7\'e3o \'e9 um erro de sintaxe. \line\b\i0\f3\fs16 u \b0\f0\fs24\par
\b\fs14 CAP\'cdTULO \b0\fs18 3 \f2\fs8 - \b\f0\fs14 FUN\'c7\'d5ES \f2\fs22 193 \line 3.4 Fun\'e7\'f5es \line\b0\f0\fs18 As fun\'e7\'f5es permitem ao programador modularizar um programa. Todas as vari\'e1veis declaradas em defini\'e7\'f5es de fun\'e7\'e3o s\'e3o \i vari\'e1veis locais \i0\f2\fs8 - \f0\fs18 elas s\'f3 s\'e3o conhecidas na fun\'e7\'e3o na qual s\'e3o definidas. A maioria das fun\'e7\'f5es tem uma lista de \i par\'e2metros \i0 que prov\'eaem os meios para transferir informa\'e7\'f5es entre fun\'e7\'f5es. Os par\'e2metros de uma fun\'e7\'e3o tamb\'e9m s\'e3o vari\'e1veis locais. \line\i Observa\'e7\'e3o de engenharia de soflware 3.2 \line\i0\f2\fs8 ______ \i\f0\fs18 Em programas que cont\'eam muitas fun\'e7\'f5es, main deveria ser implementada como um grupo de chamadas afiw\'e7\'f5es que executam o \ldblquote grosso\rdblquote  do trabalho do programa. \line\i0 Existem v\'e1rias motiva\'e7\'f5es para se \ldblquote funcionalizar\rdblquote  um programa. A abordagem dividir para conquistar toma o desenvolvimento de programas mais administr\'e1vel. Uma outra motiva\'e7\'e3o \'e9 a \i reutiliza\'e7\'e3o de software \i0\f2\fs8 - \f0\fs18 usar fun\'e7\'f5es existentes como blocos de constru\'e7\'e3o para criar programas novos. A capacidade de reutiliza\'e7\'e3o do software \'e9 um dos fatores mais importantes para a programa\'e7\'e3o orientada a objetos. Com boa defini\'e7\'e3o e nomenclatura das fun\'e7\'f5es, os programas podem ser criados a partir de fun\'e7\'f5es padronizadas que realizem tarefas espec\'edficas, em vez de serem constru\'eddos usando c\'f3digo personalizado. Um terceiro motivo \'e9 evitar a repeti\'e7\'e3o de c\'f3digo em um programa. Incluir c\'f3digo em uma fun\'e7\'e3o permite que ele seja executado em v\'e1rios locais de um programa simplesmente chamando a fun\'e7\'e3o. \line\i Observa\'e7\'e3o de engenharia de software 3.3 \line\i0\f2\fs8 ______ \i\f0\fs18 Cada fun\'e7\'e3o deve se limitar a realizar uma tarefa simples e bem-definida e o nome da fun\'e7\'e3o deve expressar efetivamente aquela tarefa. Isto promove a reutiliza\'e7\'e3o do software. \line\ul IObserva\'e7\'e3o \ulnone de engenharia de software 3.4 \line\i0\f2\fs12 ______ \i\f0\fs18 Se voc\'ea n\'e3o puder escolher um nome conciso que expresse o que a fun\'e7\'e3o faz, \'e9 poss\'edvel que sua fun\'e7\'e3o esteja tentando realizar muitas tarefas diferentes. Normalmente, \'e9 melhor dividir tal fun\'e7\'e3o em v\'e1rias \line fun\'e7\'f5es menores. \line\b\i0\f2\fs26 3.5 Defini\'e7\'f5es de fun\'e7\'f5es \line\b0\f0\fs18 Cada programa que apresentamos consiste em uma fun\'e7\'e3o denominada main que chamou as fun\'e7\'f5es da biblioteca padr\'e3o para realizar suas tarefas. Agora, vamos analisar como os programadores escrevem suas pr\'f3prias fun\'e7\'f5es personalizadas. \line Considere um programa que use a fun\'e7\'e3o \b square \b0 para calcular os quadrados dos n\'fameros inteiros de 1 a 10 \line (Fig. 3.3). \line\b\f3\fs16 1 \b0\i\f0\fs20 II \b\i0\f3\fs16 Fig. 3.3: figO3O3.cpp \line 2 \b0\f0\fs18 // \b\f3\fs16 Criando e usando \b0\f0\fs18 uma \b\f3\fs16 fun\'e7\'e3o definida pelo programador \line 3 #include <iostream> \line 5 using std: :cout; \line 6 using std: :endl; \line 8 int square( int ); \b0\f0\fs18 // \b\f3\fs16 prot\'f3tipo da fun\'e7\'e3o \line\f0\fs14 9 \line\f3\fs16 10 int main() \line 11 \line 12 for \b0\f0\fs18 ( \b\f3\fs16 int x \b0\f2\fs10 = \b\f3\fs16 1; x \f0\fs14 < \f3\fs16 10; x++ \line 13 cout \'ab square \b0\f0\fs18 ( \b\f3\fs16 x \b0\f0\fs18 ) \'ab \line\b\f3\fs16 15 cout \'ab endl; \line\f2\fs18 Fig. 3.3 \b0\fs20 Criando e usando uma fun\'e7\'e3o definida pelo programador (parte 1 de 2). \f0\fs24\par
\pard\par
\pard\sb100\sa240\b\fs16 CAP\'cdTULO \b0\fs18 3 \f2\fs8 - \b\f0\fs16 FUN\'c7\'d5ES \b0\fs18 225 \line em um cabe\'e7alho de fun\'e7\'e3o pode ser lida como\rdblquote  count \'e9 uma refer\'eancia para um int\rdblquote . Na chamada da fun\'e7\'e3o, simplesmente mencione o nome da vari\'e1vel e ela ser\'e1 passada por refer\'eancia. Ent\'e3o, mencionar a vari\'e1vel pelo nome do seu par\'e2metro, no corpo da fun\'e7\'e3o chamada, na realidade faz uma refer\'eancia \'e0 vari\'e1vel original na fun\'e7\'e3o que chamou e a vari\'e1vel original pode ser modificada diretamente pela fun\'e7\'e3o chamada. Como sempre, o prot\'f3tipo e o cabe\'e7alho da fun\'e7\'e3o devem estar de acordo. \line A Fig. 3.20 compara a chamada por valor e a chamada por refer\'eancia com par\'e2metros passados por refer\'eancia. Os \ldblquote estilos\rdblquote  dos argumentos nas chamadas a squareByValue e squareByReference s\'e3o id\'eanticos, ou seja, ambas as vari\'e1veis s\'e3o simplesmente referidas por nome. Sem verificar prot\'f3tipos ou defini\'e7\'f5es de fun\'e7\'f5es, n\'e3o \'e9 poss\'edvel dizer, somente com base nas chamadas, se as fun\'e7\'f5es podem modificar seus argumentos. Por\'e9m, como os prot\'f3tipos de fun\'e7\'e3o s\'e3o obrigat\'f3rios, o compilador n\'e3o tem problemas para resolver a ambig\'fcidade. \line\i Erro comum de programa\'e7\'e3o 3.26 \line Como par\'e2metros por refer\'eancia s\'e3o referidos somente por nome no corpo da fun\'e7\'e3o chamada, o programador pode, inadvertidamente, tratar par\'e2metros passados por refer\'eancia como par\'e2metros passados por valor. isto pode ocasionar efeitos colaterais inesperados, se as c\'f3pias originais das vari\'e1veis s\'e3o alteradas pela fun\'e7\'e3o que est\'e1 chamando. \line\b\i0\f3\fs16 1 //Fig. 3.20: figO32O.cpp \line 2 //Comparando \b0\f0\fs18 uma \b\f3\fs16 chamada por valor com \b0\f0\fs18 uma \b\f3\fs16 chamada por refer\'eancia \line 3 \b0\f0\fs18 // \b\f3\fs16 com refer\'eancias. \line 4 #include <iostream> \line\f2\fs18 5 \line\f3\fs16 using std::cout; \line using std::endl; \line int squareByValue( int ); \line void squareByReference \b0\f0\fs18 ( \b\f3\fs16 int & ); \line int main() \line int x \b0\f2\fs10 = \b\f3\fs16 2, z \b0\f2\fs10 = \b\f3\fs16 4; \b0\f0\fs24\par
\b\f3\fs16 6 \line 7 \line 8 \line 9 \line 10 \line 11 \line 12 \line 13 \line 14 \line 15 \line 16 \line 17 \line 18 \line 19 \line 20 \line 21 \line 22 \line 23 \line 24 \line 25 \line 26 \line 27 \line 28 \line 29 \line 30 \line 31 \line 32 \line 33 \line 34 \line 35 \line 36 \b0\f0\fs24\par
\fs20 cout \'ab \b\f2\fs16\ldblquote x \b0\fs10 = \ldblquote  \f0\fs20\'ab \b\f3\fs16 x \'ab \line\f0\fs14\'ab \ldblquote Valor retornado \line\'ab squareByValue( x \line\'ab \f2\fs16\ldblquote x \b0\fs10 = \ldblquote  \b\f0\fs14\'ab x \'ab \line\b0\fs20 cout \b\fs14\'ab \f3\fs16\ldblquote z \b0\f2\fs10 = \ldblquote  \b\f0\fs14\'ab z \'ab \line\f3\fs16 squareByReference \b0\f0\fs20 ( z ); \line cout \b\fs14\'ab \b0\fs16\ldblquote z \f2\fs10 = \ldblquote  \b\f0\fs14\'ab Z \'ab \line\f3\fs16 return 0; \b0\f0\fs24\par
\b\f3\fs16 antes de squareByValue\\n\rdblquote  \line por squareByValue: \line\'ab endl \line depois de squareByValue\\n\rdblquote  \'ab endl; \line antes de squareByReference\rdblquote  \'ab endl; \line depois de squareByReference\rdblquote  \'ab endi; \b0\f0\fs24\par
\b\f3\fs14 int squareByValue( int a \line return a \b0\f2\fs10 = \b\f3\fs14 a; \b0\f0\fs20 // \b\f3\fs14 argumento da chamadora n\'e3o modificado \line void squareByReference( int &cRef \line cRef \b0\f2\fs10 = \b\f3\fs14 cRef; \b0\i\f0\fs18 II \b\i0\f3\fs14 argumento da chamadora modificado \b0\f0\fs24\par
\b\f2\fs18 Fig. 3.20 \b0 Um exemplo de chamada por refer\'eancia (parte 1 de 2). \f0\fs24\par
\fs18 226 C++ \b\fs14 COMO PROGRAMAR \line\f3\fs16 x \b0\f2\fs10 = \b\f3\fs16 2 antes de sqi.iareByValue \line Valor retornado por squareByValue: 4 \line x 2 depois de squareByValue \line z \b0\f2\fs10 = \b\f3\fs16 4 antes de sqi.iareByReference \line z \b0\f2\fs10 = \b\f3\fs16 16 depois de squareByReference \line\f2\fs18 Fig. 3.20 \b0\fs20 Um exemplo de chamada por refer\'eancia (parte 2 de 2). \line\f0\fs18 No Cap\'edtulo 5, discutimos ponteiros; veremos que ponteiros oferecem uma forma alternativa de chamada por refer\'eancia, na qual o estilo da chamada indica claramente uma chamada por refer\'eancia (e o potencial para modificar os argumentos da fun\'e7\'e3o que chamou). \line\i Dica de desempenho 3.12 \line\i0\f2\fs28 f \i\f0\fs18 Para passar objetos grandes, use um par\'e2metro por refer\'eancia constante para simular a apar\'eancia e seguran\'e7a de uma chamada por valor e evitar o \i0 overhead \i de passar uma c\'f3pia do objeto grande. \line\i0 Para especificar uma refer\'eancia para uma constante, coloque o qualificador const antes do especificador do tipo, na declara\'e7\'e3o do par\'e2metro. \line Note a coloca\'e7\'e3o do \b\fs14 & \b0\fs18 na lista de par\'e2metros da fun\'e7\'e3o squareByReference. Alguns programadores de C++ preferem escrever int& cRef em vez de int &cRef. \line\i Observa\'e7\'e3o de engenharia de software 3.19 \line\i0\f2\fs8 ______ \i\f0\fs18 Tanto para fins de clareza como de desempenho, muitos programadores de C+ \b\i0\fs14 + \b0\i\fs18 preferem que argumentos modific\'e1veis sejam passados para fun\'e7\'f5es por meio de ponteiros, argumentos pequenos n\'e3o-modific\'e1veis sejam passados por chamadas por valor e argumentos grandes n\'e3o-modific\'e1veis sejam passados para fun\'e7\'f5es usando refer\'eancias para constantes. \line\i0 Refer\'eancias tamb\'e9m podem ser usadas como \i aliases \i0 para outras vari\'e1veis dentro de uma fun\'e7\'e3o. Por exemplo, o \f1\fs64\lquote  \f0\fs18 c\'f3digo \line\b\f3\fs16 int count \b0\f2\fs10 = \f0\fs18 1; \i II \b\i0\f3\fs16 declara a vari\'e1vel inteira count \line int &cRef \b0\f2\fs10 = \b\f3\fs16 count; \b0\f0\fs18 // \b\f3\fs16 cria cRef como um alias para count \line ++cRef; \b0\i\f0\fs18 II \b\i0\f3\fs16 incrementa count (usando seu alias) \line\b0\f0\fs18 incrementa a vari\'e1vel count usando seu \i alias \b\i0\fs20 cref. \b0\fs18 Vari\'e1veis de refer\'eancia devem ser inicializadas em suas declara\'e7\'f5es (ver Fig. 3.21 e Fig. 3.22) e n\'e3o podem ser novamente atribu\'eddas como \i alias \i0 para outras vari\'e1veis. Uma vez que uma refer\'eancia \'e9 declarada como um \i alias \i0 para outra vari\'e1vel, todas as opera\'e7\'f5es supostamente executadas no \i alias \i0 (i.e., a refer\'eancia) s\'e3o na realidade executadas na pr\'f3pria vari\'e1vel original. O \i alias \i0\'e9 simplesmente um outro nome para a vari\'e1vel original. Pegar o endere\'e7o de uma refer\'eancia e comparar refer\'eancias n\'e3o causa erros de sintaxe; em vez disso, cada opera\'e7\'e3o na realidade ocorre na vari\'e1vel para a qual a refer\'eancia \'e9 um \i alias. \i0 Um argumento por refer\'eancia deve ser um \i Ivalue, \i0 n\'e3o uma constante ou express\'e3o que retorna um \i rvalue. \line\b\i0\f3\fs16 1 \b0\i\f0\fs18 II \b\i0\f3\fs16 Fig. 3.21: \b0\f0\fs18 figO3_21.cpp \line\b\f3\fs16 2 \b0\f0\fs18 // \b\f3\fs16 Refer\'eancias devem ser inicializadas \line 3 #include <iostream> \line 4 \line 5 using std: :cout; \line 6 using std: :endl; \line 7 \line\f2\fs18 Fig. 3.21 \b0\fs20 Usando uma refer\'eancia n\'e3o-inicializada (parte 1 de 2). \f0\fs24\par
\i\fs18 Erro comum de programa\'e7\'e3o 3.27 \i0\fs24\par
\b\f2\fs14 CAP\'cdTULO \b0\f0\fs18 3 \f2\fs8 - \b\fs14 FUN\'c7\'d5ES \b0\fs20 227 \f0\fs24\par
\i\fs16 Declarar m\'faltiplas refer\'eancias em um s\'f3 comando, supondo que o & se distribui por uma lista de nomes de \line vari\'e1veis separados por v\'edrgulas. Para declarar as vari\'e1veis x, y e \b\i0\f2\fs18 z, \b0\i\f0\fs16 como refer\'eancias para inteiros, use \line a nota\'e7\'e3o \i0\fs18 int &x \f2\fs12 = \i\f0\fs16 a, &y \i0\f2\fs12 = \f0\fs18 b, &z \f2\fs12 = \f0\fs18 b \b\f3\fs16 ; \b0\i\f0 em vez da nota\'e7\'e3o incorreta \i0\fs18 int& x \f2\fs12 = \i\f0\fs16 a, y \i0\f2\fs12 = \f0\fs18 b, z \line\f2\fs12 = \f0\fs18 c; \i\fs16 ou de outra nota\'e7\'e3o incorreta freq\'fcentemente encontrada: \b\i0\f3 int &x, y, z;. \b0\f0\fs24\par
\fs18 Fun\'e7\'f5es podem retornar refer\'eancias, mas isto pode ser perigoso. Quando retomar uma refer\'eancia para uma vari\'e1vel declarada na fun\'e7\'e3o chamada, a vari\'e1vel deveria ser declarada static naquela fun\'e7\'e3o. Caso contr\'e1rio, a refer\'eancia referir-se-\'e1 a uma vari\'e1vel autom\'e1tica que \'e9 descartada quando a fun\'e7\'e3o termina; tal vari\'e1vel \'e9 dita \ldblquote indefinida\rdblquote  e o comportamento do programa ser\'e1 imprevis\'edvel (alguns compiladores emitem mensagens de advert\'eancia quando isto \'e9 feito). Refer\'eancias para vari\'e1veis indefinidas s\'e3o chamadas de \i refrr\'eancias sem correspondente. \i0\fs24\par
\i\fs18 Erro comum de programa\'e7\'e3o 3.28 \line N\'e3o inicializar uma vari\'e1vel de refer\'eancia quando ela \'e9 declarada \'e9 um erro de sintaxe. \i0\fs24\par
\i\fs18 Erro comum de programa\'e7\'e3o 3.29 \line Tentar atribuir a uma refer\'eancia previamente declarada um alias para outra vari\'e1vel \'e9 um erro de l\'f3gica. O \line valor da outra vari\'e1vel \'e9 simplesmente atribu\'eddo para a localiza\'e7\'e3o para a qual a refer\'eancia j\'e1 \'e9 um alias. \i0\fs24\par
\b\f3\fs16 1 \b0\i\f0\fs18 II \b\i0\f3\fs16 Fig. 3.22: fig0322.cpp \line 2 \b0\i\f0\fs18 // \b\i0\f3\fs16 Refer\'eancias devem ser inicializadas \line 3 #include <iostream> \b0\f0\fs24\par
\b\f3\fs16 4 \b0\f0\fs24\par
\b\f3\fs16 5 using std: :cout; \line 6 using std: :endl; \b0\f0\fs24\par
\b\f3\fs16 7 \b0\f0\fs24\par
\b\f3\fs16 int main \b0\i\f0\fs18 Q \i0\fs24\par
\b\f3\fs14 int x \b0\f2\fs12 = \b\f3\fs14 3, &y; \b0\i\f0\fs18 II \b\i0\f3\fs14 Erro: y deve ser inicializado \b0\f0\fs24\par
\b\f3\fs14 cout \'ab \f2\fs16\ldblquote x \b0\fs12 = \ldblquote  \b\f3\fs14 y \b0\f2\fs12 = \b\f3\fs14 7; \line cout \b0\i\f0\fs18\'ab \b\i0\f3\fs14\lquote x \b0\f2\fs12 = \ldblquote  \b\f3\fs14\'ab \b0\f0\fs24\par
\b\f3\fs16 return O; \b0\f0\fs24\par
\b\f3\fs14 8 int main \b0\i\f0\fs18 O \line\b\i0\f3\fs14 9 \line\b0\f0\fs18 10 int \b\f3\fs14 x \b0\f2\fs12 = \b\f3\fs14 3, &y \b0\f2\fs12 = \i\f0\fs18 x; II y \b\i0\f3\fs14\'e9 agora um alias para x \line 11 \line 12 cout \'ab \f2\fs18 x \b0\fs10 = \ldblquote  \b\f3\fs14\'ab x \'ab endl \'ab \ldblquote y \b0\f2\fs8\ldblquote  \b\f3\fs14\'ab y \'ab endi; \line 13 \b0\f2\fs18 y=7; \line\b\f3\fs14 14 cout \'ab \f2\fs16\lquote x \b0\fs12 = \lquote  \b\f3\fs14\'ab x \'ab endi \'ab \ldblquote y \b0\f2\fs12 = \ldblquote  \b\f3\fs14\'ab y \'ab endi; \line 15 \line 16 return O; \line 17 \b0\i\f0\fs18 ) \i0\fs24\par
\f2\fs20 Fig. 3.21 Usando uma refer\'eancia n\'e3o-inicializada (parte 2 de 2). \f0\fs24\par
\b\f2\fs18 8 \line\f3\fs16 9 \line 10 \line 11 \line 12 \line 13 \line 14 \line 15 \line 16 \line 17 \b0\f0\fs24\par
\b\f2\fs16 x \'ab \b0\f0\fs18 endl \i\'ab \ldblquote y \i0\f2\fs12 = \ldblquote  \i\f0\fs18\'ab \b\i0\f3\fs14 y \'ab endl; \line x \'ab endi \'ab \ldblquote y \b0\f2\fs12 = \ldblquote  \b\f3\fs14\'ab y \'ab endi; \b0\f0\fs24\par
\f2\fs18 Fig. \b 3.22 \b0 Tentando usar uma refer\'eancia n\'e3o-inicializada (parte 1 de 2). \f0\fs24\par
\f2\fs22 226 228 C++ \b\fs14 COMO PROGRAMAR \line\b0\i\f0\fs18 Mensagem de erro do compilador Borland C+ + com linha de comando \line\b\i0 Error E2304 figo3_22.cpp 10: Reference variable y\rquote  must be initialized \line in function \b0\fs24 main() \line\i\fs18 Mensagem de erro do compilador Microsoft Visual C+ + \line\i0\f2\fs8 ____ \b\f3\fs16 figo3_22.cpp(10) : error C2530 : \lquote y\rquote  : references must be initialized \line\f2\fs18 Fig. Fig. 3.22 \b0\fs20 Tentando usar uma refer\'eancia n\'e3o-inicializada (parte 2 de 2). \line\f0\fs18 No Ca \f2\fs12 , \b\i\f0\fs20 Erro comum de programa\'e7\'e3o 3.30 \line\b0\i0\fs18 renda, \line\b argum \b0\i Retomar um ponteiro ou refer\'eancia para uma vari\'e1vel autom\'e1tica em uma fun\'e7\'e3o chamada \'e9 um err \line l\'f3gica. Alguns compiladores emitir\'e3o uma mensagem de advert\'eancia quando isto ocorrer em um progrt \line\b\i0\f2\fs26 3.18 Argumentos default \line\b0\f0\fs18 Chamadas a fun\'e7\'f5es devem geralmente passar um valor particular de um argumento. O \b programador pode espe \line\b0 Para e car que tal argumento seja um \i argumento default \i0 e o programador pode fornecer um valor default para esse a \line na dec mento. Quando um argumento default \'e9 omitido na chamada de uma fun\'e7\'e3o, o valor default daquele argumen automaticamente inserido pelo compilador e passado na chamada. \line C++ Argumentos default devem ser os argumentos mais \'e0 direita (finais) na lista de par\'e2metros da fun\'e7\'e3o. Qua se chama uma fun\'e7\'e3o com dois ou mais argumentos default, se um argumento omitido n\'e3o \'e9 o argumento m direita na lista de argumentos, todos os argumentos \'e0 direita desse argumento tamb\'e9m devem ser omitidos. A mentos default devem ser especificados com a primeira ocorr\'eancia do nome da fun\'e7\'e3o \f2\fs8 - \f0\fs18 tipicamente no prot\'f3l Valores default podem ser constantes, vari\'e1veis globais ou chamadas de fun\'e7\'e3o. Argumentos default tamb\'e9m po ser usados com fun\'e7\'f5es \fs24 mime. \line\fs18 A Fig. 3.23 demonstra a utiliza\'e7\'e3o de argumentos default no c\'e1lculo do volume de uma caixa. O pr\'f3totip \line fun\'e7\'e3o para boxVolume, na linha 5, especifica que todos os tr\'eas argumentos recebem valores default de 1. \f2\fs8\lquote  \line\f0\fs18 que os valores default devem ser definidos somente no prot\'f3tipo da fun\'e7\'e3o. Tamb\'e9m note que fornecemos nome \line Refere vari\'e1veis no prot\'f3tipo da fun\'e7\'e3o, por raz\'f5es de legibilidade. Como sempre, nomes de vari\'e1veis n\'e3o s\'e3o requer \line codigc em prot\'f3tipos de fun\'e7\'f5es. \line A primeira chamada para boxVolume (linha 12) n\'e3o especifica argumentos e, assim, usa todos os valores default. A segunda chamada (linha 14) passa um argumento length e, por isso, usa valores default par argumentos width e height. A terceira chamada (linha 16) passa argumentos length e width e, assim. um valor default para o argumento height. A \'faltima chamada (linha 18) passa argumentos para length. wi\'e9 e height e, por isso, n\'e3o usa valores default. \line incren \line dec lar \b\i\fs20 Boa pr\'e1tica de programa\'e7\'e3o 3.12 \line\b0\i0\fs18 vez qu \line no \i alic Usar argumentos default pode simplificar a codifica\'e7\'e3o de chamadas de fun\'e7\'f5es. Contudo, alguns \line\i0 nome \i gramadores acham que especificar explicitamente todos os argumentos \'e9 mais claro. \line\b\fs20 Erro comum de programa\'e7\'e3o 3.31 \line\b0\fs18 Especificar e tentar usar um argumento default que n\'e3o \'e9 o argumento final (mais \'e0 direita) da list argumentos (sem, simultaneamente, tomar default os outros argumentos mais \'e0 direita) \'e9 um erro de Sint \line\b\i0 1 \line\f3\fs16 2 \b0\f2\fs12 , \b\f0\fs18 1 \i\fs20 II \i0\f3\fs16 Fig. 3.23: figo3_23.cpp \line 3 2 \i\f0\fs20 II \i0\f3\fs16 Usando argumentos default \line 4 3 #inciude <iostreain> \line 51 4 \line 6 5 using std::cout; \line 6 using std::endl; \line\f2\fs18 Fig. 3 Fig. \f3\fs16 3.23 \b0\f2\fs20 Usando argumentos default (parte \b\f3\fs16 1 \b0\f2\fs20 de 2). \f0\fs24\par
\fs18 CAP\'cdTULO 3 \f2\fs8 - \f0\fs18 FUN\'c7\'d5ES \f2\fs22 229 \line\b\f3\fs16 7 \line 8 int boxVolume \b0\f2\fs22 ( \b\f3\fs16 int length \b0\f2\fs10 = \b\f3\fs16 1, int width \b0\f2\fs10 = \b\f3\fs16 1, int height \b0\f2\fs10 = \b\f3\fs16 1 ); \line\bullet ized g \line 10 int main() \line 11 \line 12 cout\'ab \ldblquote O volume default da caixa \'e9: \b0\f2\fs8\ldblquote  \i\fs18\'ab \b\i0\f3\fs16 boxVolume() \line d 13 \'ab \ldblquote\\n\\nO volume de \b0\f0\fs18 uma \b\f3\fs16 caixa com comprimento 10,\\n\rdblquote  \line e 14 \'ab \ldblquote largura 1 e altura 1 \'e9: \b0\f2\fs8\ldblquote  \b\f3\fs16\'ab boxVolume( 10 \line\b0\f2\fs8 ________ \b\f3\fs16 15 \'ab \ldblquote\\n\\nO volume de \b0\f0\fs18 uma \b\f3\fs16 caixa com comprimento l0,\\n\rdblquote  \line 16 \'ab \lquote largura 5 e altura 1 \'e9: \b0\f2\fs10\lquote  \b\f3\fs16\'ab boxVolume( 10, 5 \line 17 \'ab \ldblquote\\n\\nO volume de \b0\f0\fs18 uma \b\f3\fs16 caixa com comprimento 10,\\n\rdblquote  \line 18 \'ab \ldblquote largura 5 e altura 2 \'e9: \b0\f2\fs10\ldblquote  \b\f3\fs16\'ab boxVolume( 10, 5, 2 \line\b0\f2\fs8 _______ \b\f3\fs16 19 \'ab endl; \line\b0\i\fs18\'e9umerrode \b\i0\fs16 20 \line\b0\i\f2\fs18 npmgrama. \b\i0\f3\fs16 21 \f0 return O; \line\f3 24 \b0\i\f0\fs20 /1 \b\i0\f3\fs16 Calcular o volume da caixa \line 25 int boxVolume(int length, int width, int height) \line\b0\f2\fs8 . \b\f3\fs16 26 \b0\f2\fs22\{ \line\f3\fs18 Jueespeciii- \b\f0\fs16 27 return length \b0\f2\fs10 * \b\f0\fs16 width \b0\f2\fs10 * \b\f3\fs16 height; \line\b0\fs18 aesseargu- 28 \line argumento \f2\fs22\'e9 \line\f3\fs18 O volume default da caixa \'e9: 1 \line ao. Quando \f0\fs24 o \f3\fs18 volume de \f0 uma \f3 caixa com comprimento 10, \line\f0 lento mais a \f3 largura \f0 1 e altura 1 \i\fs20\'e9: \i0\fs18 10 \line\f3 tidos. Arguonrot\'f3ti \line O volume de \f0 uma \f3 caixa com comprimento 10, \line\bullet  largura 5 e altura 1 \'e9: 50 \line\f0 bem podem \line\b\fs16 O volume de \b0\fs18 uma \b\fs16 caixa com comprimento 10, \line\b0\fs18 pr\'f3totipoda largura 5 e altura 2 \i\fs20\'e9: \i0\f3\fs18 100 \line\f0 tde 1. Note \line osnomesde \b\f3\fs16 Fig. 3.23 \b0\f0\fs18 Usando argumentos default (parte 2 de 2). \line requeridos \line dos \fs20 os \fs18 tr\'eas \b\f2\fs26 3.19 Operador un\'e1rio de resolu\'e7\'e3o de escopo \line\b0\f0\fs18 Cault para os \line assim, usa E poss\'edvel declarar vari\'e1veis locais e globais com o mesmo nome. C++ oferece o \i operador un\'e1rio de resolu\'e7\'e3o de \i0 th. width. \i escopo (: \i0 :) para acessar uma vari\'e1vel global quando uma vari\'e1vel local com o mesmo nome est\'e1 no escopo. O \line operador un\'e1rio de resolu\'e7\'e3o de escopo n\'e3o pode ser usado para acessar uma vari\'e1vel local do mesmo nome a partir de um bloco externo. Uma vari\'e1vel global pode ser acessada diretamente, sem o operador un\'e1rio de resolu\'e7\'e3o de escopo, se o nome da vari\'e1vel global n\'e3o for o mesmo que o nome de uma vari\'e1vel local no escopo. No Cap\'edtulo 6, discutimos o uso do \i operador bin\'e1rio de resolu\'e7\'e3o de escopo \i0 com classes. \line\i alguns pro- \i0\f2\fs8 . . .. \line\f0\fs18 A Fig. 3.24 mostra o uso do operador unano de resolu\'e7ao de escopo com variaveis locais e globais com o \line mesmo nome. Para enfatizar que as vers\'f5es locais e globais da vari\'e1vel constante P1 s\'e3o distintas, o programa declara uma das vari\'e1veis como double e a outra como float. \line\i da ksia de Erro comum de programa\'e7\'e3o 3.32 \line de sintaxe. Tentar acessar uma vari\'e1vel n\'e3o-global em um bloco externo usando o operador un\'e1rio de resolu\'e7\'e3o de \line escopo \'e9 um erro de sintaxe se n\'e3o existir uma vari\'e1vel global com o mesmo nome no bloco externo e um \line erro de l\'f3gica se existir uma. \i0\fs24\par
\fs14 1 \f2\fs22 // \b\f0\fs16 Fig. 3.24: figo3_24.cpp \line\f3 2 \b0\f2\fs22 // \b\f3\fs16 Usando o operador un\'e1rio de resolu\'e7\'e3o de escopo \line\f0 3 #include <iostream> \b0\fs24\par
\b\f3\fs16 Fig. 3.24 \b0\f0\fs18 Usando o operador un\'e1rio de resolu\'e7\'e3o de escopo (parte 1 de 2). \fs24\par
\b\f2\fs22 230 \b0\fs20 C++ \b\fs14 COMO PROGRAMAR \line\f3\fs16 4 \line 5 using std::cout; \line 6 using std: :endl; \line 7 \line 8 #include <iomanip> \line\b0\f0\fs20 9 \line\b\f3\fs16 10 using std::setprecision; \line 11 \line 12 const double P1 \b0\f2\fs12 = \b\f3\fs16 3.14159265358979; \line 13 \line 14 int main \f2\fs22 O \line\f3\fs16 15 \line 16 const float P1 \b0\f2\fs12 = \b\f3\fs16 static cast< float >( ::PI ); \line 17 \line 18 cout \'ab setprecision( 20 \line 19 \'ab \b0\f2\fs8\ldblquote  \b\f3\fs16 Valor local float de P1 \b0\f2\fs12 = \ldblquote  \b\f3\fs16\'ab P1 \line 20 \'ab \lquote\\nValor global double de P1 \b0\f2\fs12 = \b\f3\fs16\'ab ::PI \'ab endl; \line 21 \line 22 return 0; \line 23 \f2\fs22 ) \line\b0\i\f0\fs18 Sa\'edda do compilador Borland C+ \i0\f2\fs12 + \i\f0\fs18 com linha de comando \i0\fs24\par
\f2\fs20 Fig. 3.24 Usando o operador un\'e1rio de resolu\'e7\'e3o de escopo (parte 2 de 2). \line\i\f0\fs18 Boa pr\'e1tica de programa\'e7\'e3o \b\f2\fs20 3.13 \line\b0\f0\fs18 Evite usar vari\'e1veis com o mesmo nome para prop\'f3sitos diferentes em um programa. Embora isso seja \line permitido em v\'e1rias circunst\'e2ncias, pode gerar confus\'e3o. \line\b\i0\f3\fs16 ch \line\f2\fs26 3.20 Sobrecarga de fun\'e7\'f5es \b0\fs12 01 \line\f0\fs18 C++ possiblita que sejam definidas v\'e1rias fun\'e7\'f5es com o mesmo nome, desde que estas fun\'e7\'f5es tenham conjuntos \line de par\'e2metros diferentes (pelo menos quanto a seus tipos). Este recurso \'e9 chamado de \i sobrecarga de fun\'e7\'f5es. \line\i0 Quando \'e9 chamada uma fun\'e7\'e3o sobrecarregada, o compilador C++ seleciona a fun\'e7\'e3o apropriada pelo exame da quantidade, dos tipos e da ordem dos argumentos na chamada. A sobrecarga de fun\'e7\'f5es \'e9 comumente usada para criar v\'e1rias fun\'e7\'f5es do mesmo nome que executam tarefas semelhantes, mas sobre tipos de dados diferentes. \line\i Boa pr\'e1tica de programa\'e7\'e3o 3.14 \line Sobrecarregarfun\'e7\'f5es que executam tarefas proximamente relacionadas torna um programa mais leg\'edvel \line e compreens\'edvel. \line\i0 A Fig. 3.25 usa a fun\'e7\'e3o sobrecarregada square para calcular o quadrado de um int e o quadrado de um double. \line No Cap\'edtulo 8, discutimos como sobrecarregar operadores para definir como eles devem operar sobre objetos de tipos de dados definidos pelo usu\'e1rio. (Na verdade, temos usado muitos operadores sobrecarregados at\'e9 aqui, inclusive o operador de inser\'e7\'e3o em \i streams \i0\f2\fs24\'ab \f0\fs18 e o operador de extra\'e7\'e3o de \i st reams \i0\f2\fs14\'bb. \f0\fs18 Falaremos mais sobre sobrecarregar \line\f2\fs24\'ab \f0\fs18 e \f2\fs24\'bb \f0\fs18 no Cap\'edtulo 8). A Se\'e7\'e3o 3.21 introduz gabaritos de fun\'e7\'f5es para gerar automaticamente fun\'e7\'f5es sobrecarregadas que executam tarefas id\'eanticas sobre tipos de dados diferentes. No Cap\'edtulo 12, discutimos gabari to \line de fun\'e7\'e3o e gabaritos de classe em detalhes. F \fs24\par
\pard\par
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2509\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4503\pard\intbl\b\f3\fs14 Valor local float de P1 \b0\f2\fs12 =  \b\f3\fs14 Valor global double de P1 \b0\f0\fs24\cell\b\f3\fs14 3.141592741012573242  \b0\f2\fs12 = \b\f3\fs14 3.141592653589790007 \b0\f0\fs24\cell\fs20\row
\i\fs16\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2509\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4503\intbl Sa\'edda do compilador Microsofi C+ \i0\f2\fs12 + \f0\fs24\cell\cell\fs20\row
\b\f3\fs14\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2509\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4503\intbl Valor local float de P1 \b0\f2\fs12 = \f0\fs24\cell\b\f3\fs16 3.1415927410125732 \b0\f0\fs24\cell\fs20\row
\b\f3\fs16\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2509\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4503\intbl Valor global double de P1 \b0\f0\fs24\cell\b\f3\fs16 3.14159265358979 \b0\f0\fs24\cell\fs20\row
\pard\fs24\par
\pard\sb100\sa240\fs16 CAP\'cdTULO 3 \f2\fs8 - \b\f0\fs14 FUN\'c7\'d5ES \b0\f2\fs22 231 \f0\fs24\par
\b\f3\fs16 1 \b0\i\f2\fs22 II \b\i0\f3\fs16 Fig. 3.25: fig0325.cpp \line 2 \b0\i\f2\fs22 II \b\i0\f3\fs16 Usando fun\'e7\'f5es sobrecarregadas \line 3 #include <iostream> \line 4 \line 5 using std::cout; \line 6 using std::endl; \line 7 \line 8 int square( int x \b0\f0 ) \{ \b\f3 return x \b0\f2\fs10 * \b\f3\fs16 x; \line 9 \line 10 double square \b0\f0 ( double \b\f3 y \b0\f0 ) \{ \b\f3 return y \b0\f2\fs10 * \line\b\f3\fs16 11 \line 12 int main \b0\f0 O \line\b\f3 13 \line 14 cout\'ab \lquote O quadrado do inteiro 7 \'e9 \b0\f2\fs8\ldblquote  \f0\fs16\'ab \b\f3 square( 7 \line\b0\f0 15 \b\f3\'ab \ldblquote\\nO quadrado do double 7.5 \'e9 \b0\f2\fs8\ldblquote  \b\f3\fs16\'ab square( 7.5 \line 16 \b0\f0\'ab \b\f3 endi; \line 17 \line 18 return O; \line 19 \line O quadrado do inteiro 7 \'e9 49 \line O quadrado do double 7.5 \'e9 56.25 \line\b0\f2\fs20 Fig. 3.25 Usando fun\'e7\'f5es sobrecarregadas. \line\f0\fs16 Fun\'e7\'f5es sobrecarregadas s\'e3o distinguidas por suas \i\fs18 assinaturas \i0\f2\fs8 - \i\f0\fs18 uma assinatura \i0\fs16\'e9 uma \f2\fs20 combina\'e7\'e3o \f0\fs16 do nome de uma fun\'e7\'e3o e seus tipos de par\'e2metros. O compilador associa cada identificador de fun\'e7\'e3o com o n\'famero e os tipos de seus par\'e2metros (\'e0s vezes chamado de \i\fs18 adultera\'e7\'e3o \i0\fs16 ou \i\fs18 decora\'e7\'e3o do nome) \i0\fs16 para garantir uma \i\fs18 liga\'e7\'e3o segura quanto ao tipo \i0\fs16 dos par\'e2metros. A liga\'e7\'e3o segura quanto ao tipo assegura que a fun\'e7\'e3o sobrecarregada apropriada seja chamada e que os argumentos estejam em conformidade com os par\'e2metros. Os erros de liga\'e7\'e3o s\'e3o detectados e acusados pelo compilador. A Fig. 3.26 foi compilada com o compilador C++ da Borland. Em vez de mostrar a sa\'edda produzida pela execu\'e7\'e3o do programa (como normalmente fazemos), mostramos os nomes de fun\'e7\'e3o adulterados produzidos em linguagem simb\'f3lica pelo C++ da Borland. Cada nome adulterado come\'e7a com @ seguido pelo nome da fun\'e7\'e3o. A lista de par\'e2metros adulterada come\'e7a com $q. Na lista de par\'e2metros para a fun\'e7\'e3o \b\f3 nothing2, \b0\f0 c representa um char, i representa um int, pf representa um float* e pd representa um double*. Na lista de par\'e2metros para fun\'e7\'e3o nothingl. i representa um int, f representa um float, c representa um char e pi representa um int*. As duas fun\'e7\'f5es square s\'e3o diferenciadas por suas listas de par\'e2metros; uma especifica d significando double e a outro especifica i significando int. Os tipos de retomo das ftin\'e7\'f5es n\'e3o s\'e3o especificados nos nomes adulterados. A adultera\'e7\'e3o de nomes de fun\'e7\'e3o \'e9 espec\'edfica de cada compilador. Fun\'e7\'f5es sobrecarregadas podem ter tipos de retomo diferentes ou n\'e3o, mas devem ter listas de par\'e2metros diferentes. \line\b\f3 1 \b0\f0 // \b\f3 Fig. 3.26: fig0326.cpp \line 2 \b0\f0 // \b\f3 Alterando nomes \line 3 \line 4 int square( int x \b0\f0 ) \{ \b\f3 return x \b0\f2\fs10 * \b\f3\fs16 x; \line 5 \line\b0\f0 6 double square ( double \b\f3 y \b0\f0 ) \{ return \b\f3 y \b0\f2\fs10 * \b\f3\fs16 y; \b0\f0\} \line\b\f3 7 \line 8 void nothingl( int a, float b, char c, int *d \line 9 \b0\f0\{ \} \i\f2\fs22 II \b\i0\f3\fs16 corpo de fun\'e7\'e3o vazio \line 10 \line 11 char *nothing2( char a, int b, float *c, double *d \line 12 \b0\f0\{ \b\f3 return O; \line\f0\fs14 13 \line\f3\fs16 14 int main() \line 15 \b0\f0\fs24\par
\f2\fs20 Fig. 3.26 Alterando o nome para possiblitar a liga\'e7\'e3o segura quanto aos tipos (parte 1 de 2). \f0\fs24\par
\f2\fs22 232 \fs28 c++ \b\fs14 COMO PROGRAMAR \line\f3\fs16 16 return O; \line 17 \line main \line @ nothing2 $qcipfpd \line @nothingl$qifcpi \line @square$qd \line @square$qi \line\f2\fs18 Fig. 3.26 \b0\fs20 Alterando o nome para possiblitar a liga\'e7\'e3o segura quanto aos tipos (parte 2 de 2). \line\b\i\f0 Erro comum de programa\'e7\'e3o 3.33 \line\b0\fs18 Criarfun\'e7\'f5es sobrecarregadas com listas de par\'e2metros id\'eanticas e tipos diferentes de retorno \'e9 um erro de sintaxe. \line\i0 O compilador usa somente as listas de par\'e2metros para distinguir entre fun\'e7\'f5es do mesmo nome. Fun\'e7\'f5es sobrecarregadas n\'e3o necessitam ter o mesmo n\'famero de par\'e2metros. Os programadores devem ser cautelosos quando sobrecarregarem fun\'e7\'f5es com par\'e2metros default, pois isto pode causar ambig\'fcidades. \line\b\i\fs20 Erro comum de programa\'e7\'e3o 3.34 \line\b0\fs18 Uma fun\'e7\'e3o com par\'e2metros default omitidos pode ser chamada de forma id\'eantica a outra fun\'e7\'e3o sobrecarregada; isto \'e9 um erro de sintaxe. Por exemplo, terem um programa tanto uma fun\'e7\'e3o que explicitamente n\'e3o aceita nenhum argumento e uma fun\'e7\'e3o com mesmo nome cujos par\'e2metros s\'e3o todos default, provoca um erro de sintaxe quando \'e9feita uma tentativa de usar aquele nome de fun\'e7\'e3o em uma \line chamada sem passar nenhum argumento. \line\b\i0\f2\fs26 3.21 Gabaritos de fun\'e7\'f5es \line\b0\f0\fs18 Fun\'e7\'f5es sobrecarregadas s\'e3o usadas normalmente para executar opera\'e7\'f5es semelhantes que envolvem l\'f3gicas de programa\'e7\'e3o distintas para tipos de dados diferentes. Se a l\'f3gica dos programas e suas opera\'e7\'f5es s\'e3o id\'eanticas para os v\'e1rios tipos de dados, isto pode ser codificado mais compacta e convenientemente usando-se \i gaba ritos de fun\'e7\'e3o. \i0 O \line\f2\fs8 __________ \f0\fs18 programador escreve uma \'fanica defini\'e7\'e3o do gabarito de fun\'e7\'e3o. Dados os tipos dos par\'e2metros fornecidos nas chama da desta fun\'e7\'e3o, C++ gera automaticamente \i Jln\'e7\'f5es gabarito \i0 separadas para tratar cada tipo de chamada de forma \line apropriada. Deste modo, detinindo-se um \'fanico gabarito da fun\'e7\'e3o, define-se tamb\'e9m uma famflia inteira de solu\'e7\'f5es. Todas as defini\'e7\'f5es de gabaritos de fun\'e7\'e3o come\'e7am com a palavra-chave template seguida por uma lista \line de par\'e2metros de tipo formais para o gabarito de fun\'e7\'e3o colocada entre os s\'edmbolos \b\f3\fs16 < \b0\f0\fs18 e \f2\fs10 >. \f0\fs18 Todo par\'e2metro de tipo formal \'e9 precedido pela palavra-chave typename ou pela palavra-chave class. Os \i par\'e2metros de tipo formais \i0 s\'e3o tipos primitivos ou tipos definidos pelo programador, usados para especificar os tipos dos par\'e2metros da fun\'e7\'e3o, especificar o tipo de retorno da fun\'e7\'e3o e para declarar vari\'e1veis dentro do corpo da defini\'e7\'e3o da fun\'e7\'e3o. A defini\'e7\'e3o de fun\'e7\'e3o vem a seguir e \'e9 definida como qualquer outra fun\'e7\'e3o. \line A defini\'e7\'e3o de gabarito de fun\'e7\'e3o a seguir \'e9 usada tamb\'e9m na Fig. 3.27. \line\b\f3\fs16 teniplate <class T> \i\f0\fs20 II \i0\f3\fs16 ou template< typename T > \line T maximuxn( T valuel, T value2, T value3 \line T max valuel; \line if \b0\f2\fs22 ( \b\f3\fs16 value2 > max \line max \b0\f2\fs10 = \b\f3\fs16 value2; \line if \b0\f2\fs22 ( \b\f3\fs16 value3 > max \line max \b0\f2\fs10 = \b\f3\fs16 value3; \line return max; \b0\f0\fs24\par
\fs16 CAP\'cdTULO 3 \f2\fs8 - \f0\fs16 FUN\'c7\'d5ES \f2\fs22 233 \f0\fs24\par
\fs20 Este gabarito de fun\'e7\'e3o declara um par\'e2metro de tipo formal \'fanico, T, como o tipo dos dados que ser\'e3o testados pela fun\'e7\'e3o maximo. Quando o compilador descobre uma chamada a maximo no c\'f3digo fonte do programa, o tipo dos dados passados para maximo substitui T ao longo de toda a defini\'e7\'e3o do gabarito e C++ cria uma fun\'e7\'e3o completa para determinar o m\'e1ximo de tr\'eas valores do tipo de dados especificado. Ent\'e3o, a fun\'e7\'e3o rec\'e9m-criada \'e9 compilada. Assim, gabaritos na realidade s\'e3o uma maneira de gerar c\'f3digo. Na Fig. 3.27, tr\'eas func\'f5es s\'e3o instanciadas \f2\fs8 - \f0\fs18 uma espera receber tr\'eas valores \f3 int, uma espera tr\'eas valores double e uma espera tr\'eas valores \f0 char. O gabarito de fun\'e7\'e3o criado para o tipo int \'e9: \line\f3 int maximum( int valuel, int value2, int value3 \line int max \f2\fs10 = \f3\fs18 valuel; \line if ( value2 \f0\fs16 > \f3\fs18 max \line max value2; \line if ( value3 \f0\fs16 > \f3\fs18 max \line max \f2\fs10 = \f3\fs18 value3; \line return max; \line O nome de \f0\fs20 um par\'e2metro de tipo deve ser \'fanico na lista de par\'e2metros formais de \f3\fs18 uma defini\'e7\'e3o de gabarito particular. A Fig. 3.27 ilustra o uso do gabarito de fun\'e7\'e3o maximo para determinar \f0\fs20 o maior de tr\'eas valores int, tr\'eas \f3\fs18 valores double e tr\'eas valores char. \line 1 \i\f2\fs20 II \i0\f3\fs18 Fig. 3.27: figo3_27.cpp \line 2 \f0\fs20 // \f3\fs18 Usando um gabarito de fun\'e7\'e3o \line 3 #include <iostream> \line 4 \line 5 using std::cout; \line\f0\fs16 6 \b\f3 using std::cin; \line\b0\fs18 7 using std::endl; \line 8 \line\b\fs16 9 template < class T > \line 10 T maximum \b0\f0\fs20 ( T valuel, \b\f3\fs16 T value2, T value3 \line 11 \b0\f0\fs20\{ \line\f3\fs18 12 T max \f2\fs10 = \b\f3\fs16 valuel; \line 13 \line 14 if \b0\f0\fs20 ( \b\f3\fs16 value2 > max \line 15 max \b0\f2\fs10 = \b\f3\fs16 value2; \line 16 \line 17 jf \b0\f0\fs20 ( \b\f3\fs16 value3 > max) \line 18 max \b0\f2\fs10 = \b\f3\fs16 value3; \line 19 \line 20 return max; \line 21 \b0\f0\fs20\} \line\b\f3\fs16 22 \line 23 int main \b0\fs18 O \line\b\fs16 24 \b0\f0\fs20\{ \line\b\f3\fs16 25 int inti, int2, int3; \line 26 \line\b0\fs18 27 cout \f0\fs16\'ab \b\f3 Forne\'e7a tr\'eas valores inteiros: \line 28 cm \b0\f0\'bb intl \'bb int2 \'bb int3; \line\b\f3 29 cout \'ab \ldblquote O maior valor inteiro \'e9: \line 30 \'ab maximuni( inti, int2, int3 ); \b0\i\f2\fs22 II \b\i0\f3\fs16 vers\'e3o para int \line 31 \b0\f0\fs24\par
\b\f2\fs18 Fig. 3.27 \b0 Usando um gabarito de fun\'e7\'e3o (parte 1 de 2). \f0\fs24\par
\b\f2\fs22 234 C++ \fs14 COMO PROGRAMAR \line\f3\fs16 32 double doublel, double2, double3; \line 33 \line 34 cout \'ab \lquote\\nForne\'e7a tr\'eas valores double: \b0\f2\fs10\ldblquote ; \line\b\f3\fs16 35 cm \'bb doublel \'bb double2 \'bb double3; \line 36 cout \'ab \lquote O maior valor double \'e9: \line 37 \'ab maximum( doublel, double2, double3); \f2\fs22 // \f3\fs16 vers\'e3o para double \line 38 \line 39 char chari, char2, char3; \line 40 \line 41 cout \'ab \ldblquote\\nForne\'e7a tr\'eas caracteres: \b0\f2\fs10\ldblquote ; \line\b\f3\fs16 42 cm \'bb chari \'bb char2 \'bb char3; \line 43 cout \'ab \ldblquote O maior valor de caractere \'e9: \line 44 \'ab maximwn( chari, char2, char3 \f2\fs22 ) \i\f0\fs20 II \i0\f3\fs16 vers\'e3o para char \line 45 \'ab endi; \line 46 \line 47 return 0; \line 48 \f2\fs22\} \line\f3\fs16 Forne\'e7a tr\'eas valores inteiros: 1 2 3 \line O maior valor inteiro \'e9: 3 \line Forne\'e7a tr\'eas valores double: 3.3 2.2 1.1 \line O maior valor double \'e9: 3.3 \line Forne\'e7a tr\'eas caracteres: A C 2 \line O maior valor de caractere \'e9: C \line\f2\fs20 Fig. 3.27 \b0 Usando um gabarito de fun\'e7\'e3o (parte 2 de 2). \line\b\i\f0 IErro comum de programa\'e7\'e3o 3.35 \line\b0\fs18 N\'e3o colocar a palavra-chave \i0 das s \i ou a palavra-chave \i0 typename \i antes de cada par\'e2metro de tipo de \f2\fs16 um \f0\fs18 gabarito de fun\'e7\'e3o \'e9 um erro de sintaxe. \line\b\i0\f2\fs26 3.22 (Estudo de caso opciona\rquote ) Pensando em objetos: identificando os atributos de uma c\rquote asse \line\b0\f0\fs18 Na se\'e7\'e3o \ldblquote Pensando em objetos\rdblquote  no \f2\fs20 fim \f0\fs18 do Cap\'edtulo 2, come\'e7amos a primeira fase de um projeto orientado a objetos (OOD) para o nosso simulador de elevador \f2\fs8 - \f0\fs18 identificar as classes necess\'e1rias para implementar o simulador. Come\'e7amos listando os substantivos na defini\'e7\'e3o do problema e criamos uma classe separada para cada categoria de substantivos que executa um trabalho importante na simula\'e7\'e3o do elevador. Representamos, ent\'e3o, as classes e seus relacionamentos em um diagrama de classes UML. Classes possuem \i atributos \i0 e \i opera\'e7\'f5es. \i0 Atributos de classes s\'e3o implementados em programas C++ como dados; opera\'e7\'f5es de classes s\'e3o implementadas como fun\'e7\'f5es. Nesta se\'e7\'e3o, determinaremos muitos dos atributos de classes necess\'e1rios para implementar o simulador do elevador. No Cap\'edtulo 4, determinaremos as opera\'e7\'f5es. No Cap\'edtulo 5, vamos nos concentrar nas intera\'e7\'f5es, freq\'fcentemente chamadas de \i colabo ra\'e7\'f5es, \i0 entre os objetos no simulador de elevador. \line Considere os atributos de alguns objetos do mundo real. Os atributos de uma pessoa incluem altura e peso. Os atributos de um r\'e1dio incluem sua sintonia de esta\'e7\'f5es, o ajuste de volume e se ele est\'e1 ajustado para AM ou FM. Os atributos de um carro incluem as leituras de seu veloc\'edmetro e od\'f4metro, a quantidade de combust\'edvel no tanque, que marcha est\'e1 engrenada, etc. Os atributos de um computador pessoal incluem fabricante (por exemplo. Apple, LBM ou Compaq), tipo de tela (por exemplo, monocrom\'e1tica ou a cores), tamanho da mem\'f3ria principal (em megabytes), tamanho do disco r\'edgido (em gigabytes), etc. \line Atributos descrevem classes. Podemos identificar os atributos de nosso sistema procurando palavras e frases descritivas na defini\'e7\'e3o do problema. Para cada palavra ou frase descritiva que encontramos, criamos um atributo e atribu\'edmos aquele atributo a uma classe. Tamb\'e9m criamos atributos para representar qualquer dado de que uma classe possa necessitar. Por exemplo, a classe \b\fs20 Scheduler \b0\fs18 precisa saber a hora para criar a pr\'f3xima pessoa a entrar em cada um dos andares. A Fig. 3.28 \'e9 uma tabela que lista as palavras ou frases da defini\'e7\'e3o do problema que descrevem cada classe. \fs24\par
\b\fs14 CAP\'cdTULO \b0\fs20 3 \f2\fs8 - \b\f0\fs14 FUN\'c7\'d5ES \b0\i\f2\fs22 235 \i0\f0\fs24\par
\b\f2\fs22 Fig 3.28 \b0\fs20 Palavras e frases descritivas na defini\'e7\'e3o do problema. \f0\fs24\par
\fs18 Observe que, para as classes Bell e Building, n\'e3o foi listado nenhum atributo. \fs26\'c0 \fs18 medida que progredirmos ao longo deste estudo de caso, continuaremos a adicionar, modificar e eliminar informa\'e7\'f5es sobre cada uma das classes em nosso sistema. \line A Fig. 3.29 \'e9 um diagrama de classes que lista alguns dos atributos para cada classe em nosso sistema \f2\fs8 - \f0\fs18 estes atributos s\'e3o criados a partir das palavras e frases descritivas da Fig. 3.28. No diagrama de casos da UML, os atributos de uma classe s\'e3o colocados no compartimento do meio do ret\'e2ngulo que representa a classe. Considere o seguinte atributo da classe Elevator: \line capacity : int \f2\fs12 = \f0\fs18 1 \fs24\par
\f2\fs18 currentFloor: int \fs12 = \fs18 1 direction : enum \fs12 = \fs18 up capacity : int \fs12 = \fs18 1 arrivalTime : int moving : bool \fs12 = \fs18 false \f0\fs24\par
\f1\fs94 1 \f0\fs24\par
\f2\fs20 Elevator \f0\fs24\par
\f2\fs20 Clock \f0\fs24\par
\f2\fs16 time: int \fs10 = \fs16 O \f0\fs24\par
\f2\fs20 Door \f0\fs24\par
\f2\fs18 open : bool \fs12 = \fs18 false \f0\fs24\par
\f2\fs20 Floor \f0\fs24\par
\f2\fs20 Scheduler \f0\fs24\par
\f2\fs18 capacity: int \fs12 = \fs18 1 occupied : bool false \f0\fs24\par
\f2\fs20 floorlArrivalTime : int tloor2ArrivalTime : int \f0\fs24\par
\f2\fs20 Beli \f0\fs24\par
\f2\fs20 <nenhum ainda> \f0\fs24\par
\f2\fs20 FloorButton \f0\fs24\par
\f2\fs18 pressed : bool \fs12 = \fs18 false \f0\fs24\par
\f2\fs20 Person \line lD: int \f0\fs24\par
\f2\fs20 Light \f0\fs24\par
\f2\fs18 on : bool \fs12 = \fs18 false \f0\fs24\par
\f2\fs20 ElevatorButton \f0\fs24\par
\f2\fs18 pressed : bool \fs12 = \fs18 false \f0\fs24\par
\f2\fs20 Buildincj \f0\fs24\par
\f2\fs20 <nenhum ainda> \f0\fs24\par
\b\f2\fs22 Fig. 3.29 \b0\fs20 Diagrama de classes mostrando os atributos. \f0\fs24\par
\pard\par
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1330\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx8946\pard\intbl\b\f2\fs22 Classe \b0\f0\fs24\cell\b\f2\fs22 Palavras e frases descritivas \b0\f0\fs24\cell\fs20\row
\intbl Elevator \fs24\cell\fs20 come\'e7a o dia esperando no pavimento 1 do edif\'edcio alterna dire\'e7\'f5es: subindo e descendo  capacidade de 1  leva 5 segundos para se mover de um andar para o outro elevador se movendo \fs24\cell\fs20\row
\intbl Clock \fs24\cell\fs20 come\'e7a o dia marcando a hora 0 \fs24\cell\fs20\row
\intbl Scheduler \fs24\cell\fs20 [escalona os tempos de chegada de pessoas paraj um inteiro aleat\'f3rio entre 5 e 20 segundos em dire\'e7\'e3o ao futuro a partir do momento atual (para cada andar) \fs24\cell\fs20\row
\intbl Person \fs24\cell\fs20 n\'famero da pessoa (da sa\'edda) \fs24\cell\fs20\row
\intbl Floor \fs24\cell\fs20 capacidade de 1  est\'e1 ocupado / desocupado \fs24\cell\fs20\row
\intbl FloorButton \fs24\cell\fs20 foi pressionado \fs24\cell\fs20\row
\intbl ElevatorButton \fs24\cell\fs20 foi pressionado \fs24\cell\fs20\row
\intbl Door \fs24\cell\fs20 porta aberta / porta fechada \fs24\cell\fs20\row
\intbl Beil \fs24\cell\fs20 nenhuma na defini\'e7\'e3o do problema \fs24\cell\fs20\row
\intbl Light \fs24\cell\fs20 luz acesa / apagada \fs24\cell\fs20\row
\intbl Building \fs24\cell\fs20 nenhuma na defini\'e7\'e3o do problema \fs24\cell\fs20\row
\pard\fs24\par
\pard\sb100\sa240\b\fs16 236 C++ COMO PROGRAMAR \b0\fs24\par
\fs18 Esta listagem cont\'e9m tr\'eas componentes de informa\'e7\'e3o sobre o atributo, O atributo tem um \i nome \i0\f2\fs8 - \b\f0\fs20 capacity. \b0\fs18 O atributo tamb\'e9m tem um \i tipo, \b\i0\fs20 int. \b0\fs18 O tipo depende da linguagem usada para escrever o sistema de software. Em C++, por exemplo, o valor pode ser um tipo primitivo, tal como int. char ou float, bem como um tipo definido pelo usu\'e1rio, como uma classe (come\'e7aremos nosso estudo de classes no Cap\'edtulo 6, onde veremos que cada nova classe \'e9, em ess\'eancia, um novo tipo de dado). \line Tamb\'e9m podemos indicar um \b\i\fs20 valor \b0\fs18 inicial \i0 para cada atributo, O atributo capacitiem um valor inicial de 1. Se um atributo em particular n\'e3o tem um valor inicial especificado, somente seu nome e tipo (separados por dois pontos) s\'e3o mostrados. Por exemplo, o atributo floorArrrivalTime da classe Scheduler \'e9 do tipo int. Aqui n\'e3o mostramos nenhum valor inicial porque o valor deste atributo \'e9 um n\'famero aleat\'f3rio que ainda n\'e3o conhecemos; o n\'famero aleat\'f3rio vai ser determinado durante a execu\'e7\'e3o. Por enquanto, n\'e3o nos preocuparemos demais com os tipos ou valores iniciais dos atributos. Inclu\'edmos somente a informa\'e7\'e3o que podemos vislumbrar na defini\'e7\'e3o do problema. \line\b\i\fs20 Diagramas de mapa de estados \line\b0\i0\fs18 Objetos em um sistema podem ter \b\i\fs20 estados. \b0\i0\fs18 Estados descrevem a condi\'e7\'e3o de um objeto em um determinado instante no tempo. \i Diagramas de mapa de estados \i0 (tamb\'e9m chamados de diagramas de \i estados) \i0 nos d\'e3o uma maneira de expressar como, e sob quais condi\'e7\'f5es, os objetos em um sistema mudam de estado. \line A Fig. 3.30 \'e9 um diagrama de mapa de estados simples que modela os estados de um objeto da classe FloorButton ou da classe E].evatorButton. Cada estado, em um diagrama de mapa de estados, \'e9 representado por um ret\'e2ngulo com cantos arredondados, com o nome do estado colocado dentro dele. Um c\'edrculo cheio com uma seta presa a ele aponta para o estado inicial (i.e., o estado \ldblquote N\'e3o pressionado\rdblquote ). As linhas cheias com setas indicam \i transi\'e7\'f5es \i0 entre estados. Um objeto pode passar de um estado para outro em resposta a um \i evento. \b\i0\fs20 Por \b0\fs18 exemplo, as classes FloorButton e ElevatorButton mudam do estado \ldblquote N\'e3o pressionado\rdblquote  para o estado \ldblquote Pressionado\rdblquote  em resposta ao evento \ldblquote apertar bot\'e3o\rdblquote . O nome do evento que causa a transi\'e7\'e3o \'e9 escrito junto \'e0 linha que corresponde \'e0quela transi\'e7\'e3o (podemos incluir mais informa\'e7\'f5es sobre eventos, como veremos). \fs24\par
\ul\f2\fs20 pressionaJ \f0\fs24\par
\f2\fs20 apertar bot\'e3o \ulnone soltar bot\'e3o \f0\fs24\par
\f2\fs20 iodJ \f0\fs24\par
\b\f2\fs18 Fig. \b0\fs20 3.30 Diagrama de estados para as classes FloorButton e ElevatorButton. \line\f0\fs18 A Fig. 3.31 mostra o diagrama de mapa de estados para a classe Elevator. O elevador tem tr\'eas estados poss\'edveis: \line\ldblquote Esperando\rdblquote , \ldblquote Atendendo andar\rdblquote  (i.e., o elevador est\'e1 parado em um andar, mas est\'e1 ocupado desligando o bot\'e3o do elevador ou se comunicando com o andar, etc.) e \ldblquote Movendo-se\rdblquote . O elevador inicia no estado \ldblquote Esperando\rdblquote . Os eventos que provocam as transi\'e7\'f5es est\'e3o indicados junto as linhas de transi\'e7\'e3o apropriadas. \fs24\par
\f2\fs20 [nenhuma chamada adicional] \f0\fs24\par
\f2\fs18 apertar bot\'e3o [no outro andar]! arrivalTime \fs10 = \fs18 currentTime + 5 \f0\fs24\par
\f2\fs20 apertar bot\'e3o [precisa se mover] \f0\fs24\par
\f2\fs20 apertar bot\'e3o \f0\fs24\par
\f2\fs20 Atendendo andar \f0\fs24\par
\f2\fs20 sa\'edda! fechar a porta \f0\fs24\par
\b\f2\fs18 Fig 3.31 \b0 Diagrama de estados para a classe Elevator. \f0\fs24\par
\b\fs14 CAP\'cdTULO \b0\fs18 3 \f2\fs8 - \b\f0\fs14 FUN\'c7\'d5ES \f2\fs22 237 \line\b0\f0\fs18 Examinemos os eventos neste diagrama de mapa de estados. O texto \line\f2\fs22 apertar bot\'e3o [precisa se mover] \line\f0\fs18 nos diz que o evento \ldblquote apertar bot\'e3o\rdblquote  faz com que o elevador passe do estado \ldblquote Atendendo andar\rdblquote  para o estado \ldblquote Movendo-se\rdblquote . A \i condi\'e7\'e3o guarda, \i0 entre colchetes, indica que a transi\'e7\'e3o acontece somente se o elevador precisa se mover, O texto completo do evento indica que o elevador passa do estado \ldblquote Atendendo andar\rdblquote  para o estado \ldblquote Movendo-se\rdblquote  em resposta ao evento \ldblquote apertar bot\'e3o\rdblquote  somente se o elevador precisar se mover. Similarmente, as transi\'e7\'f5es do elevador do estado \ldblquote Esperando\rdblquote  para o estado \ldblquote Atendendo andar\rdblquote  indicam quando \'e9 apertado um bot\'e3o no andar em que o elevador est\'e1 atualmente. \line O texto junto \'e0 linha de transi\'e7\'e3o do estado \ldblquote Esperando\rdblquote  para o estado \ldblquote Movendo-se\rdblquote  indicam que esta transi\'e7\'e3o ocorre no caso de um bot\'e3o ser apertado (se o bot\'e3o \'e9 apertado no outro andar). A barra \b\i\fs22 (\ldblquote 1\rdblquote ) \b0\i0\fs18 indica que uma \i a\'e7\'e3o \i0 acompanha esta mudan\'e7a de estado. O elevador executa a a\'e7\'e3o de calcular e ajustar a hora em que vai chegar ao outro andar.\rquote  \line Uma transi\'e7\'e3o de estado tamb\'e9m pode ocorrer no caso de uma certa condi\'e7\'e3o ser verdadeira, O texto \line quando \f2\fs22 [currentTime \fs12 == \fs22 arrivalTime] \line\f0\fs18 indica que o elevador passa do estando \ldblquote Movendo-se\rdblquote  para o estado \ldblquote Atendendo andar\rdblquote  \i quando \i0 a hora atual na simula\'e7\'e3o \'e9 igual \'e0 hora em que o elevador deve chegar em um andar. \line O texto que est\'e1 junto \'e0 linha de transi\'e7\'e3o do estado \ldblquote Atendendo andar\rdblquote  para o estado \ldblquote Esperando\rdblquote  indica que o elevador passa para o estado \ldblquote Esperando\rdblquote  a partir do estado \ldblquote Atendendo andar\rdblquote  com a condi\'e7\'e3o de que n\'e3o exista nenhuma chamada adicional para atendimento pelo elevador.2 \line\b\i\fs22 Diagramas de atividades \line\b0\i0\fs18 O \i diagrama de atividades \i0\'e9 uma varia\'e7\'e3o do diagrama de mapa de estados. O diagrama de atividades se concentra nas atividades que um objeto executa; em outras palavras, o diagrama de atividades modela o que um objeto faz durante sua exist\'eancia. \line O diagrama de mapa de estados na figura anterior (Fig. 3.3 1) n\'e3o traz nenhuma informa\'e7\'e3o sobre para qual estado o elevador passa se duas pessoas diferentes no edif\'edcio apertam um bot\'e3o ao mesmo tempo em andares diferentes. Ele tamb\'e9m n\'e3o cont\'e9m informa\'e7\'e3o sobre como o elevador decide se precisa se mover. O diagrama de atividades na Fig. 3.32 acrescenta novas informa\'e7\'f5es \'e0s apresentadas no diagrama de mapa de estados, modelando as atividades que o elevador executa em resposta a uma chamada. \line Atividades s\'e3o representadas por elipses. O nome da atividade \'e9 colocado dentro da elipse. Uma linha cheia com uma seta conecta duas atividades, indicando a ordem na qual as atividades s\'e3o executadas. Assim como no diagrama de mapa de estados, o c\'edrculo cheio indica o ponto de partida da seq\'fc\'eancia de atividades. A seq\'fc\'eancia de atividades modelada neste diagrama \'e9 executada sempre que \'e9 apertado um bot\'e3o (i.e., se qualquer um dos bot\'f5es de andar est\'e1 agora no estado \ldblquote Pressionado\rdblquote ). Quando esta condi\'e7\'e3o \'e9 verdadeira, o elevador precisa tomar uma decis\'e3o (representada pelo losango).3 O elevador opta por uma entre v\'e1rias atividades neste ponto, com base em certas condi\'e7\'f5es. Cada linha (ou caminho) saindo do losango representa um destes diferentes conjuntos de atividades. Uma condi\'e7\'e3o de guarda colocada junto a cada caminho indica sob que circunst\'e2ncias aquele caminho \'e9 executado. \line Em nosso diagrama, o elevador executa um de tr\'eas diferentes conjuntos de atividades quando \'e9 pressionado \line um bot\'e3o. Se o elevador est\'e1 em movimento (i.e., no estado \ldblquote Movendo-se\rdblquote ), o elevador n\'e3o pode executar imediatamente qualquer outra atividade, de modo que a seq\'fc\'eancia de atividades no caminho atual simplesmente termina. \line Em um sistema de elevador do mundo real, um sensor no elevador poderia fazer com que ele parasse em um andar. Em nosso simulador de elevador, sabemos que o elevador leva cinco segundos para se mover de um andar para o outro. Assim, em nossa simula\'e7\'e3o, o elevador pode simplesmente agendar sua pr\'f3pria chegada em um andar e o elevador ir\'e1 parar naquela hora agendada. \line Em um sistema de elevador do mundo real, o elevador provavelmente passa de um destes estados para o outro depois de decorrido um certo intervalo de tempo. Queremos programar um simulador, mas n\'e3o queremos nos preocupar com os detalhes de como o elevador vai \ldblquote saber\rdblquote  quando n\'e3o existe nenhuma chamada adicional. Portanto, simplesmente dizemos que o elevador muda de estado no caso de n\'e3o haver mais nenhuma chamada. \fs24\par
\f2\fs20 238 \b\fs16 C++ COMO PROGRAMAR \b0\f0\fs24\par
\f2\fs20 [bot\'e3o do andar atual pressionado] \f0\fs24\par
\b\f2\fs18 Fig. 3.32 \b0 Diagrama de atividades modelando a l\'f3gica do elevador para responder a pressionamentos de bot\'f5es. \f0\fs24\par
\fs20 Um c\'edrculo cheio circundado por outro c\'edrculo (\'e0s vezes chamado de \ldblquote olho de boi\rdblquote ) indica o ponto final de um diagrama de atividades. \line Se o bot\'e3o do andar \'e9 pressionado no andar em que est\'e1 o elevador, o elevador desliga o bot\'e3o, toca a campainha \line e abre a porta. Se o bot\'e3o no andar em que o elevador est\'e1 n\'e3o \'e9 pressionado, o elevador precisa primeiro fechar a \line porta, mover para o outro andar e ent\'e3o parar no outro andar, antes que ele possa atender ao outro andar. Observe que \line a UML modela a jun\'e7\'e3o de caminhos de decis\'e3o com outro losango pequeno. Depois que o elevador abre a porta, a \line seq\'fc\'eancia de atividades termina. \fs24\par
\b\i\fs22 Conclus\'e3o \line\b0\i0\fs20 Para recapitular, expandimos nossos conhecimentos sobre as classes de nosso sistema (como vamos continuar a fazer nos pr\'f3ximos v\'e1rios cap\'edtulos) e representamos este conhecimento em nosso diagrama de classes. Tamb\'e9m usamos diagramas de mapa de estados e diagramas de atividades para obter mais informa\'e7\'f5es sobre como funciona nosso sistema. Embora ainda n\'e3o tenhamos discutido os detalhes da programa\'e7\'e3o orientada a objetos em C++, \fs24 j\'e1 \fs20 temos uma quantidade significativa de informa\'e7\'f5es sobre nosso sistema. Nas se\'e7\'f5es \ldblquote Pensando em objetos\rdblquote  nos finais dos Cap\'edtulos 4 e 5, determinamos as opera\'e7\'f5es associadas com nossas classes e como nossas classes interagem (i.e., colaboram) umas com as outras. \fs24\par
\b\f2\fs14 CAP\'cdTULO \b0\fs18 3 \fs8 - \b\fs14 FUN\'c7\'d5ES \fs22 239 \b0\f0\fs24\par
\i\fs20 Nota \line\i0\fs16 1. Neste cap\'edtulo, voc\'ea apreendeu como implementar a \ldblquote aleatoriedade\rdblquote . O comando \line\f3\fs18 arrivalTime \f2\fs10 = \f3\fs18 currentTime \f0\fs16 + \i\fs20 ( \i0\f3\fs18 5 \f0\fs16 + rand() % 16 ); \line\f3\fs18 pode ser usado para programar aleatoriamente a pr\'f3xima chegada de uma pessoa em um andar. \line\b\i\f2\fs26 Resumo \line\b0\i0\f0\fs16\bullet  O melhor caminho para desenvolver e manter um programa grande \f2\fs18\'e9 \f0\fs16 dividi-lo em v\'e1rios m\'f3dulos de programa menores, sendo cada um deles mais administr\'e1vel que o programa original. M\'f3dulos s\'e3o escritos em C++ como classes e fun\'e7\'f5es. \line\bullet  Um fun\'e7\'e3o \'e9 invocada por uma chamada de fun\'e7\'e3o. A chamada da fun\'e7\'e3o menciona a fun\'e7\'e3o por nome e fornece informa\'e7\'e3o (como par\'e2metros) de que a fun\'e7\'e3o chamada necessita para executar sua tarefa. \line\bullet  A finalidade da oculta\'e7\'e3o de informa\'e7\'f5es \f2\fs18\'e9 \f0\fs16 as fun\'e7\'f5es terem acesso apenas \'e0s informa\'e7\'f5es de que necessitam para completar suas tarefas. Este \f2\fs18\'e9 \f0\fs16 um meio de implementar o princ\'edpio do m\'ednimo privil\'e9gio, um dos princ\'edpios mais importantes da boa engenharia de software. \line\bullet  O tipo de dados double \f2\fs18\'e9 \f0\fs16 um tipo de ponto flutuante como float. Uma vari\'e1vel do tipo double pode armazenar um valor de magnitude e precis\'e3o muito maiores do que float pode armazenar. \line\bullet  Cada par\'e2metro de uma fun\'e7\'e3o pode ser uma constante, uma vari\'e1vel ou uma express\'e3o. \line\bullet  Uma vari\'e1vel local \'e9 conhecida s\'f3 em uma defini\'e7\'e3o da fun\'e7\'e3o. Fun\'e7\'f5es n\'e3o podem saber os detalhes de implementa\'e7\'e3o de qualquer outra fun\'e7\'e3o (inclusive vari\'e1veis locais). \line\bullet  O formato geral da defini\'e7\'e3o de uma fun\'e7\'e3o \f2\fs18\'e9 \line\i\f0\fs16 tipo do valor de retorno nome da fun\'e7\'e3o ( lista de par\'e2metros \line declara\'e7\'f5es e instru\'e7\'f5es \line O tipo do valor de retorno \i0 indica o tipo do valor enviado de volta para a fun\'e7\'e3o que fez a chamada. Se uma fun\'e7\'e3o n\'e3o retorna \f3\fs18 um valor, \f0\fs16 o \i tipo do valor de retorno \i0\f2\fs18\'e9 \f0\fs16 declarado como void. \i O nome da fun\'e7\'e3o \'e9 \i0 qualquer identificador v\'e1lido. A \i lista de par\'e2metros \'e9 \i0 uma lista separada por v\'edrgulas que cont\'e9m as declara\'e7\'f5es das vari\'e1veis que ser\'e3o passadas \'e0 fun\'e7\'e3o. Se uma fun\'e7\'e3o n\'e3o recebe valor algum, a \i lista de par\'e2metros \'e9 \i0 declarada void. \i O corpo da fun\'e7\'e3o \i0\'e9 o conjunto de declara\'e7\'f5es e comandos que formam a fun\'e7\'e3o. \line\bullet  Os argumentos passados a uma fun\'e7\'e3o devem ser equivalentes em n\'famero, tipo e ordem aos par\'e2metros na defini\'e7\'e3o da fun\'e7\'e3o. \line\bullet  Quando um programa encontra uma chamada de fun\'e7\'e3o, o controle \f2\fs18\'e9 \f0\fs16 transferido do ponto de chamada para a referida fun\'e7\'e3o, a fun\'e7\'e3o chamada \'e9 executada e o controle retorna a quem chamou. \line\bullet  Uma fun\'e7\'e3o chamada pode devolver o controle a quem chamou de tr\'eas maneiras. Se a fun\'e7\'e3o n\'e3o retorna um valor, o controle \f2\fs18\'e9 \f0\fs16 devolvido quando a chave \'e0 direita final da fun\'e7\'e3o \f2\fs18\'e9 \f0\fs16 alcan\'e7ada ou pela execu\'e7\'e3o do comando \line return; \line Se a fun\'e7\'e3o retornar um valor, o comando \line return \i express\'e3o; \line\i0 retorna o valor de \i express\'e3o. \line\i0\bullet  Um prot\'f3tipo de fun\'e7\'e3o declara o tipo de retorno da fun\'e7\'e3o e declara o n\'famero, os tipos e a ordem dos par\'e2metros que a fun\'e7\'e3o espera receber. \fs24\par
\fs16 Este s\'edmbolo n\'e3o deve ser confundido como losango grande usado em fluxogramas como aqueles apresentados na Se\'e7\'e3o 2.21. \fs24\par
\b\f2\fs22 240 C++ \fs14 COMO PROGRAMAR \line\b0\f0\fs16\bullet  Os prot\'f3tipos de fun\'e7\'f5es permitem que o compilador verifique se as fun\'e7\'f5es s\'e3o chamadas corretamente. \f2\fs10\bullet  \f0\fs16\'c1 \line\bullet  O compilador ignora nomes vari\'e1veis mencionados no prot\'f3tipo da fun\'e7\'e3o. \f2\fs10 . \f0\fs16 H \line\bullet  Cada biblioteca padr\'e3o tem um arquivo de cabe\'e7alho correspondente, contendo os prot\'f3tipos de fun\'e7\'e3o para todas as fun\'e7\'f5es \line daquela biblioteca, bem como defini\'e7\'f5es de constantes simb\'f3licas necess\'e1rias para aquelas fun\'e7\'f5es. \'c1 \line\bullet  Os programadores podem e devem criar e incluir seus pr\'f3prios arquivos de cabe\'e7alho. \line\bullet  Quando um par\'e2metro \'e9 passado em uma chamada por valor, uma c\'f3pia do valor da vari\'e1vel \'e9 feita e a c\'f3pia \'e9 passada para \'c1 \line a fun\'e7\'e3o chamada. Altera\'e7\'f5es da c\'f3pia na fun\'e7\'e3o chamada n\'e3o afetam o valor da vari\'e1vel original. T \line\bullet  A fun\'e7\'e3o rand gera um inteiro entre O e \f2 RAND-MAX, \f0 que \'e9 definido como sendo pelo menos 32767. e \line\bullet  Os prot\'f3tipos de fun\'e7\'e3o para rand e srand est\'e3o contidos em <cstdlib>. C \line\bullet  Os valores produzidos por rand podem ser ajustados em escala e deslocados para produzir valores em um intervalo espec\'edfico. \line\bullet  Para randomizar a sa\'edda de rand, use a fun\'e7\'e3o srand da biblioteca padr\'e3o. \line\bullet  O comando srand normalmente \'e9 inserido em um programa s\'f3 depois de o programa estar completamente depura- \f2\fs10\bullet  \line\f0\fs16 do. Enquanto se faz a depura\'e7\'e3o, \'e9 melhor omitir srand. Isto garante a \ldblquote repetibilidade\rdblquote , que \'e9 essencial para provar d que as corre\'e7\'f5es em um programa de gera\'e7\'e3o de n\'fameros aleat\'f3rios funcionam corretamente. \line\bullet  Para randomizar sem necessidade de fornecer uma semente toda vez, podemos usar srand ( time ( O \f2 )). \f0 A fun\'e7\'e3o time \line normalmente retorna o \ldblquote tempo de calend\'e1rio\rdblquote  em segundos. O prot\'f3tipo da fun\'e7\'e3o time est\'e1 localizado no arquivo de \line cabe\'e7alho <etime>. \f2\fs10\bullet  \fs16 ( \line\f0\bullet  A equa\'e7\'e3o geral para ajustar a escala e deslocar um n\'famero aleat\'f3rio \'e9 \line n \f2\fs10 = \f0\fs16 a-I- rand() % b; \line onde a \'e9 o valor do deslocamento (que \f2\'e9 \f0 igual ao primeiro n\'famero no intervalo desejado de inteiros sucessivos), e b \'e9 o fator 6 de ajuste de escala (que \'e9 igual ao comprimento do intervalo de inteiros sucessivos desejado). \line\bullet  Uma enumera\'e7\'e3o, introduzida pela palavra-chave enum e seguida por um nome de tipo, \'e9 um conjunto de constantes do tipo \f2\fs10 . \f0\fs16 l \line inteiro representadas por identificadores. \f2\fs10\bullet  \f1\fs26 s \line\f0\fs16\bullet  Os valores destas constantes de enumera\'e7\'e3o come\'e7am em O, a menos que especificado de maneira diversa, e s\'e3o incrementados \f2\fs12 U \line\f0\fs16 pori. \f2\fs12 U \line\f0\fs16\bullet  Os identificadores em uma erium devem ser \'fanicos, mas constantes de enumera\'e7\'e3o separadas podem ter o mesmo valor inteiro. \line\bullet  A qualquer constante de enumera\'e7\'e3o pode ser explicitamente atribu\'eddo um valor inteiro na enumera\'e7\'e3o. \line\bullet  Cada identificador de vari\'e1vel tem os atributos classe de armazenamento, escopo e liga\'e7\'e3o. \line\bullet  C++ fornece cinco especificadores de classe de armazenamento: auto. register. extern, mutable e static. \f2\fs10\bullet  \line\f0\fs16\bullet  A classe de armazenamento de um identificador determina quando aquele identificador existe na mem\'f3ria. \line\bullet  O escopo de um identificador \'e9 onde o identificador pode ser referenciado em um programa. \line\bullet  A liga\'e7\'e3o de um identificador determina, em um programa com v\'e1rios arquivos-fonte, que um identificador \'e9 conhecido \line apenas no arquivo-fonte atual ou em qualquer arquivo-fonte com declara\'e7\'f5es adequadas. e \line\bullet  As vari\'e1veis da classe de armazenamento autom\'e1tica s\'e3o criadas quando se ingressa no bloco onde elas s\'e3o declaradas, \f2\fs10 . \f0\fs16 1 \line existem enquanto o bloco estiver ativo e s\'e3o destru\'eddas quando o bloco chega ao fim. Normalmente, as vari\'e1veis locais de uma \line fun\'e7\'e3o s\'e3o da classe de armazenamento autom\'e1tica por default. \f2\fs10\bullet  \line\f0\fs16\bullet  O especificador de classe de armazenamento register pode ser colocado antes de uma declara\'e7\'e3o de vari\'e1vel autom\'e1tica \f1\fs12 C \line\f0\fs16 para sugerir que o compilador mantenha a vari\'e1vel em um dos registradores de hardware de alta velocidade do computador. \f2\fs10\bullet  \line\f0\fs16 O compilador pode ignorar declara\'e7\'f5es register. A palavra-chave register pode ser usada apenas com vari\'e1veis da 1 \line classe de armazenamento autom\'e1tica. \line\bullet  As palavras-chave extern e static s\'e3o usadas para declarar identificadores para vari\'e1veis e fun\'e7\'f5es da classe de \line armazenamento est\'e1tica. e \fs24\par
\fs16 CAP\'cdTULO 3 \f2\fs8 - \b\f0\fs14 FUN\'c7\'d5ES \f2\fs22 241 \line\b0\f0\fs16\bullet  As vari\'e1veis com classe de armazenamento est\'e1tica s\'e3o alocadas e inicializadas quando a execu\'e7\'e3o do programa \'e9 iniciada. \line\bullet  H\'e1 dois tipos de identificadores da classe de armazenamento est\'e1tica: identificadores externos (como vari\'e1veis globais e nomes de fun\'e7\'f5es) e vari\'e1veis locais declaradas com o especificador de classe de armazenamento static. \line\bullet  As vari\'e1veis globais s\'e3o criadas colocando-se declara\'e7\'f5es de vari\'e1veis fora de qualquer defini\'e7\'e3o de fun\'e7\'e3o e conservam seus valores ao longo de toda a execu\'e7\'e3o do programa. \line\bullet  As vari\'e1veis locais declaradas como static conservam seus valores quando termina a fun\'e7\'e3o na qual s\'e3o declaradas. \line\bullet  Todas as vari\'e1veis num\'e9ricas da classe de armazenamento est\'e1tica s\'e3o inicializadas com o valor zero se n\'e3o forem inicializadas explicitamente pelo programador. \line\bullet  Os escopos de um identificador s\'e3o: escopo de fun\'e7\'e3o, escopo de arquivo, escopo de bloco e escopo de prot\'f3tipo de fun\'e7\'e3o. \line\bullet  Os r\'f3tulos s\'e3o os \'fanicos identificadores com escopo de fun\'e7\'e3o. Os r\'f3tulos podem ser usados em qualquer lugar da fun\'e7\'e3o onde aparecem, mas n\'e3o se pode fazer refer\'eancia a eles fora do corpo da fun\'e7\'e3o. \line\bullet  Um identificador declarado fora de qualquer fun\'e7\'e3o tem escopo de arquivo. Tal identificador \'e9 \ldblquote conhecido\rdblquote  por todas as fun\'e7\'f5es, desde o ponto em que o identificador \'e9 declarado at\'e9 o final do arquivo. \line\bullet  Os identificadores declarados dentro de um bloco possuem escopo de bloco. O escopo de bloco termina na chave \'e0 direita ( \}) de encerramento do bloco. \line\bullet  As vari\'e1veis locais declaradas no in\'edcio de uma fun\'e7\'e3o possuem escopo de bloco, assim como os par\'e2metros da fun\'e7\'e3o, que s\'e3o considerados vari\'e1veis locais por ela. \line\bullet  Qualquer bloco pode conter declara\'e7\'f5es de vari\'e1veis. Quando houver blocos aninhados e um identificador externo ao bloco tiver o mesmo nome que um identificador interno a ele, o identificador do bloco externo fica \ldblquote escondido\rdblquote  at\'e9 que termine a execu\'e7\'e3o do bloco interno. \line\bullet  Os \'fanicos identificadores com escopo de prot\'f3tipo de fun\'e7\'e3o s\'e3o os utilizados na lista de par\'e2metros de um prot\'f3tipo de fun\'e7\'e3o. Os identificadores empregados em um prot\'f3tipo de fun\'e7\'e3o podem ser reutilizados em qualquer lugar do programa, sem ambig\'fcidade. \line\bullet  Uma fun\'e7\'e3o recursiva \'e9 uma fun\'e7\'e3o que chama a si mesma, direta ou indiretamente. \line\bullet  Se uma fun\'e7\'e3o recursiva \'e9 chamada com um caso b\'e1sico, ela simplesmente retorna um resultado. Se a fun\'e7\'e3o \'e9 chamada com um problema mais complexo, ela divide o problema em duas partes conceituais: uma parte que a fun\'e7\'e3o sabe como tratar e uma vers\'e3o ligeiramente menor do problema original. Como esse novo problema se parece com o problema original, a fun\'e7\'e3o ativa uma chamada recursiva para trabalhar com o problema menor. \line\bullet  Para uma recurs\'e3o terminar, cada vez que uma fun\'e7\'e3o recursiva chamar a si mesma com uma vers\'e3o ligeiramente mais simples do problema original, a seq\'fc\'eancia de problemas cada vez menores deve convergir para o caso b\'e1sico. Quando a fun\'e7\'e3o reconhecer o caso b\'e1sico, o resultado \'e9 devolvido para a chamada anterior da fun\'e7\'e3o e segue-se uma seq\'fc\'eancia de retornos, at\'e9 que a chamada original da fun\'e7\'e3o devolve, em algum momento, o resultado final. \line\bullet  O padr\'e3o C++ n\'e3o especifica a ordem na qual os operandos da maioria dos operadores devem ser calculados. C++ especifica a ordem de c\'e1lculo dos operandos dos operadores \b\fs14 &&. \f2\fs22 1 1 \b0\fs8 , \f0\fs16 o operador v\'edrgula \b\f2\fs22 (,) \b0\f0\fs16 e \f2\fs10 ?:. \f0\fs16 Os tr\'eas primeiros s\'e3o opera- dores bin\'e1rios, cujos dois operandos s\'e3o calculados da esquerda para a direita. O \'faltimo operador \'e9 o \'fanico operador tern\'e1rio de C++. Seu operando da extremidade esquerda \'e9 avaliado em primeiro lugar; se o operando mais \'e0 esquerda tiver valor diferente de zero, o operando do meio \'e9 avaliado em seguida e o \'faltimo operando \'e9 ignorado; se o operando mais \'e0 esquerda tiver o valor zero, o terceiro operando \'e9 avaliado a seguir e o operando do meio \'e9 ignorado. \line\bullet  Tanto a itera\'e7\'e3o como a recurs\'e3o se baseiam em uma estrutura de controle: a itera\'e7\'e3o usa uma estrutura de repeti\'e7\'e3o; a recurs\'e3o, uma estrutura de sele\'e7\'e3o. \line\bullet  Tanto a itera\'e7\'e3o como a recurs\'e3o envolvem repeti\'e7\'f5es: a itera\'e7\'e3o usa explicitamente uma estrutura de repeti\'e7\'e3o; a recurs\'e3o consegue a repeti\'e7\'e3o atrav\'e9s de chamadas repetidas da fun\'e7\'e3o. \line\bullet  Tanto a itera\'e7\'e3o como a recurs\'e3o envolvem testes de encerramento: a itera\'e7\'e3o se encerra quando a condi\'e7\'e3o de continua\'e7\'e3o do la\'e7o se torna falsa; a recurs\'e3o termina quando um caso b\'e1sico \'e9 reconhecido. \line\bullet  A itera\'e7\'e3o e a recurs\'e3o podem ocorrer infinitamente: ocorre um la\'e7o infinito com a itera\'e7\'e3o se o teste de continua\'e7\'e3o do la\'e7o nunca se tornar falso; acontece recurs\'e3o infinita se a etapa de recurs\'e3o n\'e3o reduzir o problema de forma que convirja para o caso b\'e1sico. \fs24\par
\b\f2\fs18 242 C++ COMO PROGRAMAR \b0\f0\fs24\par
\fs16\bullet  A recurs\'e3o ativa repetidamente o mecanismo, e conseq\'fcentemente o \i overhead, \i0 de chamadas de fun\'e7\'f5es. Isso pode custar caro, tanto em termos de tempo do processador como em espa\'e7o de mem\'f3ria. \line\bullet  Os programas em C++ n\'e3o compilam a menos que um prot\'f3tipo de fun\'e7\'e3o seja fornecido para cada fun\'e7\'e3o ou que cada fun\'e7\'e3o seja definida antes de ser usada. \line\bullet  Uma fun\'e7\'e3o que n\'e3o retorna um valor \'e9 declarada com um tipo de rctorno void. Uma tentativa de retornar um valor da fun\'e7\'e3o ou de usar o resultado da invoca\'e7\'e3o da fun\'e7\'e3o na fun\'e7\'e3o que chamou \'e9 um erro de sintaxe. Uma lista de par\'e2metros vazia \'e9 especificada com par\'eanteses vazios ou void em par\'eanteses. \line\bullet  Fun\'e7\'f5es \i mime \i0 eliminam o \i overhead \i0 de uma chamada de fun\'e7\'e3o. O programador usa a palavra-chave mime para aconselhar o compilador a gerar o c\'f3digo da fun\'e7\'e3o em linha (quando poss\'edvel), para minimizar chamadas de fun\'e7\'e3o. O compilador pode escolher optar por ignorar a especifica\'e7\'e3o mune. \line\bullet  C++ oferece uma forma direta de chamada por refer\'eancia usando par\'e2metros de refer\'eancia. Para indicar que um par\'e2metro de fun\'e7\'e3o \'e9 passado por refer\'eancia, coloque um \f2\fs14 & \f0\fs16 ap\'f3s o tipo do par\'e2metro, no prot\'f3tipo da fun\'e7\'e3o. Na chamada da fun\'e7\'e3o, mencione a vari\'e1vel por seu nome e ela ser\'e1 passada por refer\'eancia. Na fun\'e7\'e3o chamada, mencionar a vari\'e1vel por seu nome local na realidade faz refer\'eancia \'e0 vari\'e1vel original na fun\'e7\'e3o que chamou. Deste modo, a vari\'e1vel original pode ser diretamente modificada pela fun\'e7\'e3o chamada. \line\bullet  Par\'e2metros por refer\'eancia tamb\'e9m podem ser criados para uso local como \i aliases \i0 para outras vari\'e1veis dentro de uma fun\'e7\'e3o. As vari\'e1veis de refer\'eancia devem ser inicializadas em suas declara\'e7\'f5es e n\'e3o lhe podem ser atribu\'eddas a \i aliases \i0 de outras vari\'e1veis. Uma vez que uma vari\'e1vel de refer\'eancia tenha sido declarada como um nome alternativo para outra vari\'e1vel, todas as opera\'e7\'f5es supostamente executadas sobre o nome alternativo s\'e3o realmente executadas sobre a vari\'e1vel por ele referida. \line\bullet  C++ permite ao programador especificar par\'e2metros default e seus valores default. Se um par\'e2metro default \'e9 omitido em uma chamada de uma fun\'e7\'e3o, o valor default daquele par\'e2metro \'e9 usado. Os par\'e2metros default devem ser os par\'e2metros mais \'e0 direita (finais) na lista de par\'e2metros de uma fun\'e7\'e3o. Os par\'e2metros default devem ser especificados com a primeira ocorr\'eancia do nome da fun\'e7\'e3o. Os valores default podem ser constantes, vari\'e1veis globais ou chamadas de fun\'e7\'e3o. \line\bullet  O operador un\'e1rio de resolu\'e7\'e3o de escopo (: :) possibilita a um programa acessar uma vari\'e1vel global quando uma vari\'e1vel \line localdo mesmo nome est\'e1 no escopo. \line\f1\fs24\bullet  \'c9 \f0\fs16 poss\'edvel definir v\'e1rias fun\'e7\'f5es com o mesmo nome, mas com os tipos dos par\'e2metros diferentes. Isto \'e9 chamado de sobrecarregar uma fun\'e7\'e3o. Quando \'e9 chamada uma fun\'e7\'e3o sobrecarregada, o compilador seleciona a fun\'e7\'e3o apropriada examinando o n\'famero e os tipos de par\'e2metros na chamada. \line\bullet  Fun\'e7\'f5es sobrecarregadas podem ter valores de retorno diferentes ou n\'e3o, mas devem ter listas de par\'e2metros diferentes. Se duas fun\'e7\'f5es diferem somente pelo tipo de retorno, isto resultar\'e1 em um erro de compila\'e7\'e3o. \line\bullet  Gabaritos de fun\'e7\'e3o possibilitam a cria\'e7\'e3o de fun\'e7\'f5es que executam as mesmas opera\'e7\'f5es sobre tipos diferentes de dados, mas o gabarito da fun\'e7\'e3o \'e9 definido somente uma vez. \line\b\i\f2\fs26 Terminologia \line\b0\i0\f0\fs16 ajustar escala classe de armazenamento \line argumento em uma chamada de fun\'e7\'e3o classe de armazenamento autom\'e1tica \line argumentos default de uma fun\'e7\'e3o classe de armazenamento est\'e1tica \line armazenamento autom\'e1tico coer\'e7\'e3o de argumentos \line arquivo de cabe\'e7alho colabora\'e7\'e3o \line arquivos de cabe\'e7alho da biblioteca padr\'e3o compilador otimizador \line assinatura componente \line assinatura de fun\'e7\'e3o const \line biblioteca padr\'e3o C++ constante com nome \line bloco constante de enumera\'e7\'e3o \line caso b\'e1sico da recurs\'e3o c\'f3pia de um valor \line chamada de fun\'e7\'e3o declara\'e7\'e3o de fun\'e7\'e3o \line chamada por refer\'eancia decora\'e7\'e3o de nome \line chamada por valor defini\'e7\'e3o de fun\'e7\'e3o \line chamada recursiva deslocamento \line chamar uma fun\'e7\'e3o dividir para conquistar \fs24\par
\b\f1\fs98 1 \b0\f0\fs24\par
\f2\fs18 242 C++ \b\fs14 COMO PROGRAMAR \b0\f0\fs24\par
\fs16 : \f2\fs10\bullet  \f0\fs16 A recurs\'e3o ativa repetidamente o mecanismo, e conseq\'fcentemente o \i overhead, \i0 de chamadas de fun\'e7\'f5es. Isso pode custar caro, tanto em termos de tempo do processador como em espa\'e7o de mem\'f3ria. \line Os programas em C++ n\'e3o compilam a menos que um prot\'f3tipo de fun\'e7\'e3o seja fornecido para cada fun\'e7\'e3o ou que cada fun\'e7\'e3o seja definida antes de ser usada. \line\bullet  Uma fun\'e7\'e3o que n\'e3o retorna um valor \'e9 declarada \b\fs14 com um tipo \b0\fs16 de retorno void. Uma tentativa de retornar um valor da fun\'e7\'e3o ou de usar o resultado da invoca\'e7\'e3o da fun\'e7\'e3o na fun\'e7\'e3o que chamou \'e9 um erro de sintaxe. Uma lista de par\'e2metros \line vazia \'e9 especificada com par\'eanteses vazios ou void em par\'eanteses. \line Fun\'e7\'f5es \i mime \i0 eliminam o \i overhead \i0 de uma chamada de fun\'e7\'e3o. O programador usa a palavra-chave mime para aconselhar o compilador a gerar o c\'f3digo da fun\'e7\'e3o em linha (quando poss\'edvel), para minimizar chamadas de fun\'e7\'e3o. O compilador \line pode escolher optar por ignorar a especifica\'e7\'e3o iriline. \line\bullet  C++ oferece uma forma direta de chamada por refer\'eancia usando par\'e2metros de refer\'eancia. Para indicar que um par\'e2metro de fun\'e7\'e3o \'e9 passado por refer\'eancia, coloque um \f2 & \f0 ap\'f3s o tipo do par\'e2metro, no prot\'f3tipo da fun\'e7\'e3o. Na chamada da fun\'e7\'e3o, \line mencione a vari\'e1vel por seu nome e ela ser\'e1 passada por refer\'eancia. Na fun\'e7\'e3o chamada, mencionar a vari\'e1vel por seu nome local na realidade faz refer\'eancia \'e0 vari\'e1vel original na fun\'e7\'e3o que chamou. Deste modo, a vari\'e1vel original pode ser diretamente modificada pela fun\'e7\'e3o chamada. \line\bullet  Par\'e2metros por refer\'eancia tamb\'e9m podem ser criados para uso local como \i aliases \i0 para outras vari\'e1veis dentro de uma fun\'e7\'e3o. As vari\'e1veis de refer\'eancia devem ser inicializadas em suas declara\'e7\'f5es e n\'e3o lhe podem ser atribu\'eddas a \i aliases \i0 de outras \line vari\'e1veis. Uma vez que uma vari\'e1vel de refer\'eancia tenha sido declarada como um nome alternativo para outra vari\'e1vel, todas as opera\'e7\'f5es supostamente executadas sobre o nome alternativo s\'e3o realmente executadas sobre a vari\'e1vel por ele referida. \line\bullet  C++ permite ao programador especificar par\'e2metros default e seus valores default. Se um par\'e2metro default \'e9 omitido em uma chamada de uma fun\'e7\'e3o, o valor default daquele par\'e2metro \'e9 usado. Os par\'e2metros default devem ser os par\'e2metros mais \line\'e0 direita (finais) na lista de par\'e2metros de uma fun\'e7\'e3o. Os par\'e2metros default devem ser especificados com a primeira ocorr\'eancia do nome da fun\'e7\'e3o. Os valores default podem ser constantes, vari\'e1veis globais ou chamadas de fun\'e7\'e3o. \line\bullet  O operador un\'e1rio de resolu\'e7\'e3o de escopo (: :) possibilita a um programa acessar uma vari\'e1vel global quando uma vari\'e1vel local do mesmo nome est\'e1 no escopo. \line\bullet  E poss\'edvel definir v\'e1rias fun\'e7\'f5es com o mesmo nome, mas com os tipos dos par\'e2metros diferentes. Isto \'e9 chamado de sobrecarregar uma fun\'e7\'e3o. Quando \'e9 chamada uma fun\'e7\'e3o sobrecarregada, o compilador seleciona a fun\'e7\'e3o apropriada examinando o n\'famero e os tipos de par\'e2metros na chamada. \line\bullet  Fun\'e7\'f5es sobrecarregadas podem ter valores de retorno diferentes ou n\'e3o, mas devem ter listas de par\'e2metros diferentes. Se duas fun\'e7\'f5es diferem somente pelo tipo de retorno, isto resultar\'e1 em um erro de compila\'e7\'e3o. \line\bullet  Gabaritos de fun\'e7\'e3o possibilitam a cria\'e7\'e3o de fun\'e7\'f5es que executam as mesmas opera\'e7\'f5es sobre tipos diferentes de dados, mas o gabarito da fun\'e7\'e3o \'e9 definido somente uma vez. \line\b\i\f2\fs26 Terminologia \line\b0\i0\f0\fs16 ajustar escala classe de armazenamento \line argumento em uma chamada de fun\'e7\'e3o classe de armazenamento autom\'e1tica \line argumentos default de uma fun\'e7\'e3o classe de armazenamento est\'e1tica \line armazenamento autom\'e1tico coer\'e7\'e3o de argumentos \line arquivo de cabe\'e7alho colabora\'e7\'e3o \line arquivos de cabe\'e7alho da biblioteca padr\'e3o compilador otimizador \line assinatura componente \line assinatura de fun\'e7\'e3o const \line biblioteca padr\'e3o C++ constante com nome \line bloco constante de enumera\'e7\'e3o \line caso b\'e1sico da recurs\'e3o c\'f3pia de um valor \line chamada de fun\'e7\'e3o declara\'e7\'e3o de fun\'e7\'e3o \line chamada por refer\'eancia decora\'e7\'e3o de nome \line chamada por valor defini\'e7\'e3o de fun\'e7\'e3o \line chamada recursiva deslocamento \line chamar uma fun\'e7\'e3o dividir para conquistar \fs24\par
\b\fs16 CAP\'cdTULO \b0\fs18 3 \f2\fs8 - \b\f0\fs16 FUN\'c7\'d5ES \f2\fs22 243 \b0\f0\fs24\par
\f2\fs16 dura\'e7\'e3o do armazenamento est\'e1tico efeito \f0\fs18 colateral \line engenharia \f2\fs16 de \f0\fs18 software \line enum \line enumera\'e7\'e3o \fs24\par
\fs18 escopo \line escopo de arquivo \line escopo de bloco \line escopo de fun\'e7\'e3o \line especifica\'e7\'e3o de liga\'e7\'e3o \line especificador de classe de armazenamento \line especificador de classe de armazenamento auto especificador de classe de armazenamento mutable especificador de classe de armazenamento register especificador de classe de armazenamento static especificador de classe de armazenamento extern express\'e3o de tipo misto \line fator sorte \line fun\'e7\'e3o \line fun\'e7\'e3o chamada \fs24\par
\fs18 fun\'e7\'e3o chamadora \line fun\'e7\'e3o definida pelo programador fun\'e7\'e3o fatorial \line fun\'e7\'e3o mime \line fun\'e7\'e3o recursiva \line fun\'e7\'f5es da biblioteca matem\'e1tica fun\'e7\'e3o gabarito \line gera\'e7\'e3o de n\'fameros aleat\'f3rios hierarquia de promo\'e7\'e3o \line invocar uma fun\'e7\'e3o \fs24\par
\fs18 itera\'e7\'e3o \line liga\'e7\'e3o \line liga\'e7\'e3o segura quanto ao tipo \fs24\par
\fs18 oculta\'e7\'e3o de informa\'e7\'f5es \line operador un\'e1rio de resolu\'e7\'e3o de escopo (: :) par\'e2metro de refer\'eancia \line par\'e2metro em uma defini\'e7\'e3o de fun\'e7\'e3o princ\'edpio do m\'ednimo privil\'e9gio \fs24\par
\fs16 programa modular prot\'f3tipo de fun\'e7\'e3o rarid \line\f2 RANDMAX \line\f0 randomizar \fs24\par
\fs18 recurs\'e3o \line recurs\'e3o infinita refer\'eancia sem correspondente return \line reutiliza\'e7\'e3o de software simula\'e7\'e3o \line sobrecarga de fun\'e7\'e3o sobrecarregar \fs24\par
\b\fs16 srand \line\b0 sufixo \lquote e comercial\rdblquote  (&) \fs24\par
\b\f3\fs16 template \b0\f0\fs24\par
\b\fs16 time \b0\fs24\par
\fs18 tipo de refer\'eancia tipo de valor de retorno \fs24\par
\fs16 typename \line\b unsigned \line\b0 vari\'e1vel autom\'e1tica vari\'e1vel constante vari\'e1vel global vari\'e1vel local vari\'e1vel somente para leitura vari\'e1vel static \fs24\par
\b\f3\fs16 void \b0\f0\fs24\par
\b\i\f2 Terminologia de \ldblquote Pensando em objetos\rdblquote  \b0\i0\f0\par
\fs18 a\'e7\'e3o \line a\'e7\'e3o de \ldblquote sa\'edda\rdblquote  atividade \line atributo \fs24\par
\fs18 condi\'e7\'e3o de guarda \line diagrama de atividades \line diagrama de mapa de estados e de atividades em UML elipse no diagrama de atividades da UML \fs24\par
\fs18 estado \fs24\par
\fs18 estado inicial \line evento \line evento \ldblquote quando\rdblquote  \line linha cheia com seta na ponta nos diagramas de mapa de estados e de atividades na UML \fs24\par
\b\i\f2 Erros comuns de programa\'e7\'e3o \b0\i0\f0\par
\fs18 losango no diagrama de atividades da UML nome de atributo em UML palavras descritivas na defini\'e7\'e3o do problema \fs24\par
\fs18 ret\'e2ngulo com cantos arredondados no diagrama de mapa de estados da UML \line r\'f3tulo de a\'e7\'e3o \line seta em diagrama UML \line s\'edmbolo \ldblquote olho de boi\rdblquote  no diagrama de atividades da UML \line s\'edmbolo de ponto de partida nos diagramas de mapa de esta- \fs24\par
\fs18 dos \fs24\par
\fs18 tipo de atributo em UML transi\'e7\'e3o \line valor inicial de atributo em UML valor inicial de um atributo de classe \fs24\par
\fs18 3.1 Esquecer de incluir o arquivo de cabe\'e7alho <crnath> ao usar fun\'e7\'f5es da biblioteca matem\'e1tica \'e9 um erro de sintaxe. Para cada fun\'e7\'e3o da biblioteca padr\'e3o usada em um programa deve ser inclu\'eddo um arquivo de cabe\'e7alho padr\'e3o. \line 3.2 Omitir o tipo do valor de retorno em uma defini\'e7\'e3o de fun\'e7\'e3o \'e9 um erro de sintaxe. \line 3.3 Esquecer de retornar um valor de uma fun\'e7\'e3o que deve faz\'ea-lo \'e9 erro de sintaxe. \fs24\par
\b\fs22 244 C\'f7+ \fs14 COMO PROGRAMAR \line\b0\fs16 3.4 Retornar um valor de uma fun\'e7\'e3o cujo tipo de retorno foi declarado \b\fs18 void \b0\fs16 causa um erro de sintaxe. \line 3.5 Declarar par\'e2metros da fun\'e7\'e3o do mesmo tipo como float x, y em vez de float x, float y. A declara\'e7\'e3o de par\'e2metros float x, y geraria na realidade um erro de compila\'e7\'e3o, porque os tipos s\'e3o obrigat\'f3rios para cada par\'e2metro \line na lista de par\'e2metros. \line 3.6 Colocar um ponto-e-v\'edrgula ap\'f3s o par\'eantese direito, ao encerrar a lista de par\'e2metros de uma defini\'e7\'e3o de fun\'e7\'e3o, \'e9 um erro de sintaxe. \line 3.7 Definir um par\'e2metro de fun\'e7\'e3o novamente como vari\'e1vel local dentro da fun\'e7\'e3o \'e9 um erro de sintaxe. \line 3.8 Os () em uma chamada de fun\'e7\'e3o s\'e3o, na realidade, um operador de C++. Eles fazem com que a fun\'e7\'e3o seja chamada. Esquecer os \b\fs22 () \b0\fs16 em uma chamada de fun\'e7\'e3o que n\'e3o aceita argumentos n\'e3o \'e9 um erro de sintaxe. A fun\'e7\'e3o n\'e3o \'e9 invocada \line quando voc\'ea provavelmente pretendia que ela fosse. \line 3.9 Definir uma fun\'e7\'e3o dentro de outra fun\'e7\'e3o \'e9 um erro de sintaxe. \line 3.10 E um erro de sintaxe se o prot\'f3tipo da fun\'e7\'e3o, o arquivo de cabe\'e7alho e as chamadas da fun\'e7\'e3o n\'e3o concordarem quanto ao n\'famero, tipo e ordem dos argumentos e par\'e2metros e quanto ao tipo do valor de retomo. \line 3.11 Esquecer o ponto-e-v\'edrgula no final de um prot\'f3tipo de fun\'e7\'e3o causa um erro de sintaxe. \line 3.12 Uma chamada de fun\'e7\'e3o que n\'e3o corresponde ao prot\'f3tipo da fun\'e7\'e3o \'e9 um erro de sintaxe. \line 3.13 E um erro de sintaxe se o prot\'f3tipo da fun\'e7\'e3o e a defini\'e7\'e3o da mesma estiverem em desacordo. \line 3.14 Converter de um tipo superior de dados em uma hierarquia de promo\'e7\'e3o para um tipo inferior pode modificar o valor dos dados. \line 3.15 Esquecer um prot\'f3tipo de fun\'e7\'e3o causa um erro de sintaxe se a defini\'e7\'e3o daquela fun\'e7\'e3o aparecer depois de sua chamada no programa. \line\b\fs18 3.16 \b0\fs16 Usar srand no lugar de rand para gerar n\'fameros aleat\'f3rios \'e9 um erro de sintaxe, porque a fun\'e7\'e3o srand n\'e3o retoma um valor. \line 3.17 Atribuir o inteiro equivalente a uma constante de enumera\'e7\'e3o a uma vari\'e1vel do tipo da enumera\'e7\'e3o \'e9 um erro de sintaxe. \line 3.18 Ap\'f3s uma constante de enumera\'e7\'e3o ter sido definida, tentar atribuir outro valor para a constante de enumera\'e7\'e3o \'e9 um erro de sintaxe. \line\b\fs18 3.19 \b0\fs16 Usar diversos especificadores de classe de armazenamento para o mesmo identificador \'e9 um erro de sintaxe. Somente um especificador de classe de armazenamento pode ser aplicado a um identificador. Por exemplo, se voc\'ea incluir regis ter, \line n\'e3o inclua tamb\'e9m auto. \line 3.20 Usar acidentalmente, em um bloco interno, o mesmo nome que \'e9 usado para um identificador em um bloco mais externo, quando, na realidade, o programador quer que o identificador do bloco externo esteja ativo durante o processamento do \line bloco interno, geralmente causa um erro de l\'f3gica. \line 3.21 Esquecer-se de retornar um valor de uma fun\'e7\'e3o recursiva, quando isto \'e9 necess\'e1rio, far\'e1 com que a maioria dos compiladores produza uma mensagem de advert\'eancia. \line 3.22 Omitir o caso b\'e1sico, ou escrever incorretamente a etapa de recurs\'e3o, de forma que ela n\'e3o convirja para o caso b\'e1sico, ocasionar\'e1 uma recurs\'e3o infinita, o que pode eventualmente esgotar a mem\'f3ria. Isso \'e9 an\'e1logo ao problema de um la\'e7o infinito em uma solu\'e7\'e3o iterativa (n\'e3o-recursiva). A recurs\'e3o infinita tamb\'e9m pode ser causada pelo fornecimento de um dado incorreto de entrada. \line 3.23 Escrever programas que dependam da ordem de c\'e1lculo dos operandos de operadores diferentes de \b\fs14 &&. \b0\fs16 1 ?: e o operador v\'edrgula \b\fs22 (,) \b0\fs16 pode levar a erros, porque os compiladores poderiam n\'e3o calcular necessariamente os operandos na \line ordem em que o programador espera. \line 3.24 Fazer uma fun\'e7\'e3o n\'e3o-recursiva chamar acidentalmente a si mesma, tanto direta como indiretamente (atrav\'e9s de outra fun\'e7\'e3o), \'e9 um erro de l\'f3gica. \line 3.25 A menos que sejam fornecidos prot\'f3tipos de fun\'e7\'e3o para todas as fun\'e7\'f5es ou, ent\'e3o, que cada fun\'e7\'e3o seja definida antes de ser usada, os programas em C++ n\'e3o s\'e3o compilados. \line 3.26 Como par\'e2metros por refer\'eancia s\'e3o referidos somente por nome no corpo da fun\'e7\'e3o chamada, o programador pode, inadvertidamente, tratar par\'e2metros passados por refer\'eancia como par\'e2metros passados por valor. Isto pode ocasionar \line efeitos colaterais inesperados, se as c\'f3pias originais das vari\'e1veis s\'e3o alteradas pela fun\'e7\'e3o que est\'e1 chamando. \line 3.27 Declarar multiplas refer\'eancias em um s\'f3 comando, supondo que o \b\fs14 & \b0\fs16 se distribui por uma lista de nomes de vari\'e1veis separados por v\'edrgulas. Para declarar as vari\'e1veis x, y e z, como refer\'eancias para inteiros, use a nota\'e7\'e3o irit \b\fs14 & x=a, \b0\fs16 &y \f2\fs10 = \f0\fs16 b, &z b;,emvezdanota\'e7\'e3oincorretaint& x \f2\fs10 = \b\f0\fs18 a, \b0\fs16 y \f2\fs10 = \b\f0\fs18 z \b0\f2\fs10 = \f0\fs16 e; oudeoutranota\'e7\'e3oincorreta freq\'fcentemente encontrada: int &x, y, z;. \line 3.28 N\'e3o inicializar uma vari\'e1vel de refer\'eancia quando ela \'e9 declarada \'e9 um erro de sintaxe. \line 3.29 Tentar atribuir a uma refer\'eancia previamente declarada um \i alias \i0 para outra vari\'e1vel \'e9 um erro de l\'f3gica. O valor da outra vari\'e1vel \'e9 simplesmente atribu\'eddo para a localiza\'e7\'e3o para a qual a refer\'eancia \fs20 j\'e1 \i\fs16\'e9 \i0 um \i alias. \line\i0 3.30 Retornar um ponteiro ou refer\'eancia para uma vari\'e1vel autom\'e1tica em uma fun\'e7\'e3o chamada \'e9 um erro de l\'f3gica. Alguns compiladores emitir\'e3o uma mensagem de advert\'eancia quando isto ocorrer em um programa. \line 3.31 Especificar e tentar usar um argumento default que n\'e3o \'e9 o argumento final (mais \'e0 direita) da lista de argumentos (sem, simultaneamente, tornar default os outros argumentos mais \'e0 direita) \'e9 um erro de sintaxe. \line 3.32 Tentar acessar uma vari\'e1vel n\'e3o-global em um bloco externo usando o operador un\'e1rio de resolu\'e7\'e3o de escopo \'e9 um erro de sintaxe se n\'e3o existir uma vari\'e1vel global com o mesmo nome no bloco externo e um erro de l\'f3gica se existir uma. \fs24\par
\b\fs16 CAP\'cdTULO \b0\fs18 3 \f2\fs8 - \b\f0\fs16 FUN\'c7\'d5ES \b0\i\f2\fs22 245 \line\i0\f0\fs18 3.33 Criar fun\'e7\'f5es sobrecarregadas com listas de par\'e2metros id\'eanticas e tipos diferentes de retomo \'e9 um erro de sintaxe. \line 3.34 Uma fun\'e7\'e3o com par\'e2metros default omitidos pode ser chamada de forma id\'eantica a outra fun\'e7\'e3o sobrecarregada; isto \'e9 um erro de sintaxe. Por exemplo, ter em um programa tanto uma fun\'e7\'e3o que explicitamente n\'e3o aceita nenhum argumento e uma fun\'e7\'e3o com mesmo nome cujos par\'e2metros s\'e3o todos default. provoca um erro de sintaxe quando \'e9 feita uma tentativa de usar aquele nome de fun\'e7\'e3o em uma chamada sem passar nenhum argumento. \line 3.35 N\'e3o colocar a palavra-chave class ou a palavra-chave typename antes de cada par\'e2metro de tipo de um gabarito de fun\'e7\'e3o \'e9 um erro de sintaxe. \line\b\i\f2\fs24 Boas pr\'e1ticas de programa\'e7\'e3o \line\i0\f0\fs18 3.1 \b0 Familiarize-se com a rica cole\'e7\'e3o de fun\'e7\'f5es e classes da biblioteca padr\'e3o C++. \line 3.2 Coloque uma linha em branco entre as defini\'e7\'f5es das fun\'e7\'f5es para separ\'e1-las e melhorar a legibilidade do programa. \line 3.3 Embora n\'e3o seja incorreto faz\'ea-lo, n\'e3o use os mesmos nomes para os argumentos passados para uma fun\'e7\'e3o e os par\'e2metros correspondentes na defini\'e7\'e3o da fun\'e7\'e3o. Isso ajuda a evitar ambig\'fcidades. \line 3.4 Escolher nomes significativos para fun\'e7\'f5es e par\'e2metros toma os programas mais leg\'edveis e ajuda a evitar o uso excessivo de coment\'e1rios. \line 3.5 Muitos programadores usam nomes de par\'e2metros nos prot\'f3tipos de fun\'e7\'e3o para fins de documenta\'e7\'e3o. O compilador ignora esses nomes. \line 3.6 Use mai\'fascula na primeira letra de um identificador usado como o nome de um tipo definido pelo usu\'e1rio. \line 3.7 Use somente letras mai\'fasculas nos nomes de constantes de enumera\'e7\'e3o. Isto faz com que estas constantes se destaquem no programa, lembrando ao programador que constantes de enumera\'e7\'e3o n\'e3o s\'e3o vari\'e1veis. \line 3.8 Usar constantes de enumera\'e7\'e3o em vez de constantes inteiras, toma um programa mais compreens\'edvel. \line\b 3.9 \b0 Evite nomes de vari\'e1veis que escondam nomes em escopos mais externos. Isso pode ser conseguido simplesmente evitando-se, em um programa, o uso de identificadores duplicados. \line 3.10 Sempre inclua prot\'f3tipos de fun\'e7\'e3o, ainda que seja poss\'edvel omiti-los quando as fun\'e7\'f5es s\'e3o definidas antes que sejam usadas. Incluir os prot\'f3tipos evita amarrar o c\'f3digo \'e0 ordem na qual as fun\'e7\'f5es s\'e3o definidas (que pode facilmente mudar \line\'e0 medida que um programa evolui). \line 3.11 O qualificador mime deveria ser usado somente com fun\'e7\'f5es pequenas, freq\'fcentemente usadas. \line 3.12 Usar argumentos default pode simplificar a codifica\'e7\'e3o de chamadas de fun\'e7\'f5es. Contudo, alguns programadores acham que especificar explicitamente todos os argumentos \'e9 mais claro. \line 3.13 Evite usar vari\'e1veis com o mesmo nome para prop\'f3sitos diferentes em um programa. Embora isso seja permitido em v\'e1rias circunst\'e2ncias, pode gerar confus\'e3o. \line 3.14 Sobrecarregar fun\'e7\'f5es que executam tarefas proximamente relacionadas toma um programa mais leg\'edvel e compreens\'edvel. \line\b\i\f2\fs24 Dicas de desempenho \line\b0\i0\f0\fs18 3.1 N\'e3o tente rescrever rotinas de biblioteca existentes para tom\'e1-las mais eficientes. Voc\'ea normalmente n\'e3o ser\'e1 capaz de melhorar o desempenho destas rotinas. \line 3.2 A fun\'e7\'e3o srand necessita ser chamada somente uma vez em um programa para obter o efeito de randomiza\'e7\'e3o desejado. Cham\'e1-la mais de uma vez \'e9 redundante e, portanto, reduz o desempenho do programa. \line 3.3 O armazenamento autom\'e1tico \'e9 um meio de economizar mem\'f3ria porque as vari\'e1veis autom\'e1ticas s\'e3o criadas quando o bloco na qual s\'e3o declaradas \'e9 ativado e s\'e3o destru\'eddas quando o bloco \'e9 deixado. \line 3.4 O especificador de classe de armazenamento register pode ser colocado antes de uma declara\'e7\'e3o de vari\'e1vel autom\'e1tica para sugerir que o compilador mantenha a vari\'e1vel em um dos registradores de hardware de alta velocidade do computador em vez de na mem\'f3ria. Se as vari\'e1veis forem usadas freq\'fcentemente como contadores ou para c\'e1lculo de totais, elas podem ser conservadas em registradores de hardware, e o \i\fs16 overhead \i0\fs18 de carregar repetidamente as vari\'e1veis da mem\'f3ria para os registradores e armazenar os resultados novamente na mem\'f3ria pode ser eliminado. \line 3.5 Freq\'fcentemente, as declara\'e7\'f5es regis ter s\'e3o desnecess\'e1rias. Os atuais compiladores otimizadores s\'e3o capazes de reconhecer as vari\'e1veis usadas repetidamente e podem decidir coloc\'e1-las em registradores sem que haja a necessidade de \line o programador incluir uma declara\'e7\'e3o register. \line 3.6 Evite programas recursivos semelhantes ao da fun\'e7\'e3o fibonacci que resultem em uma \ldblquote explos\'e3o\rdblquote  exponencial de chamadas. \line 3.7 Evite usar a recurs\'e3o em situa\'e7\'f5es que exigem um alto desempenho. Chamadas recursivas consumem tempo e exigem mais mem\'f3ria. \line 3.8 Um programa muito dividido em fun\'e7\'f5es \f2\fs8 - \f0\fs18 em compara\'e7\'e3o com um programa monol\'edtico, n\'e3o dividido em fun\'e7\'f5es (i.e., composto de um \'fanico m\'f3dulo) \f2\fs8 - \f0\fs18 executa um n\'famero potencialmente maior de chamadas de fun\'e7\'f5es e isto consume \fs24\par
\b\f2\fs20 246 C+\'f7 \fs14 COMO PROGRAMAR \line\b0\f0\fs18 tempo de execu\'e7\'e3o e espa\'e7o do(s) processador(es) de um computador. Por\'e9m, programas monol\'edticos s\'e3o dif\'edceis de \line programar, testar, depurar, manter e de acrescentar novas funcionalidades. \line 3.9 Usar fun\'e7\'f5es mime pode reduzir o tempo de execu\'e7\'e3o, mas pode aumentar o tamanho do programa. \line 3.10 Uma desvantagem da chamada por valor \'e9 que, se um grande item de dados est\'e1 sendo passado, copiar esses dados pode \line consumir um tempo de processamento consider\'e1vel. \line\b 3.11 \b0 Chamada por refer\'eancia \'e9 bom sob o ponto de vista do desempenho porque elimina o \i\fs16 overhead \i0\fs18 de copiar grandes \line volumes de dados. \line 3.12 Para passar objetos grandes, use um par\'e2metro por refer\'eancia constante para simular a apar\'eancia e seguran\'e7a de uma \line chamada por valor e evitar o \i\fs16 overhead \i0\fs18 de passar uma c\'f3pia do objeto grande. \line\b\i\f2\fs24 Dicas de portabilidade \line\i0\fs20 E \line\b0\f0\fs18 3.1 Usar as fun\'e7\'f5es da biblioteca padr\'e3o C++ ajuda a criar programas mais port\'e1veis. \line 3.2 Programas que dependem da ordem de c\'e1lculo de operandos de operadores diferentes de \b\f2\fs14 &&, \b0\f0\fs18 1 1 ?: e o operador virgula \line\b\f2\fs20 (,) \b0\f0\fs18 podem funcionar de modo distinto em sistemas com compiladores diferentes. \line 3.3 O significado de uma lista de par\'e2metros de fun\'e7\'e3o vazia em C++ \'e9 completamente diferente do que em C. Em C, \line significa que toda a verifica\'e7\'e3o de argumentos \'e9 desativada (i.e., a chamada da fun\'e7\'e3o pode passar quaisquer argumentos \line que queira). Em C++, significa que a fun\'e7\'e3o n\'e3o recebe argumentos. Assim, a compila\'e7\'e3o em C++ de programas escritos \line em C que usam este recurso pode acusar erros de sintaxe. \line\b\i\f2\fs24 Observa\'e7\'f5es de engenharia de software \line\b0\i0\f0\fs18 3.1 Evite reinventar a roda. Quando poss\'edvel, use as fun\'e7\'f5es da biblioteca padr\'e3o C++ em vez de escrever fun\'e7\'f5es novas. Isso \line reduz o tempo de desenvolvimento de programas. \line 3.2 Em programas que cont\'eam muitas fun\'e7\'f5es, main deveria ser implementada como um grupo de chamadas a fun\'e7\'f5es que \line executam o \ldblquote grosso\rdblquote  do trabalho do programa. \line 3.3 Cada fun\'e7\'e3o deve se limitar a realizar uma tarefa simples e bem-definida e o nome da fun\'e7\'e3o deve expressar efetivamente \line aquela tarefa. Isto promove a reutiliza\'e7\'e3o do software. \line\b 3.4 \b0 Se voc\'ea n\'e3o puder escolher um nome conciso que expresse o que a fun\'e7\'e3o faz, \'e9 poss\'edvel que sua fun\'e7\'e3o esteja tentando \line realizar muitas tarefas diferentes. Normalmente, \'e9 melhor dividir tal fun\'e7\'e3o em v\'e1rias fun\'e7\'f5es menores. \line 3.5 Uma fun\'e7\'e3o deveria caber inteira na janela de um editor. Independentemente de qu\'e3o longa seja uma fun\'e7\'e3o, ela \line deveria executar bem uma tarefa. Fun\'e7\'f5es pequenas favorecem a reutiliza\'e7\'e3o do software. \line 3.6 Os programas devem ser escritos como conjuntos de pequenas fun\'e7\'f5es. Isso toma os programas mais f\'e1ceis de escrever, \line depurar, manter e modificar. \line 3.7 Uma fun\'e7\'e3o que exige um grande n\'famero de par\'e2metros pode estar realizando tarefas demais. Pense na possibilidade de \line dividir a fun\'e7\'e3o em fun\'e7\'f5es menores, que realizem tarefas separadas. O cabe\'e7alho da fun\'e7\'e3o deveria estar contido em \line uma linha, se poss\'edvel. \line 3.8 Prot\'f3tipos de fun\'e7\'f5es s\'e3o obrigat\'f3rios em C++. Use diretivas #inciude do pr\'e9-processador para obter prot\'f3tipos de \line todas as fun\'e7\'f5es da biblioteca padr\'e3o a partir dos arquivos de cabe\'e7alho das bibliotecas apropriadas. Use tamb\'e9m \line #iriciude para obter os arquivos de cabe\'e7alho que cont\'eam os prot\'f3tipos de fun\'e7\'f5es usados por voc\'ea ou pelos membros \line de sua equipe. \line 3.9 Um prot\'f3tipo de fun\'e7\'e3o n\'e3o \'e9 obrigat\'f3rio se a defini\'e7\'e3o da fun\'e7\'e3o aparece antes do primeiro uso da fun\'e7\'e3o no programa. \line Em tal caso, a defini\'e7\'e3o da fun\'e7\'e3o tamb\'e9m serve como o prot\'f3tipo da fun\'e7\'e3o. \line\b 3.10 \b0 Um prot\'f3tipo de fun\'e7\'e3o colocado fora de qualquer defini\'e7\'e3o de fun\'e7\'e3o se aplica a todas as chamadas daquela fun\'e7\'e3o que \line aparecem depois de seu prot\'f3tipo no arquivo. Um prot\'f3tipo de fun\'e7\'e3o colocado dentro de uma fun\'e7\'e3o se aplica somente \line\'e0s chamadas realizadas naquela fun\'e7\'e3o. \line\b 3.11 \b0 O armazenamento autom\'e1tico \'e9 mais um exemplo do princ\'edpio do menor privil\'e9gio. Por que armazenar vari\'e1veis na \line mem\'f3ria e deix\'e1-las dispon\'edveis, quando na realidade n\'e3o s\'e3o mais necess\'e1rias? \line 3.12 Declarar uma vari\'e1vel como global em vez de local permite que ocorram efeitos colaterais indesej\'e1veis quando uma \line fun\'e7\'e3o que n\'e3o necessita de acesso \'e0 vari\'e1vel modifica, acidental ou intencionalmente, essa vari\'e1vel. Em geral, o uso de \line vari\'e1veis globais deveria ser evitado, exceto em certas situa\'e7\'f5es com exig\'eancias especiais de desempenho. \line\b 3.13 \b0 As vari\'e1veis usadas apenas em uma determinada fun\'e7\'e3o devem ser declaradas como vari\'e1veis locais naquela fun\'e7\'e3o, em \line vez de serem declaradas como vari\'e1veis globais. \line\b 3.14 \b0 Qualquer problema que pode ser resolvido recursivamente tamb\'e9m pode ser resolvido interativamente (n\'e3o recursivamente). \line Uma abordagem recursiva \'e9 escolhida em detrimento de uma abordagem iterativa, quando ela reflete o problema de \line modo mais natural, resultando em programa mais f\'e1cil de compreender e depurar. Outra raz\'e3o para se optar por uma \line solu\'e7\'e3o recursiva \'e9 quando uma solu\'e7\'e3o iterativa n\'e3o \'e9 f\'e1cil de ser encontrada. \fs24\par
\b\fs14 CAP\'cdTULO \b0\fs16 3 \f2\fs8 - \b\f0\fs14 FUN\'c7\'d5ES \f2\fs22 247 \line\b0\f0\fs16 3.15 Funcionalizar programas de maneira clara e hier\'e1rquica promove a boa engenharia de software. Mas isso tem um pre\'e7o. \line 3.16 Qualquer mudan\'e7a em uma fun\'e7\'e3o mime pode exigir que todos os clientes da fun\'e7\'e3o sejam recompilados. Isso pode ser relevante em algumas situa\'e7\'f5es de desenvolvimento e manuten\'e7\'e3o de programas. \line 3.17 Muitos programadores n\'e3o se preocupam em declarar par\'e2metros passados por valor como const. ainda que a fun\'e7\'e3o chamada n\'e3o deva modificar o argumento passado. A palavra-chave const est\'e1 somente protegendo uma c\'f3pia \line do argumento original, n\'e3o o pr\'f3prio argumento original. \line 3.I Chamada por refer\'eancia pode diminuir a seguran\'e7a porque a fun\'e7\'e3o chamada pode corromper os dados da fun\'e7\'e3o que chamou. \line 3.19 Tanto para fins de clareza como de desempenho, muitos programadores de C++ preferem que argumentos modific\'e1veis sejam passados para fun\'e7\'f5es por meio de ponteiros, argumentos pequenos n\'e3o-modific\'e1veis sejam passados por chamadas por valor e argumentos grandes n\'e3o-modific\'e1veis sejam passados para fun\'e7\'f5es usando refer\'eancias para constantes. \line\b\i\f2\fs24 Dica de teste e depura \'e7\'e3o \line\b0\i0\f0\fs16 3.1 Inclua um caso default em uma estrutura switch para detectar erros mesmo que voc\'ea esteja absolutamente seguro de que n\'e3o h\'e1 erros. \line\b\i\f2\fs24 Exerc\'edcios de auto-revis\'e3o \line\b0\i0\f0\fs16 3.1 Complete as frases abaixo: \line a) Os componentes de programa em C++ s\'e3o chamados de \f2\fs8 ___________ \f0\fs16 e \f2\fs8 _________ \line\f0\fs16 b) Uma fun\'e7\'e3o \'e9 invocada com uma \f2\fs8 ___________ \line\f0\fs16 c) Uma vari\'e1vel que \'e9 conhecida s\'f3 dentro da fun\'e7\'e3o em que \'e9 definida \'e9 chamada de \f2\fs8 ________________ \line\f0\fs16 d) O comando \f2\fs8 _____________ \f0\fs16 em uma fun\'e7\'e3o chamada \'e9 usado para passar de volta o valor de uma express\'e3o para a fun\'e7\'e3o que chamou. \line e) A palavra-chave \'e9 usada em um cabe\'e7alho de fun\'e7\'e3o para indicar que uma fun\'e7\'e3o n\'e3o retorna um valor, ou para indicar que uma fun\'e7\'e3o n\'e3o recebe nenhum par\'e2metro. \line f) O \f2\fs8 __________________ \f0\fs16 de um identificador \'e9 a parte do programa em que o identificador pode ser usado. \line g) Os tr\'eas meios para retornar o controle de uma fun\'e7\'e3o chamada para que chamou s\'e3o \f2\fs8 _______ _______ \f0\fs16 e \f2\fs8 _______ \line\f0\fs16 h) Um permite ao compilador conferir a quantidade, os tipos e a ordem dos par\'e2metros passados para uma \line fun\'e7\'e3o. \line i) A fun\'e7\'e3o \'e9 usada para produzir n\'fameros aleat\'f3rios. \line J) A fun\'e7\'e3o \'e9 usada para inicializar a semente dos n\'fameros aleat\'f3rios usados para randomizar um programa. \line k) Os especificadores de classes de armazenamento s\'e3o mutabie. \f2\fs8 __________\lquote  _________\lquote  _________ \f0\fs16 e \f2\fs8 ____________ \line\f0\fs16 1) Vari\'e1veis declaradas em um bloco ou na lista de par\'e2metros de uma fun\'e7\'e3o s\'e3o assumidas como sendo da classe de armazenamento ____________\lquote a menos que especificado de forma diversa. \line m) O especificador de classe de armazenamento \f2\fs8 ________________ \f0\fs16\'e9 uma recomenda\'e7\'e3o para o compilador armazenar uma vari\'e1vel em um dos registradores do computador. \line n) Uma vari\'e1vel declarada fora de qualquer bloco ou fun\'e7\'e3o \'e9 uma vari\'e1vel \f2\fs8 _______________ \line\f0\fs16 o) Para uma vari\'e1vel local em uma fun\'e7\'e3o reter seu valor entre chamadas \'e0 fun\'e7\'e3o,ela deve ser declarada com o especificador de classe de armazenamento \f2\fs8 __________________ \line\f0\fs16 p) Os quatro escopos poss\'edveis de um identificador s\'e3o \f2\fs8 , , \f0\fs16 e \f2\fs8 _______________ \line\f0\fs16 q) Unia fun\'e7\'e3o que chama a si mesma, direta ou indiretamente, \'e9 uma fun\'e7\'e3o \line r) Uma fun\'e7\'e3o recursiva tem tipicamente dois componentes: um que fornece um meio para a recurs\'e3o terminar testando \line a ocorr\'eancia de um caso \f2\fs8 ________________ \f0\fs16 e um que expressa o problema como uma chamada recursiva para um \line problema ligeiramente mais simples que a chamada original. \line s) Em C \b\fs12 ++, \b0\fs16\'e9 poss\'edvel se ter v\'e1rias fun\'e7\'f5es com o mesmo nome, cada uma operando sobre tipos e/ou quantidades de \line par\'e2metros diferentes. Isto \'e9 chamado de \f2\fs8 ________________ \f0\fs16 a fun\'e7\'e3o. \line\b\fs14 t) \b0\fs16 O possibilita o acesso a uma vari\'e1vel global com o mesmo nome que uma vari\'e1vel no escopo atual. \line u) O qualificador \'e9 usado para declarar vari\'e1veis somente para leitura. \line v) Uma fun\'e7\'e3o possibilita que uma \'fanica fun\'e7\'e3o seja definida para executar uma tarefa em muitos \line tipos de dados diferentes. \line 3.2 Para o programa seguinte, indique o escopo (escopo de fun\'e7\'e3o, escopo de arquivo, escopo de bloco ou escopo de prot\'f3tipo fun\'e7\'e3o) de cada dos elementos seguintes. \line a) A vari\'e1vel x em main. \line b) A vari\'e1vel y em cube. \line e) A fun\'e7\'e3o cube. \fs24\par
\b\f2\fs22 248 \b0\f0\fs24\par
\b\f2\fs22 C\'f7+ \fs16 COMO PROGRAMAR \b0\f0\fs24\par
\fs18 d) A fun\'e7\'e3o fiam. \line e) O prot\'f3tipo da fun\'e7\'e3o para cube. \line 1\rquote ) O identificador y no prot\'f3tipo de fun\'e7\'e3o para \f2 cube. \f0\fs24\par
\fs18 3.3 Escreva um programa que testa se os exemplos de chamadas \'e0 fun\'e7\'e3o da biblioteca de matem\'e1tica mostrados na Fig. 3.2 produzem realmente os resultados indicados. \fs24\par
\fs16 Escreva o cabe\'e7alho da fun\'e7\'e3o para cada uma das seguintes fun\'e7\'f5es: \line a) Fun\'e7\'e3o hypotenuse. que recebe dois par\'e2metros em ponto flutuante com precis\'e3o dupla, sidel e \b side2. e \b0 retoma um resultado em ponto flutuante com precis\'e3o dupla. \line b) Fun\'e7\'e3o smallest, que recebe tr\'eas inteiros, x, y e z, e retoma um inteiro. \line c) Fun\'e7\'e3o instructions, que n\'e3o recebe quaisquer par\'e2metros e n\'e3o retoma um valor. (Nota: tais fun\'e7\'f5es s\'e3o comumente usadas para exibir instru\'e7\'f5es para o usu\'e1rio). \line d) Fun\'e7\'e3o \'edntToDouble que recebe um argumento do tipo inteiro, number, e devolve um resultado em ponto flutuante com precis\'e3o simples. \fs24\par
\fs18 Escreva o prot\'f3tipo de fun\'e7\'e3o para cada uma das seguintes fun\'e7\'f5es: \line a) A fun\'e7\'e3o descrita no Exerc\'edcio 3.4a. \line b) A fun\'e7\'e3o descrita no Exerc\'edcio 34b. \line c) A fun\'e7\'e3o descrita no Exerc\'edcio 3.4c. \line d) A fun\'e7\'e3o descrita no Exerc\'edcio 3.4d. \fs24\par
\fs18 Escreva uma declara\'e7\'e3o para cada um dos seguintes casos: \line a) O inteiro \i counter, \i0 que deve ser mantido em um registrador. lnicialjze count com 0. \line b) Vari\'e1vel em ponto flutuante com precis\'e3o dupla lastVal, que deve manter seu valor entre chamadas \'e0 fun\'e7\'e3o em que est\'e1 definida. \line c) Inteiro externo nuinber, cujo escopo deve ser restringido ao restante do arquivo em que \'e9 definido. \fs24\par
\fs18 3.7 Ache o erro em cada um dos segmentos seguintes de programa e explique como o erro pode ser corrigido (veja tamb\'e9m Exerc\'edcio \i 3.53): \i0\fs24\par
\fs18 a) int g( void ) ( \line\b\fs16 cout \'ab \ldblquote Dentro da fun\'e7\'e3o g\rdblquote  \'ab endi; \b0\fs24\par
\b\fs16 int h( vojd \b0\fs24\par
\fs18\{ \fs24\par
\b\fs16 1 \line\f3\fs18 2 \b0\f0\fs24\par
\b\f3\fs18 3 \b0\f0\fs24\par
\i\f2\fs22 II \b\i0\f3\fs18 ex0302.cpp #include <iostream> \b0\f0\fs24\par
\i\fs18 4 \line\b\i0\fs16 5 \line 6 \b0\fs24\par
\b\f3\fs18 using std::cout; usinq std: :endl \b0\f0\fs24\par
\b\fs16 7 \line 8 \b0\fs24\par
\b\fs16 int \b0 cube ( int y \fs24\par
\b\fs16 int main \b0\fs18 O \fs24\par
\b\fs16 int \f2 x \b0\f0\fs24\par
\b\f3\fs18 9 \line\f0\fs16 10 \line 11 \line\f3\fs18 12 \line\f0\fs16 13 \line\f3\fs18 14 \line\f0\fs16 15 \line 16 \line 17 \line 18 \line\f3\fs18 19 \line\f0\fs16 20 \line 21 \line 22 \b0\fs24\par
\b\f3\fs16 for \b0\f0\fs18 ( \b\f3\fs16 x 1; x \b0\f2\fs12 <= \b\f3\fs16 10; x++ \line cout \f0\'ab \f3 cube( x \b0\f0\fs18 ) \b\fs16\'ab \f3 endi; \b0\f0\fs24\par
\b\fs16 return 0; \b0\fs24\par
\fs18\} \fs24\par
\b\f2\fs22\{ \b0\f0\fs24\par
\b\fs16 int \b0 cube ( int y \fs24\par
\b\f2\fs22\} \b0\f0\fs24\par
\b\fs14 return y \b0\f2\fs10 * \b\f0\fs14 y \b0\f2\fs10 * \b\f3\fs18 y \b0\f0\fs24\par
\b\f3\fs18 3.4 \b0\f0\fs24\par
\b\fs16 3.5 \b0\fs24\par
\fs18 3.6 \fs24\par
\b\fs16 cout \'ab \ldblquote Dentro da fun\'e7\'e3o h\rdblquote  \'ab endl; \b0\fs24\par
\b\f2\fs22 ) \b0\f0\fs24\par
\b\fs14 CAP\'cdTULO \b0\f2\fs16 3 \fs8 - \b\f0\fs14 FUN\'c7\'d5ES \f2\fs20 249 \b0\f0\fs24\par
\b\f3\fs16 b) int sum( int x, int y \f2\fs20 ) \{ \line\f3\fs16 int result; \line result \b0\f2\fs10 = \b\fs18 x \f0\fs14 + \f3\fs16 y; \line c) int sum( int n \line if (n \b0\f2\fs10 == \b\f3\fs16 O) \line return O; \line else \line n + sum( n \b0\f2\fs8 - \b\f3\fs16 1 ); \line d) void f \f2\fs20 ( \f3\fs16 double a ); \line float a; \line cout \'ab a \'ab endl; \line e) void product \f2\fs20 ( \f3\fs16 void \line int a, b, c, result; \line cout \'ab \ldblquote Digite tr\'eas inteiros: \line cm \'bb a \'bb b \'bb c; \line result \b0\f2\fs10 = \b\fs18 a \b0\fs10 * \b\f3\fs16 b \b0\f2\fs10 * \b\f3\fs16 c; \line cout \'ab \ldblquote Resultado \'e9 \'ab result; \line return result; \line\b0\f0 3.8 Por que um prot\'f3tipo de fun\'e7\'e3o conteria \b\f3 uma declara\'e7\'e3o de tipo de par\'e2metro tal como double &? \line\b0\f0 3.9 (Verdadeiro/Falso) Todas as chamadas em C++ s\'e3o chamadas por valor. \line 3.10 Escreva um programa completo em C++ que usa uma fun\'e7\'e3o mime sphereVolume para solicitar ao usu\'e1rio o raio de uma esfera e calcular e imprimir o volume dessa esfera usando a atribui\'e7\'e3o volume \f2\fs10 = \b\fs20 ( \b0\f0\fs16 4 .0 \b\f2\fs20 / \f0\fs14 3 \f2\fs20 ) \b0\fs10 * \b\f0\fs14 3.14159 \line\b0\f2\fs10 * \f0\fs16 pow \b\f2\fs20 ( \b0\f0\fs16 radius, 3 \b\f2\fs20 ). \line\i\fs24 Respostas aos exerc\'edcios de auto-revis\'e3o \line\b0\i0\f0\fs16 3.1 a) Fun\'e7\'f5es e classes. b) Chamada de fun\'e7\'e3o. c) Vari\'e1vel local. d) return. e) void. f) Escopo. g) return; ou return expression; ou encontrando a chave \'e0 direita \fs30 o) \fs16 de t\'e9rmino de uma fun\'e7\'e3o. h) Prot\'f3tipo de fun\'e7\'e3o. i) rand. \f1\fs24 j) \f0\fs16 srand. k) auto. register. extern e static. 1) auto. m) register. n) Externa, global, o) static. p) Escopo de fun\'e7\'e3o, escopo de arquivo, escopo de bloco e escopo de prot\'f3tipo de fun\'e7\'e3o. q) Recursiva. r) B\'e1sico. s) Sobrecarregar. \b\fs14 t) \b0\fs16 Operador un\'e1rio de resolu\'e7\'e3o de escopo (: \f2 :). \f0 o) const. v) Gabarito. \line 3.2 a) Escopo de bloco. b) Escopo de bloco. c) Escopo de arquivo. d) Escopo de arquivo, e) Escopo de arquivo. f) Escopo de \line prot\'f3tipo de fun\'e7\'e3o. \line 3.3 Veja abaixo. \line 1 \b\i\f2\fs24 II \i0\f3\fs16 exO3_03.cpp \line 2 \f2\fs20 // \f3\fs16 Testando as fun\'e7\'f5es da biblioteca de matem\'e1tica \line 3 #include <iostream> \line 4 \line 5 using std: :cout; \line 6 using std: :endl; \line 7 using std: :ios; \line 8 \b0\f0\fs24\par
\fs14 250 C++ COMO PROGRAMAR \line\f3 9 #include <iomanip> \line\f0 lo \line\f3 11 using std: :setiosflags; \line 12 using std: :fixed; \line 13 using std: :setprecision; \line 14 \line 15 #include <cmath> \line 16 \line 17 int main() \line 18 \f0\{ \line\f3 19 cout\'ab setiosflags( ios::fixed \f0 1 \f3 ios::showpoint \line 20 \'ab setprecision( 1 \line 21 \'ab \ldblquote sqrt(\rdblquote  \'ab 900.0 \'ab \f0 ) = \f3\'ab sqrt( 900.0 \line 22 \'ab \ldblquote\\nsqrt(\rquote  \'ab 9.0 \'ab \f2\fs12\ldblquote ) \f0\fs14 = \f3\'ab sqrt( 9.0 \line 23 \'ab \ldblquote\\nexp(\rdblquote  \'ab 1.0 \'ab \f2\fs12\ldblquote ) \f0\fs14 = \f3\'ab setprecision( 6 \line 24 \'ab exp( 1.0 \f0 ) \f3\'ab \ldblquote\\nexp(\rdblquote  \'ab setprecision( 1 \f0 ) \'ab \f3 2.0 \line 25 \'ab \f2\fs12\lquote ) = \f3\fs14\'ab setprecision( 6 \f0 ) \f3\'ab exp( 2.0 \line 26 \'ab \ldblquote\\nlog(\rdblquote  \'ab 2.718282 \'ab \f2\fs12\ldblquote ) \f0\fs14 = \f3\'ab setprecision( 1 \line 27 \'ab log( 2.718282 \f0 ) \f3\'ab \lquote\\nlog(\rdblquote  \'ab setprecision( 6 \line 28 \'ab 7.389056 \'ab \f2\fs12\ldblquote ) \f0\fs14 = \f3\'ab setprecision( 1 \line 29 \'ab log( 7.389056 \f0 ) \'ab \f3 endi; \line 30 cout\'ab loglO(\rdblquote  \'ab 1.0 \'ab \f0\ldblquote ) = \f3\'ab loglO( 1.0 \line 31 \'ab \lquote\\nloglO(\rdblquote  \'ab 10.0 \'ab \f0 ) = \f3\'ab loglO( 10.0 \line 32 \'ab \ldblquote\\nloglO( \'ab 100.0 \'ab \f2\fs12\ldblquote ) \f0\fs14 = \f3\'ab loglO( 100.0 \line 33 \'ab \'b0\\nfabs( \'ab 13.5 \'ab \f2\fs12\ldblquote ) \f3\fs14\'ab fabs( 13.5 \line 34 \'ab \lquote\\nfabs(\rdblquote  \'ab 0.0 \'ab \f2\fs12\ldblquote ) \f0\fs14 = \f3\'ab fabs( 0.0 \line 35 \'ab \ldblquote\\nfabs(\rdblquote  \'ab -13.5 \'ab \f2\fs12\lquote ) = \f3\fs14\'ab \i\f0\fs18 fabs( \i0\f3\fs14 -13.5 \f0 ) \'ab \f3 endi; \line 36 cout \'ab \ldblquote ceil(\rdblquote  \'ab 9.2 \'ab \f2\fs12\lquote ) = \f3\fs14\'ab ceil( 9.2 \line 37 \'ab \ldblquote\\nceil(\rdblquote  \'ab -9.8 \'ab \f2\fs12\ldblquote ) \f0\fs14 = \f3\'ab ceil( -9.8 \line 38 \'ab \ldblquote\\nfloor( \'ab 9.2 \'ab \f2\fs12\ldblquote ) \f0\fs14 = \f3\'ab floor( 9.2 \line 39 \'ab \\nfloor(\rdblquote  \'ab -9.8 \'ab \f2\fs12\ldblquote ) \f0\fs14 = \f3\'ab floor( -9.8 \f0 ) \'ab \f3 endi; \line 40 cout\'ab pow(\rdblquote  \'ab 2.0 \'ab \f2\fs8\ldblquote , \f0\fs14\'ab \f3 7.0 \'ab \f2\fs12\ldblquote ) \line\f3\fs14 41 \'ab \ldblquote pow( 2.0, 7.0 \f0 ) \f3\'ab \\npow(\rdblquote  \'ab 9.0 \'ab \f2\fs8\ldblquote , \line\f3\fs14 42 \'ab 0.5 \'ab \f2\fs12\ldblquote ) \f0\fs14 = \f3\'ab pow( 9.0, 0.5 \line 43 \'ab setprecision( 3 \f0 ) \'ab \f3\ldblquote\\nfmod(\rdblquote  \line 44 \'ab 13.675 \'ab \f2\fs8\ldblquote , \f0\fs14\'ab \f3 2.333 \'ab \ldblquote ) \line 45 \'ab fmod( 13.675, 2.333 \f0 ) \f3\'ab setprecision( 1 \line 46 \'ab \ldblquote\\nsin(\rdblquote  \'ab 0.0 \'ab \f2\fs12\ldblquote ) \f0\fs14 = \f3\'ab sin( 0.0 \line 47 \'ab \ldblquote\\ncos(\rdblquote  \'ab 0.0 \'ab \f2\fs12\lquote ) = \fs20\'ab \f3\fs14 cos( 0.0 \line 48 \f0\'ab \f3\\ntan(\rdblquote  \f0\'ab \f3 0.0 \'ab \f0 ) = \'ab \f3 tan( 0.0 \f0 ) \'ab \f3 endi; \line 49 return 0; \line 50 \f0\} \line\f3 sqrt(900.0) \f0 = \f3 30.0 \line sqrt(9.0) \f0 = \f3 3.0 \line exp(1.0) \f0 = \f3 2.718282 \line exp(2.0) \f0 = \f3 7.389056 \line log(2.718282) \f0 = \f3 1.0 \line log(7.389056) \f0 = \f3 2.0 \line loglO(1.0) \f0 = \f3 0.0 \line loglO(10.0)= 1.0 \line loglO(l00.0) 2.0 \line fabs(13.5) \f0 = \f3 13.5 \line fabs(0.0) \f0 = 0.0 \fs24\par
\b\f3\fs14 fabs(-13.5) \b0\f2\fs12 = \b\f3\fs14 13.5 \line ceil(9.2) \b0\f2\fs12 = \b\f3\fs14 10.0 \line ceil(-9.8) \b0\f2\fs12 = \b\f3\fs14 -9.0 \line floor(9.2) \b0\f2\fs12 = \b\f3\fs14 9.0 \line floor(-9.8) \b0\f2\fs12 = \b\f3\fs14 -10.0 \line pow(2.0, 7.0) \b0\f2\fs12 = \b\f3\fs14 128.0 \line pow(9.0, 0.5) \b0\f2\fs12 = \b\f3\fs14 3.0 \line fmod(13.675, 2.333) \b0\f2\fs12 = \b\f3\fs14 2.010 \line sirz(0.0) \b0\f2\fs12 = \b\f3\fs14 0.0 \line cos(0.0) \b0\f2\fs12 = \b\f3\fs14 1.0 \line tan(0.0) \b0\f2\fs12 = \b\f3\fs14 0.0 \b0\f0\fs24\par
\fs14 CAP\'cdTULO 3 \f2\fs8 - \f0\fs14 FUN\'c7\'d5ES \f2\fs20 251 \f0\fs24\par
\b\f3\fs16 3.4 a) double hypotenuse \b0\f2\fs20 ( \b\f3\fs16 double sidel, double side2 \line b) int smallest \b0\f2\fs20 ( \b\f3\fs16 int x, int y, int z) \line c) void instructions \b0\f2\fs20 ( \b\f3\fs16 void \b0\f2\fs20 ) \i II \b\i0\f3\fs16 em C++ (void) pode \line d) float intToDouble( int number \b0\f0\fs24\par
\b\f3\fs16 3.5 a) double hypotenuse \b0\f2\fs20 ( \b\f3\fs16 double, double ); \line b) int smallest( int, int, int ); \line c) void instructions \b0\f2\fs20 ( \b\f3\fs16 void ); \b0\i\f2\fs22 II \b\i0\f3\fs16 em \b0\f0 C-I-+ \b\f3 (void) pode \line d) float intToDouble \b0\f2\fs20 ( \b\f3\fs16 int ); \b0\f0\fs24\par
\b\f3\fs14 3.6 a) register int count \b0\f2\fs12 = \b\f3\fs14 0; b) static double lastVal; \b0\f0\fs24\par
\f2\fs18 c) static \b\f3\fs16 int nunber; \line\b0\f0 Nota: isto apareceria fora de qualquer defini\'e7\'e3o de fun\'e7\'e3o. \fs24\par
\fs16 3.7 a) Erro: a fun\'e7\'e3o h \'e9 definida dentro da fun\'e7\'e3o g. \line Corre\'e7\'e3o: mova a defini\'e7\'e3o de h para fora da defini\'e7\'e3o de g. \line b) Erro: a fun\'e7\'e3o deveria retomar um inteiro, mas n\'e3o o faz. \line Corre\'e7\'e3o: delete a vari\'e1vel result e coloque o seguinte comando na fun\'e7\'e3o: \fs24\par
\b\f3\fs16 return x + y; \b0\f0\fs24\par
\fs16 c) Erro: o resultado de n \b\f3 + \b0\f0 sum \f2\fs20 ( \b\f3\fs16 n \b0\f2\fs8 - \f0\fs16 1 ) n\'e3o \'e9 retornado: sum retoma um resultado impr\'f3prio. Corre\'e7\'e3o: rescreva o comando na cl\'e1usula else como segue \fs24\par
\b\f3\fs16 return n \b0\f0 + sum( n \f2\fs8 - \b\f3\fs16 1 ); \b0\f0\fs24\par
\fs18 3.10 Veja abaixo. \fs24\par
\f2\fs20 // \b\f3\fs16 exO3_10.cpp \line\b0\f2\fs20 // \b\f3\fs16 Fun\'e7\'e3o mime \b0\f0\fs18 que \b\f3\fs16 calcula o volume de \b0\f0 uma \b\f3 esfera #include <iostream> \b0\f0\fs24\par
\b\f3\fs16 using std::cout; \b0\f0\fs24\par
\b\f3\fs16 ser escrito \b0\f2\fs20 O \f0\fs24\par
\b\f3\fs16 ser escrito \b0\f2\fs20 O \f0\fs24\par
\fs18 d) Erros: o ponto-e-v\'edrgula depois do par\'eantese direito que fecha a lista de par\'e2metros e est\'e1 redefinindo o par\'e2metro a na defini\'e7\'e3o da fun\'e7\'e3o. \line Corre\'e7\'f5es: apague o ponto-e-v\'edrgula depois do par\'eantese \'e0 direita da lista de par\'e2metros e apague a declara\'e7\'e3o float a:. \line e) Erro: a fun\'e7\'e3o retoma um valor quando n\'e3o deve faz\'ea-lo. \line Corre\'e7\'e3o: elimine o comando return. \line 3.8 Porque o programador est\'e1 declarando um par\'e2metro por refer\'eancia do tipo \ldblquote refer\'eancia para\rdblquote  double para obter acesso atrav\'e9s de chamada por refer\'eancia \'e0 vari\'e1vel argumento original. \line 3.9 Falso. C++ permite chamada por refer\'eancia direta atrav\'e9s do uso de par\'e2metros de refer\'eancia, al\'e9m do uso de ponteiros. \fs24\par
\b\f3\fs16 1 \line 2 \line 3 \line 4 \line 5 \line 6 \line 7 \b0\f0\fs24\par
\b\f3\fs16 using std: :cin; \line using std: :endl; \b0\f0\fs24\par
\f2\fs22 252 \b\f0\fs20 C++ \fs14 COMO \f2 PROGRAMAR \line\f3\fs16 8 \line 9 const double P1 \b0\f2\fs10 = \b\f3\fs16 3.14159; \line 10 \line 11 mime doubie sphereVoiume( const double r \line 12 \b0\f2\fs22\{ \b\f3\fs16 return 4.0 \b0\f2\fs22 / \b\f3\fs16 3.0 \b0\f2\fs10 * \b\f3\fs16 P1 \b0\f2\fs10 * \b\f3\fs16 r \b0\f2\fs10 * \b\f3\fs16 r \b0\f2\fs10 * \b\f3\fs16 r; \line 13 \line 14 int main \b0\f2\fs22 Q \line\b\f3\fs16 15 \line 16 double radius; \line 17 \line 18 cout\'ab \ldblquote Forne\'e7a o raio de sua esfera: \line 19 cm \'bb radius; \line 20 cout \'ab \lquote Volume da esfera com raio \b0\f2\fs8\ldblquote  \fs22\'ab \b\f3\fs16 radius \'ab \line 21 \b0\f2\fs8\ldblquote  \b\f0\fs20\'e9 \b0\f2\fs8\ldblquote  \b\f3\fs16\'ab sphereVolume \b0\f2\fs22 ( \b\f3\fs16 radius \b0\f2\fs22 ) \'ab \b\f3\fs16 endi; \line 22 return 0; \line 23 \line\i\f2\fs24 Exerc\'edcios \line\i0\f3\fs16 3.11 \b0\f0 Mostre o valor de x ap\'f3s cada um dos comandos seguintes ser executado: \line a) x \f2\fs10 = \f0\fs16 fabs( 7.5 \f2\fs22 ) \line\f0\fs16 b) x \f2\fs10 = \f0\fs16 fioor( 7.5 \f2\fs22 ) \line\f0\fs16 c) x \f2\fs10 = \f0\fs16 fabs( 0.0 \f2\fs22 ) \line\f0\fs16 d) x \f2\fs10 = \f0\fs16 ceil( 0.0 \f2\fs22 ) \line\f0\fs16 e) x \f2\fs10 = \f0\fs16 fabs( -6.4 \line f) x \f2\fs10 = \f0\fs16 ceii( -6.4 \line g) x \f2\fs10 = \f0\fs16 ceil( -fabs( -8 \b\fs14 + \b0\fs16 fioor( -5.5 \line 3.12 Uma garagem de estacionamento cobra $2,00 de taxa m\'ednima para estacionar at\'e9 tr\'eas horas. A garagem cobra um adicional de $0,50 por hora ou fra\'e7\'e3o de hora, caso sejam excedidas as tr\'eas horas. A taxa m\'e1xima para qualquer per\'edodo determinado de 24 horas \'e9 $10,00. Suponha que nenhum carro fique estacionado por mais de 24 horas. Escreva um programa que calcule e imprima as taxas de estacionamento para tr\'eas clientes que ontem estacionaram seus carros nessa garagem. Voc\'ea deve digitar a quantidade de horas durante as quais cada cliente ficou estacionado. Seu programa deve imprimir os resultados organizados em um formato de tabela e deve calcular e imprimir o total das receitas do dia de ontem. O programa deve usar a fun\'e7\'e3o calculateCharges para determinar o valor a ser cobrado de cada cliente. A sa\'edda de seu programa deve ter o seguinte formato: \line Carro \b\f3 Horas Taxa Cobrada \line 1 1.5 2.00 \line 2 4.0 2.50 \line 3 24.0 10.00 \line TOTAL 29.5 14.50 \line 3.13 A fun\'e7\'e3o floor pode ser usada para arredondar um valor para o inteiro mais pr\'f3ximo. O comando \line\b0\f0 y \f2\fs10 = \f0\fs16 fioor( x \b\fs14 + .5 ); \line\b0\fs16 arredonda o valor num\'e9rico x para o inteiro mais pr\'f3ximo e atribui o resultado a y. Escreva um programa que leia v\'e1rios n\'fameros e use o comando precedente para arredondar cada um desses n\'fameros para o inteiro mais pr\'f3ximo. Para cada n\'famero processado, imprima o n\'famero original e o n\'famero arredondado. \line 3.14 A fun\'e7\'e3o floor pode ser usada para arredondar um n\'famero para uma determinada casa decimal. O comando \b\f3 y=fioor(x \b0\f2\fs10 * \b\f3\fs16 10 + .5) \b0\f2\fs22 / \b\f3\fs16 10; \b0\f0\fs24\par
\fs14 CAP\'cdTULO 3 \f2\fs8 - \f0\fs14 FUN\'c7\'d5ES \b\f2\fs20 253 \b0\f0\fs24\par
\fs16 arredonda x para d\'e9cimos (a primeira posi\'e7\'e3o \'e0 direita da casa decimal). O comando \line\f3\fs18 y floor( x \f2\fs10 * \f0\fs16 100 + .5 \b\f2\fs20 ) / \b0\f0\fs16 100; \line arredonda x para cent\'e9simos \f3\fs18 (a segunda posi\'e7\'e3o \f0\fs16\'e0 direita da casa decimal). Escreva um programa que defina quatro fun\'e7\'f5es para \line arredondar um n\'famero x de v\'e1rias maneiras: \line a) roundTolnteger( number \b\f2\fs20 ) \line\b0\f0\fs16 b) roundToTenths \b\f2\fs20 ( \b0\f0\fs16 number \b\f2\fs20 ) \line\b0\f0\fs16 c) roundToHundredths \b\f2\fs20 ( \b0\f0\fs16 number \line d) roundToThousandths( nuinber \line Para cada valor lido, seu programa deve imprimir o valor original, o n\'famero arredondado para o inteiro mais pr\'f3ximo, o n\'famero arredondado para o d\'e9cimo mais pr\'f3ximo, o n\'famero arredondado para o cent\'e9simo mais pr\'f3ximo e o n\'famero arredondado para o mil\'e9simo mais pr\'f3ximo. \line\b\fs18 3.15 \b0\fs16 Responda a cada uma das seguintes perguntas: \line a) O que significa escolher n\'fameros aleatoriamente\rdblquote ? \line b) Por que a fun\'e7\'e3o rand \'e9 \'fatil para simular jogos de azar? \line c) Por que randomizar um programa usando srand? Sob que circunst\'e2ncias n\'e3o \'e9 desej\'e1vel randomizar? \line d) Por que \'e9 necess\'e1rio ajustar e dimensionar a escala dos valores produzidos por rand? \line e) Por que a simula\'e7\'e3o computadorizada de situa\'e7\'f5es do mundo real \'e9 uma t\'e9cnica \'fatil? \line 3.16 Escreva comandos que atribuam inteiros aleat\'f3rios \'e0 vari\'e1vel \i\f3\fs18 n \i0\f0\fs16 nos seguintes intervalos: \line a) \i\f3\fs18 l\'11n\'112 \line\i0\f0\fs16 b) \i\f3\fs18 1\'11n\'11l0O \line\i0\f0\fs16 c) \i\f3\fs18 0\'11n\'119 \line\i0\f0\fs16 d) \i\f3\fs18 l000\'11n\'11 \i0\f0\fs16 1112 \line e) -L\'11n\'111 \line 1) -3\'11n\'11ll \line 3.17 Para cada um dos seguintes conjuntos de inteiros, escreva um comando simples que imprima um n\'famero aleat\'f3rio do conjunto \line a) 2,4,6, 8, 10. \line b) 3,5,7,9, \i\f3\fs18 11. \line\i0\f0\fs16 c) 6, 10, 14, 18,22. \line 3.18 Escreva uma fun\'e7\'e3o integerPower \b\f2\fs20 ( \b0\f3\fs18 base, exponent \b\f2\fs20 ) \b0\f0\fs16 que retorne o valor de \line\b\f2\fs10 exponent \line\b0\f3\fs18 base \line\f0\fs16 Por exemplo, integerPower \b\f2\fs20 ( \b0\f3\fs18 3, 4 \b\f2\fs20 ) \fs10 = \b0\f3\fs18 3 \f2\fs10 * \f3\fs18 3 \f2\fs10 * \f3\fs18 3 \f2\fs10 * \f0\fs16 3. \f3\fs18 Suponha que exponent \f0\fs16 seja um inteiro positivo, diferente de zero, e base seja um inteiro. A fun\'e7\'e3o integerPower deve usar for ou while para controlar o c\'e1lculo. N\'e3o use nenhuma das fun\'e7\'f5es da biblioteca matem\'e1tica. \line 3.19 Defina uma fun\'e7\'e3o hypotenuse que calcule o comprimento da hipotenusa de um tri\'e2ngulo ret\'e2ngulo quando s\'e3o fornecidos os catetos. Use essa fun\'e7\'e3o em um programa para determinar o comprimento da hipotenusa de cada um dos seguintes tri\'e2ngulos. A fun\'e7\'e3o deve utilizar dois argumentos do tipo double e retornar a hipotenusa com o tipo double. \fs24\par
\fs16 Tri\'e2ngulo \f3\fs18 Lado \b\f0\fs16 1 Lado 2 \b0\fs24\par
\f3\fs18 1 3,0 4,0 \line\f0\fs16 2 \i\f3\fs18 5,0 \i0\f0\fs16 12,0 \line 3 8,0 \i\f3\fs18 15,0 \line\i0\f0\fs16 3.20 Escreva uma fun\'e7\'e3o multiple que determine, para um par de n\'fameros inteiros, se o segundo n\'famero \'e9 m\'faltiplo do primeiro. A fun\'e7\'e3o deve ter dois argumentos inteiros e retornar true, se o segundo n\'famero for m\'faltiplo do primeiro, ou false caso contr\'e1rio. Use essa fun\'e7\'e3o em um programa que leia uma s\'e9rie de n\'fameros inteiros. \fs24\par
\i\f2\fs22 254 \b\i0\fs20 C++ COMO \f0\fs14 PROGRAMAR \line\b0\fs16 3.21 Escreva um programa que receba uma s\'e9rie de inteiros e passe cada um deles por vez para a fun\'e7\'e3o par, que usa o \line operador m\'f3dulo para determinar se um inteiro \'e9 par. A fun\'e7\'e3o deve utilizar um argumento inteiro e retornar true se o inteiro \line for par e false caso contr\'e1rio. \line 3.22 Escreva uma fun\'e7\'e3o que mostre, na margem esquerda da tela, um quadrado de asteriscos cujo lado \'e9 especificado por um \line par\'e2metro inteiro lado. Por exemplo, se lado for igual a 4, a fun\'e7\'e3o exibe \line\b\fs18 3.31 \line\b0\fs16 n\'fam \line 3.32 Escr \line 3.23 Modifique a fun\'e7\'e3o criada no Exerc\'edcio 3.22 para formar um quadrado com qualquer caractere que esteja contido no par\'e2metro 3 33 \line do tipo char caractereDePreenchimento. Dessa forma, se lado for igual a \b\fs18 5 \b0\fs16 e caractereDePreenchimento for 90-lI \line a fun\'e7\'e3o deve imprimir e O s \line\b\fs18 3.34 \line\b0\fs16 mir \line Impr \line e I \line dam \line 3.24 Use t\'e9cnicas similares \'e0s descritas nos Exerc\'edcios 3.22 e 3.23 para produzir um programa que gere gr\'e1ficos com uma 3.35 \line grande variedade de formas. alum \line progi \line 3.25 Escreva segmentos de programas que realizem cada uma das tarefas seguintes: \line a) Calcule a parte inteira do quociente quando um inteiro a \'e9 dividido por um inteiro b. \line b) Calcule o resto inteiro quando um inteiro a \'e9 dividido por um inteiro b. \line e) Use os segmentos de programa desenvolvidos ema) e b) para escrever uma fun\'e7\'e3o que receba um inteiro entrei e 32767 O ah \line e o imprima como uma s\'e9rie de d\'edgitos separados por dois espa\'e7os. Por exemplo, o inteiro 4562 deve ser impresso como \line nov \fs24\par
\f1\fs50 1 \f0\fs18 4562 \fs24\par
\b\fs18 3.36 \line\b0\fs16 3.26 Escreva uma fun\'e7\'e3o que obtenha a hora como tr\'eas argumentos inteiros (para horas, minutos e segundos) e retorne o \i assis \line\i0 n\'famero de segundos desde a \'faltima vez que o rel\'f3gio \ldblquote bateu 12 horas\rdblquote . Use essa fun\'e7\'e3o para calcular o intervalo de tempo em do-s \line segundos, entre duas horas, ambas dentro de um ciclo de doze horas do rel\'f3gio. sejar \line 3.27 Implemente as seguintes fun\'e7\'f5es inteiras: Com \line a) A fun\'e7\'e3o celsius retorna a temperatura no equivalente em graus Celsius a uma temperatura em graus Fahrenheit. \line b) A fun\'e7\'e3o fahrenheit retorna a temperatura em graus Fahrenheit equivalente a uma temperatura em graus Celsius. \line e) Use essas fun\'e7\'f5es para escrever um programa que imprima gr\'e1ficos mostrando as temperaturas Fahrenheit equivalen te \line a temperaturas Celsius de O a 100 graus e temperaturas Celsius equivalentes a temperaturas Fahrenheit de 32 a 212 \line graus. Imprima as sa\'eddas organizadas em um formato de tabela que minimize o n\'famero de linhas de sa\'edda ao mesmo \line tempo em que permanece legivel. Con \line 3.28 Escreva uma fun\'e7\'e3o que retorna o menor n\'famero entre tr\'eas n\'fameros do tipo ponto flutuante com precis\'e3o dupla. \line 3.29 Diz-se que um n\'famero inteiro \'e9 um \i n\'famero perfeito \i0 se a soma de seus fatores, incluindo 1 (mas n\'e3o o pr\'f3prio n\'famero), \'e9 \line igual ao pr\'f3prio n\'famero. Por exemplo, 6 \'e9 um n\'famero perfeito porque 6 1 \b\fs14 + \b0\fs16 2 \b\fs14 + \b0\fs16 3. Escreva uma fun\'e7\'e3o perfect que \line determine se o par\'e2metro riumber \'e9 um n\'famero perfeito. Use essa fun\'e7\'e3o em um programa que determine e imprima todos os \line n\'fameros perfeitos entre 1 e 1000. Imprima os fatores de cada n\'famero encontrado para confirmar que ele \'e9 realmente perfeito. Use \line Desafie o poder de seu computador testando n\'fameros muito maiores do que 1000. resp \line 3.30 Diz-se que um inteiro \'e9 \i primo \i0 se for divis\'edvel apenas por 1 e por si mesmo. Por exemplo, 2, 3,5 e 7 s\'e3o primos, mas 4,6, 3.37 \line 8e9n\'e3oos\'e3o. det \line pro \line digi \fs24\par
\f2\fs12 **** \line **** \f0\fs24\par
\fs18 a) Escreva uma fun\'e7\'e3o que determine se um n\'famero \'e9 primo. \fs24\par
\fs18 seu \fs24\par
\b\fs14 CAP\'cdTULO \b0\f2\fs20 3 \fs8 - \b\fs14 FUN\'c7\'d5ES \b0\i\fs22 255 \line\i0\f0\fs16 b) Use essa fun\'e7\'e3o em um programa que determine e imprima todos os n\'fameros primos entre 1 e 10.000. Quantos desses 10.000 n\'fameros dever\'e3o ser realmente testados, antes de se ter a certeza de que todos os n\'fameros primos foram \line encontrados? \line c) lnicialmente voc\'ea poderia pensar que \i nl2 \i0\'e9 o limite superior que deve ser testado para verificar se um n\'famero \'e9 primo, mas voc\'ea s\'f3 precisa ir at\'e9 a raiz quadrada de \i n. \i0 Por qu\'ea? Rescreva o programa e execute-o das duas maneiras. Fa\'e7a uma \line estimativa da melhora no desempenho. \line 3.31 Escreva uma fun\'e7\'e3o que receba um valor inteiro e retorne o n\'famero com seus d\'edgitos invertidos. Por exemplo, dado o n\'famero 7631, a fun\'e7\'e3o deve retornar 1367. \line 3.32 O \i m\'e1ximo divisor comum \i0 (MDC) de dois inteiros \'e9 o maior inteiro que divide exatamente cada um dos dois n\'fameros. Escreva uma fun\'e7\'e3o mdc que retorna o m\'e1ximo divisor comum de dois inteiros. \line\b\f3 3.33 \b0\f0 Escreva uma fun\'e7\'e3o pontosDeQualificacao que receba a m\'e9dia de um aluno e retome 4, se ela estiver no intervalo \line 90-100,3 se a m\'e9dia estiver no intervalo 80-89,2 se a m\'e9dia estiver no intervalo 70-79, 1 se a m\'e9dia estiver no intervalo 60-69, \line e O se a m\'e9dia for menor que 60. \line 3.34 Escreva um programa que simule o lan\'e7amento de uma moeda. Para cada lan\'e7amento da moeda, o programa deve imprimir Cara ou Coroa. Deixe o programa lan\'e7ar a moeda 100 vezes e conte o n\'famero de vezes que cada lado da moeda aparece. Imprima os resultados. O programa deve chamar uma fun\'e7\'e3o separada flip que n\'e3o utiliza argumentos e retorna O para coroa e 1 para cara. \i Nota: \i0 se o programa simular realisticamente o lan\'e7amento da moeda, cada lado da moeda deve aparecer aproximadamente metade das vezes. \line 3.35 Os computadores est\'e3o desempenhando um papel cada vez maior na educa\'e7\'e3o. Escreva um programa que ajudar\'e1 os alunos da escola do primeiro grau a aprender a multiplicar. Use rand para produzir dois inteiros positivos de um d\'edgito. O programa deve ent\'e3o imprimir uma pergunta do tipo \line Quanto \b\f3\'e9 6 vezes 7? \line\b0\f0 O aluno ent\'e3o digita a resposta. Seu programa deve examinar a resposta do aluno. Se ela estiver correta, o programa deve imprimir \ldblquote Muito bem!\rdblquote  e fazer outra pergunta de multiplica\'e7\'e3o. Se a resposta estiver errada, o programa deve imprimir \ldblquote N\'e3o. \b\f3 Tente \b0\f0 novamente.\rdblquote  e ent\'e3o deixar que o aluno fique tentando acertar a mesma pergunta repetidamente, at\'e9 conseguir. \line 3.36 O uso dos computadores na educa\'e7\'e3o \'e9 conhecido como \i instru\'e7\'f5o assistida por computador \b\i0\f3 (CAI, \b0\i\f0 computerassisted instruction). \i0 Um problema que ocorre em ambientes CAI \'e9 a fadiga dos alunos.. Isso pode ser eliminado variando-se o di\'e1logo do computador para atrair a aten\'e7\'e3o do aluno. Modifique o programa do Exerc\'edcio 3.35 de forma que sejam impressos v\'e1rios coment\'e1rios para cada resposta correta e incorreta, como se segue: \line Coment\'e1rios para uma resposta correta \line\b Muito bem! \line\f3 Excelente! \line Bom trabalho! \line Certo! Continue assim! \line\b0\f0 Coment\'e1rios para uma resposta incorreta \line\b\f3 N\'e3o. Tente \b0\f0 novamente. \line\b\f3 Errado. Tente outra vez. \line N\'e3o desista! \line N\'e3o. Continue tentando. \line\b0\f0 Use o gerador de n\'fameros aleat\'f3rios para escolher um n\'famero de \b\f3 1 a \b0\f0 4 para selecionar o coment\'e1rio apropriado para cada resposta. Use uma estrutura switch para as respostas. \line 3.37 Sistemas mais sofisticados de instru\'e7\'e3o assistida por computador controlam o desempenho do aluno durante um per\'edodo de tempo. Freq\'fcentemente, a decis\'e3o de iniciar um novo t\'f3pico \'e9 baseada no sucesso do aluno no t\'f3pico anterior. Modifique o programa do Exerc\'edcio 3.36 para contar o n\'famero de respostas corretas e incorretas digitadas pelo aluno. Depois de o aluno digitar 10 respostas, seu programa deve calcular a porcentagem de respostas corretas. Se a porcentagem for menor do que 75%, seu programa deve imprimir \ldblquote Solicite ajuda extra ao professor\rquote  e ent\'e3o encerrar a execu\'e7\'e3o. \fs24\par
\b\i\f2\fs20 256 \i0\fs16 C++ COMO PROGRAMAR \b0\f0\fs24\par
\fs18 3.38 Escreva um programa em C++ que fa\'e7a o jogo de \ldblquote adivinhar um n\'famero\rdblquote  da maneira que se segue: seu programa escolhe a) Mc \line um n\'famero para ser adivinhado, sorteando aleatoriamente um inteiro no intervalo de 1 a 1000. O programa ent\'e3o escreve: b) Mc \line c) Mc \fs24\par
\fs16 Se o palpite do jogador estiver incorreto, seu programa deve repetir as leituras at\'e9 que o jogador finalmente acerte o \line n\'famero. O programa deve continuar dizendo Muito alto ou Muito baixo para ajudar o jogador a \ldblquote aproximar-se\rdblquote  \line da resposta correta. \line 3.39 Modifique o problema do Exerc\'edcio 3.38 para contar o n\'famero de palpites que o jogador fez. Se o n\'famero for 10 ou \line menor, imprima Ou voc\'ea sabe o segredo ou est\'e1 com sorte! Se o jogador acertar o n\'famero em 10 tentativas, \b\f2\fs20 Fig. \f3\fs18 3.33 \line\b0\f0\fs16 imprima Ah! Voc\'ea sabe o segredo! Se o jogador fizer mais de 10 tentativas, imprima Voc\'ea deve ser capaz de \f2\fs26 o \f0\fs16 processot \line fazer melhor! Por que n\'e3o deve demorar mais do que 10 tentativas? Bem, com cada \ldblquote bom palpite\rdblquote  ojogador deve ser capaz te o disco pa \line de eliminar metade dos n\'fameros. Agora mostre por que qualquer n\'famero entre 1 e 1000 pode ser adivinhado, com 10 palpites ou Escre \line menos, a) o \line b)o \line 3.40 Escreva uma fun\'e7\'e3o recursiva potencia \b\i\f2\fs20 ( \b0\i0\f0\fs16 base, expoente \b\i\f2\fs20 ) \b0\i0\f0\fs16 que, quando chamada, retoma c) o \line d) o Seu \line no. Por exe \line Por exemplo, potencia \b\i\f2\fs20 ( \b0\i0\f0\fs16 3, 4 \b\i\f2\fs20 ) \b0\i0\fs10 = \f0\fs16 3 \f2\fs10 * \f0\fs16 3 \f2\fs10 * \f0\fs16 3 \f2\fs10 * \f0\fs16 3. Assuma que expoente \'e9 um inteiro maior ou igual a 1. \i Sugest\'e3o: \i0 seq\'fc\'eancia d \line a etapa de recurs\'e3o usaria o relacionamento \line 1. \line\i base \i0\f2\fs8\ldblquote\'b0\lquote\lquote  = \i\f0\fs16 base. base \i0 1 \f2\fs8 -* \line\f0\fs16 3- \line e a condi\'e7\'e3o de t\'e9rmino ocorre quando expoente for igual a 1 porque 1 \f2\fs8 -* \line\f0\fs16 2- \line\i base\rquote  base \i0 2+ \line\b\f3\fs18 l-. \line 3.41 A \b0\f0\fs16 s\'e9rie de Fibonacci 3.43 Quah \line vezes com \line 0,1,1,2,3,5,8,13,21,... conseguir,cc \line clareza e sua \line come\'e7a com os termos O e 1 e tem a propriedade de que cada termo subseq\'fcente \i\'e9 \i0 a soma dos dois termos precedentes. a) \line Escreva uma fun\'e7\'e3o \i n\'e3o-recursiva \i0 fibonacci \b\i\f2\fs20 ( \b0\i0\f0\fs16 ri \b\i\f2\fs20 ) \b0\i0\f0\fs16 que calcula o n-\'e9simo n\'famero de Fibonacci. b) Determine o maior 3.44 (Visu \line n\'famero de Fibonacci que pode ser impresso em seu sistema. c) Modifique o programa da parte a) para usar double em vez para imprim \line de int para calcular e retornar os n\'fameros de Fibonacci e use este programa modificado para repetir a parte (b). separadas e \line objetivo aqu \line 3.42 \i (Torres de Han\'f3i) \i0 Todo principiante em Ci\'eancia da Computa\'e7\'e3o deve lidar com determinados problemas cl\'e1ssicos, e o desejar adiei \line problema das Torres de Han\'f3i (veja a Fig. 3.28) \'e9 um dos mais famosos. Diz a lenda que, em um templo do Extremo Oriente, os \line monges est\'e3o tentando mover uma pilha de discos de um pino para outro. A pilha inicial tinha 64 discos colocados em um pino 3.45 O m\'e1 \line e organizados na ordem decrescente de di\'e2metro, da base para o topo. Os monges est\'e3o tentando mover a pilha desse pino para mdc que retc \line um segundo pino com a restri\'e7\'e3o de que exatamente um disco deve ser movido de cada vez e em nenhum momento um disco se y for iguai \line maior pode ser colocado sobre um disco menor. H\'e1 um terceiro pino dispon\'edvel para coloca\'e7\'e3o tempor\'e1ria de discos. Teoricamente, \line o mundo terminar\'e1 quando os monges completarem sua tarefa, portanto h\'e1 pouco incentivo para n\'f3s facilitarmos seus esfor\'e7os. \b\f3\fs18 3.46 A fur \line\b0\f0\fs16 Assumiremos que os monges est\'e3o tentando mover os discos do pino 1 para o pino 3. Desejamos desenvolver um algoritmo static loc \line que imprimir\'e1 a seq\'fc\'eancia exata de transfer\'eancias de discos de um pino para outro. da. Execute \line Se f\'f4ssemos solucionar este problema com os m\'e9todos convencionais, rapidamente nos encontrar\'edamos perdidos lidando \line com os discos. Em vez disso, se abordarmos o problema com a recurs\'e3o em mente, ele se toma imediatamente trat\'e1vel. Mover \i n \line\i0 discos pode ser considerado em termos de mover apenas \i n \i0\f2\fs8 - \f0\fs16 1 discos (da\'ed a recurs\'e3o), como segue: \fs24\par
\b\f3\fs18 3.47 Os E: \line\b0\f0 plica\'e7\'e3o a \f1\fs16 u \f0\fs24\par
\pard\par
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx8946\pard\intbl\b\f3\fs18 Tenho um n\'famero entre 1 e 1000. \b0\f0\fs24\cell\fs20\row
\b\f3\fs18\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx8946\intbl Voc\'ea pode adivinhar meu n\'famero? \b0\f0\fs24\cell\fs20\row
\b\f3\fs18\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx8946\intbl Digite seu primeiro palpite. \b0\f0\fs24\cell\fs20\row
\b\f3\fs18\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx8946\intbl O jogador digita ent\'e3o o primeiro palpite. O programa escreve uma das respostas seguintes: \b0\f0\fs24\cell\fs20\row
\b\f3\fs18\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx8946\intbl 1.Excelente! Voc\'ea adivinhou o n\'famero! \b0\f0\fs24\cell\fs20\row
\b\f3\fs18\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx8946\intbl Voc\'ea gostaria de jogar novamente (s ou n)? \b0\f0\fs24\cell\fs20\row
\b\f3\fs18\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx8946\intbl 2.Muito baixo. Tente novamente. \b0\f0\fs24\cell\fs20\row
\b\f3\fs18\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx8946\intbl 3.Muito alto. Tente novamente. \b0\f0\fs24\cell\fs20\row
\pard\fs24\par
\pard\sb100\sa240\fs18 CAP\'cdTULO 3 \f2\fs8 - \b\f0\fs14 FUN\'c7\'d5ES \b0\i\f2\fs22 257 \line\i0\f0\fs18 a) Mova \i\fs16 n \i0\f2\fs8 - \f0\fs18 1 discos do pino 1 para o pino 2, usando o pino 3 como \'e1rea de armazenamento tempor\'e1rio. \line b) Mova o \'faltimo disco (o maior) do pino 1 para o pino 3. \line c) Mova os \i\fs16 n \i0\f2\fs8 - \i\f0\fs18 1 \i0 discos do pino 2 para o pino 3, usando o pino 1 como \'e1rea de armazenamento tempor\'e1rio. \line\b\f2 Fig. 3.33 \b0\fs20 O \f0\fs18 problema das Torres de Han\'f3i para o caso com quatro \f2\fs20 discos. \line\f0\fs18 O processo termina quando a \'faltima tarefa envolver mover \i\fs16 n \i0\f2\fs12 = \i\f0\fs18 1 \i0 disco, i.e., o caso b\'e1sico. Isso \'e9 realizado movendo-se simplesmente o disco para o seu destino final, sem a necessidade de uma \'e1rea de armazenamento tempor\'e1rio. \line Escreva um programa para resolver o problema das Torres de Han\'f3i. Use uma fun\'e7\'e3o recursiva com quatro par\'e2metros: \line a) o n\'famero de discos a serem movidos \line b) o pino no qual esses discos est\'e3o inicialmente colocados \line c) o pino para o qual essa pilha de discos deve ser movida \line d) o pino a ser usado como \'e1rea de armazenamento tempor\'e1rio \line Seu programa deve imprimir instru\'e7\'f5es precisas necess\'e1rias para mover os discos do pino inicial para o pino de destino. Por exemplo, para mover uma pilha de tr\'eas discos do pino 1 para o pino 3. seu programa deve imprimir a seguinte seq\'fc\'eancia de movimentos: \line 1 \f2\fs8 -* \f0\fs18 3 (Isso significa mover o disco do pino 1 para o pino 3.) \line 1 .-,2 \line 3-*2 \line 1-s3 \line 2- 1 \line 2-3 \line l-3 \line 3.43 Qualquer programa que pode ser implementado recursivamente pode ser implementado iterativamente, embora algumas vezes com dificuldade maior e clareza menor. Tente escrever uma vers\'e3o iterativa do problema das Torres de Han\'f3i. Se voc\'ea conseguir, compare sua vers\'e3o iterativa com a vers\'e3o recursiva desenvolvida no Exerc\'edcio 3.42. Investigue quest\'f5es de desempenho, clareza e sua habilidade de demonstrar a corre\'e7\'e3o do programa. \line 3.44 (Visualizando a redurs\'e3o) \f1\fs24\'c9 \f0\fs18 interessante observar a recurs\'e3o \ldblquote em a\'e7\'e3o\rdblquote . Modifique a fun\'e7\'e3o factorial da Fig. 3.14 para imprimir sua vari\'e1vel local e o par\'e2metro da chamada recursiva. Para cada chamada recursiva, mostre as sa\'eddas em linhas separadas e adicione um n\'edvel de recuo. Fa\'e7a o melhor poss\'edvel para tornar a sa\'edda clara, interessante e com significado. Seu objetivo aqui \'e9 desenvolver e implementar um formato de sa\'edda que ajude uma pessoa a entender melhor a recurs\'e3o. Voc\'ea pode desejar adicionar tais capacidades de exibi\'e7\'e3o a muitos outros exemplos e exerc\'edcios de recurs\'e3o ao longo do texto. \line 3.45 O m\'e1ximo divisor comum dos inteiros x e y \'e9 o maior inteiro que divide exatamente x e y. Escreva uma fun\'e7\'e3o recursiva mdc que retoma o m\'e1ximo divisor comum de x e y. O m\'e1ximo divisor comum de x e y \'e9 definido recursivamente como se segue: \line se y for igual a O, ent\'e3o mdc ( \b\f2\fs16 x, \b0\f0\fs18 y ) \'e9 x: caso contr\'e1rio, mdc ( \b\f2\fs16 x, \b0\f0\fs18 y ) \'e9 mdc ( y, x % y ) onde % \'e9 o operador m\'f3dulo. \line 3.46 A fun\'e7\'e3o main pode ser chamada redursivamente? Escreva um programa contendo a fun\'e7\'e3o main. Inclua a vari\'e1vel static local contador inicializada com 1. P\'f3s-incremente e imprima o valor de contador cada vez que main for chamada. Execute seu programa. O que acontece? \fs24\par
\fs18 3.47 Os Exerc\'edcios \i 3.35 \i0 a 3.37 desenvolveram um programa de instru\'e7\'e3o assistido por computador para ensinar multiplica\'e7\'e3o a um aluno de uma escola do primeiro grau. Este exerc\'edcio sugere algumas melhorias para esse programa. \fs24\par
\f2\fs20 258 C\'f7\'f7 \b\f3\fs16 CoMo \b0\f2\fs14 PROGRAMAR \line\f0\fs16 a) Modifique o programa para que ele permita ao usu\'e1rio especificar o n\'edvel de dificuldade dos testes. Um n\'edvel de dificuldade 1 significa usar somente n\'fameros de um \'fanico d\'edgito nos problemas, um n\'edvel de dificuldade dois significa usar n\'fameros de at\'e9 dois d\'edgitos, etc. \line b) Modifique o programa para que ele permita ao usu\'e1rio selecionar o tipo de problemas aritm\'e9ticos que deseja estudar. Uma op\'e7\'e3o igual a 1 significa apenas problemas de adi\'e7\'e3o, 2 significa apenas problemas de subtra\'e7\'e3o, 3 significa apenas problemas de multiplica\'e7\'e3o, 4 significa apenas problemas de divis\'e3o e \i\f2 5 \i0\f0 significa misturar aleatoriamente os problemas de todos os tipos. \line 3.48 Escreva uma fun\'e7\'e3o distancia que calcule a dist\'e2ncia entre dois pontos \i\fs20 (xl, \i0\fs16 yl) e \i\fs20 (x2, \f2\fs16 y2). \i0\f0 Todos os n\'fameros e valores de retorno devem ser do tipo double. \line 3.49 O que faz o programa seguinte? \line\b\f3 1 \b0\i\f0\fs20 II \b\i0\f3\fs16 ex3_49.cpp \line 2 #include <iostream> \line 3 \line 4 using std::cin; \line 5 using std::cout; \line\f0 6 \line\f3 7 int \b0\f0\fs22 main() \line\b\f3\fs16 8 \line 9 intc; \line 10 \line 11 if \b0\f2\fs20 ( ( \b\f3\fs16 c \b0\f2\fs12 = \b\f3\fs16 cmn.getO) \b0\f2\fs20 ) \i\fs16 != \b\i0\f3 EOF \line 12 main(); \line 13 cout \'ab c; \line 14 \b0\f0\} \line\b\f3 15 \line 16 return O; \line 17 \b0\f2\fs20\} \line\b\f0\fs16 3.50 \b0 O que faz o programa seguinte? \line\b 1 \b0\i\fs20 II \b\i0\fs16 ex0350.cpp \line\f3 2 #include <iostream> \line 3 \line 4 using std: :cout; \line 5 using std::cin; \line 6 using std: :endl; \line 7 \line 8 int mystery \b0\f2\fs20 ( \b\f3\fs16 int, int ); \line 9 \line 10 int main() \line\b0\f1\fs12 8 \f2\fs20\{ \line\b\f0\fs16 12 int x, y; \line\f3 13 \line 14 cout \'ab \ldblquote Digite dois inteiros: \b0\f2\fs10\ldblquote ; \line\b\f3\fs16 15 cin\'bbx\'bby; \line 16 cout \'ab \lquote O resultado \'e9 \b0\f2\fs8\ldblquote  \b\f3\fs16\'ab mystery( x, y \b0\f2\fs20 ) \f0\fs16\'ab \b\f3 endi; \line 17 return O; \line\b0\f0 18 \} \line\b\f3 19 \line\f0 20 \b0\i\fs20 II \b\i0\f3\fs16 O par\'e2metro b \f0 deve ser um inteiro \line\b0\f1\fs118 1 \f0\fs24\par
\b\fs16 21 \b0\f2\fs20 // \b\f3\fs16 positivo para evitar \b0\f0 uma \b\f3 recurs\'e3o infinita \line 22 int mystery \b0\f2\fs20 ( \b\f3\fs16 int a, int b \line\b0\f0\fs18 23 \f2\fs20\{ \line\b\f0\fs16 24 if(b==1) \b0\fs24\par
\b\fs16 26 else \b0\fs24\par
\b\f3\fs14 return a + mystery \b0\f2\fs20 ( \b\f3\fs14 a, b \b0\f2\fs8 - \b\f0\fs16 1 \b0\fs24\par
\b\fs16 CAP\'cdTULO \b0\f2 3 \fs8 - \b\f0\fs16 FUN\'c7\'d5ES \b0\f2 259 \f0\fs24\par
\fs18 3.51 Depois de determinar o que faz o programa do Exerc\'edcio 3.50, modifique-o para funcionar adequadamente ap\'f3s remover a restri\'e7\'e3o do segundo argumento n\'e3o ser negativo. \fs24\par
\fs18 3.52 Escreva um programa que teste o m\'e1ximo poss\'edvel das fun\'e7\'f5es da biblioteca matem\'e1tica listadas na Fig. 3.2. Experimente cada uma das fun\'e7\'f5es, fazendo com que seu programa imprima tabelas com os valores de retomo para diversos valores de argumentos. \fs24\par
\fs18 3.53 Encontre o erro em cada um dos seguintes segmentos de programas e explique como corrigi-lo: \fs24\par
\b\fs16 a) float cube \b0\f2\fs20 ( \b\f0\fs16 float ); \b0\fs24\par
\i\f2\fs20 II \b\i0\f0\fs16 prot\'f3tipo da fun\'e7\'e3o \b0\fs24\par
\b\fs16 double cube \b0\f2\fs20 ( \f0\fs16 float nuniber \f2\fs20 ) // \b\f3\fs16 defini\'e7\'e3o da fun\'e7\'e3o \b0\f0\fs24\par
\b\f3\fs16 return \b0\f0\fs14 number * nurnber * number; \fs24\par
\b\fs14 b) register auto int x \b0\f2\fs10 = \b\f0\fs14 7; \b0\fs24\par
\b\f3\fs14 e) int randomNuniber \b0\f2\fs10 = \b\f3\fs14 srand d) float y \b0\f2\fs10 = \b\f3\fs14 123.45678; \b0\f0\fs24\par
\b\fs16 int x; \b0\fs24\par
\b\f3\fs16 x \b0\f2\fs12 = \f0\fs24\par
\b\f3\fs16 cout \'ab static_cast< float >( x \b0\f2\fs20 ) \b\f3\fs16\'ab endi; \b0\f0\fs24\par
\b\fs16 e) double square \b0\f2\fs20 ( \b\f0\fs16 double number \b0\fs24\par
\f2\fs20 ( \f0\fs24\par
\f2\fs20\} \f0\fs24\par
\fs16 double nuniber; \fs24\par
\b\f3\fs16 return nuxnber \b0\f0\fs14 * number; \fs24\par
\fs18 f) \b\fs16 int \b0 sum( \b int n \b0\fs24\par
\b\fs14 if \b0\f2\fs20 ( \b\f0\fs14 n \b0\f2\fs10 = \b\f0\fs14 O \b0\fs24\par
\b\fs16 return O; \b0\fs24\par
\b\f3\fs16 else \b0\f0\fs24\par
\b\f3\fs16 return n + \b0\f0 sum( n \b\f3 ); \b0\f0\fs24\par
\fs16 3.54 Modifique o programa do jogo de \i craps \i0 da Fig. 3.10 para permitir apostas. Transforme em uma fun\'e7\'e3o a parte do programa que executa um jogo de \i craps. \i0 Inicialize a vari\'e1vel bankBalance com 1.000 d\'f3lares. Pe\'e7a ao jogador para digitar uma aposta e coloque este valor na vari\'e1vel wager. Use um la\'e7o while para verificar se wager \'e9 menor ou igual a bankBalance e, se n\'e3o for, pe\'e7a ao jogador para fornecer um novo valor de aposta, at\'e9 que um valor v\'e1lido para wager seja fornecido. Depois de ser informado um valor correto para wager. execute um jogo de \i craps. \i0 Se o jogador vencer, aumente bankBalance, com o valor de wager e imprima o novo \b\f3 bankBalance. \b0\f0 Se o jogador perder, subtraia o valor de wager do total em bankBalance, imprima o novo bankBalance. verifique se bankBalance se tomou zero e, em caso positivo, imprima a mensagem \ldblquote Sinto muito. Voc\'ea est\'e1 arruinado! \f2\fs8\ldblquote . \f0\fs16 Com o passar do jogo. imprima v\'e1rias mensagens para criar um \ldblquote interlocutor estilo \lquote crupi\'ea\rquote  \f2\fs8\ldblquote . \f0\fs16 tais como: \ldblquote Oh!, voc\'ea vai perder tudo, hein?\rdblquote  ou \ldblquote Isso mesmo, teste sua sorte!\rdblquote  ou \b\f3\ldblquote Voc\'ea \'e9 o m\'e1ximo. Chegou a hora de trocar suas fichas por \lquote grana\rquote !. \b0\f0\fs24\par
\b\f3\fs16 25 \b0\f0\fs24\par
\b\fs16 return a; \b0\fs24\par
\b\f3\fs16 27 \line\f0 28 \b0\f2\fs20\} \f0\fs24\par
\fs18 3.55 Escreva um programa em C++ que usa um fun\'e7\'e3o iriline areaDoCirculo para solicitar ao usu\'e1rio o raio de um \line c\'edrculo e calcular e imprimir a \'e1rea desse c\'edrculo. \fs24\par
\b\f2\fs22 260 C++ \b0\fs16 COMO \b\f0\fs14 PROGRAMAR \line\b0\fs16 3.56 Escreva um programa completo em com as duas fun\'e7\'f5es alternadas especificadas abaixo, sendo que cada uma delas simplesmente triplica a vari\'e1vel contador definida em main. Ent\'e3o compare e contraste as duas abordagens. Estas duas fun\'e7\'f5es s\'e3o \line a) Fun\'e7\'e3o triplaChamadaPorValor que passa uma c\'f3pia de contador por valor, triplica a c\'f3pia, e retoma o novo valor. \line b) Fun\'e7\'e3o triplaChamadaPorReferencia que passa contador com uma verdadeira chamada por refer\'eancia, via um par\'e2metro de refer\'eancia, e triplica a c\'f3pia original de contador atrav\'e9s de seu nome alternativo (i.e., o \line par\'e2metro de refer\'eancia). \line 3.57 Qual \'e9 a finalidade do operador un\'e1rio de resolu\'e7\'e3o de escopo? \line 3.58 Escreva um programa que usa um gabarito de fun\'e7\'e3o chamado mm para determinar o menor de dois par\'e2metros. Teste o programa usando pares de n\'fameros inteiros, de caracteres e de n\'fameros em ponto flutuante. \line 3.59 Escreva um programa que usa um gabarito de fun\'e7\'e3o chamado \b max \b0 para determinar o maior de tr\'eas par\'e2metros. Teste o programa usando triplas de n\'fameros inteiros, de caracteres e de n\'fameros em ponto flutuante. \line\b\fs20 3.60 \b0\fs16 Determine se os segmentos de programa seguinte cont\'eam erros. Para cada erro, explique como ele pode ser corrigido. Nota: para um segmento de programa particular, \'e9 poss\'edvel que nenhum erro exista no segmento. \line a) template \b\fs14 < \b0\fs16 class A \b\fs14 > \line\b0\fs16 int sum( int numi, int num2, int num3 \b\fs20 ) \line return \b0\fs16 numl + num2 + num3; \line\b\f3 b) void printResults( int x, int y \line cout \'ab \ldblquote A soma \'e9 \b0\f2\fs8\ldblquote  \fs22\'ab \b\f0\fs16 x + \f3 y \'ab \lquote\\n\rquote ; \line return x + y; \line e) template < A > \line A product( A numi, A num2, A num3 \line\b0\f0 return numi \f2\fs10 * \f0\fs16 num2 \f2\fs10 * \b\f3\fs16 num3; \line\b0\f0 d) double cube \b\fs20 ( \f3\fs16 int ); \line int cube \f0\fs20 ( \f3\fs16 int ); \par
\par
\pard\lang1033\b0\f4\fs20\par
}
 