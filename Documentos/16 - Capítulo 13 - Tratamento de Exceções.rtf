{\rtf1\ansi\ansicpg1252\deff0\deflang1033{\fonttbl{\f0\fswiss\fprq2\fcharset0 Arial;}{\f1\froman\fcharset0 Times New Roman;}}
\viewkind4\uc1\pard\sb100\sa240\lang2070\f0\fs24\par
\par
\ul 13 \ulnone\line Tratamento de exce\'e7\'f5es \par
\pard\sb100\sa100 Objetivos \line\bullet  Usar try, throw e catch para detectar, indicar e tratar exce\'e7\'f5es, respectivamente. \line\bullet  Processar exce\'e7\'f5es n\'e3o-capturadas e inesperadas. \line\bullet  Ser capaz de processar falhas de new. \line\bullet  Usar auto_ptr para prevenir perdas de mem\'f3ria. \line\bullet  Entender a hierarquia padr\'e3o de exce\'e7\'f5es. \line Nunca esque\'e7o um rosto, mas no seu caso vou abrir uma exce \'e7\'e3o. \par
\pard\sb100\sa240 Groucho (Julius Henry) Marx \par
Nenhuma regra \'e9 t\'e3o geral que n\'e3o admita exce\'e7\'f5es. Robert Burton, The Anatomy of Melancholy \line\'c9 do senso comum pegar um m\'e9todo e experiment\'e1-lo. Sefalhar admita francamente e tente outro. Mas acima de tudo, tente alguma coisa. \line Franklin Delano Roosevelt. \line Oh! Jogue fora a pior parte disso e deixe a parte mais pura com a outra metade. \line William Shakespeare \line Se eles est\'e3o correndo e n\'e3o olham aonde est\'e3o indo, Tenho que sair de algum lugar e apanh\'e1-los. Jerome David Salinger \line E ao se desculpar v\'e1rias vezes de uma falha n\'e3o piore essa falha pela desculpa. \line William Shakespeare. \par
1 \par
Errar \'e9 humnano, perdoar \'e9 divino. \line Alexander Pope, An Essay on Criticism \par
CAPfTULO 13 - TRATAMENTO DE EXCE\'c7\'d5ES 697 \par
\ul Vis\'e3o geral \ulnone\line 13.1 Introdu\'e7\'e3o \line 13.2 Quando o tratamento de exce\'e7\'f5es deve ser usado \line 13.3 Outras t\'e9cnicas de tratamento de erros \line 13.4 Fundamentos do tratamento de exce\'e7\'f5es em C++: try, throw, catch \line 13.5 Um exemplo simples de tratamento de exce\'e7\'e3o: divis\'e3o por zero \line 13.6 Disparando uma exce\'e7\'e3o \line 13.7 Capturando uma exce\'e7\'e3o \line 13.8 Disparando novamente uma exce\'e7\'e3o \line 13.9 Especifica\'e7\'f5es de exce\'e7\'e3o \line 13.10 Processando exce\'e7\'f5es inesperadas \line 13.11 Desempilhando a pilha \line 13.12 Construtores, destruidores e o tratamento de exce\'e7\'f5es \line 13.13 Exce\'e7\'f5es e heran\'e7a \line 13.14 Processando falhas de new \line 13.15 A classe auto_ptr e a aloca\'e7\'e3o din\'e2mica de mem\'f3ria \line 13.16 Hierarquia de exce\'e7\'f5es da biblioteca padr\'e3o \line Resumo\bullet  Terminologia Erros comuns de programa\'e7\'e3o \bullet  Boas pr\'e1ticas de programa\'e7\'e3o. Observa\'e7\'f5es de engenharia de software Dicas de desempenho Dicas de teste e depura \'e7\'e3o Exerc\'edcios de auto-revis\'e3o Respostas aos exerc\'edcios de auto-revis\'e3o \bullet  Exerc\'edcios \line 13.1 Introdu\'e7\'e3o \line Neste cap\'edtulo, introduzimos o tratamento de exce\'e7\'f5es. A estensibilidade de C++ pode aumentar substancialmente a quantidade e os tipos de erros que podem acontecer. Os recursos apresentados aqui possibilitam aos programadores escreverem programas mais claros, mais robustos e tolerantes a falhas. Sistemas recentes desenvolvidos com estas e/ou t\'e9cnicas semelhantes t\'eam reportado resultados positivos. Tamb\'e9m mencionaremos quando o tratamento de exce\'e7\'f5es n\'e3o deve ser usado. \line O estilo e os detalhes do tratamento de exce\'e7\'f5es apresentados neste cap\'edtulo est\'e3o baseados no trabalho de Andrew Koenig e Bjarne Stroustrup apresentado em seu artigo \ldblquote Exception Handling for C++ (revised)\rdblquote , publicado nos Proceedings ofthe USENIX C++ Conference, ocorrida em S\'e3o Francisco, em abril de 1990. \line O c\'f3digo de tratamento de erro varia em natureza e entre sistemas de software, dependendo de se o aplicativo de software \'e9 ou n\'e3o um produto para lan\'e7amento comercial. Os produtos comerciais tendem a conter muito mais c\'f3digo de tratamento de erros do que o software \ldblquote mais informal\rdblquote . \line Existem muitos meios populares de se lidar com erros. Mais comumente, o c\'f3digo de tratamento de erro est\'e1 misturado no meio do c\'f3digo de um sistema. Os erros s\'e3o tratados nos lugares do c\'f3digo onde os erros podem acontecer. A vantagem desta abordagem \'e9 que um programador que estiver lendo o c\'f3digo pode ver o processamento de erro na vizinhan\'e7a imediata do c\'f3digo e determinar se foi implementada a verifica\'e7\'e3o apropriada de erro. \line O problema com este esquema \'e9 que o c\'f3digo, de certo modo, se torna \ldblquote polu\'eddo\rdblquote  com o processamento de erros. Se torna mais dif\'edcil para um programador preocupado com o aplicativo em si ler o c\'f3digo e determinar se o mesmo est\'e1 funcionando corretamente. Isto torna mais dif\'edcil de se entender e manter o c\'f3digo. \line Alguns exemplos comuns de exce\'e7\'f5es s\'e3o uma falha de new em obter uma quantidade solicitada de mem\'f3ria, um subscrito de array fora dos limites, estouro em opera\'e7\'f5es aritm\'e9ticas, divis\'e3o por zero e par\'e2metros de fun\'e7\'e3o inv\'e1lidos. \par
698 C++ COMO PROGRAMAR \line Os recursos de tratamento de exce\'e7\'f5es de C++ possibilitam ao programador remover o c\'f3digo de tratamento de erros da \ldblquote linha principal\rdblquote  de execu\'e7\'e3o de um programa. Isso melhora a legibilidade e a possibilidade de modificar o programa. Com o estilo de C++ de tratamento de exce\'e7\'f5es, \'e9 poss\'edvel se capturar todos os tipos de exce\'e7\'f5es, capturar todas as exce\'e7\'f5es de um certo tipo ou capturar todas as exce\'e7\'f5es de tipos relacionados. Isso torna os programas mais robustos, reduzindo a probabilidade de que erros n\'e3o sejam capturados por um programa. O tratamento de exce\'e7\'f5es \'e9 fornecido para possibilitar aos programas capturar e tratar erros, em vez de deix\'e1-los acontecer e sofrer as conseq\'fc\'eancias. Se o programador n\'e3o fornece um meio de tratamento para um erro fatal, o programa termina. \line O tratamento de exce\'e7\'f5es foi projetado para lidar com erros s\'edncronos, tal como uma tentativa de dividir por zero (isso acontece quando o programa executa a instru\'e7\'e3o dividir). Com tratamento de exce\'e7\'f5es, antes de o programa executar a divis\'e3o, ele confere o denominador e \ldblquote dispara\rdblquote  uma exce\'e7\'e3o se o denominador for zero. \line O tratamento de exce\'e7\'f5es n\'e3o foi projetado para lidar com situa\'e7\'f5es ass\'edncronas, tais como t\'e9rmino de EIS em disco, chegada de mensagem pela rede, diques de mouse, etc.; essas s\'e3o mais bem tratadas atrav\'e9s de outros meios, tal como interrup\'e7\'f5es de processamento. \line O tratamento de exce\'e7\'f5es \'e9 usado em situa\'e7\'f5es em que o sistema pode recuperar o erro que causou a exce\'e7\'e3o. O procedimento que faz a recupera\'e7\'e3o \'e9 chamado de tratador de exce\'e7\'e3o. O tratamento de exce\'e7\'f5es \'e9 tipicamente usado quando o erro ser\'e1 tratado por uma parte diferente do programa (i.e., um escopo diferente) daquela que detectou o erro. Um programa que conduz um di\'e1logo interativo com um usu\'e1rio n\'e3o deve usar exce\'e7\'f5es para processar erros de entrada. \line O tratamento de exce\'e7\'f5es \'e9 especialmente apropriado a situa\'e7\'f5es em que o programa n\'e3o ser\'e1 capaz de se recuperar, mas precisa fazer uma \ldblquote limpeza final\rdblquote  organizada e ent\'e3o terminar \ldblquote elegantemente\rdblquote . \line Boa pr\'e1tica de programa\'e7\'e3o 13.1 \line Use exce\'e7\'f5es para erros que devem ser processados em um escopo diferente daquele em que ocorrem. Use \line outros meios de tratamento de erros para erros que ser\'e3o processados no escopo em que acontecem. \line Boa pr\'e1tica de programa\'e7\'e3o 13.2 \line Evite usar tratamento de exce\'e7\'f5es para fins diferentes do tratamento de erros, pois isso pode reduzir a \line clareza do programa. \line Existe outra raz\'e3o para se evitar usar t\'e9cnicas de tratamento de exce\'e7\'f5es para o controle de programas convencionais. O tratamento de exce\'e7\'f5es foi projetado para processamento de erros, que \'e9 uma atividade infreq\'fcente, comumente usada porque um programa est\'e1 para terminar. Em vista disso, n\'e3o se espera que os autores de compiladores C++ implementem o tratamento de exce\'e7\'f5es com o tipo de desempenho otimizado que se espera para o c\'f3digo regular de aplicativos. \line Dica de desempenho 13.1 \line f Embora seja poss\'edvel se usar o tratamento de exce\'e7\'f5es para prop\'f3sitos diferentes do tratamento de erros, isso pode reduzir o desempenho do programa. \line Dica de desempenho 13.2 \line f \lquote  O tratamento de exce\'e7\'f5es \'e9 geralmente implementado em compiladores de tal maneira que quando n\'e3o ocorrem exce\'e7\'f5es, pouco ou nenhum overhead \'e9 imposto pela presen\'e7a do c\'f3digo de tratamento de exce\'e7\'f5es. Quando ocorrem exce\'e7\'f5es, elas incorrem em overhead durante a execu\'e7\'e3o. Certamente, a presen\'e7a de c\'f3digo de tratamento de exce\'e7\'f5es faz o programa consumir mais mem\'f3ria. \line Observa\'e7\'e3o de engenharia de software 13.1 \line ______ O fluxo de controle com estruturas de controle convencionais \'e9 geralmente mais claro e eficiente do que com exce\'e7\'f5es. \par
Erro comum de programa\'e7\'e3o 13.1 \par
CAP\'cdTULO 13 - TRATAMENTO DE EXCE\'c7\'d5ES 699 \par
Uma outra raz\'e3o segundo a qual exce\'e7\'f5es podem ser perigosas como uma alternativa ao fluxo normal de controle \'e9 que a pilha \'e9 desempilhada e os recursos alocados antes da ocorr\'eancia da exce\'e7\'e3o podem n\'e3o ser liberados. Este problema pode ser evitado com uma programa\'e7\'e3o cuidadosa. \par
O tratamento de exce\'e7\'f5es ajuda a melhorar a toler\'e2ncia a falhas de um programa. Torna-se \ldblquote mais agrad\'e1vel\rdblquote  escrever c\'f3digo de processamento de erros e, assim, \'e9 mais prov\'e1vel que os programadores o fa\'e7am. Tamb\'e9m se torna poss\'edvel capturar exce\'e7\'f5es de v\'e1rios modos, tal como por tipo, ou at\'e9 especificar que exce\'e7\'f5es de qualquer tipo devem ser capturadas. \line A maioria dos programas escritos atualmente suporta somente uma \ldblquote\'fanica thread\rdblquote  (fluxo) de execu\'e7\'e3o. O multithreading vem recebendo grande aten\'e7\'e3o em sistemas operacionais recentes, como Windows NT, OS/2 e v\'e1rias vers\'f5es do Unix. As t\'e9cnicas discutidas neste cap\'edtulo se aplicam at\'e9 para programas que usam multithreading, embora n\'e3o discutamos especificamente programas que usam multithreading. \line Mostraremos como lidar com exce\'e7\'f5es \ldblquote n\'e3o-capturadas\rdblquote . Consideraremos como s\'e3o tratadas exce\'e7\'f5es inesperadas. Mostraremos como exce\'e7\'f5es relacionadas podem ser representadas por classes de exce\'e7\'f5es derivadas de uma classe base de exce\'e7\'e3o comum. \line Os recursos de tratamento de exce\'e7\'f5es de C++ est\'e3o se tornando amplamente usados, como resultado do padr\'e3o C++. A padroniza\'e7\'e3o \'e9 especialmente importante para grandes projetos de software, nos quais dezenas ou at\'e9 centenas de pessoas trabalham em componentes separados de um sistema, e tais componentes necessitam interagir para o sistema global funcionar corretamente. \par
Observa\'e7\'e3o de engenharia de software 13.2 \par
O tratamento de exce\'e7\'f5es \'e9 bem adequado para sistemas com componentes desenvolvidos separadamente. O tratamento de exce\'e7\'f5es facilita a combina\'e7\'e3o dos componentes. Cada componente pode executar sua pr\'f3pria detec\'e7\'e3o de exce\'e7\'e3o, separada do tratamento das exce\'e7\'f5es em outro escopo. \par
o tratamento de exce\'e7\'f5es pode ser visto como um outro meio de retornar o controle de uma fun\'e7\'e3o ou sair de um bloco de c\'f3digo. Normalmente, quando acontece uma exce\'e7\'e3o, ela ser\'e1 tratada por um invocador da fun\'e7\'e3o geradora da exce\'e7\'e3o, por um invocador daquele invocador, ou qu\'e3o longe para tr\'e1s na cadeia de chamadas for necess\'e1rio se ir para achar um tratador para aquela exce\'e7\'e3o. \par
13.2 Quando o tratamento de exce\'e7\'f5es deve ser usado \par
O tratamento de exce\'e7\'f5es deve ser usado somente para processar situa\'e7\'f5es excepcionais, apesar do fato de que n\'e3o existe nada que impe\'e7a o programador de usar exce\'e7\'f5es como uma alternativa para o controle do programa; processar exce\'e7\'f5es para componentes de programa que n\'e3o est\'e3o preparados para tratar aquelas exce\'e7\'f5es diretamente; processar exce\'e7\'f5es de componentes de software tais como fun\'e7\'f5es, bibliotecas e classes que, provavelmente, ser\'e3o amplamente usados e onde n\'e3o faz sentido que esses componentes tratem suas pr\'f3prias exce\'e7\'f5es; e em projetos de grande porte para tratar o processamento de erros de uma maneira uniforme em todo o projeto. \par
\ul Boa pr\'e1tica de \ulnone programa\'e7\'e3o 13.3 \par
Use t\'e9cnicas de tratamento de erros convencionais em lugar do tratamento de exce\'e7\'f5es para um processamento de erros direto e local, no qual um programa pode facilmente lidar com seus pr\'f3prios erros. \par
Observa\'e7\'e3o de engenharia de software 13.3 \par
Ao lidar com bibliotecas, o chamador dafirn\'e7\'e3o de biblioteca provavelmente ter\'e1 em mente umprocessainento de erro especifico para uma exce\'e7\'e3o gerada na fun\'e7\'e3o de biblioteca. E improv\'e1vel que uma fun\'e7\'e3o de biblioteca execute um processamento de erro que satisfa\'e7a \'e0s necessidades particulares de todos os usu\'e1rios. Portanto, exce\'e7\'f5es s\'e3o meios apropriados para tratar erros produzidos por fun\'e7\'f5es de bibliotecas. \par
700 C+\'f7 CoMo PROGRAMAR \line 13.3 Outras t\'e9cnicas de tratamento de erros \line Apresentamos uma variedade de modos de lidar com situa\'e7\'f5es excepcionais anteriormente a este cap\'edtulo. O texto a seguir resume estas e outras t\'e9cnicas \'fateis. \line\bullet  Use assert para testar erros de codifica\'e7\'e3o e projeto. Se uma asser\'e7\'e3o for false. o programa termina e o c\'f3digo deve ser corrigido. Isto \'e9 \'fatil durante a depura\'e7\'e3o do programa. \line\bullet  Simplesmente ignore as exce\'e7\'f5es. Isso seria devastador para produtos de software lan\'e7ados para o p\'fablico em geral, ou para software de finalidade especial - necess\'e1rio para miss\'f5es cr\'edticas. Mas para seu pr\'f3prio \line software, desenvolvido para seus pr\'f3prios fins, \'e9 bastante comum se ignorar muitos tipos de erros. \line\bullet  Aborte o programa. Isso, \'e9 claro, evita que um programa execute at\'e9 a conclus\'e3o e produza resultados incorretos. Realmente, para muitos tipos de erros isto \'e9 apropriado, especialmente para erros n\'e3o-fatais que possibilitam que um programa execute at\'e9 a conclus\'e3o, talvez levando o programador a pensar que o programa funcionou corretamente. Aqui, tamb\'e9m, tal estrat\'e9gia \'e9 impr\'f3pria para aplicativos destinados a miss\'f5es cr\'edticas. Os aspectos relacionados aos recursos tamb\'e9m s\'e3o importantes aqui. Se um programa obt\'e9m um recurso, o programa deveria liberar normalmente aquele recurso antes do t\'e9rmino do programa. \line Erro comum de programa\'e7\'e3o 13.2 \line Abortar um programa pode deixar um recurso em um estado em que outros programas n\'e3o s\'e3o capazes de \line acessar o mesmo, e conseq\'fcentemente o programa teria uma assim chamada \ldblquote perda de recurso \line\bullet  Inicialize algum indicador de erro. O problema com esta solu\'e7\'e3o \'e9 que os programas n\'e3o podem verificar estes indicadores de erro em todos os pontos em que os erros poderiam ser problem\'e1ticos. \line\bullet  Teste a condi\'e7\'e3o de erro, emita uma mensagem de erro e chame exit para passar um c\'f3digo de erro apropriado para o ambiente do programa. \line\bullet  Use setjump e longjump. Estas fun\'e7\'f5es da biblioteca <csetjmp> possibilitam ao programador especificar um desvio imediato para fora de chamadas de fun\'e7\'f5es profundamente aninhadas, de volta para um tratador de erro. Sem setjump /longjump. um programa deve executar v\'e1rios returns para sair das chamadas de fun\'e7\'f5es profundamente aninhadas. Isso poderia ser usado para desviar para algum tratador de erro. Mas elas s\'e3o perigosas, porque elas desempilham a pilha sem chamar destruidores para objetos autom\'e1ticos. Isso pode levar a s\'e9rios problemas. \line\bullet  Certos tipos espec\'edficos de erros t\'eam recursos dedicados para o seu tratamento. Por exemplo, quando new falha na aloca\'e7\'e3o de mem\'f3ria, pode fazer com que uma fun\'e7\'e3o new handier seja executada para tratar o erro. Esta fun\'e7\'e3o pode ser trocada fornecendo-se um nome de fun\'e7\'e3o como argumento para setnewhandler. Discutimos a fun\'e7\'e3o set newhandler em detalhes na Se\'e7\'e3o 13.14. \line 13.4 Fundamentos do tratamento de exce\'e7\'f5es em C++: try, throw, catch \line O tratamento de exce\'e7\'f5es em C++ se destina a situa\'e7\'f5es em que a fun\'e7\'e3o que descobre um erro est\'e1 impossibilitada de trat\'e1-lo. Tal fun\'e7\'e3o disparar\'e1 (throw) uma exce\'e7\'e3o. N\'e3o existe nenhuma garantia de que existir\'e1 \ldblquote qualquer coisa l\'e1 fora\rdblquote , i.e., um tratador de exce\'e7\'e3o especificamente preparado para processar aquele tipo de exce\'e7\'e3o. Se existir, a exce\'e7\'e3o ser\'e1 capturada e tratada. Se n\'e3o existir nenhum tratador de exce\'e7\'e3o para aquele tipo particular de exce\'e7\'e3o, o programa termina. \line O programador coloca dentro de um bloco try o c\'f3digo que pode gerar um erro que produzir\'e1 uma exce\'e7\'e3o. O bloco try \'e9 seguido por um ou mais blocos catch. Cada bloco catch especifica o tipo de exce\'e7\'e3o que ele pode capturar e tratar. Cada bloco catch cont\'e9m um tratador de exce\'e7\'e3o. Se a exce\'e7\'e3o corresponde ao tipo do par\'e2metro em um dos blocos catch, o c\'f3digo daquele bloco catch \'e9 executado. Se nenhum tratador for encontrado, \'e9 chamada a fun\'e7\'e3o terminate. a qual, por default. chama a fun\'e7\'e3o abort. \line Quando uma exce\'e7\'e3o \'e9 disparada, o controle do programa sai do bloco try e pesquisa os blocos catch em \line busca de um tratador apropriado (logo discutiremos o que torna um tratador \ldblquote apropriado\rdblquote ). Se nenhuma exce\'e7\'e3o foi \par
CAP\'cdTULO 13 - TRATAMENTO DE EXCE\'c7\'d5ES 701 \par
disparada no bloco try, os tratadores de exce\'e7\'e3o para aquele bloco s\'e3o saltados e o programa retoma a execu\'e7\'e3o depois do \'faltimo bloco catch. \line Podemos especificar as exce\'e7\'f5es que uma fun\'e7\'e3o dispara. Como op\'e7\'e3o, podemos especificar que uma fun\'e7\'e3o \line n\'e3o disparar\'e1 nenhuma exce\'e7\'e3o. \line A exce\'e7\'e3o \'e9 disparada em um bloco try na fun\'e7\'e3o, ou a exce\'e7\'e3o \'e9 disparada a partir de uma fun\'e7\'e3o chamada diretamente ou indiretamente a partir do bloco try. O ponto em que o throw \'e9 executado \'e9 chamado de ponto de disparo. Este termo tamb\'e9m \'e9 usado para descrever a pr\'f3pria express\'e3o throw. Depois que uma exce\'e7\'e3o \'e9 disparada, o controle n\'e3o pode retornar ao ponto de disparo da mesma. \line Quando ocorre uma exce\'e7\'e3o, \'e9 poss\'edvel passar informa\'e7\'f5es para o tratador de exce\'e7\'e3o, a partir do ponto em \line que ocorreu a exce\'e7\'e3o. Essa informa\'e7\'e3o \'e9 o tipo do pr\'f3prio objeto disparado ou informa\'e7\'f5es colocadas no objeto disparado. \line O objeto disparado \'e9 tipicamente um string de caracteres (para uma mensagem de erro) ou um objeto de uma classe. O objeto disparado leva informa\'e7\'f5es para o tratador de exce\'e7\'e3o que processar\'e1 aquela exce\'e7\'e3o. \par
Observa\'e7\'e3o de engenharia de software 13.4 \par
Uma id\'e9ia-chave do tratamento de exce\'e7\'f5es \'e9 que a parte de um programa ou sistema que tratar\'e1 a exce\'e7\'e3o pode ser bastante diferente ou distante da parte do programa que descobriu e gerou a situa\'e7\'e3o excepcional. \par
13.5 Um exemplo simples de tratamento de exce\'e7\'e3o: divis\'e3o por zero \par
Agora, iremos considerar um exemplo simples de tratamento de exce\'e7\'f5es. A Fig. 13.1 usa try, throw e catch para descobrir que ocorreu uma divis\'e3o por zero, indicar uma exce\'e7\'e3o de divis\'e3o por zero e tratar uma exce\'e7\'e3o de divis\'e3o por zero. \par
1 II Fig. 13.1: figl3Ol.cpp \line 2 II Um exemplo simples de tratamento de exce\'e7\'e3o. \line 3 // Verificando uma exce\'e7\'e3o de divis\'e3o por zero. \line 4 #include <iostream> \par
5 \par
6 using std::cout; \line 7 using std::cin; \line 8 using std: :endl; \par
9 \par
II Classe DivideByZeroException a ser usada no tratamento de 1/ exce\'e7\'e3o para disparar uma exce\'e7\'e3o em caso de divis\'e3o por zero. class DivideByZeroException \line public: \line DivideByZeroException O \line message( \lquote tentou dividir por zero\rdblquote  \line const char *what() const \{ return message; \line private: \line const char *message; \par
// Defini\'e7\'e3o da fun\'e7\'e3o quociente. Demonstra o disparo de uma // exce\'e7\'e3o quando uma exce\'e7\'e3o de divis\'e3o por zero \'e9 encontrada. double quotient( int numerator, int denominator \par
if ( denominator == O \line throw DivideByZeroExceptionO; \par
28 return static_cast< double > ( numerator ) / denominator; \par
10 \line 11 \line 12 \line 13 \line 14 \line 15 \line 16 \line 17 \line 18 \line 19 \line 20 \line 21 \line 22 \line 23 \line 24 \line 25 \line 26 \line 27 \par
Fig. 13.1 Um exemplo simples de tratamento de exce\'e7\'e3o com divis\'e3o por zero (parte 1 de 2). \par
702 C++ COMO PROGRAMAR \line 29 \} \line 30 \line 31 // Programa de teste \line 32 int main() \line 33 \line 34 int numberi, number2; \line 35 double result; \line 36 \line 37 cout \'ab \ldblquote Digite dois inteiros (fim de arquivo para terminar) : \line 38 \line 39 while ( cm \'bb nuxnberl \'bb number2 \line 40 \line 41 // o bloco try engloba o c\'f3digo que pode disparar \line 42 II uma exce\'e7\'e3o e o c\'f3digo que n\'e3o deve ser executado \line 43 II se ocorrer uma exce\'e7\'e3o \line 44 try\{ \line 45 result = quotient( numberi, number2 ); \line 46 cout \'ab \ldblquote O quociente \'e9: \'ab result \'ab endl; \line 47 \line 48 catch ( DivideByZeroException ex ) \{ II exception handler \line 49 cout \'ab \ldblquote Ocorreu uma exce\'e7\'e3o: \ldblquote  \'ab ex. what () \'ab \lquote\\n \line 50 \line 51 \line 52 cout \'ab \ldblquote\\nDigite dois inteiros (fim de arquivo para terminar) \line 53 \line 54 \line 55 cout \'ab endl; \line 56 return 0; // termina normalmente \line 57 \par
Fig. 13.1 Um exemplo simples de tratamento de exce\'e7\'e3o com divis\'e3o por zero (parte 2 de 2). \line Agora, considere o programa de teste em main. Note a declara\'e7\'e3o \ldblquote localizada\rdblquote  de numberl e nuniber2. \line O programa cont\'e9m um bloco try (linha 44) que engloba o c\'f3digo que pode disparar uma exce\'e7\'e3o. Note que a divis\'e3o real, que pode causar o erro, n\'e3o \'e9 explicitamente listada dentro do bloco try. Em vez disso, a chamada \line para a fun\'e7\'e3o quotient (definida na linha 23) invoca o c\'f3digo que tenta a divis\'e3o real. A fun\'e7\'e3o quotient realmente dispara o objeto de exce\'e7\'e3o divis\'e3o por zero, como veremos em seguida. Em geral, os erros podem aparecer atrav\'e9s de c\'f3digo explicitamente mencionado no bloco try. atrav\'e9s de chamadas a uma fun\'e7\'e3o ou at\'e9 atrav\'e9s de chamadas de fun\'e7\'e3o profundamente aninhadas iniciadas por c\'f3digo no bloco try. \line O bloco try \'e9 imediatamente seguido por um bloco catch contendo o tratador de exce\'e7\'e3o para o erro divis\'e3o por zero. Em geral, quando uma exce\'e7\'e3o \'e9 disparada dentro de um bloco try. a exce\'e7\'e3o \'e9 capturada por um bloco catch que especifica o tipo apropriado que corresponde \'e0 exce\'e7\'e3o disparada. Na Fig. 13.1, o bloco catch especifica que ele capturar\'e1 objetos de exce\'e7\'e3o do tipo DivideByZeroException; este tipo corresponde ao tipo do objeto associado \'e0 fun\'e7\'e3o quotient. O corpo desse tratador de exce\'e7\'e3o imprime a mensagem de erro retornada pela chamada da fun\'e7\'e3o what. Tratadores de exce\'e7\'e3o podem ser muito mais elaborados que esse. \par
\pard\par
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2150\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4733\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx6295\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx7892\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx8397\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx8710\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx8946\pard\intbl Digite dois  O quociente \cell inteiros (fim de \'e9: 14.2857 \cell arquivo \cell para terminar): \cell 100 \cell 7 \cell\cell\row
\intbl Digite dois Ocorreu uma \cell inteiros (fim de  exce\'e7\'e3o: tentou \cell arquivo dividir \cell para terminar):  por zero \cell 100 \cell O \cell\cell\row
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2150\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4733\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx6295\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx7892\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx8710\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx8946\pard\intbl Digite dois O quociente \cell inteiros (fim de \'e9: 3.66667 \cell arquivo \cell para terminar): \cell 33 9 \cell\cell\row
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2150\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4733\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx6295\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx7892\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx8397\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx8710\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx8946\pard\intbl Digite dois \cell inteiros (fim de \cell arquivo \cell para terminar): \cell\cell\cell\cell\row
\pard\par
\pard\sb100\sa240 CAP\'cdTULO 13 - TRATAMENTO DE EXCE\'c7\'d5ES 703 \par
Se, ao ser executado, o c\'f3digo em um bloco try n\'e3o dispara uma exce\'e7\'e3o, ent\'e3o todos os tratadores catch imediatamente ap\'f3s o bloco try s\'e3o saltados e a execu\'e7\'e3o continua na primeira linha de c\'f3digo depois dos tratadores catch; na Fig. 13.1, \'e9 executado um comando return que retorna O, indicando t\'e9rmino normal. \line Agora, iremos examinar as defini\'e7\'f5es da classe DivideByzeroException e da fun\'e7\'e3o quotient. Na fun\'e7\'e3o quotient, quando o comando if determina que o denominador \'e9 zero, o corpo do comando if executa um comando throw que especifica o nome do construtor para o objeto de exce\'e7\'e3o. Isto faz com que um objeto da classe DivideByZeroException seja criado. Este objeto ser\'e1 capturado pelo comando catch (que especifica o tipo DivideByzeroException) depois do bloco try. O construtor para a classe DivideByZeroException simplesmente aponta o membro de dados message para o string \ldblquote tentou dividir por zero\rdblquote . O objeto disparado \'e9 recebido no par\'e2metro especificado no tratador catch (nesse caso, o par\'e2metro ex) e a mensagem \'e9 impressa l\'e1 atrav\'e9s de uma chamada \'e0 fun\'e7\'e3o what O. \line Boa pr\'e1tica de programa\'e7\'e3o 13.4 \line Associar cada tipo de erro durante a execu\'e7\'e3o a um objeto de exce\'e7\'e3o apropriadamente nomeado melhora a clareza do programa. \line 13.6 Disparando uma exce\'e7\'e3o \line A palavra-chave throw \'e9 usada para indicar que uma exce\'e7\'e3o aconteceu. Isto \'e9 chamado de disparar uma exce\'e7\'e3o. \line Um throw normalmente especifica um operando (um caso especial que discutiremos n\'e3o especifica nenhum ope rando) O operando de um throw pode ser de qualquer tipo. Se o operando \'e9 um objeto, chamamo-lo de objeto de \line exce\'e7\'e3o. O valor de qualquer express\'e3o pode ser disparado em vez de um objeto. E poss\'edvel se disparar objetos n\'e3o \line voltados ao tratamento de erro. \line Onde uma exce\'e7\'e3o \'e9 capturada? Ao ser disparada, a exce\'e7\'e3o ser\'e1 capturada pelo tratador de exce\'e7\'e3o mais \line pr\'f3ximo (do bloco try do qual a exce\'e7\'e3o foi disparada) que especifique o tipo apropriado. Os tratadores de exce\'e7\'e3o \line para um bloco try s\'e3o listados imediatamente ap\'f3s o bloco try. \line\bullet  Como parte do disparo de uma exce\'e7\'e3o, uma c\'f3pia tempor\'e1ria do operando do throw \'e9 criada e inicializada. \line A Esse objeto ent\'e3o inicializa o par\'e2metro no tratador de exce\'e7\'e3o. O objeto tempor\'e1rio \'e9 destru\'eddo quando o tratador \line de exce\'e7\'e3o completa a execu\'e7\'e3o e o controle sai dele. F \line Observa\'e7\'e3o de engenharia de software 13.5 \line ______ Se \'e9 necess\'e1rio passar informa\'e7\'f5es sobre o erro que causou uma exce\'e7\'e3o, tal informa\'e7\'e3o pode ser colocada no objeto disparado. O tratador catch ent\'e3o vai conter um nome de par\'e2metro atrav\'e9s do qual as infi.rma\'e7\'f5es podem ser referenciadas. \line Observa\'e7\'e3o de engenharia de software 13.6 \line ______ Um objeto pode ser disparado sem conter informa\'e7\'f5es a serem passadas; nesse caso, o mero conhecimento de que uma exce\'e7\'e3o desse tipo foi disparada pode fornecer informa\'e7\'f5es suficientes para o tratador fazer seu trabalho corretamente. \line Quando uma exce\'e7\'e3o \'e9 disparada, o controle sai do bloco try corrente e continua em um tratador catch apropriado (se existir um) ap\'f3s aquele bloco try. E poss\'edvel que o ponto de disparo esteja em um escopo profundamente aninhado dentro de um bloco try; o controle ainda seguir\'e1 para o tratador catch. E tamb\'e9m poss\'edvel que o ponto de throw possa estar em uma chamada de fun\'e7\'e3o profundamente aninhada; ainda neste caso, o controle seguir\'e1 para o tratador catch. \line Um bloco try pode parecer n\'e3o conter nenhuma verifica\'e7\'e3o de erro e n\'e3o incluir nenhum comando throw. mas o c\'f3digo referenciado no bloco try certamente pode fazer com que c\'f3digo de verifica\'e7\'e3o de erro nos construtores seja exectitado. O c\'f3digo em um bloco try poderia executar indexa\'e7\'e3o de arrays em um objeto de classe array cuja fun\'e7\'e3o membro operator [1 \'e9 sobrecarregada para disparar uma exce\'e7\'e3o quando ocorre um erro de subscrito fora do intervalo. Qualquer chamada de fun\'e7\'e3o pode invocar c\'f3digo que pode disparar uma exce\'e7\'e3o ou chamar \line 4 outra fun\'e7\'e3o que dispara uma exce\'e7\'e3o. \par
704 C++ COMO PROGRAMAR \line Embora uma exce\'e7\'e3o possa terminar a execu\'e7\'e3o do programa, n\'e3o \'e9 obrigat\'f3rio faz\'ea-lo. Por\'e9m, uma exce\'e7\'e3o \line termina o bloco em que a mesma aconteceu. \line Erro comum de programa\'e7\'e3o 13.3 \line Exce\'e7\'f5es deveriam ser disparadas somente dentro de um bloco try. Uma exce\'e7\'e3o disparada fora de um \line bloco try provoca uma chamada a terminate. \line Erro comum de programa\'e7\'e3o 13.4 \line\'c9 poss\'edvel se disparar uma express\'e3o condicional. Mas seja cuidadoso, porque as regras de promo\'e7\'e3o podem fazer com que o valor retornado pela express\'e3o condicional seja de um tipo diferente daquele que voc\'ea esperava. Por exemplo, ao disparar um int ou um double a partir da mesma express\'e3o condicional, a express\'e3o condicional converter\'e1 o int em um double. Ent\'e3o, o resultado sempre ser\'e1 capturado por um catch com um par\'e2metro double, em vez de, \'e0s vezes, capturar double (para um double realmente pretendido) e \'e0s vezes capturar int. \line 13.7 Capturando uma exce\'e7\'e3o \line Os tratadores de exce\'e7\'e3o est\'e3o contidos em blocos catch. Cada bloco catch come\'e7a com a palavra-chave catch seguida por par\'eanteses contendo um tipo (indicando o tipo de exce\'e7\'e3o que este bloco catch trata) e um nome de par\'e2metro opcional. Este \'e9 seguido por chaves delimitando o c\'f3digo de tratamento de exce\'e7\'f5es. Quando uma exce\'e7\'e3o \'e9 capturada, o c\'f3digo no bloco catch \'e9 executado. \line O tratador catch define seu pr\'f3prio escopo. Um catch especifica entre par\'eanteses o tipo do objeto a ser capturado. O par\'e2metro em um tratador catch pode ter nome ou n\'e3o. Se o par\'e2metro tem nome, ele pode ser referenciado no tratador. Se o par\'e2metro n\'e3o tem nome, i.e., s\'f3 um tipo \'e9 listado para fins de compara\'e7\'e3o com o tipo de objeto disparado, ent\'e3o n\'e3o s\'e3o levadas informa\'e7\'f5es do ponto de disparo at\'e9 o tratador; s\'f3 o controle passa do ponto de disparo para o tratador. Para muitas exce\'e7\'f5es, isto \'e9 aceit\'e1vel. \line IErro comum de programa\'e7\'e3o 13.5 \line Especificar uma lista de par\'e2metros catch separados por v\'edrgulas \'e9 um erro de sintaxe. \line Uma exce\'e7\'e3o cujo tipo de objeto disparado corresponde ao tipo do par\'e2metro no cabe\'e7alho do catch faz com que o bloco catch. i.e., o tratador de exce\'e7\'e3o para exce\'e7\'f5es daquele tipo, seja executado. \line O tratador catch que captura uma exce\'e7\'e3o \'e9 o primeiro listado depois do bloco try atualmente ativo que corresponde ao tipo do objeto disparado. As regras de correspond\'eancia ser\'e3o discutidas em breve. \line Uma exce\'e7\'e3o que n\'e3o \'e9 capturada provoca uma chamada para terminate que, por default, termina o programa chamando abort. E poss\'edvel se especificar um comportamento personalizado, estabelecendo que outra fun\'e7\'e3o seja executada, fornecendo-se o nome daquela fun\'e7\'e3o como par\'e2metro em uma chamada da fun\'e7\'e3o setterminate. \line Um catch seguido por par\'eanteses incluindo retic\'eancias \line catch ( ... ) \line significa capturar todas as exce\'e7\'f5es. \line Erro comum de programa\'e7\'e3o 13.6 \line Colocar catch (. . .) antes de outros blocos catch impediria que aqueles blocos fossem executados; \line catch (. . .) deve ser colocado por \'faltimo na lista de tratadores que segue um bloco try. \line Observa\'e7\'e3o de engenharia de software 13.7 \line ______ Um ponto fraco na t\'e9cnica de capturar exce\'e7\'f5es com catch . . . \'e9 que normalmente voc\'ea n\'e3o pode ter certeza de qual \'e9 o tipo da exce\'e7\'e3o. Outro ponto fraco \'e9 que, sem um par\'e2metro nomeado, n\'e3o existe \line nenhum modo de se referir ao objeto de exce\'e7\'e3o dentro do tratador de exce\'e7\'e3o. \par
CAP\'cdTULO 13 - TRATAMENTO DE EXCE\'c7\'d5ES 705 \line\'c9 poss\'edvel que nenhum tratador corresponda a um objeto disparado em particular. Isso faz com que a procura por uma correspond\'eancia continue no pr\'f3ximo bloco try mais externo. A medida que tal processo continua, pode eventualmente ser determinado que n\'e3o existe nenhum tratador no programa que corresponda ao tipo do objeto disparado; neste caso, \'e9 chamada a fun\'e7\'e3o terminate, a qual, por default, chama a fun\'e7\'e3o abort. \line Os tratadores de exce\'e7\'e3o s\'e3o pesquisados em ordem, procurando uma correspond\'eancia apropriada. O primeiro tratador que corresponde ao tipo de objeto disparado \'e9 executado. Quando aquele tratador termina de executar, o \line controle continua com o primeiro comando depois do \'faltimo bloco catch, i.e., o primeiro comando depois do \'faltimo tratador de exce\'e7\'e3o para aquele bloco try. \line E poss\'edvel que v\'e1rios tratadores de exce\'e7\'e3o representem uma correspond\'eancia aceit\'e1vel para o tipo da exce\'e7\'e3o que foi disparada. Neste caso, \'e9 executado o primeiro tratador de exce\'e7\'e3o que corresponde ao tipo de exce\'e7\'e3o. Se v\'e1rios tratadores apresentam uma correspond\'eancia, e se cada um destes trata a exce\'e7\'e3o diferentemente, ent\'e3o a ordem dos tratadores afetar\'e1 a maneira como a exce\'e7\'e3o \'e9 tratada. \line E poss\'edvel que v\'e1rios tratadores catch possam conter um tipo de classe que corresponda ao tipo de um objeto disparado em particular. Isto pode ocorrer por v\'e1rias raz\'f5es. Primeiro, pode haver um tratador catch (. \line\ldblquote captura tudo\rdblquote , que capturar\'e1 qualquer exce\'e7\'e3o. Segundo, por causa das hierarquias de heran\'e7a, \'e9 poss\'edvel que um objeto de uma classe derivada possa ser capturado por qualquer tratador que especifique o tipo da classe derivada ou por tratadores que especifiquem os tipos de quaisquer classes base daquela classe derivada eliminar. \line Erro comum de programa\'e7\'e3o 13.7 \line Colocar um catch que captura um objeto de uma classe base antes de um catch que captura um objeto de uma classe derivada daquela classe base \'e9 um erro de l\'f3gica. O catch da classe base capturaria todos os objetos de classes derivadas daquela classe base e, desse modo, o catch da classe derivada nunca seria executado. \line\'ae Dica de teste e depura \'e7\'e3o 13.1 \line O programador determina a ordem em que os tratadores de exce\'e7\'e3o s\'e3o listados. Esta ordem pode afetar C(\'bbflO exce\'e7\'f5es originadas naquele bloco try s\'e3o manipuladas. Se voc\'ea estiver obtendo um comportamento inesperado no tratamento de exce\'e7\'f5es do seu programa, pode ser porque um bloco catch anterior \line est\'e1 interceptando e tratando as exce\'e7\'f5es antes que possam alcan\'e7ar seu tratador catch planejado. \line\'c0s vezes, um programa pode processar muitos tipos de exce\'e7\'f5es intimamente relacionados. Em vez de fornecer classes de exce\'e7\'e3o e tratadores catch separados para cada uma, um programador pode fornecer uma \'fanica classe de exce\'e7\'e3o e um tratador catch \'fanico para um grupo de exce\'e7\'f5es. A medida que acontece cada exce\'e7\'e3o, o objeto de exce\'e7\'e3o pode ser criado com dados privados diferentes. O tratador catch pode examinar estes dados privados para identificar o tipo da exce\'e7\'e3o. \line Quando ocorre uma correspond\'eancia? O tipo de par\'e2metro do tratador catch corresponde ao tipo do objeto \line disparado se \line\bullet  eles s\'e3o realmente do mesmo tipo. \line\bullet  o tipo de par\'e2metro do tratador catch \'e9 uma classe base public da classe do objeto disparado. \line\bullet  o par\'e2metro do tratador \'e9 de um tipo ponteiro ou refer\'eancia para uma classe base e o objeto disparado \'e9 de um tipo ponteiro ou refer\'eancia para uma classe derivada. \line\bullet  o tratador catch \'e9 da forma catch (. . \line Erro comum de programa\'e7\'e3o 13.8 \line Colocar um tratador de exce\'e7\'e3o com um tipo de argumento void* antes de tratadores de exce\'e7\'e3o com outros tipos de ponteiro provoca um erro de l\'f3gica. O tratador void* capturaria todas as exce\'e7\'f5es de tipos ponteiro, de modo que os outros tratadores nunca seriam executados. Somente catch ( . . . ) deve virap\'f3scatch(void *) \line\'c9 necess\'e1ria uma correspond\'eancia de tipo de exata. Nenhuma promo\'e7\'e3o ou convers\'e3o s\'e3o executadas quando se estiver procurando um tratador de exce\'e7\'e3o, exceto convers\'f5es de classe derivada para classe base. \par
706 C++ COMO PROGRAMAR \line\'c9 poss\'edvel se disparar objetos const. Neste caso, o tipo de par\'e2metro do tratador catch deve tamb\'e9m ser \line declarado const. \line Se nenhum tratador \'e9 encontrado para uma exce\'e7\'e3o, o programa termina. Embora isto possa parecer a coisa \line certa a ser feita, n\'e3o \'e9 o que os programadores est\'e3o acostumados a fazer. Em vez disso, em geral os erros simplesmente acontecem e ent\'e3o a execu\'e7\'e3o do programa continua, possivelmente \ldblquote mancando\rdblquote . \line Um bloco try seguido por v\'e1rios catches se assemelha a um comando switch. N\'e3o \'e9 necess\'e1rio usar break para sair um tratador de exce\'e7\'e3o de modo a passar por cima os tratadores de exce\'e7\'e3o restantes. Cada bloco catch define um escopo distinto, enquanto que todos os casos em um comando switch est\'e3o contidos dentro do escopo do switch. \line Erro comum de programa\'e7\'e3o 13.9 \line Colocar um ponto-e-v\'edrgula depois de um bloco try, ou depois de qualquer tratador catch (exceto o \line\'faltimo catch) em seguida a um bloco try \'e9 um erro de sintaxe. \line Um tratador de exce\'e7\'e3o n\'e3o pode acessar objetos autom\'e1ticos definidos dentro de seu bloco try, porque quando uma exce\'e7\'e3o ocorre o bloco try termina e todos os objetos autom\'e1ticos dentro do bloco try s\'e3o destru\'eddos antes de o tratador come\'e7ar a ser executado. \line O que acontece quando uma exce\'e7\'e3o ocorre em um tratador de exce\'e7\'e3o? A exce\'e7\'e3o original que foi capturada \'e9 oficialmente tratada quando o tratador de exce\'e7\'e3o come\'e7a a executar. Assim, exce\'e7\'f5es que acontecem em um tratador de exce\'e7\'e3o necessitam ser processadas fora do bloco try em que a exce\'e7\'e3o original foi disparada. \line Os tratadores de exce\'e7\'e3o podem ser escritos de v\'e1rios modos. Podem dar uma olhada mais de perto em um erro e decidir chamar terminate. Podem disparar novamente uma exce\'e7\'e3o (Se\'e7\'e3o 13.8). Podem converter um tipo de exce\'e7\'e3o em outro, disparando uma exce\'e7\'e3o diferente. Podem executar qualquer recupera\'e7\'e3o necess\'e1ria e retomar a execu\'e7\'e3o depois do \'faltimo tratador de exce\'e7\'e3o. Podem olhar para a situa\'e7\'e3o que est\'e1 causando o erro. remover a causa do erro e tentar novamente chamar a fun\'e7\'e3o original que provocou uma exce\'e7\'e3o (isto n\'e3o criaria uma recurs\'e3o infinita). Podem retornar algum valor de estado ao seu ambiente, etc. \line Observa\'e7\'e3o de engenharia de software 13.8 \line _______ \'c9 melhor incorporar sua estrat\'e9gia de tratamento de exce\'e7\'f5es a um sistema desde o come\'e7o do projeto. \'c9 dif\'edcil incorporar um tratamento de exce\'e7\'f5es efetivo depois de um sistema ter sido implernentado. \line Quando um bloco try n\'e3o dispara exce\'e7\'f5es e o bloco try completa normalmente a execu\'e7\'e3o, o controle passa para o primeiro comando depois do \'faltimo catch ap\'f3s o try. \line N\'e3o \'e9 poss\'edvel se retornar ao ponto de disparo executando um comando return em um tratador catch. Tal \line return simplesmente retorna para a fun\'e7\'e3o que chamou a fun\'e7\'e3o que cont\'e9m o bloco catch. \line Erro comum de programa\'e7\'e3o comum 13.10 \line Assumir que, depois que uma exce\'e7\'e3o \'e9 processada, o controle retornar\'e1 ao primeiro comando depois do \line throw \'e9 um erro de l\'f3gica. \line Observa\'e7\'e3o de engenharia de software 13.9 \line _______ Outra raz\'e3o para n\'e3o usar exce\'e7\'f5es para fluxo de controle convencional \'e9 que estas \ldblquote exce\'e7\'f5es adicionais\rdblquote  podem se confundir com exce\'e7\'f5es genu\'ednas de tratamento de erro. Torna-se mais dif\'edcil para o programador manter o controle do n\'famero de casos de exce\'e7\'e3o. Por exemplo, quando um programa processa uma variedade excessiva de exce\'e7\'f5es, podemos realmente estar certos do que est\'e1 sendo capturado por um catch ( . . . ) ? Situa\'e7\'f5es excepcionais deveriam ser raras, e n\'e3o comuns. \line Quando uma exce\'e7\'e3o \'e9 capturada, \'e9 poss\'edvel que recursos tenham sido alocados, mas ainda n\'e3o liberados no bloco try. O tratador czatch. se poss\'edvel, deveria liberar estes recursos. Por exemplo, o tratador catch deveria eliminar o espa\'e7o alocado por new e fechar quaisquer arquivos abertos no bloco try que disparou a exce\'e7\'e3o. \line Um bloco catch pode processar o erro de uma maneira que possibilite ao programa continuar a executar \line corretamente. Ou o bloco catch pode terminar o programa. \par
CAP\'cdTULO 13 - TRATAMENTO DE EXCE\'c7\'d5ES 707 \line Um tratador catch pode ele mesmo descobrir um erro e disparar uma exce\'e7\'e3o. Tal exce\'e7\'e3o n\'e3o ser\'e1 processada por tratadores catch associados ao mesmo bloco try que o tratador catch que est\'e1 disparando a exce\'e7\'e3o. Em vez disso, a exce\'e7\'e3o disparada ser\'e1 capturada, se poss\'edvel, por um tratador catch associado ao pr\'f3ximo bloco try mais externo. \line Erro comum de programa\'e7\'e3o 13.11 \line\'c9 um erro de l\'f3gica assumir que uma exce\'e7\'e3o disparada a partir de um tratador catch serci processada por aquele tratador ou por qualquer outro tratador associado ao bloco try que disparou a exce\'e7\'e3o que fez com que o tratador catch original fosse executado. \line 13.8 Disparando novamente uma exce\'e7\'e3o \line\'c9 poss\'edvel que o tratador que captura uma exce\'e7\'e3o decida que ele n\'e3o pode processar a exce\'e7\'e3o ou que ele simplesmente queira liberar recursos antes de deixar algum outro trat\'e1-la. Neste caso, o tratador pode simplesmente disparar novamente a exce\'e7\'e3o, com o comando \line throw; \line Tal throw sem argumentos dispara novamente a exce\'e7\'e3o. Se nenhuma exce\'e7\'e3o foi disparada, ent\'e3o o novo disparo provoca uma chamada para terminate. \line Erro comum de programa\'e7\'e3o 13.12 \line Colocar um comando throw vazio fora de um tratador catch; executar tal throw provoca uma chamada para terminate. \line Ainda que um tratador possa processar uma exce\'e7\'e3o, e independentemente de se fazer qualquer processamento sobre aquela exce\'e7\'e3o, o tratador ainda pode disparar novamente a exce\'e7\'e3o para um processamento adicional fora do tratador. \line Uma exce\'e7\'e3o disparada novamente \'e9 detectada pelo pr\'f3ximo bloco try externo e \'e9 tratada por um tratador de \line exce\'e7\'e3o listado depois daquele bloco try externo. \line Observa\'e7\'e3o de engenharia de software 13. 10 \line ______ Use catch ( . . . ) para executar recupera\'e7\'e3o que n\'e3o depende do tipo da exce\'e7\'e3o, tal como liberar recursos comuns. A exce\'e7\'e3o pode ser disparada novamente para alertar blocos catch externos mais \line espec(ficos. \line O programa da Fig. 13.2 demonstra o novo disparo de uma exce\'e7\'e3o. No bloco try de main. a fun\'e7\'e3o throwException \'e9 chamada na linha 31. No bloco try da fun\'e7\'e3o throwException, o comando throw na linha 17 dispara uma inst\'e2ncia da classe exception da biblioteca padr\'e3o (definida no arquivo de cabe\'e7alho <exception>). Esta exce\'e7\'e3o \'e9 imediatamente capturada no tratador catch na linha 19, que imprime uma mensagem de erro e ent\'e3o dispara novamente a exce\'e7\'e3o. Isto termina a fun\'e7\'e3o throwException e retorna o controle para o bloco try/catch em main. A exce\'e7\'e3o \'e9 novamente capturada na linha 34 e \'e9 impressa uma mensagem de erro. \line 1 // Fig. 13.2: figl3O2.cpp \line 2 II Demonstra\'e7\'e3o de se disparar novamente uma exce\'e7\'e3o. \line 3 #include <iostream> \line 4 \line 5 using std: :cout; \line 6 using std: :endl; \line Fig. 13.2 Disparando novamente uma exce\'e7\'e3o (parte 1 de 2). \par
708 c+\'f7 COMO PROGRAMAR \line 7 \line 8 #include <exception> \line 9 \line 10 using std::exception; \line li \line 12 void throwException() \line 13 \line 14 // Dispara urna exce\'e7\'e3o e a captura imediatamente. \line 15 try\{ \line 16 cout \'ab \ldblquote Fun\'e7\'e3o throwException\\n\rquote ; \line 17 throw exceptionO; II gera exce\'e7\'e3o \line 18 \line 19 catch( exception e \line 20 \line 21 cout \'ab \ldblquote Exce\'e7\'e3o tratada na fun\'e7\'e3o throwException\\n\rdblquote ; \line 22 throw; II dispara novamente a exce\'e7\'e3o para processamento adicional \line 23 \line 24 \line 25 cout \'ab \ldblquote Isto tamb\'e9m n\'e3o deve ser impresso\\n\rdblquote ; \line 26 \line 27 \line 28 int main() \line 29 \line 30 try\{ \line 31 throwException \line 32 cout \'ab \ldblquote Isto n\'e3o deve ser impresso\\n\rdblquote ; \line 33 \line 34 catch ( exception e \line 35 \line 36 cout \'ab \ldblquote Exce\'e7\'e3o tratada em main\\n\rdblquote ; \line 37 \line 38 \line 39 cout \'ab \ldblquote Controle do programa continua ap\'f3s captura em main\rdblquote  \line 40 \'ab endl; \line 41 return 0; \line 42 \line Fun\'e7\'e3o throwException \line Exce\'e7\'e3o tratada na fun\'e7\'e3o throwException \line Exce\'e7\'e3o tratada em main \line Controle do programa continua ap\'f3s captura em main \line Fig. 13.2 Disparando novamente uma exce\'e7\'e3o (parte 2 de 2). \line 13.9 Especifica\'e7\'f5es de exce\'e7\'e3o \line Uma especifica\'e7\'e3o de exce\'e7\'e3o enumera uma lista de exce\'e7\'f5es que podem ser disparadas por uma fun\'e7\'e3o. \line int g( double h ) throw ( a, b, c \line II corpo da fun\'e7\'e3o \line\'c9 poss\'edvel se restringir os tipos de exce\'e7\'e3o disparadas por uma fun\'e7\'e3o. Os tipos de exce\'e7\'e3o s\'e3o especificados na declara\'e7\'e3o da fun\'e7\'e3o como uma especifica\'e7\'e3o de exce\'e7\'e3o (tamb\'e9m chamada de lista de throw). A especifica\'e7\'e3o de exce\'e7\'e3o lista as exce\'e7\'f5es que podem ser disparadas. Uma fun\'e7\'e3o pode disparar as exce\'e7\'f5es indicadas ou tipos \par
CAP\'cdTULO 13 - TRATAMENTO DE EXCE\'c7\'d5ES 709 \line derivados. Apesar desta suposta garantia de que outros tipos de exce\'e7\'e3o n\'e3o ser\'e3o disparados, \'e9 poss\'edvel se fazer isso. Se uma exce\'e7\'e3o n\'e3o-listada na especifica\'e7\'e3o de exce\'e7\'e3o \'e9 disparada, a fun\'e7\'e3o unexpected \'e9 chamada. \line Colocar throw ( ) (i.e., uma especifica\'e7\'e3o de exce\'e7\'e3o vazia) depois da lista de par\'e2metros de uma fun\'e7\'e3o \line indica que a fun\'e7\'e3o n\'e3o disparar\'e1 quaisquer exce\'e7\'f5es. Tal fun\'e7\'e3o poderia, de fato, disparar uma exce\'e7\'e3o; isso tamb\'e9m geraria uma chamada \'e0 fun\'e7\'e3o unexpected. \line Erro comum de programa\'e7\'e3o 13.13 \line Disparar uma exce\'e7\'e3o que n\'e3o est\'e1 na especifica\'e7\'e3o de exce\'e7\'f5es de uma fun\'e7\'e3o gera uma chamada para \line unexpected. \line Uma fun\'e7\'e3o sem especifica\'e7\'e3o de exce\'e7\'e3o pode disparar qualquer exce\'e7\'e3o. \line void gO; // esta fun\'e7\'e3o pode disparar qualquer exce\'e7\'e3o \line O significado da fun\'e7\'e3o unexpected pode ser redefinido chamando a fun\'e7\'e3o set_unexpected. \line Um aspecto interessante do tratamento de exce\'e7\'f5es \'e9 que o compilador n\'e3o considerar\'e1 como um erro de \line sintaxe se uma fun\'e7\'e3o contiver uma express\'e3o throw para uma exce\'e7\'e3o n\'e3o-listada na especifica\'e7\'e3o de exce\'e7\'f5es da fun\'e7\'e3o. A fun\'e7\'e3o deve tentar disparar aquela exce\'e7\'e3o, durante a execu\'e7\'e3o, antes de o erro ser capturado. \line Se uma fun\'e7\'e3o dispara uma exce\'e7\'e3o de um tipo de classe particular, aquela fun\'e7\'e3o tamb\'e9m pode disparar \line exce\'e7\'f5es de todas as classes derivadas daquela classe por heran\'e7a public. \line 13.10 Processando exce\'e7\'f5es inesperadas \line A fun\'e7\'e3o unexpected chama a fun\'e7\'e3o especificada pela fun\'e7\'e3o set_unexpected. Se nenhuma fun\'e7\'e3o foi especificada desta maneira, terminate \'e9 chamada por default. \line A fun\'e7\'e3o terminate pode ser explicitamente chamada, se urna exce\'e7\'e3o disparada n\'e3o pode ser capturada, se a pilha foi corrompida durante o tratamento de exce\'e7\'f5es, como a a\'e7\'e3o default para uma chamada \'e0 fun\'e7\'e3o unexpected e se, durante o desempilhamento da pilha iniciada por uma exce\'e7\'e3o, uma tentativa por um destruidor de disparar uma exce\'e7\'e3o faz com que terminate seja chamada. \line A fun\'e7\'e3o set terminate pode especificar a fun\'e7\'e3o que ser\'e1 chamada quando terminate \'e9 chamada. \line Caso contr\'e1rio, terminate chama abort. \line Os prot\'f3tipos para as fun\'e7\'f5es set tertninate e set unexpected est\'e3o localizados no arquivo de \line cabe\'e7alho <exception>. \line A fun\'e7\'e3o set terminate e a fun\'e7\'e3o set unexpected retornam, cada uma, um ponteiro para a \'faltima \line fun\'e7\'e3o chamada por terminate e unexpected. Isso possibilita ao programador salvar o ponteiro da fun\'e7\'e3o, de modo que ele possa ser restabelecido mais tarde. \line As fun\'e7\'f5es set terininate e set unexpected aceitam ponteiros para fun\'e7\'f5es como par\'e2metros. \line Cada par\'e2metro deve apontar para uma fun\'e7\'e3o com tipo de retorno void e sem nenhum argumento. \line Se a \'faltima a\'e7\'e3o de uma fun\'e7\'e3o de t\'e9rmino definida pelo usu\'e1rio n\'e3o for sair de um programa, a fun\'e7\'e3o \line abort ser\'e1 automaticamente chamada para terminar a execu\'e7\'e3o do programa depois que os outros comandos da fun\'e7\'e3o de t\'e9rmino definida pelo usu\'e1rio forem executados. \line 13.11 Desempilhando a pilha \line Quando uma exce\'e7\'e3o \'e9 disparada mas n\'e3o capturada em um escopo particular, a pilha (stack) de chamadas de fun\'e7\'e3o \'e9 desempilhada e \'e9 feita uma tentativa para capturar a exce\'e7\'e3o no pr\'f3ximo bloco try/catch externo. Desempilhar a pilha de chamadas de fun\'e7\'e3o significa que a fun\'e7\'e3o em que a exce\'e7\'e3o n\'e3o foi capturada termina, todas as vari\'e1veis locais naquela fun\'e7\'e3o s\'e3o destru\'eddas e o controle retorna para o ponto em que a fun\'e7\'e3o foi chamada. Se aquele ponto no programa est\'e1 em um bloco try. \'e9 feita uma tentativa para capturar a exce\'e7\'e3o. Se aquele ponto no programa n\'e3o est\'e1 em um bloco try ou a exce\'e7\'e3o n\'e3o \'e9 capturada, o desempilhamento acontece novamente. Como mencionado na se\'e7\'e3o anterior, se a exce\'e7\'e3o n\'e3o \'e9 capturada no programa, a fun\'e7\'e3o terminate \'e9 chamada para terminar o programa. O programa da Fig. 13.3 demonstra o desempilhamento da pilha. \par
710 C++ COMO PROGRAMAR \line 1 II Fig. 13.3: figl3O3.cpp \line 2 // Demonstrando o desempilhamento da pilha. \line 3 #include <iostream> \line 4 \line 5 using std::cout; \line 6 using std::endl; \line 7 \line 8 #include <stdexcept> \line 9 \line 10 using std: :runtime_error; \line 11 \line 12 void function3() throw ( runtimeerror \line 13 \line 14 throw runtimeerror( \ldblquote runtimeerror em function3\rdblquote  ); \line 15 \line 16 \line 17 void function2() throw ( runtimeerror \line 18 \line 19 function3O; \line 20 \line 21 \line 22 void functionl() throw ( runtimeerror \line 23 \line 24 function2O; \line 25 \line 26 \line 27 int main() \line 28 \line 29 try \{ \line 30 functionlO; \line 31 \line 32 catch ( runtimeerror e \line 33 \{ \line 34 cout \'ab \ldblquote Ocorreu exce\'e7\'e3o: \'ab e.what() \'ab endi; \line 35 1 \line 36 \line 37 return 0; \line 38 \} \line Ocorreu exce\'e7\'e3o: runtime_error em function3 \line Fig. 13.3 Demonstra\'e7\'e3o do desempilhamento da pilha. \line Em main, o bloco try na linha 30 chama functionl. Em seguida, functionl (definida na linha 22) chama function2. Ent\'e3o, function2 (definida na linha 17) chama function3. A linha 14 de function3 dispara um objeto exception. Como a linha 14 n\'e3o est\'e1 em um bloco try, acontece o desempilhamento da pilha - a funcao3 termina na linha 19 e o controle retoma para a function2. Como a linha 19 n\'e3o est\'e1 em um bloco try. acontece novamente o desempilhamento da pilha - a function2 termina na linha 24 e o controle retoma para a function. Como a linha 24 n\'e3o est\'e1 em um bloco try, o desempilhamento da pilha acontece mais um vez - a functionl termina na linha 30 e o controle retoma para main. Como a linha 30 est\'e1 em um bloco try, a exce\'e7\'e3o pode ser capturada e processada no primeiro tratador catch correspondente depois do bloco try (na linha 32). \line 13.12 Construtores, destruidores e o tratamento de exce\'e7\'f5es \line Primeiro, vamos tratar de um assunto que mencionamos, mas que ainda tem que ser satisfatoriamente resolvido. O que acontece quando um erro \'e9 descoberto em um construtor? Por exemplo, como um construtor de String \par
CAP\'cdTULO 13 - TRATAMENTO DE EXCE\'c7\'d5ES 711 \line deveria responder quando new falha e indica que foi impossibilitado de obter o espa\'e7o necess\'e1rio para manter a representa\'e7\'e3o interna do String? O problema \'e9 que um construtor n\'e3o pode retornar um valor; assim, como comunicamos ao mundo exterior que o objeto n\'e3o foi corretamente constru\'eddo? Um esquema \'e9 simplesmente retornar o objeto inapropriadamente constru\'eddo e esperar que algu\'e9m que use o objeto fa\'e7a testes apropriados para determinar que o objeto \'e9 de fato ruim. Outro esquema \'e9 inicializar alguma vari\'e1vel fora do construtor. O disparo de uma exce\'e7\'e3o passa para o mundo exterior as informa\'e7\'f5es sobre a falha do construtor e a responsabilidade de trat\'e1-la. \line Para capturar uma exce\'e7\'e3o, o tratador de exce\'e7\'e3o deve ter acesso a um construtor de c\'f3pia para o objeto \line disparado (c\'f3pia default membro a membro tamb\'e9m \'e9 v\'e1lida). \line Exce\'e7\'f5es disparadas em construtores fazem com que destruidores sejam chamados para quaisquer objetos \line constru\'eddos como parte do objeto que est\'e1 sendo constru\'eddo antes de a exce\'e7\'e3o ser disparada. \line Destruidores s\'e3o chamados para todo objeto autom\'e1tico constru\'eddo em um bloco try antes de uma exce\'e7\'e3o ser disparada. Uma exce\'e7\'e3o \'e9 tratada no momento em que o tratador come\'e7a a ser executado; \'e9 garantido que o desempilhamento da pilha foi completado at\'e9 aquele ponto. Se um destruidor invocado como resultado do desempilhamento da pilha dispara uma exce\'e7\'e3o, terminate \'e9 chamada. \line Se um objeto tem objetos membro e se uma exce\'e7\'e3o \'e9 disparada antes de o objeto externo estar completamente constru\'eddo, ent\'e3o destruidores ser\'e3o executados para os objetos membro que foram completamente constru\'eddos antes da ocorr\'eancia da exce\'e7\'e3o. \line Se um array de objetos estava parcialmente constru\'eddo quando ocorreu uma exce\'e7\'e3o, s\'f3 os destruidores para \line os elementos do array constru\'eddos ser\'e3o chamados. \line Uma exce\'e7\'e3o poderia impedir a execu\'e7\'e3o de c\'f3digo que normalmente liberaria um recurso, causando deste \line modo uma perda de recurso. Uma t\'e9cnica para solucionar este problema \'e9 inicializar um objeto local quando o recurso \'e9 adquirido. Quando ocorrer uma exce\'e7\'e3o, o destruidor ser\'e1 invocado e pode liberar o recurso. \line E poss\'edvel se capturar exce\'e7\'f5es disparadas a partir de destruidores incluindo a fun\'e7\'e3o que chama o destruidor \line em um bloco try e fornecendo um tratador catch com o tipo apropriado. O destruidor do objeto disparado \'e9 executado depois que um tratador de exce\'e7\'e3o completa a sua execu\'e7\'e3o. \line 13.13 Exce\'e7\'f5es e heran\'e7a \line V\'e1rias classes de exce\'e7\'e3o podem ser derivadas de uma classe base comum. Se um catch captura um ponteiro ou refer\'eancia para um objeto de exce\'e7\'e3o de um tipo de uma classe base, ele tamb\'e9m captura um ponteiro ou refer\'eancia para todos os objetos de classes derivadas daquela classe base. Isso pode permitir o processamento polim\'f3rfico de erros relacionados. \line\'ae Dica de teste e depura \'e7\'e3o 13.2 \line Usar heran\'e7a com exce\'e7\'f5es possibilita a um tratador de exce\'e7\'e3o capturar erros relacionados com uma nota\'e7\'e3o bastante concisa. Poder\'edamos certamente capturar cada tipo de ponteiro ou refer\'eancia para um objeto de exce\'e7\'e3o de uma classe derivada individualmente, mas \'e9 mais conciso se capturar ponteiros ou refer\'eancias para objetos de exce\'e7\'e3o da classe base. Al\'e9m disso, capturar ponteiros ou refer\'eancias para objetos de exce\'e7\'e3o de classes derivadas individualmente \'e9 sujeito a erros se o programador se esquecer de incluir testes expl\'edcitos para um ou mais dos tipos de ponteiro ou de refer\'eancia para a classe derivada. \line 13.14 Processando falhas de new \line Existem v\'e1rios m\'e9todos de se lidar com falhas de new. At\'e9 este ponto, usamos a macro assert para testar o valor retornado por new. Se aquele valor for O, a macro assert termina o programa. Isto n\'e3o \'e9 um mecanismo robusto para lidar com falhas de new - ele n\'e3o nos permite qualquer forma de se recuperar da falha. O padr\'e3o C++ especifica que, quando new falha, \'e9 disparada uma exce\'e7\'e3o bad alloc (definida no arquivo de cabe\'e7alho <new>). Por\'e9m, alguns compiladores podem n\'e3o estar de acordo com o padr\'e3o C++ e, portanto, usam a vers\'e3o de new que retorna O quando falha. Nesta se\'e7\'e3o, apresentamos tr\'eas exemplos de falhas de new. O primeiro exemplo retorna O quando new falha. O segundo e terceiro exemplos usam a vers\'e3o de new que dispara uma exce\'e7\'e3o badalloc quando new falha. \par
712 C++ COMO PROGRAMAR \par
A Fig. 13.4 demonstra new retornando O quando falha em alocar a quantidade solicitada de mem\'f3ria. A estrutura for na linha 12 deveria executar o la\'e7o 50 vezes e alocar um array de 5.000.000 de valores double (i.e., 40.000.000 bytes, porque um double normalmente ocupa 8 bytes) a cada passagem pelo la\'e7o. A estrutura if na linha 15 testa o resultado de cada opera\'e7\'e3o new. para determinar se a mem\'f3ria foi alocada. Se new falha e retorna 0, a mensagem \ldblquote Aloca\'e7\'e3o de mem\'f3ria falhou\rquote  \'e9 impressa e o la\'e7o termina. \line 1 II Fig. 13.4: figl3_04.cpp \line 2 // Demonstrando new retornando 0 \line 3 II quando a mem\'f3ria n\'e3o \'e9 alocada \line 4 #include <iostream> \line 5 \line 6 using std::cout; \line 7 \line 8 int main() \line 9\{ \line 10 double *ptr[ 50 ]; \line 11 \line 12 for ( int i = 0; i < 50; i++ \line 13 ptr[ i ] = new double[ 5000000 ); \line 14 \line 15 if ( ptr[ i ] == O ) ( // new falhou na aloca\'e7\'e3o de mem\'f3ria \line 16 cout \'ab \ldblquote Aloca\'e7\'e3o de mem\'f3ria falhou para ptr[ \line 17 \'ab i \'ab \ldblquote  \line 18 break; \line 19 \} \line 20 else \line 21 cout \'ab \ldblquote Alocados 5000000 doubles em ptr[ \line 22 \'ab i \'ab \line 23 \} \line 24 \line 25 return 0; \line 26 \} \line Alocados 5000000 doubles em ptr[ O \line Alocados 5000000 douiles em ptr[ 1 \line Alocados 5000000 doubles em ptr[ 2 \line Alocados 5000000 doubles em ptr[ 3 \line Aloca\'e7\'e3o de mem\'f3ria falhou para ptr[ 4 1 \line Fig. 13.4 Demonstrando new retornando O em caso de falha. \line A sa\'edda mostra que s\'f3 quatro repeti\'e7\'f5es do la\'e7o foram executadas antes de new falhar e as repeti\'e7\'f5es do la\'e7o terminarem. Sua sa\'edda pode ser diferente, dependendo da mem\'f3ria f\'edsica, do espa\'e7o em disco dispon\'edvel para mem\'f3ria virtual em seu sistema e do compilador que voc\'ea usar para compilar o programa. \line ___ A Fig. 13.5 demonstra new disparando bad alloc quando ela falhar em alocar a mem\'f3ria solicitada. A estrutura for na linha 18 dentro do bloco try deve executar 50 itera\'e7\'f5es e em cada uma alocar um array de 5.000.000 de valores double (i.e., 40.000.000 bytes, porque um double normalmente \'e9 8 bytes). Se new falha e dispara uma exce\'e7\'e3o bad alloc, o la\'e7o termina e o programa continua no fluxo de controle de tratamento de exce\'e7\'f5es na linha 24, onde a exce\'e7\'e3o \'e9 capturada e processada. A mensagem \ldblquote Ocorreu uma exce\'e7\'e3o:\rdblquote  \'e9 impressa, seguida pelo string (contendo a mensagem espec\'edfica para a exce\'e7\'e3o \ldblquote Falha na aloca\'e7\'e3o\rdblquote ) retornado por exception . what () . A sa\'edda mostra que s\'f3 quatro repeti\'e7\'f5es do la\'e7o foram executadas antes de new falhar e disparar a exce\'e7\'e3o bad alloc. Sua sa\'edda pode ser diferente, dependendo da mem\'f3ria f\'edsica, do \line espa\'e7o em disco dispon\'edvel para mem\'f3ria virtual em seu sistema e do compilador que voc\'ea usar para compilar o programa. \par
\pard\par
\pard\sb100\sa240 CAP\'cdTULO 13 - TRATAMENTO DE EXCE\'c7\'d5ES 713 \line 1 // Fig. 13.5: figl3O5.cpp \line 2 1/ Demonstrando new disparando bad_alloc \line 3 II quando a mem\'f3ria n\'e3o \'e9 alocada \line 4 #include <iostreain> \line 5 \line 6 using std: :cout; \line 7 using std::endl; \line 8 \line 9 #include <new> \line 10 \line 11 using std: :bad_alloc; \line 12 \line 13 int main() \line 14 \{ \line 15 double *ptr[ 50 1; \line 16 \line 17 try\{ \line 18 for ( int i = 0; i < 50; i++ \line 19 ptr[ i ] = new double[ 5000000 ); \line 20 cout \'ab \ldblquote Alocados 5000000 doubles em ptr[ \line 21 \'ab i \'ab \line 22 \} \line 23 ) \line 24 catch ( badalloc exception \line 25 cout \'ab Ocorreu uma exce\'e7\'e3o: \line 26 \'ab exception.what() \'ab endl; \line 27 \} \line 28 \line 29 return 0; \line 30 \} \line Alocados 5000000 doubles em ptr[ O \line Alocados 5000000 doubles em ptr[ 1 \line Alocados 5000000 doubles em ptr[ 2 ] \line Alocados 5000000 doubles em ptr[ 3 \line Ocorreu uma exce\'e7\'e3o: falha na aloca\'e7\'e3o \line Fig. 13.5 Demonstrando new disparando bad_alloc em caso de falha. \line Os compiladores variam em seu suporte ao tratamento de falhas de new. Muitos compiladores de C++ retomam O por default quando new falha. Alguns destes compiladores suportam new disparando uma exce\'e7\'e3o se o arquivo de cabe\'e7alho <new> (ou <new . h>) for inclu\'eddo. Outros compiladores disparam bad alloc por default, n\'e3o importando se voc\'ea inclui ou n\'e3o o arquivo de cabe\'e7alho <new>. Leia a documenta\'e7\'e3o de seu compilador para determinar qual o suporte oferecido por seu compilador para tratamento de falhas de new. \line O padr\'e3o C++ especifica que compiladores aderentes ao padr\'e3o podem ainda usar uma vers\'e3o de new que retoma O quando ele falha. Para este finalidade, o arquivo de cabe\'e7alho <new> define nothrow (do tipo nothrowt), que \'e9 usado como segue: \line double *ptr = new( nothrow ) double[ 5000000 ]; \line O comando precedente indica que a vers\'e3o de new que n\'e3o dispara exce\'e7\'f5es bad alloc (i.e., nothrow) deve ser usada para alocar um array de 5.000.000 de doubles. \line Observa\'e7\'e3o de engenharia de software 13.11 \line ______ O padr\'e3o C+ + recomenda que, para tornar os programas mais robustos, os programadores usem a vers\'e3o de new que dispara exce\'e7\'f5es bad alloc no caso de insucessos de new. \par
714 C++ COMO PROGRAMAR \par
Existe um recurso adicional que pode ser usado para tratamento de falhas de new. A fun\'e7\'e3o setnewharidler (prototipada no arquivo de cabe\'e7alho <new>) aceita como seu par\'e2metro um ponteiro de fun\'e7\'e3o para uma fun\'e7\'e3o que n\'e3o recebe nenhum argumento e retorna void. O ponteiro de fun\'e7\'e3o \'e9 registrado como a fun\'e7\'e3o a chamar quando new falha. Isto fornece ao programador um m\'e9todo uniforme de processar todas as falhas de new. n\'e3o importando onde a falha acontece no programa. Uma vez que um tratador de new \'e9 registrado no programa com set new handier. new n\'e3o disparar\'e1 bad alloc quando fracassar. \line O operador new \'e9 na realidade um la\'e7o que tenta adquirir mem\'f3ria. Se a mem\'f3ria \'e9 alocada, new retorna um ponteiro para aquela mem\'f3ria. Se new falha em alocar mem\'f3ria e nenhuma fun\'e7\'e3o tratadora de new foi registrada com set new handier, new dispara uma exce\'e7\'e3o bad alloc. Se new falha na aloca\'e7\'e3o de mem\'f3ria e uma fun\'e7\'e3o tratadora de new foi registrada, a fun\'e7\'e3o tratadora de new \'e9 chamada. O padr\'e3o C++ especifica que a fun\'e7\'e3o tratadora de new deveria executar uma das tarefas seguintes: \line 1. Tornar dispon\'edvel mais mem\'f3ria, apagando outra mem\'f3ria dinamicamente alocada, e retornar ao la\'e7o no operador new para tentar alocar a mem\'f3ria novamente. \line 2. Disparar uma exce\'e7\'e3o do tipo badalloc. \line 3. Chamar a fun\'e7\'e3o abort ou exit (ambas do arquivo de cabe\'e7alho <csdtlib>), para terminar o programa. \line O programa da Fig. 13.6 demonstra set new handier. A fun\'e7\'e3o customNewHandler simplesmente imprime uma mensagem de erro e termina o programa com uma chamada para abort. A sa\'edda mostra que s\'f3 tr\'eas repeti\'e7\'f5es do la\'e7o foram executadas antes de new ter falhado e disparado a exce\'e7\'e3o bad alloc. Sua sa\'edda pode ser diferente, dependendo da mem\'f3ria f\'edsica, do espa\'e7o em disco dispon\'edvel para mem\'f3ria virtual em seu sistema e do compilador que voc\'ea usar para compilar o programa. \line 1 II Fig. 13.6: figl3O6.cpp \line 2 // Demonstrando setnewhandler \line 3 #include <iostream> \line 4 \line 5 using std: :cout; \line 6 using std: :cerr; \line 7 \line 8 #include <new> \line 9 #include <cstdlib> \line 10 \line 11 using std: :set_new_handler; \line 12 \line 13 void custoznNewHandler() \line 14 \line 15 cerr \'ab \lquote customNewHandler foi chamada; \line 16 abortO; \line 17 \line 18 \line 19 int main() \line 20\{ \line 21 double *ptr[ 50 ]; \line 22 setnewhandler( customNewHandler ); \line 23 \line 24 for O int i = o; i < 50; i++ \line 25 ptr[ i ] = new double[ 5000000 ]; \line 26 \line 27 cout \'ab \lquote Alocados 5000000 doubles em ptr[ \line 28 \'ab i \'ab \line 29 \} \line 30 \line 31 return 0; \line 32 \} \par
Fig. 13.6 Demonstrando set new handier (parte 1 de 2). \par
Alocados 5000000 doubles em ptr[ O \line Alocados 5000000 doubles em ptr[ 1 \line Alocados 5000000 doubles em ptr[ 2 \line Alocados 5000000 doubles em ptr[ 3 1 \line customNewHandler foi chamada \par
CAP\'cdTULO 13 - TRATAMENTO DE EXCE\'c7\'d5ES 715 \par
Fig. 13.6 Demonstrando set newhandler (parte 2 de 2). \par
13.15 A classe auto_ptr e a aloca\'e7\'e3o din\'e2mica de mem\'f3ria \par
Uma pr\'e1tica comum de programa\'e7\'e3o \'e9 alocar mem\'f3ria din\'e2mica (possivelmente um objeto) na mem\'f3ria livre, atribuir o endere\'e7o daquela mem\'f3ria a um ponteiro, usar o ponteiro para manipular a mem\'f3ria e desalocar a mem\'f3ria com delete quando a mem\'f3ria n\'e3o for mais necess\'e1ria. Se uma exce\'e7\'e3o acontece depois de a mem\'f3ria ter sido alocada e antes de o comando delete ser executado, pode ocorrer uma perda de mem\'f3ria. O padr\'e3o C++ fornece o gabarito de classe autoytr no arquivo de cabe\'e7alho <memory> para lidar com esta situa\'e7\'e3o. \line Um objeto da classe auto_ptr mant\'e9m um ponteiro para mem\'f3ria dinamicamente alocada. Quando um objeto autoytr sai do escopo, ele executa a opera\'e7\'e3o delete sobre seu membro de dados ponteiro. O gabarito de classe autoytr fornece operadores * e -> de modo que um objeto auto_ptr possa ser usado como uma vari\'e1vel ponteiro regular. A Fig. 13.7 demonstra um objeto autoytr que aponta para um objeto da classe Integer (definida nas linhas 12 a 22). \par
1 II Fig. 13.7: figl3O7.cpp \line 2 II Demonstrando autoytr \line 3 #include <iostream> \par
4 \par
5 using std: :cout; \line 6 using std: :endl; \par
7 \par
8 #include <memory> \par
9 \par
using std: :auto_ptr; \par
class Integer \{ \line public: \line Integer( int i = O ) : value( i \line cout \'ab \ldblquote Construtor para Integer \ldblquote  \'ab value \'ab endl; \line -Integer O \line cout \'ab \ldblquote Destruidor \line void setlnteger( int i \line int getlnteger() const \line private: \line int value; \par
cout \'ab \ldblquote Criando um objeto autoytr que \line\'ab \ldblquote aponta para um Integer\\n\rdblquote ; \par
autoytr< Integer > ptrTolnteger( new Integer( 7 ) ); \par
cout \'ab \ldblquote Usando o auto2tr para manipular o Integer\\n\rdblquote ; \line ptrTolnteger->setlnteger( 99 ); \par
10 \line 11 \line 12 \line 13 \line 14 \line 15 \line 16 \line 17 \line 18 \line 19 \line 20 \line 21 \line 22 \line 23 \line 24 \line 25 \line 26 \line 27 \line 28 \line 29 \line 30 \line 31 \line 32 \par
para Integer \ldblquote  \'ab value \'ab endl; value = i; \line return value; \par
int main() \par
Fig. 13.7 Demonstrando autoytr (parte 1 de 2). \par
716 C++ COMO PROGRAMAR \line 33 cout \'ab \lquote Integer depois de setlnteger: \line j 34 \'ab ( *ptrTolnteger ) .getlnteger() \line 35 \'ab \ldblquote\\nTerminando o programa\rdblquote  \'ab endl; \line 36 \line 37 return O; \line 38 \} \line Criando um objeto autoytr que aponta para um Integer \line Construtor para Integer 7 \line Usando o autoytr para manipular o Integer \line Integer depois de setlnteger: 99 \line Terminando o programa \line Destruidor para Integer 99 \line Fig. 13.7 Demonstrando auto_ptr (parte 2 de 2). \line Alinha 29 \line autoytr< Integer > ptrTolnteger( new Integer( 7 ) ); \line cria o objeto auto-ptr ptrTolnteger e inicializa-o com um ponteiro para um objeto Integer dinamicamente alocado contendo o valor 7. \line A linha 32 \line ptrTolnteger->setlnteger( 99 ); \line usa o operador -> sobrecarregado de auto_ptr e o operador chamada de fun\'e7\'e3o ( ) para chamar a fun\'e7\'e3o setlnteger sobre o objeto Integer apontado por ptrTolnteger. \line A chamada \line (*ptrTolnteger ) .getlnteger() \line na linha 34 usa o operador * de autoytr sobrecarregado para derreferenciar ptrTolnteger e ent\'e3o usa o : operador ponto (.) e o operador chamada de fun\'e7\'e3o ( ) para chamar a fun\'e7\'e3o getlnteger sobre o objeto \line Integer apontado por ptrTolnteger. \line Como ptrTolnteger \'e9 uma vari\'e1vel autom\'e1tica local em main, ptrTolnteger \'e9 destru\'eddo quando main termina. Isto for\'e7a um delete do objeto Integer apontado por ptrTolnteger que, \'e9 claro, for\'e7a uma chamada para o destruidor da classe Integer. Por\'e9m, mais importante, esta t\'e9cnica pode prevenir perdas de mem\'f3ria. \line 13.16 Hierarquia de exce\'e7\'f5es da biblioteca padr\'e3o \line A experi\'eancia mostrou que exce\'e7\'f5es se enquadram bem em v\'e1rias categorias. O padr\'e3o C++ inclui uma hierarquia \line de classes de exce\'e7\'e3o. Essa hierarquia \'e9 encabe\'e7ada pela classe base exception (definida no arquivo de cabe\'e7a lh <exception>) que cont\'e9m a fun\'e7\'e3o what () que \'e9 sobrescrita em cada classe derivada, para emitir uma \line mensagem de erro apropriada. \line Da classe base exception. algumas das classes derivadas imediatas s\'e3o runtime error e logicerror \line (ambas definidas no cabe\'e7alho <stdexcept>). cada uma com v\'e1rias classes derivadas. \line Tamb\'e9m derivada de exception s\'e3o as exce\'e7\'f5es disparadas por recursos da linguagem C++ - por exem plo bad alloc \'e9 disparada por new (Se\'e7\'e3o 13.14), badcast \'e9 disparada por dynamiccast (Cap\'edtulo \line 21) e bad typeid \'e9 disparada por typeid (Cap\'edtulo 21). Incluindo std: :bad exception na lista de r \line throw de uma fun\'e7\'e3o, se uma exce\'e7\'e3o inesperada acontece, unexpected ( ) disparar\'e1 bad_exception em \line vez de terminar (por default) ou em vez de chamar outra fun\'e7\'e3o especificada com set_unexpected. \line A classe logic error \'e9 a classe base de v\'e1rias classes de exce\'e7\'e3o padr\'e3o que indicam erros de l\'f3gica em \line programas que podem freq\'fcentemente ser evitados escrevendo-se c\'f3digo apropriado. As descri\'e7\'f5es de algumas \line destas classes aparecem a seguir. A classe invalid argument indica que um par\'e2metro inv\'e1lido foi passado \par
CAP\'cdTULO 13 - TRATAMENTO DE EXCE\'c7\'d5ES 717 \line para uma fun\'e7\'e3o (codifica\'e7\'e3o apropriada pode, \'e9 claro, evitar que par\'e2metros inv\'e1lidos cheguem a uma fun\'e7\'e3o). A classe length error indica que um comprimento maior que o tamanho m\'e1ximo permitido para o objeto que est\'e1 sendo tratado foi usado para aquele objeto (disparamos length errors no Cap\'edtulo 19 quando lidamos com strings). A classe out of range indica que um valor tal como um subscrito para um array ou string ca\'edram fora do intervalo v\'e1lido. \line A classe runtime error \'e9 a classe base de v\'e1rias outras classes de exce\'e7\'e3o padr\'e3o que indicam erros em um programa que s\'f3 podem ser descobertos durante a execu\'e7\'e3o. A classe overflow error indica que ocorreu um erro de ovetfiow em uma opera\'e7\'e3o aritm\'e9tica. A classe underflow error indica que aconteceu um erro de underflow em uma opera\'e7\'e3o aritm\'e9tica. \line Observa\'e7\'e3o de engenharia de software 13.12 \line ______ A hierarquia padr\'e3o de exception se destina a servir como um ponto de partida. Os usu\'e1 rios podem disparar exce\'e7\'f5es padr\'e3o, disparar exce\'e7\'f5es derivadas das exce\'e7\'f5es padr\'e3o ou disparar suas pr\'f3prias \line exce\'e7\'f5es n\'e3o-derivadas das exce\'e7\'f5es padr\'e3o. \line Erro comum de programa\'e7\'e3o 13.14 \line Classes de exce\'e7\'e3o definidas pelo usu\'e1rio n\'e3o precisam ser derivadas da classe exception. Assim, n\'e3o \'e9 garantido que escrever catch ( exception e ) capture todas as exce\'e7\'f5es que um programa pode encontrar \line\'ae Dica de teste e depura \'e7\'e3o 13.3 \line Para capturar todas as exce\'e7\'f5es que podem ser disparadas em um bloco try, use catch (. . \line Resumo \line\bullet  Alguns exemplos comuns de exce\'e7\'f5es s\'e3o: subscritos fora do intervalo v\'e1lido em arrays, overfiow em opera\'e7\'f5es aritm\'e9ticas, divis\'e3o por zero, par\'e2metros de fun\'e7\'e3o inv\'e1lidos e verifica\'e7\'e3o de mem\'f3ria insuficiente para atender a um pedido de aloca\'e7\'e3o por new. \line\bullet  O esp\'edrito por tr\'e1s do tratamento de exce\'e7\'f5es \'e9 possibilitar aos programas capturar e tratar erros, em vez de deix\'e1-los acontecer e simplesmente sofrer as conseq\'fc\'eancias. Com o tratamento de exce\'e7\'f5es, se o programador n\'e3o fornece um meio de tratamento para um erro fatal, o programa terminar\'e1; erros n\'e3o-fatais permitem normalmente a um programa continuar a execu\'e7\'e3o, mas produzindo resultados incorretos. \line\bullet  O tratamento de exce\'e7\'f5es foi projetado para lidar com erros s\'edncronos, i.e., erros que acontecem como resultado da execu\'e7\'e3o de um programa. \line\bullet  O tratamento de exce\'e7\'f5es n\'e3o foi projetado para tratar de situa\'e7\'f5es ass\'edncronas, tais como chegadas de mensagens pela rede, conclus\'f5es de EIS de disco, diques do mouse, etc.: estas s\'e3o mais bem manipuladas atrav\'e9s de outros meios. tal como o processamento de interrup\'e7\'f5es. \line\bullet  O tratamento de exce\'e7\'f5es \'e9 tipicamente usado em situa\'e7\'f5es em que o erro ser\'e1 tratado por uma parte diferente do programa (i.e., um escopo diferente) daquela que descobriu o erro. \line\bullet  As exce\'e7\'f5es n\'e3o devem ser usadas como mecanismo para especificar o fluxo de controle. O fluxo de controle com estruturas de controle convencionais \'e9 geralmente mais claro e eficiente do que com exce\'e7\'f5es. \line\bullet  O tratamento de exce\'e7\'f5es deve ser usado para processar exce\'e7\'f5es de componentes do programa que n\'e3o est\'e3o preparados para tratar diretamente aquelas exce\'e7\'f5es. \line\bullet  O tratamento de exce\'e7\'f5es deve ser usado para processar exce\'e7\'f5es de componentes de software tais como fun\'e7\'f5es, bibliotecas e classes que provavelmente ser\'e3o amplamente usados e onde n\'e3o faz sentido para aqueles componentes tratar suas pr\'f3prias exce\'e7\'f5es. \line\bullet  O tratamento de exce\'e7\'f5es deveria ser usado em grandes projetos para tratar o processamento de erros de uma maneira uniforme para o projeto inteiro. \line\bullet  O tratamento de exce\'e7\'f5es em C++ \'e9 voltado para situa\'e7\'f5es em que a fun\'e7\'e3o que descobre um erro est\'e1 impossibilitada de trat\'e1-lo. Tal fun\'e7\'e3o disparar\'e1 uma exce\'e7\'e3o. Se a exce\'e7\'e3o corresponde ao tipo do par\'e2metro em um dos blocos catch. o \par
c\'f3digo para aquele bloco catch \'e9 executado. Caso contr\'e1rio, \'e9 chamada a fun\'e7\'e3o terminate que, por default, chama a fun\'e7\'e3o abort. \line\bullet  O programador inclui em um bloco try o c\'f3digo que pode gerar um erro que produzir\'e1 uma exce\'e7\'e3o. O bloco try \'e9 imediatamente seguido por um ou mais blocos catch. Cada bloco catch especifica o tipo de exce\'e7\'e3o que ele pode capturar e tratar. Cada bloco catch cont\'e9m um tratador de exce\'e7\'e3o. \line\bullet  Quando uma exce\'e7\'e3o \'e9 disparada, o controle do programa deixa o bloco try e procura os blocos catch em busca de um tratador apropriado. Se nenhuma exce\'e7\'e3o \'e9 disparada em um bloco try, os tratadores de exce\'e7\'e3o para aquele bloco s\'e3o saltados e o programa retoma a execu\'e7\'e3o depois do \'faltimo bloco catch. \line\bullet  Exce\'e7\'f5es s\'e3o disparadas em um bloco try em uma fun\'e7\'e3o ou de uma fun\'e7\'e3o chamada direta ou indiretamente a partir do \line\bullet  Uma vez que uma exce\'e7\'e3o \'e9 disparada, o controle n\'e3o pode retornar diretamente ao ponto de disparo. \line\bullet  \'c9 poss\'edvel se passar informa\'e7\'f5es para o tratador de exce\'e7\'e3o a partir do ponto em que ocorreu a exce\'e7\'e3o. Essas informa\'e7\'f5es s\'e3o o tipo de objeto disparado ou informa\'e7\'f5es colocadas no objeto disparado. \line\bullet  Um tipo de exce\'e7\'e3o popular disparada \'e9 char*. \'c9 comum simplesmente se incluir uma mensagem de erro como o operando de throw. \line\bullet  As exce\'e7\'f5es disparadas por uma fun\'e7\'e3o particular podem ser especificadas com uma especifica\'e7\'e3o de exce\'e7\'e3o. Uma especifica\'e7\'e3o de exce\'e7\'e3o vazia afirma que a fun\'e7\'e3o n\'e3o disparar\'e1 quaisquer exce\'e7\'f5es. \line\bullet  As exce\'e7\'f5es s\'e3o capturadas pelo tratador de exce\'e7\'e3o mais pr\'f3ximo (para o bloco try do qual a exce\'e7\'e3o foi disparada) especificando-se um tipo apropriado. \line\bullet  Como parte do disparo de uma exce\'e7\'e3o, uma c\'f3pia tempor\'e1ria do operando do throw \'e9 criada e inicializada. Este objeto tempor\'e1rio ent\'e3o inicializa a vari\'e1vel apropriada no tratador de exce\'e7\'e3o. O objeto tempor\'e1rio \'e9 destru\'eddo quando se sai do tratador de exce\'e7\'e3o. \line\bullet  Erros n\'e3o s\'e3o sempre verificados explicitamente. Um bloco try. por exemplo, pode parecer n\'e3o conter nenhuma verifica\'e7\'e3o de erro e n\'e3o incluir nenhum comando throw. Mas o c\'f3digo referenciado no bloco try pode certamente fazer com que c\'f3digo de verifica\'e7\'e3o de erro seja executado eliminar espa\'e7o. \line\bullet  Uma exce\'e7\'e3o termina o bloco no qual a exce\'e7\'e3o aconteceu. \line\bullet  Os tratadores de exce\'e7\'e3o est\'e3o contidos em blocos catch. Cada bloco catch come\'e7a com a palavra-chave catch seguida por par\'eanteses contendo um tipo e um nome de par\'e2metro opcional. Isto \'e9 seguido por chaves delimitando o c\'f3digo de \line tratamento de exce\'e7\'e3o. Quando uma exce\'e7\'e3o \'e9 capturada, o c\'f3digo no bloco catch \'e9 executado. O tratador catch define seu pr\'f3prio escopo. \line\bullet  O par\'e2metro em um tratador catch pode ter um nome ou n\'e3o. Se o par\'e2metro tem um nome, o par\'e2metro pode ser referenciado n tratador. Se o par\'e2metro n\'e3o tem nome, i.e., se somente um tipo \'e9 listado com a finalidade de procurar uma correspond\'eancia com o tipo de objeto disparado ou retic\'eancias para todos os tipos, ent\'e3o o tratador ignorar\'e1 o objeto disparado. O tratador \line pode disparar novamente o objeto para um bloco try externo. \line\bullet  \'c9 poss\'edvel se especificar um comportamento personalizado para substituir a fun\'e7\'e3o terininate. designando-se outra fun\'e7\'e3o a ser executada e fornecendo-se aquele nome de fun\'e7\'e3o como o par\'e2metro em uma chamada da fun\'e7\'e3o setterininate. \line\bullet  catch ( ) significa capturar todas as exce\'e7\'f5es. \line\bullet  \'c9 poss\'edvel que nenhum tratador tenha uma correspond\'eancia com um objeto disparado particular. Isso faz com que a procura por uma correspond\'eancia continue em um bloco try externo. \line\bullet  Os tratadores de exce\'e7\'e3o s\'e3o pesquisados na ordem para encontrar uma correspond\'eancia apropriada. O primeiro tratador que tem uma correspond\'eancia \'e9 executado. Quando aquele tratador termina a execu\'e7\'e3o, o controle continua com o primeiro comando depois do \'faltimo bloco catch. \line\bullet  A ordem dos tratadores de exce\'e7\'e3o afeta a maneira como uma exce\'e7\'e3o \'e9 tratada. \line\bullet  Um objeto de uma classe derivada pode ser capturado ou por um tratador especificando o tipo da classe derivada ou por tratadores especificando os tipos de quaisquer classes base daquela classe derivada. \line\bullet  \'c0s vezes, um programa pode processar muitos tipos intimamente relacionados de exce\'e7\'f5es. Em vez de fornecer classes de exce\'e7\'e3o separadas e tratadores catch para cada uma, um programador pode fornecer uma classe de exce\'e7\'e3o \'fanica e um \par
718 C++ COMO PROGRAMAR \par
bloco try. \par
CAP\'cdTULO 13 - TRATAMENTO DE EXCE\'c7\'d5ES 719 \line tratador catch para um grupo de exce\'e7\'f5es. \'c0 medida que ocorre cada exce\'e7\'e3o, o objeto de exce\'e7\'e3o pode ser criado com dados private diferentes. O tratador catch pode examinar estes dados private para identificar o tipo da exce\'e7\'e3o. \line\bullet  \'c9 poss\'edvel que, muito embora esteja dispon\'edvel uma correspond\'eancia precisa, uma correspond\'eancia exigindo convers\'f5es padr\'f5es ser\'e1 feita porque aquele tratador aparece antes daquele que resultaria em uma correspond\'eancia precisa. \line\bullet  Por default, se nenhum tratador for encontrado para uma exce\'e7\'e3o, o programa termina. \line\bullet  Um tratador de exce\'e7\'e3o n\'e3o pode acessar diretamente vari\'e1veis no escopo de seu bloco try. As informa\'e7\'f5es de que o tratador necessita s\'e3o normalmente passadas no objeto disparado. \line\bullet  Os tratadores de exce\'e7\'e3o podem examinar mais de perto um erro e decidir chamar terminate. Podem disparar novamente uma exce\'e7\'e3o. Podem converter um tipo de exce\'e7\'e3o para outro disparando uma exce\'e7\'e3o diferente. Podem executar qualquer recupera\'e7\'e3o necess\'e1ria e retomar a execu\'e7\'e3o depois do \'faltimo tratador de exce\'e7\'e3o. Podem examinar a situa\'e7\'e3o que est\'e1 causando o erro, remover a causa do erro e tentar chamar novamente a fun\'e7\'e3o original que causou uma exce\'e7\'e3o (isto n\'e3o cria uma recurs\'e3o infinita). Podem simplesmente retomar algum valor de estado para seu ambiente, etc. \line\bullet  Um tratador que captura um objeto de uma classe derivada deveria ser colocado antes de um tratador que captura um objeto da classe base. Se o tratador da classe base fosse colocado primeiro, capturaria tanto os objetos da classe base como os objetos de classes derivadas daquela classe base. \line\bullet  Quando uma exce\'e7\'e3o \'e9 capturada, \'e9 poss\'edvel que recursos possam ter sido alocados, mas ainda n\'e3o liberados no bloco try. O tratador catch deveria liberar estes recursos. \line\bullet  \'c9 poss\'edvel que um tratador catch possa decidir que ele n\'e3o pode processar a exce\'e7\'e3o. Neste caso, o tratador pode simplesmente disparar novamente a exce\'e7\'e3o. Um throw sem par\'e2metros dispara novamente a exce\'e7\'e3o. Se nenhuma exce\'e7\'e3o foi disparada, ent\'e3o o novo disparo produz uma chamada para terminate. \line\bullet  Ainda que um tratador possa processar uma exce\'e7\'e3o, e n\'e3o importando se ele faz qualquer processamento daquela exce\'e7\'e3o, o tratador pode disparar novamente a exce\'e7\'e3o para processamento adicional fora do tratador. Uma exce\'e7\'e3o disparada novamente \'e9 detectada pelo pr\'f3ximo bloco try externo e \'e9 tratada por um tratador de exce\'e7\'e3o listado depois daquele bloco try externo. \line\bullet  Uma fun\'e7\'e3o sem especifica\'e7\'e3o de exce\'e7\'e3o pode disparar qualquer exce\'e7\'e3o. \line\bullet  A fun\'e7\'e3o unexpected chama uma fun\'e7\'e3o especificada com a fun\'e7\'e3o set unexpected. Se nenhuma fun\'e7\'e3o foi especificada desta maneira, terminate \'e9 chamada por default. \line\bullet  A fun\'e7\'e3o terminate pode ser chamada de v\'e1rios modos: explicitamente; se uma exce\'e7\'e3o disparada n\'e3o pode ser capturada; se a pilha de chamadas de fun\'e7\'f5es foi corrompido durante o tratamento de exce\'e7\'f5es; como a a\'e7\'e3o defauit em uma chamada para unexpected; ou, se durante o desempilhamento da pilha iniciada por uma exce\'e7\'e3o, uma tentativa de disparar uma exce\'e7\'e3o feita por um destruidor faz com que terminate seja chamada. \line\bullet  Os prot\'f3tipos para as fun\'e7\'f5es set terminate e set unexpected s\'e3o encontrados no arquivo de cabe\'e7alho <exception>. \line\bullet  As fun\'e7\'f5es set terminate e set_unexpected retornam ponteiros para a \'faltima fun\'e7\'e3o chamada por terminate e unexpected. isto possibilita ao programador salvar o ponteiro da fun\'e7\'e3o de modo que ele possa ser restaurado mais tarde. \line\bullet  As fun\'e7\'f5es setterminate e set unexpected aceitam ponteiros para fun\'e7\'f5es como argumentos. Cada par\'e2metro deve apontar para uma fun\'e7\'e3o com tipo de retorno void e nenhum argumento. \line Se a \'faltima a\'e7\'e3o de uma fun\'e7\'e3o de t\'e9rmino definida pelo usu\'e1rio n\'e3o \'e9 sair de um programa, a fun\'e7\'e3o abort ser\'e1 automaticamente chamada para terminar a execu\'e7\'e3o do programa depois de os outros comandos da fun\'e7\'e3o de t\'e9rmino definida pelo usu\'e1rio terem sido executados. \line\bullet  Uma exce\'e7\'e3o disparada fora de um bloco try far\'e1 com que o programa termine. \line\bullet  Se um tratador n\'e3o pode ser encontrado depois de um bloco try. o desempilhamento da pilha continua at\'e9 um tratador apropriado ser encontrado. Se, em \'faltima inst\'e2ncia, um tratador n\'e3o \'e9 encontrado, ent\'e3o \'e9 chamada terminate. o que, por default, aborta o programa com abort. \line\bullet  Especifica\'e7\'f5es de exce\'e7\'e3o listam as exce\'e7\'f5es que podem ser disparadas a partir de uma fun\'e7\'e3o. Uma fun\'e7\'e3o pode disparar as exce\'e7\'f5es indicadas ou pode disparar tipos derivados. Se uma exce\'e7\'e3o n\'e3o-listada na especifica\'e7\'e3o de exce\'e7\'e3o \'e9 disparada, unexpected \'e9 chamada. \line\bullet  Se uma fun\'e7\'e3o dispara uma exce\'e7\'e3o de um tipo de classe particular, aquela fun\'e7\'e3o tamb\'e9m pode disparar exce\'e7\'f5es de todas as classes derivadas daquela classe por heran\'e7a public. \par
720 C++ COMO PROGRAMAR \par
\bullet  Para capturaI uma exce\'e7\'e3o, o tratador de exce\'e7\'e3o deve ter acesso a um construtor de c\'f3pia para o objeto disparado. \line\bullet  As exce\'e7\'f5es disparadas a partir de construtores fazem com que sejam chamados destruidores para todos os objetos de classes base completados e os objetos membros do objeto que estava sendo constru\'eddo antes de a exce\'e7\'e3o ter sido disparada. \line\bullet  Se um array de objetos havia sido parcialmente constru\'eddo quando ocorreu uma exce\'e7\'e3o, s\'f3 os destruidores para os elementos completamente constru\'eddos do array ser\'e3o chamados. \line\bullet  As exce\'e7\'f5es disparadas a partir de destruidores podem ser capturadas incluindo-se a fun\'e7\'e3o que chama o destruidor em um bloco try e fornecendo-se um tratador catch com o tipo apropriado. \line\bullet  Uma raz\'e3o poderosa para usar heran\'e7a com exce\'e7\'f5es \'e9 criar a possibilidade de capturar facilmente uma variedade de erros relacionados, com uma nota\'e7\'e3o concisa. Poder\'edamos certamente capturar cada tipo de objeto de exce\'e7\'e3o de uma classe \line derivada individualmente, mas, se todas as exce\'e7\'f5es derivadas s\'e3o tratadas da mesma forma, \'e9 muito mais conciso simplesmente se capturar o objeto de exce\'e7\'e3o da classe base. \line\bullet  O padr\'e3o C++ especifica que, quando new falha, ela dispara uma exce\'e7\'e3o bad alloc (bad alloc \'e9 definido no arquivo de cabe\'e7alho <new>). \line\bullet  Alguns compiladores n\'e3o est\'e3o atualizados de acordo com o padr\'e3o C++ e ainda usam a vers\'e3o de new que retorna O quando falha. \line\bullet  A fun\'e7\'e3o set new handier (prototipada no arquivo de cabe\'e7alho <new>) aceita como seu argumento um ponteiro de fun\'e7\'e3o para uma fun\'e7\'e3o que n\'e3o aceita nenhum argumento e retorna void. O ponteiro de fun\'e7\'e3o \'e9 registrado como a fun\'e7\'e3o \line a ser chamada quando new falha. Uma vez que um tratador de new \'e9 registrado com set_riew_haridler, new n\'e3o disparar\'e1 bad alba quando ocorrer uma falha. \line\bullet  Um objeto da classe autoytr mant\'e9m um ponteiro para mem\'f3ria alocada dinamicamente. Quando um objeto autoytr sai do escopo, ele executa automaticamente uma opera\'e7\'e3o delete sobre seu membro de dados ponteiro. O gabarito de \line classe autoytr fornece operadores * e -> de modo que um objeto auto_ptr pode ser usado como uma vari\'e1vel ponteiro regular. \line\bullet  O padr\'e3o C++ inclui uma hierarquia de classes de exce\'e7\'e3o encabe\'e7adas pela classe base exception (definida no arquivo cabe\'e7alho <exception>), que oferece o servi\'e7o what () que \'e9 redefinido em cada classe derivada para emitir uma mensagem de erro apropriada. \line\bullet  Incluindo-se std: badexception na lista de throw de uma defini\'e7\'e3o de fun\'e7\'e3o, se uma exce\'e7\'e3o inesperada ocorrer, unexpected () disparar\'e1 bad exception em vez de terminar (por default) ou em vez de chamar outra fun\'e7\'e3o especificada com set_unexpected. \line Terminologia \line abort O disparar express\'e3o \line aplicativo para miss\'f5es cr\'edticas disparar novamente uma exce\'e7\'e3o \line argumento de catch disparar uma exce\'e7\'e3o \line arquivo de cabe\'e7alho <exception> disparar uma exce\'e7\'e3o inesperada \line arquivo de cabe\'e7alho <memory> dynamic_cast \line arquivo de cabe\'e7alho <new> especifica\'e7\'e3o de exce\'e7\'e3o \line arquivo de cabe\'e7alho <stdexcept> especifica\'e7\'e3o de exce\'e7\'e3o vazia \line autoptr especifica\'e7\'e3o de throw vazia \line bad_alloc exce\'e7\'e3o \line badcast exce\'e7\'e3o n\'e3o-capturada \line badtypeid exit() \line bloco catch fun\'e7\'e3o sem especifica\'e7\'e3o de exce\'e7\'e3o \line bloco try invalid_argument \line bloco try externo lengtherror \line capturar um grupo de exce\'e7\'f5es lista de disparo \line capturar uma exce\'e7\'e3o lista de exce\'e7\'f5es \line catch(...) bogicerror \line catch(void *) macroassert \line condi\'e7\'e3o excepcional new_handler \line declara\'e7\'e3o de exce\'e7\'e3o nothrow \line desempilhamento da pilha objeto de exce\'e7\'e3o \par
722 C++ COMO PROGRAMAR \line Dicas de desempenho \line 13.1 Embora seja poss\'edvel se usar o tratamento de exce\'e7\'f5es para prop\'f3sitos diferentes do tratamento de erros, isso pode reduzir o desempenho do programa. \line 13.2 O tratamento de exce\'e7\'f5es \'e9 geralmente implementado em compiladores de tal maneira que quando n\'e3o ocorrem exce\'e7\'f5es, pouco ou nenhum os\rquote erhead \'e9 imposto pela presen\'e7a do c\'f3digo de tratamento de exce\'e7\'f5es. Quando ocorrem exce\'e7\'f5es, elas incorrem em overhead durante a execu\'e7\'e3o. Certamente, a presen\'e7a de c\'f3digo de tratamento de exce\'e7\'f5es faz o programa consumir mais mem\'f3ria. \line Observa\'e7\'f5es de engenharia de software \line 13.1 O fluxo de controle com estruturas de controle convencionais \'e9 geralmente mais claro e eficiente do que com exce\'e7\'f5es. \line 13.2 O tratamento de exce\'e7\'f5es \'e9 bem adequado para sistemas com componentes desenvolvidos separadamente. O tratamento de exce\'e7\'f5es facilita a combina\'e7\'e3o dos componentes. Cada componente pode executar sua pr\'f3pria detec\'e7\'e3o de exce\'e7\'e3o, \line separada do tratamento das exce\'e7\'f5es em outro escopo. \line 13.3 Ao lidar com bibliotecas, o chamador da fun\'e7\'e3o de biblioteca provavelmente ter\'e1 em mente um processamento de erro espec\'edfico para uma exce\'e7\'e3o gerada na fun\'e7\'e3o de biblioteca. E improv\'e1vel que uma fun\'e7\'e3o de biblioteca execute um processamento de erro que satisfa\'e7a \'e0s necessidades particulares de todos os usu\'e1rios. Portanto, exce\'e7\'f5es s\'e3o meios apropriados para tratar erros produzidos por fun\'e7\'f5es de bibliotecas. \line 13.4 Uma id\'e9ia-chave do tratamento de exce\'e7\'f5es \'e9 que a parte de um programa ou sistema que tratar\'e1 a exce\'e7\'e3o pode ser bastante diferente ou distante da parte do programa que descobriu e gerou a situa\'e7\'e3o excepcional. \line 13.5 Se \'e9 necess\'e1rio passar informa\'e7\'f5es sobre o erro que causou uma exce\'e7\'e3o, tal informa\'e7\'e3o pode ser colocada no objeto disparado. O tratador catch ent\'e3o vai conter um nome de par\'e2metro atrav\'e9s do qual as informa\'e7\'f5es podem ser \line referenciadas. \line 13.6 Um objeto pode ser disparado sem conter informa\'e7\'f5es a serem passadas; nesse caso, o mero conhecimento de que uma exce\'e7\'e3o desse tipo foi disparada pode fornecer informa\'e7\'f5es suficientes para o tratador fazer seu trabalho corretamente. \line 13.7 Um ponto fraco na t\'e9cnica de capturar exce\'e7\'f5es com catch . . . \'e9 que normalmente voc\'ea n\'e3o pode ter certeza de qual \'e9 o tipo da exce\'e7\'e3o. Outro ponto fraco \'e9 que, sem um par\'e2metro nomeado, n\'e3o existe nenhum modo de se referir ao \line objeto de exce\'e7\'e3o dentro do tratador de exce\'e7\'e3o. \line 13.8 E melhor incorporar sua estrat\'e9gia de tratamento de exce\'e7\'f5es a um sistema desde o come\'e7o do projeto. E dif\'edcil incorporar um tratamento de exce\'e7\'f5es efetivo depois de um sistema ter sido implementado. \line 13.9 Outra raz\'e3o para n\'e3o usar exce\'e7\'f5es para fluxo de controle convencional \'e9 que estas \ldblquote exce\'e7\'f5es adicionais\rdblquote  podem se confundir com exce\'e7\'f5es genu\'ednas de tratamento de erro. Torna-se mais dif\'edcil para o programador manter o controle do n\'famero de casos de exce\'e7\'e3o. Por exemplo, quando um programa processa uma variedade excessiva de exce\'e7\'f5es, podemos realmente estar certos do que est\'e1 sendo capturado por um catch ( . . . ) ? Situa\'e7\'f5es excepcionais deveriam ser raras, e n\'e3o comuns. \line 13.10 Use catch ( . . . ) para executar recupera\'e7\'e3o que n\'e3o depende do tipo da exce\'e7\'e3o, tal como liberar recursos comuns. A exce\'e7\'e3o pode ser disparada novamente para alertar blocos catch externos mais espec\'edficos. \line 13.11 O padr\'e3o C++ recomenda que, para tornar os programas mais robustos, os programadores usem a vers\'e3o de new que dispara exce\'e7\'f5es bad alloc no caso de insucessos de new. \line 13.12 A hierarquia padr\'e3o de exception se destina a servir como um ponto de partida. Os usu\'e1rios podem disparar exce\'e7\'f5es padr\'e3o, disparar exce\'e7\'f5es derivadas das exce\'e7\'f5es padr\'e3o ou disparar suas pr\'f3prias exce\'e7\'f5es n\'e3o-derivadas das exce\'e7\'f5es \line padr\'e3o. \line Dicas de teste e depura \'e7\'e3o \line 13.1 O programador determina a ordem em que os tratadores de exce\'e7\'e3o s\'e3o listados. Esta ordem pode afetar como exce\'e7\'f5es originadas naquele bloco try s\'e3o manipuladas. Se voc\'ea estiver obtendo um comportamento inesperado no tratamento de exce\'e7\'f5es do seu programa, pode ser porque um bloco catch anterior est\'e1 interceptando e tratando as exce\'e7\'f5es antes que possam alcan\'e7ar seu tratador catch planejado. \line 13.2 Usar heran\'e7a com exce\'e7\'f5es possibilita a um tratador de exce\'e7\'e3o capturar erros relacionados com uma nota\'e7\'e3o bastante concisa. Poder\'edamos certamente capturar cada tipo de ponteiro ou refer\'eancia para um objeto de exce\'e7\'e3o de uma classe derivada individualmente, mas \'e9 mais conciso se capturar ponteiros ou refer\'eancias para objetos de exce\'e7\'e3o da classe base. Al\'e9m disso, capturar ponteiros ou refer\'eancias para objetos de exce\'e7\'e3o de classes derivadas individualmente \'e9 sujeito a erros se o programador se esquecer de incluir testes expl\'edcitos para um ou mais dos tipos de ponteiro ou de refer\'eancia para a classe derivada. \line 13.3 Para capturar todas as exce\'e7\'f5es que podem ser disparadas em um bloco try, use catch (. .). \par
CAP\'cdTULO 13 - TRATAMENTO DE EXCE\'c7\'d5ES 723 \par
Exerc\'edcios de auto-revis\'e3o \line 13.1 Liste cinco exemplos comuns de exce\'e7\'f5es. \line 13.2 D\'ea v\'e1rias raz\'f5es pelas quais as t\'e9cnicas de tratamento de exce\'e7\'f5es n\'e3o devem ser usadas para controle convencional do programa. \line 13.3 Por que exce\'e7\'f5es s\'e3o apropriadas para lidar com erros produzidos por fun\'e7\'f5es de bibliotecas? \line 13.4 O que \'e9 uma \ldblquote perda de recurso?\rdblquote  \line 13.5 Se nenhuma exce\'e7\'e3o \'e9 disparada de um bloco try, para onde vai ser transferido o controle depois de o bloco try \line completar a execu\'e7\'e3o? \line 13.6 O que ocorre se uma exce\'e7\'e3o \'e9 disparada fora de um bloco try7 \line 13.7 D\'ea uma vantagem importante e uma desvantagem importante de se usar catch (. . \line 13.8 O que ocorre se nenhum tratador catch corresponde ao tipo de um objeto disparado? \line 13.9 O que ocorre se v\'e1rios tratadores correspondem ao tipo do objeto disparado? \line 13.10 Por que um programador especificaria um tipo de uma classe base como o tipo de um tratador catch e ent\'e3o dispararia \line objetos de tipos de classes derivadas? \line 13.11 Como pode um tratador catch ser escrito para processar tipos de erros relacionados sem usar heran\'e7a entre classes de \line exce\'e7\'e3o? \line 13.12 Que tipo de ponteiro \'e9 usado em um tratador catch para capturar alguma exce\'e7\'e3o de qualquer tipo de ponteiro? \line 13.13 Suponha que um tratador catch com uma correspond\'eancia precisa ao tipo de um objeto de exce\'e7\'e3o est\'e1 dispon\'edvel. Em que circunst\'e2ncias pode um tratador diferente ser executado para objetos de exce\'e7\'e3o daquele tipo? \line 13.14 Disparar uma exce\'e7\'e3o deve fazer com que o programa termine? \line 13.15 O que ocorre quando um tratador catch dispara uma exce\'e7\'e3o? \line 13.16 O que faz o comando throw; ? \line 13.17 Como o programador restringe os tipos de exce\'e7\'f5es que podem ser disparados de uma fun\'e7\'e3o? \line 13.18 O que ocorre se uma fun\'e7\'e3o dispara uma exce\'e7\'e3o de um tipo n\'e3o permitido pela especifica\'e7\'e3o de exce\'e7\'f5es para a fun\'e7\'e3o? \line 13.19 O que ocorre aos objetos autom\'e1ticos que foram constru\'eddos em um bloco try quando aquele bloco dispara uma exce\'e7\'e3o? \line Respostas aos exerc\'edcios de auto-revis\'e3o \line 13.1 Mem\'f3ria insuficiente para satisfazer uma solicita\'e7\'e3o de new. sobrescrito de array fora dos limites, overflow em opera\'e7\'e3o aritm\'e9tica, divis\'e3o por zero, par\'e2metros de fun\'e7\'e3o inv\'e1lidos. \line 13.2 (a) O tratamento de exce\'e7\'f5es foi projetado para tratar situa\'e7\'f5es que acontecem pouco freq\'fcentemente e resultam \line freq\'fcentemente no t\'e9rmino do programa, assim os implementadores de compiladores n\'e3o s\'e3o obrigados a implementar o trata _______ mento de exce\'e7\'f5es de maneira otimizada. (b) O fluxo de controle com estruturas de controle convencionais \'e9 geralmente mais claro e eficiente do que com exce\'e7\'f5es. (c) Podem ocorrer problemas porque a pilha de chamadas de fun\'e7\'f5es \'e9 desempilhada quando ocorrer uma exce\'e7\'e3o e os recursos alocados antes da exce\'e7\'e3o n\'e3o podem ser liberados. (d) As \ldblquote exce\'e7\'f5es adicionais\rdblquote  podem se confundir com exce\'e7\'f5es de erro genu\'ednas. Torna-se mais dif\'edcil para o programador manter o controle do n\'famero maior de casos de exce\'e7\'e3o. O que um catch (. . .) realmente captura? . - \line 13.3 \'c9 improv\'e1vel que uma fun\'e7\'e3o de biblioteca execute processamento de erro que satisfa\'e7a \'e0s necessidades de todos os usu\'e1rios. \line 13.4 Um programa que aborta pode deixar um recurso em um estado no qual outros programas s\'e3o incapazes de adquirir o recurso. \line 13.5 Os tratadores de exce\'e7\'e3o (nos blocos catch) para aquele bloco try s\'e3o saltados e o programa retoma a execu\'e7\'e3o depois do \'faltimo bloco catch. \line 13.6 Uma exce\'e7\'e3o disparada fora de um bloco try provoca uma chamada para terminate. \par
724 C++ COMO PROGRAMAR \line 13.7 A forma catch (. . .) captura qualquer tipo de erro disparado em um bloco try. Uma vantagem \'e9 que nenhum erro disparado pode escapar. Uma desvantagem \'e9 que o catch n\'e3o tem nenhum par\'e2metro, assim ele n\'e3o pode referenciar \line informa\'e7\'f5es no objeto disparado e n\'e3o pode saber a causa do erro. \line 13.8 Isto faz com que a procura por uma correspond\'eancia continue no pr\'f3ximo bloco try externo. \'c0 medida que o processamento continua, pode eventualmente ser determinado que n\'e3o existe nenhum tratador no programa que corresponde ao tipo do objeto disparado; neste caso, \'e9 chamada terminate. o que, por default, chama abort. Uma fun\'e7\'e3o terminate alternativa pode ser fornecida como um par\'e2metro para setterminate. \line 13.9 \'c9 executado o primeiro tratador de exce\'e7\'e3o correspondente ao tipo da exce\'e7\'e3o depois do bloco try. \line 13.10 Este \'e9 um meio agrad\'e1vel para se capturar tipos relacionados de exce\'e7\'f5es. \line 13.11 Forne\'e7a uma classe de exce\'e7\'e3o e um tratador catch \'fanicos para um grupo de exce\'e7\'f5es. \'c0 medida que ocorre cada exce\'e7\'e3o, o objeto de exce\'e7\'e3o pode ser criado com dados privados diferentes. O tratador catch pode examinar estes \line dados private para identificar o tipo da exce\'e7\'e3o. \line 13.12 void*. \line 13.13 Um tratador exigindo convers\'f5es padr\'e3o pode aparecer antes de uma correspond\'eancia precisa ser encontrada. \line 13.14 N\'e3o, mas ele termina o bloco em que a exce\'e7\'e3o \'e9 disparada. \line 13.15 A exce\'e7\'e3o ser\'e1 processada por um tratador catch (se existir um) associado com o bloco try (se existir um) externo ao tratador catch que causou a exce\'e7\'e3o. \line 13.16 Ele dispara novamente a exce\'e7\'e3o. \line 13.17 Forne\'e7a uma especifica\'e7\'e3o de exce\'e7\'e3o listando os tipos de exce\'e7\'e3o que podem ser disparadas da fun\'e7\'e3o. \line 13.18 A fun\'e7\'e3o unexpected \'e9 chamada. \line 13.19 Atrav\'e9s do processo de desempilhamento da pilha de chamadas, s\'e3o chamados os destruidores para estes objetos. \line Exerc\'edcios \line 13.20 Liste as v\'e1rias condi\'e7\'f5es excepcionais que aconteceram em programas ao longo deste texto. Liste tantas condi\'e7\'f5es excepcionais quantas puder. Para cada uma delas, descreva brevemente como um programa tipicamente trataria a exce\'e7\'e3o usando as t\'e9cnicas de tratamento de exce\'e7\'f5es discutidas neste cap\'edtulo. Algumas exce\'e7\'f5es t\'edpicas s\'e3o divis\'e3o por zero, oveiflow aritm\'e9tico, subscrito de array fora dos limites, esgotamento da mem\'f3ria livre, etc. \line 13.21 Em que circunst\'e2ncias o programador n\'e3o forneceria um nome de par\'e2metro ao definir o tipo do objeto que ser\'e1 capturado por um tratador? \line 13.22 Um programa cont\'e9m o comando \line throw; \line Onde voc\'ea esperaria achar normalmente um tal comando? E se esse comando apareceu em uma parte diferente de um programa? \line 13.23 Em que circunst\'e2ncias voc\'ea usaria o comando seguinte? \line catch(...) \{ throw; \} \line 13.24 Compare e contraste o tratamento de exce\'e7\'f5es com os v\'e1rios outros esquemas de processamento de erros discutidos no texto. \line 13.25 Liste as vantagens do tratamento de exce\'e7\'f5es em rela\'e7\'e3o aos meios convencionais de processamento de erros. \line 13.26 Forne\'e7a raz\'f5es pelas quais exce\'e7\'f5es n\'e3o deveriam ser usadas como uma forma alternativa de controle do programa. \line 13.27 Descreva uma t\'e9cnica para tratamento de exce\'e7\'f5es relacionadas. \line 13.28 At\'e9 este cap\'edtulo, ach\'e1vamos que lidar com erros descobertos por construtores era um pouco complicado. O tratamento de exce\'e7\'f5es nos d\'e1 um meio muito melhor de lidar com tais erros. Considere um construtor para uma classe String. O construtor usa new para obter espa\'e7o da mem\'f3ria livre. Suponha que new falhe. Mostre como voc\'ea lidaria com isto sem o tratamento de exce\'e7\'f5es. Discuta os aspectos-chave. Mostre como voc\'ea lidaria com tal esgotamento de mem\'f3ria com tratamento de exce\'e7\'f5es. Explique por que o m\'e9todo de tratamento de exce\'e7\'f5es \'e9 superior. \par
CAP\'cdTULO 13 - TRATAMENTO DE EXCE\'c7\'d5ES 725 \par
13.29 Suponha que um programa dispara uma exce\'e7\'e3o e o tratador de exce\'e7\'e3o apropriado come\'e7a a ser executado. Agora, suponha que o tratador de exce\'e7\'e3o apropriado dispara a mesma exce\'e7\'e3o. Isto cria uma recurs\'e3o infinita? Escreva um programa para verificar sua observa\'e7\'e3o. \line 13.3() Use heran\'e7a para criar uma classe base de exce\'e7\'e3o e v\'e1rias classes de exce\'e7\'e3o derivadas. Ent\'e3o, mostre que um tratador \line catch especificando a classe base pode capturar exce\'e7\'f5es das classe derivadas. \line 13.31 Mostre uma express\'e3o condicional que retorna ou um double ou um int. Forne\'e7a um tratador catch int e um \line tratador catch double. Mostre que s\'f3 o tratador catch double \'e9 executado, n\'e3o importando se int ou double \'e9 retornado. \line 13.32 Escreva um programa projetado para gerar e tratar um erro de esgotamento de mem\'f3ria. Seu programa deveria fazer um \line la\'e7o de pedidos para alocar mem\'f3ria dinamicamente, atrav\'e9s do operador new. \line 13.33 Escreva um programa que mostra que todos os destruidores para objetos constru\'eddos em um bloco s\'e3o chamados antes de \line uma exce\'e7\'e3o ser disparada daquele bloco. \line 13.34 Escreva um programa que mostra que os destruidores de objetos membro s\'e3o chamados somente para aqueles objetos \line membro que foram constru\'eddos antes de ocorrer uma exce\'e7\'e3o. \line 13.35 Escreva um programa que demonstra como qualquer exce\'e7\'e3o \'e9 capturada com catch (. . \line 13.36 Escreva um programa que mostra que a ordem dos tratadores de exce\'e7\'f5es \'e9 importante. O primeiro tratador para o qual existe uma correpond\'eancia \'e9 o que \'e9 executado. Compile e execute seu programa de duas maneiras diferentes, para mostrar que dois tratadores diferentes s\'e3o executados com dois efeitos diferentes. \line 13.37 Escreva um programa que mostra um construtor passando informa\'e7\'f5es sobre a falha do construtor para um tratador de exce\'e7\'e3o depois de um bloco try. \line 13.38 Escreva um programa que usa uma hierarquia de heran\'e7a m\'faltipla de classes de exce\'e7\'e3o para criar uma situa\'e7\'e3o em que a ordem dos tratadores de exce\'e7\'f5es \'e9 importante. \line 13.39 Usando setjmp/longjmp. um programa pode transferir o controle imediatamente para uma rotina de erro de dentro de uma chamada de fun\'e7\'e3o profundamente aninhada. Infelizmente, como a pilha \'e9 desempilhada, os destruidores n\'e3o s\'e3o chamados para os objetos autom\'e1ticos que foram criados durante a seq\'fc\'eancia das chamadas de fun\'e7\'e3o aninhadas. Escreva um programa que demonstra que esses destruidores, de fato, n\'e3o s\'e3o chamados. \line 13.40 Escreva um programa que ilustra o novo disparo de uma exce\'e7\'e3o. \line 13.41 Escreva um programa que usa set unexpected para inicializar uma fun\'e7\'e3o definida pelo usu\'e1rio para unexpected. usa set_unexpected novamente e, ent\'e3o. redetine unexpected de volta para sua fun\'e7\'e3o anterior. Escreva um programa semelhante para testar set terminate e terminate. \line 13.42 Escreva um programa que mostra que uma fun\'e7\'e3o com seu pr\'f3prio bloco try n\'e3o tem que capturar todos os erros poss\'edveis gerados dentro do try. Algumas exce\'e7\'f5es podem escapar e ser tratadas em escopos externos. \line 13.43 Escreva um programa que dispara um erro de uma chamada de fun\'e7\'e3o profundamente aninhada e ainda tem o tratador catch ap\'f3s o bloco externo \'e0 cadeia de chamadas, capturando a exce\'e7\'e3o. \par
\pard\lang1033\f1\fs20\par
}
 