{\rtf1\ansi\ansicpg1252\deff0\deflang1033{\fonttbl{\f0\fswiss\fprq2\fcharset0 Arial;}}
\viewkind4\uc1\pard\sb100\sa240\lang2070\f0\fs24 Sum\'e1rio \line Cap\'edtulo 1 Introdu\'e7\'e3o aos computadores e \'e0 programa\'e7\'e3o em C++ 49 \line 1.1 Introdu\'e7\'e3o 50 \line 1.2 O que \'e9 um computador?  52 \line 1.3 Organiza\'e7\'e3o de computadores 53 \line 1.4 Evolu\'e7\'e3o dos sistemas operacionais 53 \line 1.5 Computa\'e7\'e3o pessoal, computa\'e7\'e3o distribu\'edda e computa\'e7\'e3o cliente/servidor 54 \line 1.6 Linguagens de m\'e1quina, linguagens simb\'f3licas e linguagens de alto n\'edvel 55 \line 1.7 Ahist\'f3riadeC/C++ 56 \line 1.8 A biblioteca padr\'e3o de C++ 57 \line 1.9 Java e Java Como Programar 58 \line 1.10 Outras linguagens de alto n\'edvel 58 \line 1.11 Programa\'e7\'e3o estruturada 58 \line 1.12 A tend\'eancia-chave em software: tecnologia de objetos 59 \line 1.13 Fundamentos de um ambiente t\'edpico de C++ 61 \line 1.14 Tend\'eancias de hardware 63 \line 1.15 Hist\'f3ria da Internet 63 \line 1.16 Hist\'f3ria da World Wide Web 65 \line 1.17 Notas gerais sobre C++ e este livro 65 \line 1.18 Introdu\'e7\'e3o \'e0 programa\'e7\'e3o de C++ 66 \line 1.19 Um programa simples: imprimindo uma linha de texto 66 \line 1.20 Outro programa simples: somando dois inteiros 70 \line 1.21 Conceitos de mem\'f3ria 73 \line 1.22 Aritm\'e9tica 74 \line 1.23 Tomada de decis\'f5es: operadores relacionais e de igualdade 77 \line 1.24 Pensando em objetos: introdu\'e7\'e3o \'e0 tecnologia de objetos e \'e0 \line Unified Modeling LanguageTM 82 \line Cap\'edtulo 2 Estruturas de controle 99 \line 2.1 Introdu\'e7\'e3o 100 \line 2.2 Algoritmos 101 \line 2.3 Pseudoc\'f3digo 101 \line 2.4 Estruturas de controle 101 \line 2.5 A estrutura de sele\'e7\'e3o if 104 \line 2.6 A estrutura de sele\'e7\'e3o if/else 105 \line 2.7 A estrutura de repeti\'e7\'e3o while 109 \line 2.8 Formulando algoritmos: estudo de caso 1 (repeti\'e7\'e3o controlada por contador) 110 \line 2.9 Formulando algoritmos com refinamento top-down, passo a passo: estudo \line de caso 2 (repeti\'e7\'e3o controlada por sentinela) 113 \par
30 SUM\'c1RIO \line 2.10 Formulando algoritmos com refinamento top-down, passo a passo: estudo de caso 3 \line (estruturas de controle aninhadas) 120 \line 2.11 Operadores de atribui\'e7\'e3o 124 \line 2.12 Operadores de incremento e decremento 125 \line 2.13 Aspectos essenciais da repeti\'e7\'e3o controlada por contador 127 \line 2.14 A estrutura de repeti\'e7\'e3o for 129 \line 2.15 Exemplos usando a estrutura for 133 \line 2.16 A estrutura de sele\'e7\'e3o m\'faltipla switch 137 \line 2.17 A estrutura de repeti\'e7\'e3o do/while 143 \line 2.18 Os comandos break e continue 144 \line 2.19 Operadores l\'f3gicos 147 \line 2.20 Confundindo os operadores de igualdade (==) e atribui\'e7\'e3o (=) 149 \line 2.21 Resumo de programa\'e7\'e3o estruturada 151 \line 2.22 (Estudo de caso opcional) Pensando em objetos: \line identificando as classes em um problema 155 \line Cap\'edtulo 3 Fun\'e7\'f5es 189 \line 3.1 Introdu\'e7\'e3o 190 \line 3.2 Componentes de programas em C++ 190 \line 3.3 Fun\'e7\'f5es da biblioteca matem\'e1tica 191 \line 3.4 Fun\'e7\'f5es 193 \line 3.5 Defini\'e7\'f5es de fun\'e7\'f5es 193 \line 3.6 Prot\'f3tipos de fun\'e7\'f5es 197 \line 3.7 Arquivos de cabe\'e7alho 199 \line 3.8 Gera\'e7\'e3o de n\'fameros aleat\'f3rios 201 \line 3.9 Exemplo: um jogo de azar e apresentando enum 206 \line 3.10 Classes de armazenamento 209 \line 3.11 Regras de escopo 211 \line 3.12 Recurs\'e3o 214 \line 3.13 Exemplo usando recurs\'e3o: a s\'e9rie de Fibonacci 217 \line 3.14 Recurs\'e3o versus itera\'e7\'e3o 220 \line 3.15 Fun\'e7\'f5es com listas de par\'e2metros vazias 222 \line 3.16 Fun\'e7\'f5es mime 223 \line 3.17 Refer\'eancias e par\'e2metros por refer\'eancia 224 \line 3.18 Argumentos default 228 \line 3.19 Operador un\'e1rio de resolu\'e7\'e3o de escopo 229 \line 3.20 Sobrecarga de fun\'e7\'f5es 230 \line 3.21 Gabaritos de fun\'e7\'f5es 232 \line 3.22 (Estudo de caso opcional) Pensando em objetos: \line identificando os atributos de uma classe 234 \line Cap\'edtulo 4 Arrays 261 \line 4.1 Introdu\'e7\'e3o 262 \line 4.2 Arrays 262 \line 4.3 Declarando arrays 264 \line 4.4 Exemplos usando arrays 264 \line 4.5 Passando arrays a fun\'e7\'f5es 278 \line 4.6 Ordenando arrays 283 \line 4.7 Estudo de caso: calculando m\'e9dia, mediana e moda usando arrays 284 \line 4.8 Pesquisando arrays: pesquisa linear e pesquisa bin\'e1ria 288 \line 4.9 Arrays multidimensionais 293 \line 4.10 (Estudo de caso opcional) Pensando em objetos: \line identificando as opera\'e7\'f5es de uma classe 298 \par
SUM\'c1RIO 31 \line Cap\'edtulo 5 Ponteiros e strings 319 \line 5.1 Introdu\'e7\'e3o 320 \line 5.2 Declara\'e7\'f5es e inicializa\'e7\'e3o de vari\'e1veis ponteiro 320 \line 5.3 Operadores sobre ponteiros 322 \line 5.4 Chamando fun\'e7\'f5es por refer\'eancia 324 \line 5.5 Usando o qualificador const com ponteiros 328 \line 5.6 Bubble sort usando chamada por refer\'eancia 334 \line 5.7 Express\'f5es com ponteiros e aritm\'e9tica de ponteiros 339 \line 5.8 A rela\'e7\'e3o entre ponteiros e arrays 341 \line 5.9 Arrays de ponteiros 345 \line 5.10 Estudo de caso: uma simula\'e7\'e3o de embaralhamento e distribui\'e7\'e3o de cartas 346 \line 5.11 Ponteiros de fun\'e7\'e3o 350 \line 5.12 Introdu\'e7\'e3o ao processamento de caracteres e strings 354 \line 5.12.1 Fundamentos de caracteres e strings 355 \line 5.12.2 Fun\'e7\'f5es de manipula\'e7\'e3o de strings da biblioteca de tratamento de strings 357 \line 5.13 (Estudo de caso opcional) Pensando em objetos: colabora\'e7\'f5es entre objetos 363 \line Cap\'edtulo 6 Classes e abstra\'e7\'e3o de dados 395 \line 6.1 Introdu\'e7\'e3o 396 \line 6.2 Defini\'e7\'f5es de estruturas 397 \line 6.3 Acessando membros de estrutura 398 \line 6.4 Implementando um tipo Time definido pelo usu\'e1rio com uma struct 399 \line 6.5 Implementando um tipo de dado abstrato Time com uma class 401 \line 6.6 Escopo de classe e acesso a membros de classes 407 \line 6.7 Separando a interface da implementa\'e7\'e3o 408 \line 6.8 Controlando o acesso a membros 411 \line 6.9 Fun\'e7\'f5es de acesso e fun\'e7\'f5es utilit\'e1rias 414 \line 6.10 Inicializando objetos de classes: construtores 417 \line 6.11 Usando argumentos default com construtores 417 \line 6.12 Usando destruidores 421 \line 6.13 Quando construtores e destruidores s\'e3o chamados 421 \line 6.14 Usando membros de dados e fun\'e7\'f5es membro 424 \line 6.15 Uma armadilha sutil: retornando uma refer\'eancia a \line um membro de dados private 428 \line 6.16 Atribui\'e7\'e3o usando c\'f3pia membro a membro default 431 \line 6.17 Reutiliza\'e7\'e3o de software 432 \line 6.18 (Estudo de caso opcional) Pensando em objetos: come\'e7ando a programar \line as classes para o simulador de elevador 432 \line Cap\'edtulo 7 Classes: parte II 451 \line 7.1 Introdu\'e7\'e3o 452 \line 7.2 Objetos const (constantes) e fun\'e7\'f5es membro const 452 \line 7.3 Composi\'e7\'e3o: objetos como membros de classes 460 \line 7.4 Fun\'e7\'f5es friend e classes friend 465 \line 7.5 Usando o ponteiro this 468 \line 7.6 Aloca\'e7\'e3o din\'e2mica de mem\'f3ria com os operadores new e delete 473 \line 7.7 Membros de classe static 474 \line 7.8 Abstra\'e7\'e3o de dados e oculta\'e7\'e3o de informa\'e7\'f5es 479 \line 7.8.1 Exemplo: tipo de dado abstrato array 481 \line 7.8.2 Exemplo: tipo de dado abstrato string 481 \line 7.8.3 Exemplo: tipo de dado abstrato fila 482 \line 7.9 Classes cont\'eainer e iteradores 482 \line 7.10 Classes proxy 482 \line 7.11 (Estudo de caso opcional) Pensando em objetos: programando as classes para \line o simulador de elevador 484 \par
32 SUM\'c1RIO \line Cap\'edtulo 8 Sobrecarga de operadores 515 \line 8.1 Introdu\'e7\'e3o 516 \line 8.2 Fundamentos da sobrecarga de operadores 516 \line 8.3 Restri\'e7\'f5es sobre a sobrecarga de operadores 518 \line 8.4 Fun\'e7\'f5es operador como membros de classe versus como fun\'e7\'f5es friend 519 \line 8.5 Sobrecarregando os operadores de inser\'e7\'e3o em stream e extra\'e7\'e3o de stream 520 \line 8.6 Sobrecarregando operadores un\'e1rios 523 \line 8.7 Sobrecarregando operadores bin\'e1rios 524 \line 8.8 Estudo de caso: uma classe Array 524 \line 8.9 Convertendo entre tipos 535 \line 8.10 Estudo de caso: uma classe String 536 \line 8.11 Sobrecarregando ++ e -- 546 \line 8.12 Estudo de caso: uma classe Date 548 \line Cap\'edtulo 9 Heran\'e7a 563 \line 9.1 Introdu\'e7\'e3o 564 \line 9.2 Heran\'e7a: classes base e classes derivadas 565 \line 9.3 Membros protected 567 \line 9.4 Fazendo coer\'e7\'e3o de ponteiros de classe base para ponteiros de classe derivada 568 \line 9.5 Usando fun\'e7\'f5es membro 573 \line 9.6 Sobrescrevendo membros da classe base em uma classe derivada 573 \line 9.7 Heran\'e7a public, protected e private 577 \line 9.8 Classes base diretas e classes base indiretas 577 \line 9.9 Usando construtores e destruidores em classes derivadas 578 \line 9.10 Convers\'e3o impl\'edcita de objeto de classe derivada para objeto de classe base 582 \line 9.11 Engenharia de software com heran\'e7a 583 \line 9.12 Composi\'e7\'e3o versus heran\'e7a 584 \line 9.13 Relacionamentos \ldblquote usa um\rdblquote  e \ldblquote conhece um\rdblquote  585 \line 9.14 Estudo de caso: ponto, c\'edrculo e cilindro 585 \line 9.15 Heran\'e7a m\'faltipla 592 \line 9.16 (Estudo de caso opcional) Pensando em objetos: incorporando heran\'e7a \line\'e0 simula\'e7\'e3o do elevador 595 \line Cap\'edtulo 10 Fun\'e7\'f5es virtuais e polimorfismo 607 \line 10.1 Introdu\'e7\'e3o 608 \line 10.2 Campos de tipo e comandos switch 608 \line 10.3 Fun\'e7\'f5es virtual 609 \line 10.4 Classes base abstratas e classes concretas 609 \line 10.5 Polimorfismo 610 \line 10.6 Estudo de caso: um sistema de folha de pagamento usando polimorfismo 612 \line 10.7 Novas classes e vincula\'e7\'e3o din\'e2mica 621 \line 10.8 Destruidores virtual 622 \line 10.9 Estudo de caso: herdando a interface e herdando a implementa\'e7\'e3o 622 \line 10.10 Polimorfismo, fun\'e7\'f5es virtual e vincula\'e7\'e3o din\'e2mica \ldblquote vistos por dentro\rdblquote  630 \line Cap\'edtulo 11 Entrada/sa\'edda com streams em C++ 637 \line 11.1 Introdu\'e7\'e3o 639 \line 11.2 Streams 639 \line 11.2.1 Arquivos de cabe\'e7alho da biblioteca iostream 640 \line 11.2.2 Classes e objetos de entrada/sa\'edda com streams 640 \line 11.3 Sa\'edda com streams 641 \line 11.3.1 Operador de inser\'e7\'e3o em stream 642 \line 11.3.2 Encadeando operadores de inser\'e7\'e3o/extra\'e7\'e3o do stream 643 \line 11.3.3 Sa\'edda de vari\'e1veis char* 644 \par
SUM\'c1RIO 33 \line  11.3.4 Sa\'edda de caracteres com a fun\'e7\'e3o membro put; encadeando puts 645 \line  11.4 Entrada com streams 645 \line  11.4.1 Operador de extra\'e7\'e3o do stream 646 \line  11.4.2 Fun\'e7\'f5es membro get e getline 647 \line  11.4.3 Fun\'e7\'f5es membro peek. putback e ignore de istream 650 \line  11.4.4 E/S segura quanto ao tipo 651 \line  11.5 E/S n\'e3o-formatada com read. gcount e write 651 \line  11.6 Manipuladores de streams 652 \line  11.6.1 Base do stream de inteiros: dec, oct, hex e setbase 652 \line  11.6.2 Precis\'e3o em ponto flutuante (precision, setprecision) 653 \line  11.6.3 Largura de campo (setw. width) 654 \line  11.6.4 Manipuladores definidos pelo usu\'e1rio 656 \line  11.7 Estados de formato do stream 656 \line 11.7.1 Indicadores de estado de formato 657 \line 11.7.2 Zeros \'e0 direita e pontos decimais (ios: : e showpoint) 658 \line 11.7.3 Alinhamento (ios: : left, ios: : right, ios: : internal) 659 \line ) 11.7.4 Preenchimento (f iii, setfill) 660 \line 11.7.5 Basedostreamdeinteiros(ios: :dec,ios: :oct.ios: :hex, \line i8 ios: :showbase) 661 \line  11.7.6 N\'fameros em ponto flutuante; nota\'e7\'e3o cient\'edfica (ios: : scientific. \line 73 ios: :fixed) 662 \line  11.7.7 Controle de mai\'fasculas/min\'fasculas (ios: :uppercase) 663 \line  11.7.8 Inicializando e reinicializando os indicadores de formato (flags, \line  setiosflags, resetiosflags) 664 \line 11.8 Estados de erro do stream 665 \line 11.9 Vinculando um stream de sa\'edda a um stream de entrada 667 \line Cap\'edtulo 12 Gabaritos 679 \line 12.1 Introdu\'e7\'e3o 680 \line 12.2 Gabaritos de fun\'e7\'e3o 681 \line 12.3 Sobrecarregando fun\'e7\'f5es gabarito 683 \line 12.4 Gabaritos de classe 684 \line 12.5 Gabaritos de classe e par\'e2metros n\'e3o-tipo 689 \line  12.6 Gabaritos e heran\'e7a 690 \line  12.7 Gabaritos e friends 690 \line  12.8 Gabaritos e membros static 691 \line\line  Cap\'edtulo 13 Tratamento de exce\'e7\'f5es 697 \line  13.1 Introdu\'e7\'e3o 697 \line  13.2 Quando o tratamento de exce\'e7\'f5es deve ser usado 699 \line  13.3 Outras t\'e9cnicas de tratamento de erros 700 \line  13.4 Fundamentos do tratamento de exce\'e7\'f5es em C++: try, throw, catch 700 \line  13.5 Um exemplo simples de tratamento de exce\'e7\'e3o: divis\'e3o por zero 701 \line  13.6 Disparando uma exce\'e7\'e3o 703 \line 13.7 Capturando uma exce\'e7\'e3o 704 \line  13.8 Disparando novamente uma exce\'e7\'e3o 707 \line  13.9 Especifica\'e7\'f5es de exce\'e7\'e3o 708 \line  13.10 Processando exce\'e7\'f5es inesperadas 709 \line  13.11 Desempilhando a pilha 709 \line  13.12 Construtores, destruidores e o tratamento de exce\'e7\'f5es 710 \line 13.13 Exce\'e7\'f5es e heran\'e7a 711 \line  13.14 Processando falhas de new 711 \line  13.15 A classe autoptr e a aloca\'e7\'e3o din\'e2mica de mem\'f3ria 715 \line  13.16 Hierarquia de exce\'e7\'f5es da biblioteca padr\'e3o 716 \par
34 SUM\'c1RIO \line Cap\'edtulo 14 Processamento de arquivos 726 \line 14.1 Introdu\'e7\'e3o 727 \line 14.2 A hierarquia de dados 727 \line 14.3 Arquivos e streams 729 \line 14.4 Criando um arquivo de acesso seq\'fcencial 729 \line 14.5 Lendo dados de um arquivo de acesso seq\'fcencial 733 \line 14.6 Atualizando arquivos de acesso seq\'fcencial 739 \line 14.7 Arquivos de acesso aleat\'f3rio 739 \line 14.8 Criando um arquivo de acesso aleat\'f3rio 740 \line 14.9 Gravando dados aleatoriamente em um arquivo de acesso aleat\'f3rio 742 \line 14.10 Lendo dados seq\'fcencialmente de um arquivo de acesso aleat\'f3rio 744 \line 14.11 Exemplo: um programa de processamento de transa\'e7\'f5es 746 \line 14.12 Entrada/sa\'edda de objetos 751 \line Cap\'edtulo 15 Estruturas de dados 759 \line 15.1 Introdu\'e7\'e3o 760 \line 15.2 Classes auto-referentes 761 \line 15.3 Aloca\'e7\'e3o din\'e2mica de mem\'f3ria 761 \line 15.4 Listas encadeadas 763 \line 15.5 Pilhas 774 \line 15.6 Filas 778 \line 15.7 \'c1rvores 781 \line Cap\'edtulo 16 Bits, caracteres, strings e estruturas 807 \line 16.1 Introdu\'e7\'e3o 808 \line 16.2 Defini\'e7\'f5es de estrutura 808 \line 16.3 Inicializando estruturas 810 \line 16.4 Usando estruturas com fun\'e7\'f5es 810 \line 16.5 typedef 811 \line 16.6 Exemplo: uma simula\'e7\'e3o de alto desempenho do embaralhamento \line e distribui\'e7\'e3o de cartas 811 \line 16.7 Operadores sobre bits 814 \line 16.8 Campos de bits 822 \line 16.9 A biblioteca de manipula\'e7\'e3o de caracteres 825 \line 16.10 Fun\'e7\'f5es de convers\'e3o de strings 830 \line 16.11 Fun\'e7\'f5es de pesquisa da biblioteca de manipula\'e7\'e3o de strings 834 \line 16.12 Fun\'e7\'f5es de mem\'f3ria da biblioteca de manipula\'e7\'e3o de strings 839 \line 16.13 Uma outra fun\'e7\'e3o da biblioteca de manipula\'e7\'e3o de strings 843 \line Cap\'edtulo 17 O pr\'e9-processador 855 \line 17.1 Introdu\'e7\'e3o 856 \line 17.2 A diretiva #include do pr\'e9-processador 856 \line 17.3 A diretiva #define do pr\'e9-processador: constantes simb\'f3licas 857 \line 17.4 A diretiva #define do pr\'e9-processador: macros 857 \line 17.5 Compila\'e7\'e3o condicional 859 \line 17.6 As diretivas #error e #pragma do pr\'e9-processador 860 \line 17.7 Os operadores # e 861 \line 17.8 N\'fameros de linhas 861 \line 17.9 Constantes simb\'f3licas predefinidas 862 \line 17.10 Asser\'e7\'f5es 862 \line Cap\'edtulo 18 T\'f3picos sobre c\'f3digo legado em C 867 \line 18.1 Introdu\'e7\'e3o 868 \line 18.2 Redirecionando entrada/sa\'edda nos sistemas UNIX e DOS 868 \par
SUM\'c1RIO 35 \line 18.3 Lista de argumentos com tamanho vari\'e1vel 869 \line 18.4 Usando argumentos na linha de comando 871 \line 18.5 Notas sobre compila\'e7\'e3o de programas de m\'faltiplos arquivos-fonte 872 \line 18.6 Terminando um programa com exit e atexit 874 \line 18.7 O qualificador de tipo volatile 875 \line 18.8 Sufixos para constantes inteiras e de ponto flutuante 875 \line 18.9 Tratamento de sinais 876 \line 18.10 Aloca\'e7\'e3o din\'e2mica de mem\'f3ria com calloc e realloc 878 \line 18.11 Desvio incondicional: goto 878 \line 18.12 Uni\'f5es 880 \line 18.13 Especifica\'e7\'f5es de liga\'e7\'e3o 883 \line Cap\'edtulo 19 A classe string e o processamento em stream de strings 889 \line 19.1 Introdu\'e7\'e3o 890 \line 19.2 Atribui\'e7\'e3o e concatena\'e7\'e3o de strings 891 \line 19.3 Comparando strings 894 \line 19.4 Substrings 896 \line 19.5 Intercambiando strings 896 \line 19.6 Caracter\'edsticas de string 897 \line 19.7 Encontrando caracteres em um string 899 \line 19.8 Substituindo caracteres em um string 901 \line 19.9 Inserindo caracteres em um string 903 \line 19.10 Convers\'f5es para strings char* no estilo da linguagem C 904 \line 19.11 Iteradores 906 \line 19.12 Processamento de strings em streams 907 \line Cap\'edtulo 20 A biblioteca padr\'e3o de gabaritos (STL) 916 \line 20.1 Introdu\'e7\'e3o \'e0 biblioteca padr\'e3o de gabaritos (STL) 918 \line 20.1.1 Introdu\'e7\'e3o a cont\'eaineres 919 \line 20.1.2 Introdu\'e7\'e3o a iteradores 923 \line 20.1.3 Introdu\'e7\'e3o a algoritmos 928 \line 20.2 Cont\'eaineres seq\'fcenciais 930 \line 20.2.1 O cont\'eainer seq\'fcencial vector 931 \line 20.2.2 O cont\'eainer seq\'fcencial list 937 \line 20.2.3 O cont\'eainer seq\'fcencial deque 941 \line 20.3 Cont\'eaineres associativos 943 \line 20.3.1 O cont\'eainer associativo multiset 943 \line 20.3.2 O cont\'eainer associativo set 946 \line 20.3.3 O cont\'eainer associativo multimap 947 \line 20.3.4 O cont\'eainer associativo map 949 \line 20.4 Adaptadores de cont\'eaineres 951 \line 20.4.1 O adaptador stack 951 \line 20.4.2 O adaptador queue 953 \line 20.4.3 O adaptador priorityqueue 954 \line 20.5 Algoritmos 955 \line 20.5.1 f iii, filin. generate e generate_n 956 \line 20.5.2 equal, mismatch e lexicographical compare 958 \line 20.5.3 remove, remove if. remove copy e remove_copy_if 960 \line 20.5.4 replace, replace if, replace copy e replacecopyif 963 \line 20.5.5 Algoritmos matem\'e1ticos 965 \line 20.5.6 Algoritmos b\'e1sicos de pesquisa e classifica\'e7\'e3o 968 \line 20.5.7 swap, iter_swape swap ranges 971 \line 20.5.8 copy_backward, merge. unique e reverse 972 \line 20.5.9 inplacemerge, unique copy e reverse_copy 975 \par
20.5.10 Opera\'e7\'f5es sobre conjuntos . 976 \line 20.5.11 lowerbound, upper_bound e equal range 979 \line 20.5.12 Heapsort 981 \line 20.5.13 minemax 984 \line 20.5.14 Algoritmos n\'e3o-cobertos neste cap\'edtulo 985 \line 20.6 A classe bitset 986 \line 20.7 Objetos fun\'e7\'e3o 990 \par
Cap\'edtulo 21  Acr\'e9scimo a Linguagem Padr\'e3o C++\line 21.1 Acr\'e9scimos \'e0 linguagem padr\'e3o C++ 1003 \line 21.2 Introdu\'e7\'e3o 1004 \line 21.3 O tipo de dados bool 1004 \line 21.4 O operador staticcast 1006 \line 21.5 O operador constcast 1008 \line 21.6 O operador reinterpretcast 1009 \line 21.7 Ambientes de nomes 1010 \line 21.8 Informa\'e7\'e3o sobre tipo durante a execu\'e7\'e3o - RTTI 1013 \line 21.9 Palavras-chave operadores 1017 \line 21.10 Construtores explicit 1018 \line 21.11 Membros de classe mutable 1023 \line 21.12 Ponteiros para membros de classes (. * e _>*) 1024 \line 21.13 Heran\'e7a m\'faltipla e classes base virtual 1026 \line\par
Observa\'e7\'f5es finais 1030 \par
Ap\'eandice A Tabela de preced\'eancia de operadores 1035 \line 1037 \par
Ap\'eandice C \line C. 1 Sistemas de numera\'e7\'e3o 1038 \line C.2 Introdu\'e7\'e3o 1039 \line C.3 Abreviando n\'fameros bin\'e1rios como n\'fameros octais e hexadecimais 1041 \line C.4 Convertendo n\'fameros octais e hexadecimais em n\'fameros bin\'e1rios 1042 \line C.5 Convertendo do sistema bin\'e1rio, octal ou hexadecimal para o sistema decimal 1043 \line C.6 Convertendo do sistema decimal para o sistema bin\'e1rio, octal ou hexadecimal 1044 \line N\'fameros bin\'e1rios negativos: nota\'e7\'e3o em complemento de dois 1045 \line Recursos sobre C++ na Internet e na Web 1050 \line Recursos 1050 \line Tutoriais 1051 \line FAQs 1051 \line Visual C++ 1052 \line comp.lang.c++ 1052 \line Compiladores 1054 \line Ferramentas de desenvolvimento 1055 \line Biblioteca padr\'e3o de gabaritos 1055 \line Bibliografia 1057 \par
36 SuM\'c1RIo \par
Ap\'eandice B Conjunto de caracteres ASCII \par
Ap\'eandice D \line D. 1 \line D.2 \line D.3 \line D.4 \line D.5 \line D.6 \line D.7 \line D.8 \par
\'cdndice 1062 \par
Sum\'e1rio das ilustra\'e7\'f5es \line Cap\'edtulo 1 Introdu\'e7\'e3o aos computadores e \'e0 programa\'e7\'e3o em C++ \line 1.1 Um ambiente t\'edpico de C++ 62 \line 1.2 Programa de impress\'e3o de texto 67 \line 1.3 Algumas seq\'fc\'eancias comuns de escape 68 \line 1.4 Impress\'e3o em uma linha com comandos separados usando cout 69 \line 1.5 Impress\'e3o em m\'faltiplas linhas com um \'fanico comando usando cout 69 \line 1.6 Um programa de adi\'e7\'e3o 70 \line 1.7 Posi\'e7\'e3o de mem\'f3ria mostrando o nome e valor de uma vari\'e1vel 74 \line 1.8 Posi\'e7\'f5es de mem\'f3ria depois de os valores para as duas vari\'e1veis terem sido \line fornecidos como entrada 74 \line 1.9 Posi\'e7\'f5es de mem\'f3ria ap\'f3s um c\'e1lculo 74 \line 1.10 Operadores aritm\'e9ticos 75 \line 1.11 Preced\'eancia dos operadores aritm\'e9ticos 76 \line 1.12 Ordem em que um polin\'f4mio de segundo grau \'e9 calculado 78 \line 1.13 Operadores relacionais e de igualdade 78 \line 1.14 Utilizando operadores relacionais e de igualdade 79 \line 1.15 Preced\'eancia e associatividade dos operadores discutidos at\'e9 agora 81 \line Cap\'edtulo 2 Estruturas de controle \line 2.1 Colocando em um fluxograma a estrutura de seq\'fc\'eancia de C++ 102 \line 2.2 Palavras-chave de C++ 103 \line 2.3 Representando em fluxograma a estrutura de sele\'e7\'e3o \'fanica if 105 \line 2.4 Representando em fluxograma a estrutura de sele\'e7\'e3o dupla if/else 106 \line 2.5 Representando em fluxograma a estrutura de repeti\'e7\'e3o while 110 \line 2.6 Algoritmo em pseudoc\'f3digo que usa repeti\'e7\'e3o controlada por contador para \line resolver o problema da m\'e9dia da turma 111 \line 2.7 Programa em C++ e exemplo de execu\'e7\'e3o para o problema de c\'e1lculo da m\'e9dia \line da turma com repeti\'e7\'e3o controlada por contador 111 \line 2.8 Algoritmo em pseudoc\'f3digo que usa repeti\'e7\'e3o controlada por sentinela para \line resolver o problema da m\'e9dia da turma 116 \line 2.9 Programa em C++ e exemplo de execu\'e7\'e3o para o problema de c\'e1lculo da m\'e9dia \line da turma com repeti\'e7\'e3o controlada por sentinela 117 \line 2.10 Pseudoc\'f3digo para o problema dos resultados do teste 122 \line 2.11 Programa em C++ e exemplos de execu\'e7\'f5es para o problema dos resultados do teste 122 \line 2.12 Operadores aritm\'e9ticos de atribui\'e7\'e3o 125 \line 2.13 Os operadores de incremento e decremento 125 \line 2.14 A diferen\'e7a entre pr\'e9-incrementar e p\'f3s-incrementar 126 \line 2.15 Preced\'eancia dos operadores encontrados at\'e9 agora no texto 127 \line 2.16 Repeti\'e7\'e3o controlada por contador 128 \line 2.17 Repeti\'e7\'e3o controlada por contador com a estrutura for 130 \par
38 SUM\'c1RIO DAS ILUSTRA\'c7\'d5ES \line 2.18 Componentes de um cabe\'e7alho for t\'edpico 130 \line 2.19 Fluxograma de uma estrutura de repeti\'e7\'e3o for t\'edpica 133 \line 2.20 Somat\'f3rio com for 134 \line 2.21 Calculando juros compostos com for 136 \line 2.22 Um exemplo usando switch 138 \line 2.23 A estrutura de sele\'e7\'e3o m\'faltipla switch com breaks 141 \line 2.24 Usando a estrutura do/while 144 \line 2.25 O fluxograma da estrutura de repeti\'e7\'e3o do/while 145 \line 2.26 Usando o comando break em uma estrutura for 145 \line 2.27 Usando o comando continue em uma estrutura for 146 \line 2.28 Tabela verdade para o operador && (E l\'f3gico) 147 \line 2.29 Tabela verdade para o operador || (OU l\'f3gico) 148 \line 2.30 Tabela verdade para o operador ! (nega\'e7\'e3o l\'f3gica) 149 \line 2.31 Preced\'eancia e associatividade de operadores 149 \line 2.32 As estruturas de repeti\'e7\'e3o de seq\'fc\'eancia, sele\'e7\'e3o e repeti\'e7\'e3o com uma \'fanica \line entrada/\'fanica sa\'edda em C++ 151 \line 2.33 Regras para formar programas estruturados 152 \line 2.34 O fluxograma mais simples 152 \line 2.35 Aplicando repetidamente a regra 2 da Fig. 2.33 ao fluxograma mais simples 152 \line 2.36 Aplicando a regra 3 da Fig. 2.33 ao fluxograma mais simples 153 \line 2.37 Blocos de constru\'e7\'e3o empilhados, aninhados e sobrepostos 154 \line 2.38 Um fluxograma n\'e3o-estruturado 154 \line 2.39 Diagrama de caso de uso para o sistema do elevador 160 \line 2.40 Lista de substantivos na defini\'e7\'e3o do problema 160 \line 2.41 Representando uma classe na UML 162 \line 2.42 Associa\'e7\'f5es entre classes em um diagrama de classes 162 \line 2.43 Tabela de multiplicidade 163 \line 2.44 Diagrama completo de classes para a simula\'e7\'e3o do elevador 163 \line 2.45 Diagrama de objetos do edif\'edcio vazio 165 \line Cap\'edtulo 3 Fun\'e7\'f5es \line 3.1 Relacionamento hier\'e1rquico fun\'e7\'e3o chefe/fun\'e7\'e3o trabalhadora 191 \line 3.2 Fun\'e7\'f5es comumente usadas da biblioteca de matem\'e1tica 192 \line 3.3 Criando e usando uma fun\'e7\'e3o definida pelo programador 193 \line 3.4 Fun\'e7\'e3o rnaximum definida pelo programador 196 \line 3.5 Hierarquia de promo\'e7\'e3o para os tipos de dados primitivos 199 \line 3.6 Arquivos de cabe\'e7alho da biblioteca padr\'e3o 200 \line 3.7 Inteiros em uma escala ajustada e deslocada produzidos por 1 + rand ( ) % 6 202 \line 3.8 Lan\'e7ando um dado de seis faces 6.000 vezes 202 \line 3.9 Randomizando o programa de lan\'e7amento de um dado 204 \line 3.10 Programa para simular o jogo de craps 206 \line 3.11 Exemplos de resultados do jogo de craps 208 \line 3.12 Um exemplo de escopos 212 \line 3.13 C\'e1lculo recursivo de 5! 215 \line 3.14 C\'e1lculo de fatoriais com uma fun\'e7\'e3o recursiva 216 \line 3.15 Gerando os n\'fameros de Fibonacci recursivamente 217 \line 3.16 Conjunto de chamadas recursivas \'e0 fun\'e7\'e3o fibonacci 219 \line 3.17 Resumo dos exemplos e exerc\'edcios sobre recurs\'e3o no livro 221 \line 3.18 Duas maneiras de declarar e usar fun\'e7\'f5es que n\'e3o recebem argumentos 222 \line 3.19 Usando uma fun\'e7\'e3o mime para calcular o volume de um cubo 223 \line 3.20 Um exemplo de chamada por refer\'eancia 225 \line 3.21 Usando uma refer\'eancia n\'e3o-inicializada 226 \line 3.22 Tentando usar uma refer\'eancia n\'e3o-inicializada 227 \line 3.23 Usando argumentos default 228 \par
SUM\'c1RIO DAS ILUSTRA\'c7\'d5ES 39 \line 3.24 Usando o operador un\'e1rio de resolu\'e7\'e3o de escopo 229 \line 3.25 Usando fun\'e7\'f5es sobrecarregadas 231 \line 3.26 Alterando o nome para possibilitar a liga\'e7\'e3o segura quanto aos tipos 231 \line 3.27 Usando um gabarito de fun\'e7\'e3o 233 \line 3.28 Palavras e frases descritivas na defini\'e7\'e3o do problema 235 \line 3.29 Diagrama de classes mostrando os atributos 235 \line 3.30 Diagrama de estados para as classes FloorButton e ElevatorButton 236 \line 3.31 Diagrama de estados para a classe Elevator 236 \line 3.32 Diagrama de atividades modelando a l\'f3gica do elevador para responder a \line pressionamentos de bot\'f5es 238 \line 3.33 O problema das Torres de Han\'f3i para o caso com quatro discos 257 \line Cap\'edtulo 4 Arrays \line 4.1 Um array com 12 elementos 263 \line 4.2 Preced\'eancia e associatividade dos operadores 264 \line 4.3 Inicializando os elementos de um array com zeros 265 \line 4.4 Inicializando os elementos de um array com uma declara\'e7\'e3o 265 \line 4.5 Gerando os valores para serem colocados nos elementos de um array 267 \line 4.6 Inicializando e usando corretamente uma vari\'e1vel constante 268 \line 4.7 Um objeto const deve ser inicializado 268 \line 4.8 Calculando a soma dos elementos de um array 270 \line 4.9 Um programa de an\'e1lise de uma vota\'e7\'e3o de estudantes 270 \line 4.10 Um programa que imprime histogramas 272 \line 4.11 Programa de lan\'e7amento de dados usando arrays em vez de switch 274 \line 4.12 Tratando arrays de caracteres como strings 275 \line 4.13 Comparando a inicializa\'e7\'e3o de arrays static com a inicializa\'e7\'e3o autom\'e1tica 277 \line 4.14 Passando arrays e elementos individuais de arrays para fun\'e7\'f5es 280 \line 4.15 Demonstrando o qualificador de tipo const 281 \line 4.16 Ordenando um array com o bubble sort 283 \line 4.17 Programa de an\'e1lise de uma pesquisa de opini\'e3o 285 \line 4.18 Exemplo de execu\'e7\'e3o do programa de an\'e1lise de dados de uma pesquisa de opini\'e3o 287 \line 4.19 Pesquisa linear de um array 289 \line 4.20 Pesquisa bin\'e1ria em um array ordenado 290 \line 4.21 Um array bidimensional com tr\'eas linhas e quatro colunas 293 \line 4.22 Inicializando arrays multidimensionais 294 \line 4.23 Exemplo de uso de arrays bidimensionais 296 \line 4.24 Frases com verbos para cada classe do simulador 299 \line 4.25 Diagrama de classes com atributos e opera\'e7\'f5es 300 \line 4.26 Diagrama de seq\'fc\'eancia modelando um la\'e7o de simula\'e7\'e3o 302 \line 4.27 Diagrama de seq\'fc\'eancia para o processo de agendamento 303 \line 4.28 As 36 combina\'e7\'f5es poss\'edveis lan\'e7ando-se dois dados 311 \line 4.29 Os 8 movimentos poss\'edveis do cavalo 314 \line 4.30 As 22 casas eliminadas ao se colocar uma rainha no canto superior esquerdo do tabuleiro 316 \line Cap\'edtulo 5 Ponteiros e strings \line 5.1 Referenciando direta e indiretamente uma vari\'e1vel 321 \line 5.2 Representa\'e7\'e3o gr\'e1fica de um ponteiro que aponta \line para uma vari\'e1vel inteira na mem\'f3ria 322 \line 5.3 Representa\'e7\'e3o de y e yptr na mem\'f3ria 322 \line 5.4 Os operadores de ponteiro & e * 323 \line 5.5 Preced\'eancia e associatividade de operadores 324 \line 5.6 Elevando uma vari\'e1vel ao cubo usando uma chamada por valor 325 \line 5.7 Elevando uma vari\'e1vel ao cubo usando chamada por refer\'eancia \line com um ponteiro como argumento 326 \par
40 SUM\'c1RIO DAS ILUSTRA\'c7\'d5ES \line 5.8 An\'e1lise de uma chamada por valor t\'edpica 327 \line 5.9 An\'e1lise de uma chamada por refer\'eancia t\'edpica com um ponteiro como argumento 328 \line 5.10 Convertendo um string para mai\'fasculas 330 \line 5.11 Imprimindo um string, um caractere de cada vez, usando um ponteiro \line n\'e3o-constante para dados constantes 330 \line 5.12 Tentando modificar dados atrav\'e9s de um ponteiro n\'e3o-constante para dados \line constantes 331 \line 5.13 Tentando modificar um ponteiro constante para dados n\'e3o-constantes 332 \line 5.14 Tentando modificar um ponteiro constante para dados constantes 333 \line 5.15 Bubble sort com chamada por refer\'eancia 334 \line 5.16 O operador sizeof, quando aplicado a um nome de array, retorna o n\'famero de \line bytes no array 337 \line 5.17 Usando o operador sizeof para determinar os tamanhos de tipos de dados padr\'e3o 338 \line 5.18 O array v e uma vari\'e1vel ponteiro vPtr que aponta para v 339 \line 5.19 O ponteiro vPtr ap\'f3s opera\'e7\'e3o de aritm\'e9tica de ponteiros 340 \line 5.20 Usando quatro m\'e9todos de fazer refer\'eancia a elementos de array 342 \line 5.21 Copiando um string usando a nota\'e7\'e3o de array e a nota\'e7\'e3o de ponteiro 344 \line 5.22 Representa\'e7\'e3o gr\'e1fica do array suit 345 \line 5.23 Representa\'e7\'e3o de um baralho com um array bidimensional 346 \line 5.24 Programa de embaralhamento e distribui\'e7\'e3o de cartas 348 \line 5.25 Exemplo de execu\'e7\'e3o do programa de embaralhamento e distribui\'e7\'e3o de cartas 350 \line 5.26 Programa de classifica\'e7\'e3o de finalidade m\'faltipla usando ponteiros para fun\'e7\'e3o 350 \line 5.27 Sa\'eddas do programa bubble sort da Fig. 5.26 352 \line 5.28 Demonstrando um array de ponteiros para fun\'e7\'f5es 353 \line 5.29 Fun\'e7\'f5es de manipula\'e7\'e3o de strings da biblioteca de tratamento de strings 357 \line 5.30 Usando strcpy e strncpy 358 \line 5.31 Usando strcat e strncat 359 \line 5.32 Usando strcmp e strncmp 360 \line 5.33 Usando strtok 362 \line 5.34 Usando strlen 362 \line 5.35 Lista modificada de frases com verbos para as classes no sistema 364 \line 5.36 Colabora\'e7\'f5es no sistema do elevador 364 \line 5.37 Diagrama de colabora\'e7\'f5es para entrada e sa\'edda de passageiros 365 \line 5.38 Array deck n\'e3o-embaralhado 379 \line 5.39 Exemplo de embaralhamento do array deck 380 \line 5.40 C\'f3digos de opera\'e7\'e3o da Simpletron Machine Language (SML) 381 \line 5.41 Exemplo de dump 384 \line 5.42 As letras do alfabeto expressas em c\'f3digo Morse internacional 393 \line Cap\'edtulo 6 Classes e abstra\'e7\'e3o de dados \line 6.1 Criando uma estrutura. inicializando seus membros e imprimindo a estrutura 399 \line 6.2 Uma defini\'e7\'e3o simples da classe Time 401 \line 6.3 Implementa\'e7\'e3o do tipo de dado abstrato Time como uma classe 402 \line 6.4 Acessando os membros de dados e as fun\'e7\'f5es membro de um objeto \line atrav\'e9s de cada tipo de handie de objeto - atrav\'e9s do nome do objeto, \line atrav\'e9s de uma refer\'eancia e atrav\'e9s de um ponteiro para o objeto 407 \line 6.5 Separando a interface da classe Time da implementa\'e7\'e3o 409 \line 6.6 Tentativa err\'f4nea de acessar membros private de uma classe 412 \line 6.7 Usando uma fun\'e7\'e3o utilit\'e1ria 414 \line 6.8 Usando um construtor com argumentos default 418 \line 6.9 Demonstrando a ordem em que construtores e destruidores s\'e3o chamados 422 \line 6.10 Usando fun\'e7\'f5es sete get 425 \line 6.11 Retornando uma refer\'eancia a um membro de dados private 429 \line 6.12 Atribuindo um objeto a um outro por c\'f3pia membro a membro default 431 \par
SUM\'c1RIO DAS ILUSTRA\'c7\'d5ES 41 \line 6.13 Diagrama completo de classes com nota\'e7\'f5es de visibilidade 433 \line 6.14 Lista de handies para cada classe 434 \line 6.15 Arquivo de cabe\'e7alho da classe Beli 434 \line 6.16 Arquivo de cabe\'e7alho da classe Clock 435 \line 6.17 Arquivo de cabe\'e7alho da classe Person 435 \line 6.18 Arquivo de cabe\'e7alho da classe Door 436 \line 6.19 Arquivo de cabe\'e7alho da classe Light 436 \line 6.20 Arquivo de cabe\'e7alho da classe Building 437 \line 6.21 Arquivo de cabe\'e7alho da classe ElevatorButton 438 \line 6.22 Arquivo de cabe\'e7alho da classe FloorButton 438 \line 6.23 Arquivo de cabe\'e7alho da classe Scheduler 439 \line 6.24 Arquivo de cabe\'e7alho da classe Floor 440 \line 6.25 Arquivo de cabe\'e7alho da classe Elevator 441 \line Cap\'edtulo 7 Classes: parte II \line 7.1 Usando uma classe Time com objetos const e fun\'e7\'f5es membro const 454 \line 7.2 Usando um inicializador de membro para inicializar uma constante de um \line tipo de dado primitivo 457 \line 7.3 Tentativa err\'f4nea de inicializar uma constante de um tipo de dado primitivo \line por atribui\'e7\'e3o 458 \line 7.4 Usando inicializadores para objetos membro 461 \line 7.5 friends podem acessar membros private de uma classe 466 \line 7.6 Fun\'e7\'f5es n\'e3o-friend / n\'e3o-membro n\'e3o podem acessar membros \line de classe private 467 \line 7.7 Usando o ponteiro this 469 \line 7.8 Encadeando chamadas a fun\'e7\'f5es membro 470 \line 7.9 Usando um membro de dados static para manter uma contagem do n\'famero \line de objetos de uma classe 475 \line 7.10 Implementando uma classe proxy 483 \line 7.11 Acionador para a simula\'e7\'e3o do elevador 486 \line 7.12 Arquivo de cabe\'e7alho da classe Building 486 \line 7.13 Arquivo de implementa\'e7\'e3o da classe Building 487 \line 7.14 Arquivo de cabe\'e7alho da classe Clock 488 \line 7.15 Arquivo de implementa\'e7\'e3o da classe Clock 488 \line 7.16 Arquivo de cabe\'e7alho da classe Scheduler 489 \line 7.17 Arquivo de implementa\'e7\'e3o da classe Scheduler 490 \line 7.18 Arquivo de cabe\'e7alho da classe Beil 492 \line 7.19 Arquivo de implementa\'e7\'e3o da classe Beli 492 \line 7.20 Arquivo de cabe\'e7alho da classe Light 493 \line 7.21 Arquivo de implementa\'e7\'e3o da classe Light 493 \line 7.22 Arquivo de cabe\'e7alho da classe Door 494 \line 7.23 Arquivo de implementa\'e7\'e3o da classe Door 495 \line 7.24 Arquivo de cabe\'e7alho da classe ElevatorButton 496 \line 7.25 Arquivo de implementa\'e7\'e3o da classe ElevatorButton 496 \line 7.26 Arquivo de cabe\'e7alho da classe FloorButton 497 \line 7.27 Arquivo de implementa\'e7\'e3o da classe FloorButton 498 \line 7.28 Arquivo de cabe\'e7alho da classe Elevator 499 \line 7.29 Arquivo de implementa\'e7\'e3o da classe Elevator 500 \line 7.30 Arquivo de cabe\'e7alho da classe Floor 504 \line 7.31 Arquivo de implementa\'e7\'e3o da classe Floor 505 \line 7.32 Arquivo de cabe\'e7alho da classe Person 506 \line 7.33 Arquivo de implementa\'e7\'e3o da classe Person 507 \par
42 SUM\'c1RIO DAS ILUSTRA\'c7\'d5ES \line Cap\'edtulo 8 Sobrecarga de operadores \line 8.1 Operadores que podem ser sobrecarregados 518 \line 8.2 Operadores que n\'e3o podem ser sobrecarregados 518 \line 8.3 Operadores de inser\'e7\'e3o em stream e extra\'e7\'e3o de stream definidos pelo usu\'e1rio 521 \line 8.4 Uma classe Array com sobrecarga de operadores 525 \line 8.5 Uma classe String com sobrecarga de operadores 536 \line 8.6 Date com operadores de incremento sobrecarregados 548 \line 8.7 Uma classe de n\'fameros complexos 557 \line 8.8 Uma classe de inteiros enormes 559 \line Cap\'edtulo 9 Heran\'e7a \line 9.1 Alguns exemplos simples de heran\'e7a 566 \line 9.2 Uma hierarquia de heran\'e7a para membros da comunidade universit\'e1ria 566 \line 9.3 Uma parte de uma hierarquia de classes Shape 567 \line 9.4 Coer\'e7\'e3o de ponteiros da classe base para ponteiros da \line classe derivada 568 \line 9.5 Sobrescrevendo membros de classe base em uma classe derivada 574 \line 9.6 Resumo da acessibilidade de membros da classe base em uma classe derivada 578 \line 9.7 Ordem na qual construtores e destruidores de classes bases e classes derivadas \line s\'e3o chamados 579 \line 9.8 Demonstrando a classe Point 585 \line 9.9 Demonstrando a classe Circle 587 \line 9.10 Demonstrando a classe Cylinder 589 \line 9.11 Demonstrando a heran\'e7a m\'faltipla 592 \line 9.12 Atributos e opera\'e7\'f5es das classes ElevatorButton e FloorButton 596 \line 9.13 Diagrama completo de classes do simulador de elevador indicando heran\'e7a a \line partir da classe Button 596 \line 9.14 Arquivo de cabe\'e7alho da classe Button 597 \line 9.15 Arquivo de implementa\'e7\'e3o da classe Button 598 \line 9.16 Arquivo de cabe\'e7alho da classe ElevatorButton 598 \line 9.17 Arquivo de implementa\'e7\'e3o da classe ElevatorButton 599 \line 9.18 Arquivo de cabe\'e7alho da classe FloorButton 600 \line 9.19 Arquivo de implementa\'e7\'e3o da classe FloorButton 600 \line Cap\'edtulo 10 Fun\'e7\'f5es virtuais e polimorfismo \line 10.1 Demonstrando o polimorfismo com a hierarquia de classes Employee 612 \line 10.2 Demonstrando a heran\'e7a de interface com a hierarquia de classes Shape 623 \line 10.3 Fluxo de controle de uma chamada de fun\'e7\'e3o virtual 631 \line Cap\'edtulo 11 Entrada/sa\'edda com streams em C++ \line 11.1 Parte da hierarquia de classes de EIS com streams 640 \line 11.2 Parte da hierarquia de classes de E/S com streams com as \line classes essenciais para processamento de arquivo 641 \line 11.3 Enviando um string para a sa\'edda usando inser\'e7\'e3o no stream 642 \line 11.4 Enviando um string para a sa\'edda usando duas inser\'e7\'f5es no stream 642 \line 11.5 Usando o manipulador de stream endl 643 \line 11.6 Enviando valores de express\'f5es para a sa\'edda 643 \line 11.7 Encadeando o operator \'ab sobrecarregado 644 \line 11.8 Imprimindo o endere\'e7o armazenado em uma vari\'e1vel char* 645 \line 11.9 Calculando a soma de dois inteiros lidos do teclado com cm e o \line operador de extra\'e7\'e3o de stream 646 \line 11.10 Evitando um problema de preced\'eancia entre o operador de inser\'e7\'e3o em \line stream e o operador condicional 646 \line 11.11 Operador de extra\'e7\'e3o de stream retornando false quando encontra \line fim de arquivo 647 \par
SUM\'c1RIO DAS ILUSTRA\'c7\'d5ES 43 \line 11.12 Usando fun\'e7\'f5es membro get, put e eof 648 \line 11.13 Comparando a leitura de um string usando cm com extra\'e7\'e3o do stream \line e a leitura com cm . get 649 \line 11.14 Entrada de caracteres com a fun\'e7\'e3o membro getline 650 \line 11.15 E/S n\'e3o-formatada com as fun\'e7\'f5es membro read, gcount e write 651 \line 11.16 Usando os manipuladores de stream hex, oct, dec e setbase 652 \line 11.17 Controlando a precis\'e3o de valores em ponto flutuante 653 \line 11.18 Demonstrando a fun\'e7\'e3o membro width 655 \line 11 . 19 Criando e testando manipuladores de stream n\'e3o-parametrizados \line definidos pelo usu\'e1rio 656 \line 11.20 Indicadores de estado de formato 657 \line 11.21 Controlando a impress\'e3o de zeros \'e0 direita e de pontos decimais com \line valores float 658 \line 11.22 Alinhamento \'e0 esquerda e alinhamento \'e0 direita 659 \line 11.23 Imprimindo um inteiro com espa\'e7amento interno e for\'e7ando o sinal de mais 660 \line 11.24 Usando a fun\'e7\'e3o membro f iii e o manipulador setfill \line para mudar o caractere de preenchimento para campos maiores \line do que os valores que est\'e3o sendo impressos 660 \line 11.25 Usando o indicador ios: : showbase 662 \line 11.26 Exibindo valores em ponto flutuante nos formatos default, \line cient\'edfico e fixo do sistema 663 \line 11.27 Usando o indicador ios: : uppercase 663 \line 11.28 Demonstrando a fun\'e7\'e3o membro flags 664 \line 11.29 Testando estados de erro 666 \line Cap\'edtulo 12 Gabaritos \line 12.1 Um gabarito de fun\'e7\'e3o 681 \line 12.2 Usando fun\'e7\'f5es gabarito 682 \line 12.3 Demonstrando o gabarito de classe Stack 685 \line 12.4 Passando um objeto gabarito Stack para um gabarito de fun\'e7\'e3o 688 \line Cap\'edtulo 13 Tratamento de exce\'e7\'f5es \line 13.1 Um exemplo simples de tratamento de exce\'e7\'e3o com divis\'e3o por zero 701 \line 13.2 Disparando novamente uma exce\'e7\'e3o 707 \line 13.3 Demonstra\'e7\'e3o do desempilhamento da pilha 710 \line 13.4 Demonstrando new retornando 0 em caso de falha 712 \line 13.5 Demonstrando new disparando bad alloc em caso de falha 713 \line 13.6 Demonstrando setnewhandler 714 \line 13.7 Demonstrando autoytr 715 \line Cap\'edtulo 14 Processamento de arquivos \line 14.1 A hierarquia de dados 728 \line 14.2 Como a linguagem C++ visualiza um arquivo de n bytes 729 \line 14.3 Parte da hierarquia de classes de E/S com streams 730 \line 14.4 Criando um arquivo seq\'fcencial 730 \line 14.5 Modos de abertura de arquivos 731 \line 14.6 Combina\'e7\'f5es de teclas que indicam fim de arquivo para v\'e1rios sistemas \line computacionais populares 733 \line 14.7 Lendo e imprimindo um arquivo seq\'fcencial 734 \line 14.8 Programa de consulta de cr\'e9dito 736 \line 14.9 Exemplo de sa\'edda do programa da Fig. 14.8  738 \line 14.10 A vis\'e3o de C++ de um arquivo de acesso aleat\'f3rio 740 \line 14.11 Arquivo de cabe\'e7alho clntdata . h 741 \line 14.12 Criando um arquivo de acesso aleat\'f3rio seq\'fcencialmente 741 \line 14.13 Exemplo de execu\'e7\'e3o do programa da Fig. 14.12  743 \par
44 SUM\'c1RIO DAS ILUSTRA\'c7\'d5ES \line 14.14 Lendo seq\'fcencialmente um arquivo de acesso aleat\'f3rio 744 \line 14.15 Programa de contas banc\'e1rias 747 \line Cap\'edtulo 15 Estruturas de dados \line 15.1 Dois objetos vinculados de uma classe auto-referente 761 \line 15.2 Uma representa\'e7\'e3o gr\'e1fica de uma lista 764 \line 15.3 Manipulando uma lista encadeada 764 \line 15.4 Exemplo de sa\'edda para o programa da Fig. 15.3  769 \line 15.5 A opera\'e7\'e3o insertAtFront 771 \line 15.6 Uma representa\'e7\'e3o gr\'e1fica da opera\'e7\'e3o insertAtBack 772 \line 15.7 Uma representa\'e7\'e3o gr\'e1fica da opera\'e7\'e3o removeFromFront 772 \line 15.8 Uma representa\'e7\'e3o gr\'e1fica da opera\'e7\'e3o removeFromBack 773 \line 15.9 Um programa simples de pilha 775 \line 15.10 Exemplo de sa\'edda do programa da Fig. 15.9  776 \line 15.11 Um programa simples com pilha usando composi\'e7\'e3o 777 \line 15.12 Processando uma fila 778 \line 15.13 Exemplo de sa\'edda do programa da Fig. 15.12  780 \line 15.14 Uma representa\'e7\'e3o gr\'e1fica de uma \'e1rvore bin\'e1ria 781 \line 15.15 Uma \'e1rvore de pesquisa bin\'e1ria  781 \line 15.16 Criando e percorrendo uma \'e1rvore bin\'e1ria 782 \line 15.17 Exemplo de sa\'edda do programa da Fig. 15.16  785 \line 15.18 Uma \'e1rvore de pesquisa bin\'e1ria 787 \line 15.19 Uma \'e1rvore de pesquisa bin\'e1ria de 15 nodos 791 \line 15.20 Comandos de Simple 796 \line 15.21 Programa em Simple que determina a soma de dois inteiros 797 \line 15.22 Programa em Simple que encontra o maior de dois inteiros 797 \line 15.23 Calcula o quadrado de v\'e1rios inteiros 797 \line 15.24 Escrevendo, compilando e executando um programa na linguagem Simple 798 \line 15.25 Instru\'e7\'f5es SML produzidas ap\'f3s o primeiro passo do compilador 800 \line 15.26 Tabela de s\'edmbolos para o programa da Fig. 15.25  800 \line 15.27 C\'f3digo n\'e3o-otimizado do programa da Fig. 15.25  804 \line 15.28 C\'f3digo otimizado para o programa da Fig. 15.25  804 \line Cap\'edtulo 16 Bits, caracteres, strings e estruturas \line 16.1 Um alinhamento de mem\'f3ria poss\'edvel para uma vari\'e1vel do tipo Example \line mostrando uma \'e1rea indefinida na mem\'f3ria 810 \line 16.2 Simula\'e7\'e3o de alto desempenho de embaralhamento e distribui\'e7\'e3o de cartas 812 \line 16.3 Sa\'edda da simula\'e7\'e3o de alto desempenho de embaralhamento e distribui\'e7\'e3o \line de cartas 813 \line 16.4 Os operadores sobre bits 814 \line 16.5 Imprimindo um inteiro sem sinal em bin\'e1rio 815 \line 16.6 Resultados de combinar dois bits com o operador AND sobre bits (&) 817 \line 16.7 Usando os operadores sobre bits AND, OR inclusivo, OR exclusivo e \line complemento 817 \line 16.8 Sa\'edda do programa da Fig. 16.7  818 \line 16.9 Resultados de combinar dois bits com o operador sobre bits OR inclusivo (1)  819 \line 16.10 Resultados de combinar dois bits com o operador sobre bits OR exclusivo (A) 819 \line 16.11 Usando os operadores de deslocamento sobre bits 819 \line 16.12 Os operadores de atribui\'e7\'e3o sobre bits 821 \line 16.13 Preced\'eancia e associatividade de operadores 821 \line 16.14 Usando campos de bits para armazenar um baralho 823 \line 16.15 Sa\'edda do programa da Fig. 16.14  823 \line 16.16 Resumo das fun\'e7\'f5es da biblioteca de manipula\'e7\'e3o de caracteres 825 \line 16.17 Usando isdigit, isalpha, isainume isxdigit 826 \par
SUM\'c1RIO DAS ILUSTRA\'c7\'d5ES 45 \line 16.18 Usando islower. isupper, tolower e toupper 827 \line 16.19 Usando isspace. iscntrl, ispunct. isprint e isgraph 828 \line 16.20 Resumo das fun\'e7\'f5es de convers\'e3o de strings da biblioteca de utilit\'e1rios gerais 830 \line 16.21 Usando atof 830 \line  16.22 Usando atoi 831 \line 16.23 Usando atol 831 \line 16.24 Usando strtod 832 \line 16.25 Usando strtol 833 \line  16.26 Usando strtoul 834 \line  16.27 Fun\'e7\'f5es de pesquisa da biblioteca de manipula\'e7\'e3o de strings 834 \line  16.28 Usando strchr 835 \line 16.29 Usando strcspn 836 \line  16.30 Usando strpbrk 836 \line  16.3 1 Usando strrchr 837 \line 16.32 Usando strspn 838 \line  16.33 Usando strstr 838 \line 16.34 Fun\'e7\'f5es de mem\'f3ria da biblioteca de manipula\'e7\'e3o de strings 839 \line 16.35 Usando memcpy 840 \line 16.36 Usando memmove 840 \line 16.37 Usando mexncmp 841 \line 16.38 Usandomemchr 842 \line 16.39 Usandomemset 842 \line 16.40 Uma outra fun\'e7\'e3o de manipula\'e7\'e3o de strings da biblioteca de manipula\'e7\'e3o \line de strings 843 \line 16.41 Usando strerror 843 \line Cap\'edtulo 17 O pr\'e9-processador \line 17.1 As constantes simb\'f3licas predefinidas 862 \line Cap\'edtulo 18 T\'f3picos sobre c\'f3digo legado em C \line 18.1 O tipo e as macros definidas no cabe\'e7alho cstdarg 869 \line 18.2 Usando listas de argumentos de tamanho vari\'e1vel 870 \line 18.3 Usando argumentos na linha de comando 871 \line 18.4 Usando as fun\'e7\'f5es exit e atexit 874 \line 18.5 Os sinais definidos no cabe\'e7alho csignal 876 \line 18.6 Utilizando tratamento de sinais 876 \line 18.7 Usando goto 879 \line 18.8 Imprimindo o valor de uma union com os tipos de dados dos dois membros 881 \line 18.9 Usando uma union an\'f4nima 882 \line\line  Cap\'edtulo 19 A classe string e o processamento em stream de strings \line 19.1 Demonstrando a atribui\'e7\'e3o e concatena\'e7\'e3o de string 891 \line  19.2 Comparando strings 894 \line  19.3 Demonstrando a fun\'e7\'e3o substr 896 \line  19.4 Usando a fun\'e7\'e3o swap para intercambiar dois strings 896 \line  19.5 Imprimindo caracter\'edsticas de um string 897 \par
 19.6 Demonstrando as fun\'e7\'f5es de procura em um string/find 899 \line  19.7 Demonstrando as fun\'e7\'f5es erase e replace 901 \line  19.8 Demonstrando as fun\'e7\'f5es insert de string 903 \line  19.9 Convertendo strings para strings e arrays de caracteres no estilo de C 904 \line  19.10 Usando um iterador para exibir um string 906 \line  19.11 Usando um objeto ostringstream alocado dinamicamente 908 \line  19.12 Demonstrando a entrada de dados a partir de um objeto istringstream 910 \par
46 SUM\'c1RIO DAS ILUSTRA\'c7\'d5ES \line Cap\'edtulo 20 A biblioteca padr\'e3o de gabaritos (STL) \line 20.1 Classes cont\'eainer da biblioteca padr\'e3o 920 \line 20.2 Fun\'e7\'f5es comuns a todos os cont\'eaineres da STL 920 \line 20.3 Arquivos de cabe\'e7alho dos cont\'eaineres da biblioteca padr\'e3o 922 \line 20.4 typedefs comuns encontrados em cont\'eaineres de primeira classe 922 \line 20.5 Demonstrando iteradores de entrada e sa\'edda com streams 924 \line 20.6 Categorias de iteradores 925 \line 20.7 Hierarquia das categorias de iteradores 926 \line 20.8 Tipos de iteradores suportados em cada cont\'eainer da biblioteca padr\'e3o 926 \line 20.9 typedefs de iteradores predefinidos 927 \line 20.10 Algumas opera\'e7\'f5es de iteradores para cada tipo de iterador 927 \line 20.11 Algoritmos seq\'fcenciais mutantes 929 \line 20.12 Algoritmos seq\'fcenciais n\'e3o-mutantes 929 \line 20.13 Algoritmos num\'e9ricos do arquivo de cabe\'e7alho <numeric> 930 \line 20.14 Demonstrando o gabarito de classe vector da biblioteca padr\'e3o 931 \line 20.15 Demonstrando as fun\'e7\'f5es de manipula\'e7\'e3o de elementos do \line gabarito de classe vector da biblioteca padr\'e3o 934 \line 20.16 Tipos de exce\'e7\'f5es da STL 936 \line 20.17 Demonstrando o gabarito de classe list da biblioteca padr\'e3o 937 \line 20.18 Demonstrando o gabarito de classe deque da biblioteca padr\'e3o 941 \line 20.19 Demonstrando o gabarito de classe multiset da biblioteca padr\'e3o 943 \line 20.20 Demonstrando o gabarito de classe set da biblioteca padr\'e3o 946 \line 20.21 Demonstrando o gabarito de classe multimap da biblioteca padr\'e3o 948 \line 20.22 Demonstrando o gabarito de classe map da biblioteca padr\'e3o 950 \line 20.23 Demonstrando a classe adaptadora stack da biblioteca padr\'e3o 951 \line 20.24 Demonstrando os gabaritos de classe adaptadora queue da biblioteca padr\'e3o 953 \line 20.25 Demonstrando a classe adaptadora priority queue da biblioteca padr\'e3o 955 \line 20.26 Demonstrando as fun\'e7\'f5es f iii, fi].ln, generate \line e generate_n da biblioteca padr\'e3o 956 \line 20.27 Demonstrando as fun\'e7\'f5es equa]., mismatch e \line lexicographical compare da biblioteca padr\'e3o 958 \line 20.28 Demonstrando as fun\'e7\'f5es remove, remove if, remove copy e \line remove copyi f da biblioteca padr\'e3o 960 \line 20.29 Demonstrando as fun\'e7\'f5es replace. replace if. replace copy e \line replacecopyif da biblioteca padr\'e3o 963 \line 20.30 Demonstrando alguns algoritmos matem\'e1ticos da biblioteca padr\'e3o 965 \line 20.31 Algoritmos b\'e1sicos de pesquisa e classifica\'e7\'e3o da biblioteca padr\'e3o 969 \line 20.32 Demonstrando swap, iter_swap, e swap ranges 971 \line 20.33 Demonstrando copy_backward. merge. unique e reverse 972 \line 20.34 Demonstrando inplace merge, unique copy e reversecopy 975 \line 20.35 Demonstrando as opera\'e7\'f5es set da biblioteca padr\'e3o 977 \line 20.36 Demonstrando lower bound, upper bound e equa]. range 979 \line 20.37 Usando fun\'e7\'f5es da biblioteca padr\'e3o para executar um heapsort 981 \line 20.3 8 Demonstrando os algoritmos mm e max 984 \line 20.39 Algoritmos n\'e3o-cobertos neste cap\'edtulo 985 \line 20.40 Demonstrando a classe bitset e o Crivo de Erat\'f3stenes 988 \line 20.41 Objetos fun\'e7\'e3o na biblioteca padr\'e3o 990 \line 20.42 Demonstrando um objeto fun\'e7\'e3o bin\'e1ria 990 \line Cap\'edtulo 21 Acr\'e9scimos \'e0 linguagem padr\'e3o C++ \line 21.1 Demonstrando o tipo de dados primitivo bool 1004 \line 21.2 Demonstrando o operador static_cast 1006 \line 21.3 Demonstrando o operador const_cast 1008 \line 21.4 Demonstrando o operador reinterpret cast 1009 \par
SUM\'c1RIO DAS ILUSTRA\'c7\'d5ES 47 \line 21.5 Demonstrando o uso de namespaces 1010 \line  21.6 Demonstrando typeid 1013 \line  21.7 Demonstrando dynamiccast 1014 \line  21.8 Palavras-chave operadores como alternativa para s\'edmbolos de operadores 1017 \line  21.9 Demonstrando as palavras-chave operadores 1017 \line  21.10 Construtores de um \'fanico argumento e convers\'f5es impl\'edcitas 1018 \line  21.11 Demonstrando um construtor explicit 1021 \line  21.12 Demonstrando um membro de dados mutable 1024 \line  21.13 Demonstrando os operadores * e -> 1025 \line  21.14 Heran\'e7a m\'faltipla para formar a classe iostreain 1026 \line  21.15 Tentando chamar polimorficamente uma fun\'e7\'e3o herdada de multiplica\'e7\'e3o 1027 \line  21.16 Usando classes base virtual 1028 \line  \line  Ap\'eandice A Tabela de preced\'eancia de operadores \line  A.1 Tabela de preced\'eancia de operadores 1035 \line  Ap\'eandice B Conjunto de caracteres ASCII \line  B.1 O conjunto de caracteres ASCII 1037 \line  \line  Ap\'eandice C Sistemas de numera\'e7\'e3o \line  C.1 D\'edgitos dos sistemas de numera\'e7\'e3o bin\'e1rio, octal, decimal e hexadecimal 1039 \line  C.2 Compara\'e7\'e3o entre os sistemas de numera\'e7\'e3o bin\'e1rio, octal, \line  decimal e hexadecimal 1040 \line  C.3 Valores posicionais no sistema de numera\'e7\'e3o decimal 1040 \line  C.4 Valores posicionais no sistema de numera\'e7\'e3o bin\'e1rio 1041 \line  C.5 Valores posicionais no sistema de numera\'e7\'e3o octal 1041 \line  C.6 Valores posicionais no sistema de numera\'e7\'e3o hexadecimal 1041 \line C.7 Equivalentes decimais, bin\'e1rios, octais e hexadecimais 1042 \line  C.8 Convertendo um n\'famero bin\'e1rio em decimal 1043 \line C.9 Convertendo um n\'famero octal em decimal 1043 \line  C.10 Convertendo um n\'famero hexadecimal em decimal 1043 \line\line\line\line\line\par
}
 