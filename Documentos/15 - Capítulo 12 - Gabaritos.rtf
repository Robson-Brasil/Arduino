{\rtf1\ansi\ansicpg1252\deff0\deflang1033{\fonttbl{\f0\fswiss\fprq2\fcharset0 Arial;}{\f1\froman\fcharset0 Times New Roman;}}
\viewkind4\uc1\pard\sb100\sa240\lang2070\f0\fs24\par
\par
Gabaritos \line Objetivos \line\bullet  Ser capaz de usar gabaritos de fun\'e7\'f5es para criar um grupo \line de fun\'e7\'f5es relacionadas (sobrecarregadas). \line\bullet  Ser capaz de distinguir entre gabaritos de fun\'e7\'f5es e fun \'e7\'f5e gabarito. \line\bullet  Ser capaz de usar gabaritos de classes para criar um grupo \line de tipos relacionados. \line\bullet  Ser capaz de distinguir entre gabaritos de classe e classes \line gabarito. \line\bullet  Entender como sobrecarregar fun\'e7\'f5es gabarito. \line\bullet  Entender os relacionamentos entre gabaritos, friends, he- L \line ran\'e7a e membros est\'e1ticos. \line Por tr\'e1s daquele padr\'e3o externo as formas sombrias ficam mais \line claras a cada dia. \line E sempre a \'ednesma forma, apenas muito numerosa \line Charlotte Perkins Gilman \line The Yellow Wallpaper \line Se voc\'ea conseguir deslizar entre os par\'e2metros dos c\'e9us e da terra, deslize. \line O Cor\'e3o \line Um labirinto poderoso! mas n\'e3o sem um plano. \line Alexander Pope \par
12 \par
680 C+\'f7 COMO PROGRAMAR \par
\ul Vis\'e3o geral \ulnone\line 12.1 Introdu\'e7\'e3o \line 12.2 Gabaritos de fun\'e7\'e3o \line 12.3 Sobrecarregando fun\'e7\'f5es gabarito \line 12.4 Gabaritos de classe \line 12.5 Gabaritos de classe e par\'e2metros n\'e3o-tipo \line 12.6 Gabaritos e heran\'e7a \line 12.7 Gabaritos e friends \line 12.8 Gabaritos e membros static \line Resumo . Terminologia . Erros comuns de programa\'e7\'e3o Dicas de desempenho. Observa\'e7\'f5es de engenharia de software . Dica de teste e depura \'e7\'e3o \bullet  Exerc\'edcios de auto-revis\'e3o Respostas aos exerc\'edcios de auto- revis\'e3o \bullet  Exerc\'edcios \line 12.1 Introdu\'e7\'e3o \line Neste cap\'edtulo, discutimos um dos recursos mais poderosos de C++, ou seja, os gabaritos. Os gabaritos nos possibilitam especificar, com um \'fanico segmento de c\'f3digo, uma gama inteira de fun\'e7\'f5es relacionadas (sobrecarregadas) - chamadas de fun\'e7\'f5es gabarito - ou uma gama inteira de classes relacionadas - chamadas de classes gabarito. \line Podemos escrever um \'fanico gabarito de fun\'e7\'e3o para uma fun\'e7\'e3o de classifica\'e7\'e3o de arrays e ent\'e3o fazer com que C++ gere automaticamente fun\'e7\'f5es gabarito separadas que classificam um array int, classificam um array float, classificam um array de strings, e assim por diante. \line Discutimos gabaritos de fun\'e7\'e3o no Cap\'edtulo 3. Para benef\'edcio daqueles leitores que saltaram aquele t\'f3pico, apresentamos uma discuss\'e3o e um exemplo adicionais neste cap\'edtulo. \line Podemos escrever um gabarito de classe \'fanico para uma classe pilha e ent\'e3o fazer com que C++ gere classes gabaritos separadas, tais como uma classe pilha de int, uma classe pilha de float, uma classe pilha de string. e assim por diante. \line Note a distin\'e7\'e3o entre gabaritos de fun\'e7\'e3o e fun\'e7\'f5es gabarito: os gabaritos de fun\'e7\'e3o e os gabaritos de classe s\'e3o como est\'eanceis com os quais n\'f3s tra\'e7amos formas; as fun\'e7\'f5es gabarito e as classes gabarito s\'e3o como os tra\'e7ados separados que tem todos a mesma forma, mas poderiam ter sido desenhados, por exemplo, com cores diferentes. \line Observa\'e7\'e3o de engenharia de software 12.1 \line ______ Os gabaritos s\'e3o um dos recursos mais poderosos de C+ + para a reutiliza\'e7\'e3o de software. \line Neste cap\'edtulo, apresentamos exemplos de um gabarito de fun\'e7\'e3o e um gabarito de classe. Tamb\'e9m consideraremos as rela\'e7\'f5es entre gabaritos e outras caracter\'edsticas de C++, tais como sobrecarga, heran\'e7a, friends e membros static. \line O projeto e os detalhes dos mecanismos de gabarito discutidos aqui se baseiam no trabalho de Bjarne Stroustrup apresentado no seu artigo Parameterized Tvpes for C+ + e publicado nos Proceedings ofthe USENIX C+ + Conference, ocorrido em Denver, Cobrado, em outubro de 1988. \line Este cap\'edtulo pretende ser somente uma breve introdu\'e7\'e3o ao rico e complexo t\'f3pico de gabaritos. O Cap\'edtulo 20, \ldblquote A biblioteca padr\'e3o de gabaritos (STL)\rdblquote , o maior cap\'edtulo deste livro, apresenta um tratamento detalhado das classes gabarito cont\'eaineres, iteradores e algoritmos da STL. O Cap\'edtulo 20 cont\'e9m dezenas de exemplos de c\'f3digo real baseados em gabaritos - ilustrando t\'e9cnicas de programa\'e7\'e3o com gabaritos mais sofisticadas que as usadas aqui no Cap\'edtulo 12. \par
CAP\'cdTULO 12- GABAR1TOS 681 \line 12.2 Gabaritos de fun\'e7\'e3o \line Fun\'e7\'f5es sobrecarregadas s\'e3o normalmente usadas para executar opera\'e7\'f5es semelhantes sobre tipos de dados diferentes. Se as opera\'e7\'f5es s\'e3o id\'eanticas para cada tipo, isto pode ser executado mais compacta e convenientemente usando-se gabaritos de fun\'e7\'e3o. O programador escreve uma \'fanica defini\'e7\'e3o do gabarito da fun\'e7\'e3o. Baseado nos tipos de argumentos fornecidos explicitamente ou inferidos das chamadas para esta fun\'e7\'e3o, o compilador gera fun\'e7\'f5es separadas, no c\'f3digo objeto, para tratar cada tipo de chamada apropriadamente. Em C, esta tarefa pode ser executada usando-se macros criadas com a diretiva #define do pr\'e9-processador (ver Cap\'edtulo 17, \ldblquote O pr\'e9- processador\rdblquote ). Por\'e9m, macros apresentam a possibilidade de s\'e9rios efeitos colaterais e n\'e3o possibilitam ao compilador executar uma verifica\'e7\'e3o de tipo. Os gabaritos de fun\'e7\'e3o fornecem uma solu\'e7\'e3o compacta como as macros, mas possibitam uma verifica\'e7\'e3o de tipo completa. \line\'ae Dica de teste e depura \'e7\'e3o 12.1 \line Gaba ritos dei un\'e7\'e3o, como macros, possibilitam a reutiliza\'e7\'e3o de software. Mas, diferentemente de macros, gabaritos de fun\'e7\'e3o ajudam a eliminar muitos tipos de erros por causa do escrut\'ednio da verifica\'e7\'e3o de tipo completa de C++. \line Todas as defini\'e7\'f5es de gabaritos de fun\'e7\'e3o come\'e7am com a palavra-chave template seguida por uma lista de par\'e2metros de tipo formais para o gabarito de fun\'e7\'e3o, incluso entre os sinais de maior e menor (< e >); cada par\'e2metro formal de tipo deve ser precedido pela palavra-chave class ou typename, como em \line template< class T > \line ou \line template< typenaine ElementType > \line ou \line template< class BorderType, class FillType > \line Os par\'e2metros de tipo formais de uma defini\'e7\'e3o de gabarito s\'e3o usados (como seriam com par\'e2metros de tipos primitivos ou tipos definidos pelo usu\'e1rio) para especificar os tipos dos par\'e2metros da fun\'e7\'e3o, especificar o tipo de retorno da fun\'e7\'e3o e para declarar vari\'e1veis dentro da fun\'e7\'e3o. A defini\'e7\'e3o da fun\'e7\'e3o vem a seguir e \'e9 definida como qualquer outra fun\'e7\'e3o. Note que a palavra-chave class ou typename usada para especificar par\'e2metros de tipo do gabarito de fun\'e7\'e3o na realidade significa \ldblquote qualquer tipo primitivo ou tipo definido pelo usu\'e1rio\rdblquote . \line Erro comum de programa\'e7\'e3o 12.1 \line N\'e3o colocar class (ou typename) antes de cada par\'e2metro formal de tipo de um gabarito de fun\'e7\'e3o. \line Examinemos o gabarito de fun\'e7\'e3o printArray na Fig. 12.1. O gabarito de fun\'e7\'e3o \'e9 usado no programa completo daFig. 12.2. \line 1 template< class T > \line 2 void printArray( const T *array, const int count \line 3 \line 4 for ( int i = O; i < count; i++ \line 5 cout \'ab array[ i 1 \'ab \line 6 \line 7 cout \'ab endl; \line 8 \line Fig. 12.1 Um gabarito de fun\'e7\'e3o. \par
682 C++ COMO PROGRAMAR \line O gabarito de fun\'e7\'e3o printArray declara um par\'e2metro formal \'fanico T (T poderia ser qualquer identificador v\'e1lido) para o tipo do array a ser impresso pela fun\'e7\'e3o printArray: T * \'e9 chamado de par\'e2metro de tipo. Quando o compilador encontrar uma chamada para a fun\'e7\'e3o printArray no c\'f3digo-fonte do programa, o tipo do primeiro par\'e2metro de printArray \'e9 substitu\'eddo por T na defini\'e7\'e3o do gabarito e C++ cria uma fun\'e7\'e3o gabarito completa para imprimir um array do tipo de dados especificado. Ent\'e3o, a fun\'e7\'e3o rec\'e9m-criada \'e9 compilada. Na Fig. 12.2, tr\'eas fun\'e7\'f5es printArray s\'e3o instanciadas - uma espera um array int. uma espera um array double e uma espera um array char, Por exemplo, a instancia\'e7\'e3o para o tipo int \'e9: \line void printArray( const int *array, const int count \line for ( int i = O; i < count; i++ ) \line cout \'ab array[ i ] \'ab \line cout \'ab endl; \line Cada par\'e2metro de tipo formal, em uma defini\'e7\'e3o de gabarito de fun\'e7\'e3o, deve normalmente aparecer na lista de par\'e2metros da fun\'e7\'e3o pelo menos uma vez. O nome de um par\'e2metro de tipo formal pode ser usado somente uma vez na lista de par\'e2metros de um cabe\'e7alho de gabarito. Nomes de par\'e2metros de tipo formais entre fun\'e7\'f5es gabarito n\'e3o precisam ser \'fanicos. \line A Fig. 12.2 ilustra o uso do gabarito de fun\'e7\'e3o printArray. O programa come\'e7a por instanciar int array a, array double b e char array c, de tamanhos 5, 7, e 4, respectivamente. A seguir, cada um dos arrays \'e9 impresso chamando printArray - uma vez com um primeiro par\'e2metro a do tipo int* , uma vez com um primeiro par\'e2metro b do tipo double* e uma vez com um primeiro par\'e2metro c do tipo char*. A chamada \line printArray( a, aCount ); \line por exemplo, faz com que o compilador infira que T \'e9 int e instancie uma fun\'e7\'e3o gabarito printArray cujo par\'e2metro de tipo T \'e9 int. A chamada \line printArray( b, bCount ); \line faz com que o compilador infira que T \'e9 double e instancie uma segunda fun\'e7\'e3o gabarito printArray cujo par\'e2metro de tipo T \'e9 double. A chamada \line printArray( c, cCount ); \line faz com que o compilador infira que T \'e9 char e instancie uma terceira fun\'e7\'e3o gabarito printArray cujo par\'e2metro de tipo T \'e9 char. \line 1 II Fig 12.2: figl2O2.cpp \line 2 // Usando fun\'e7\'f5es gabarito \line 3 #include <iostream> \line 4 \line 5 using std: :cout; \line 6 using std: :endl; \line 7 \line 8 template< class T > \line 9 void printArray( const T *array, const int count ) \line 10 \{ \line 11 for ( int i = o; i < count; i++ \line 12 cout \'ab array[ i ] \'ab \line 13 \line 14 cout \'ab endi; \line\ul 15 \} \ulnone\line Fig. 12.2 Usando fun\'e7\'f5es gabarito (parte 1 de 2). \par
CAP\'cdTULO 12 - GABARITOS 683 \line 16 \line 17 int main() \line 18 \{ \line 19 const int aCount = 5, bCount = 7, cCount = 4; \line 20 inta[aCount)=\{1,2,3,4,5\}; \line 21 double b[ bCount J = \{ 1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7 \}; \line 22 char c[ cCount ] = \ldblquote AL\'d4\rdblquote ; //quarta posi\'e7\'e3o reservada para o caractere nulo \line 23 \line 24 cout \'ab \ldblquote Array a cont\'e9m:\rdblquote  \'ab endi; \line 25 printArray( a, aCount ); II fun\'e7\'e3o gabarito para inteiros \line 26 \line 27 cout \'ab \ldblquote Array b cont\'e9m:\rdblquote  \'ab endi; \line 28 printArray( b, bCount ); // fun\'e7\'e3o gabarito para doulies \line 29 \line 30 cout \'ab \ldblquote Array c cont\'e9m:\rdblquote  \'ab endl; \line 31 printArray( c, cCount ); // fun\'e7\'e3o gabarito para caracteres \line 32 \line 33 return 0; \line 34 \} \line Array a cont\'e9m: \line 12345 \line Array b cont\'e9m: \line .1 2.2 3.3 4.4 5.5 6.6 7.7 \line Array c cont\'e9m: \line AL\'d4 \line Fig. 12.2 Usando fun\'e7\'f5es gabarito (parte 2 de 2). \line Neste exemplo, o mecanismo de gabarito poupa o programador de ter que escrever tres run\'e7oes sonrecarregauas separadas, com prot\'f3tipos \line void printArray(const int \ldblquote , const int); \line void printArray(const double \lquote , const int); \line void printArray(const char , const int); \line as quais usam todas o mesmo c\'f3digo, exceto pelo tipo T. \line Dica de desempenho 12.1 \line f Gabaritos certamente oferecem os benef\'edcios de reutiliza\'e7\'e3o de software. Mas tenha em mente que m\'faltiplas c\'f3pias de fun\'e7\'f5es gabarito e classes gabarito ainda s\'e3o instanciadas em um programa, apesar do fato de que o gabarito \'e9 escrito somente uma vez. Estas c\'f3pias podem consumir mem\'f3ria consider\'e1vel. \line 12.3 Sobrecarregando fun\'e7\'f5es gabarito \line Fun\'e7\'f5es gabarito e sobrecarga est\'e3o intimamente relacionadas. As fun\'e7\'f5es relacionadas geradas a partir de um gabarito de fun\'e7\'e3o t\'eam todas o mesmo nome, de modo que o compilador usa a resolu\'e7\'e3o de sobrecarga para invocar a fun\'e7\'e3o apropriada. \line Um gabarito de fun\'e7\'e3o pode ser sobrecarregado de v\'e1rios modos. Podemos fornecer outros gabaritos de fun\'e7\'e3o que especificam o mesmo nome da fun\'e7\'e3o, mas par\'e2metros da fun\'e7\'e3o diferentes. Por exemplo, o gabarito da fun\'e7\'e3o printArray da Fig. 12.2 poderia ser sobrecarregado com outro gabarito da fun\'e7\'e3o printArray com par\'e2metros adicionais lowsubscript e highSubscript para especificar a parte do array a ser impressa (ver Exerc\'edcio \line 12.4). \par
684 C++ COMO PROGRAMAR \line Um gabarito de fun\'e7\'e3o pode tamb\'e9m ser sobrecarregado fornecendo outras fun\'e7\'f5es n\'e3o-gabarito com o mesmo nome da fun\'e7\'e3o, mas com argumentos de fun\'e7\'e3o diferentes. Por exemplo, o gabarito de fun\'e7\'e3o printArray da Fig. 12.2 poderia ser sobrecarregado com uma vers\'e3o n\'e3o-gabarito que imprime especificamente um array de string de caracteres em um formato organizado, tabular, de coluna (ver Exerc\'edcio 12.5). \line Erro comum de programa\'e7\'e3o 12.2 \line Se um gabarito \'e9 invocado com um tipo de classe definido pelo usu\'e1rio e se esse gabarito usa operadores (como +, <, etc.) com objetos do tipo daquela classe, ent\'e3o aqueles operadores devem ser sobrecarregados! Esquecer de sobrecarregar tais operadores provoca erros, porque o com pilador naturalmente, ainda gera chamadas \'e0s fun\'e7\'f5es operador sobrecarregado apropriadas, apesar do fato de que estas fun\'e7\'f5es n\'e3o est\'e3o presentes. \line O compilador executa um processo de correspond\'eancia para determinar qual fun\'e7\'e3o chamar quando uma fun\'e7\'e3o \'e9 invocada. Primeiro, o compilador tenta achar e usar uma correspond\'eancia precisa, na qual os nomes da fun\'e7\'e3o e os tipos de par\'e2metro coincidem exatamente com aqueles da chamada da fun\'e7\'e3o. Se isto falha, o compilador verifica se est\'e1 dispon\'edvel um gabarito de fun\'e7\'e3o que pode ser usado para gerar uma fun\'e7\'e3o gabarito com uma correspond\'eancia precisa de nome da fun\'e7\'e3o e tipos de par\'e2metros. Se tal gabarito de fun\'e7\'e3o \'e9 encontrado, o compilador gera e usa a fun\'e7\'e3o gabarito apropriada. \line Erro comum deprogramna\'e7\'e3o 12.3 \line O compilador executa um processo de correspond\'eancia para determinar qualfun\'e7\'e3o chamar quando uma fun\'e7\'e3o \'e9 invocada. Se nenhuma correspond\'eancia pode ser encontrada ou se o processo de correspond\'eancia produz correspond\'eancias m\'faltiplas, \'e9 gerado um erro de compila\'e7\'e3o. \line 12.4 Gabaritos de classe \line\'c9 poss\'edvel se compreender o que \'e9 uma pilha (uma estrntura de dados na qual inserimos itens em uma ordem e recuperamos os mesmos na ordem inversa, ou seja, \ldblquote\'faltimo a entrar, primeiro a sair\rdblquote ), independentemente do tipo dos itens que est\'e3o sendo colocados na pilha. Mas quando chega o momento de efetivamente instanciar uma pilha, um tipo de dados deve ser especificado. Isto cria uma oportunidade maravilhosa para a reutiliza\'e7\'e3o de software. Necessitamos dos meios de descrever a no\'e7\'e3o de uma pilha genericamente e instanciar classes que s\'e3o vers\'f5es desta classe gen\'e9rica para tipos espec\'edficos. Este recurso \'e9 fornecido por gabaritos de classe em C++. \line Observa\'e7\'e3o de engenharia de software 12.2 \line _______ Os gabaritos de classe incentivam a reutiliza\'e7\'e3o de software, possibilitando que sejam instanciadas vers\'f5es de classes gen\'e9ricas para tipos espec(ficos. \line Gabaritos de classe s\'e3o chamados de tipos parametrizados porque exigem um ou mais par\'e2metros de tipo para especificar como personalizar um gabarito de uma \ldblquote classe gen\'e9rica\rdblquote  para formar um gabarito de classe espec\'edfico. \line O programador que deseja produzir diversas classes gabarito simplesmente escreve uma defini\'e7\'e3o de gabarito de classe. Toda vez que o programador necessita de uma nova instancia\'e7\'e3o espec\'edfica para um tipo, o programador usa uma nota\'e7\'e3o concisa, simples e o compilador escreve o c\'f3digo-fonte para a classe gabarito de que o programa- dor necessita. Um gabarito de classe Stack, por exemplo, poderia assim se tornar a base para criar muitas classes Stack (tais como \ldblquote Stack de double\rdblquote , \ldblquote Stack de int\rdblquote . \ldblquote Stack de char\rdblquote . \ldblquote  Stack de Employee\rquote . etc.) usadas em um programa. \line Note a defini\'e7\'e3o do gabarito de classe Stack na Fig. 12.3. Parece com uma defini\'e7\'e3o de classe convencional, a n\'e3o ser pelo fato de ser precedida pelo cabe\'e7alho (linha 6) \line template< class T > \line para especificar que esta \'e9 uma defini\'e7\'e3o de gabarito de classe com o par\'e2metro de tipo T indicando o tipo da classe de Stack a ser criada. O programador n\'e3o necessita usar especificamente o identificador T - qualquer identificador \par
CAP\'cdTULO 12 - GABARITOS 685 \line pode ser usado, O tipo de elemento a ser armazenado nessa Stack \'e9 mencionado somente genericamente como T, em todo o cabe\'e7alho de classe de Stack e nas defini\'e7\'f5es das fun\'e7\'f5es membro. Mostraremos em breve como T torna-se associado com um tipo espec\'edfico, tal como double ou int. Existem duas restri\'e7\'f5es para tipos de dados n\'e3o-primitivos usados com esta Stack: eles devem ter um construtor default e devem suportar o operador de atribui\'e7\'e3o. Se um objeto da classe usada com esta Stack cont\'e9m mem\'f3ria alocada dinamicamente, o operador de atribui\'e7\'e3o deve ser sobrecarregado para aquele tipo, como mostrado no Cap\'edtulo 8. \line 1 II Fig. 12.3: tstackl.h \line 2 // Gabarito de classe Stack \line 3 #ifndef TSTACK1H \line 4 #define TSTACK1H \line 5 \line 6 template< class T > \line 7 class Stack \line 8 public: \line 9 Stack( int = 10 ); // construtor default (tamanho da pilha 10) \line 10 -\lquote Stack() \{ delete [] stackPtr; ) II destruidor \line 11 bool push( const T& ); II insere um elemento na pilha \line 12 bool pop( T& ); II retira um elemento da pilha \line 13 private: \line 14 int size; II quantidade de elementos na pilha \line 15 int top; II posi\'e7\'e3o do elemento do topo da pilha \line 16 T *stackptr; II ponteiro para a pilha \line 17 \line 18 bool isEmpty() const \{ return top == -1; \} II fun\'e7\'f5es \line 19 bool isFull() const ( return top == size - 1; \} II utilit\'e1rias \line 20 \line 21 \line 22 // Construtor com tamanho default 10 \line 23 template< class T > \line 24 Stack< T >::Stack( int s \line 25 \line 26 size = s > O ? s : 10; \line 27 top = -1; // inicialmente, Stack est\'e1 vazia \line 28 stackPtr = new T[ size ]; // aloca espa\'e7o para elementos \line 29 \} \line 30 \line 31 II Insere uni elemento na pilha \line 32 // retorna 1 se bem-sucedida, O caso contr\'e1rio \line 33 template< class T > \line 34 bool Stack< T >::push( const T &pushValue \line 35 \{ \line 36 if ( \lquote isFull() ) \{ \line 37 stackPtr[ ++top ] pushValue; II coloca item em Stack \line 38 return true; II push bem-sucedida \line 39 1 \line 40 return false; II push malsucedida \line 41 \line 42 \line 43 // Retira um elemento da pilha \line 44 template< class T > \line 45 bool Stack< T >: :pop( T &popValue \line 46 \{ \line 47 if ( !isEmpty() ) \{ \line 48 popValue = stackPtr[ top- ]; II remove item de Stack \line 49 return true; // pop bem-sucedida \line 50 \line Fig. 12.3 Demonstrando o gabarito de classe Stack - tstackl .h (parte 1 de 2). \par
686 C++ COMO PROGRAMAR \line 51 return false; II pop malsucedida \line 52 \} \line 53 \line 54 #endif \line Fig. 12.3 Demonstrando o gabarito de coasse Stack - tstackl .h parte 2 ae 2). \line Agora consideremos o programa (fun\'e7\'e3o main) que testa o funcionamento do gabarito de classe Stack (ver a sa\'edda na Fig. 12.3). O programa de teste come\'e7a por instanciar o objeto doubleStack, de tamanho 5. Esse objeto \'e9 declarado como sendo da classe Stack< double> (pronunciado \ldblquote Stack de double\rdblquote ). O compilador associa o tipo double com o par\'e2metro de tipo T no gabarito, para produzir o c\'f3digo-fonte para uma classe Stack do tipo double. Embora o programador n\'e3o veja este c\'f3digo-fonte, ele \'e9 inclu\'eddo no c\'f3digo-fonte e compilado. \line 55 II Fig. 12.3: figl2O3.cpp \line 56 II Programa de teste para o gabarito Stack \line 57 #include <iostream> \line 58 \line 59 using std: :cout; \line 60 using std: :cin; \line 61 using std: :endl; \line 62 \line 63 #include \ldblquote tstackl.h\rdblquote  \line 64 \line 65 int main() \line 66 \{ \line 67 Stack< double > doubleStack( 5 ); \line 68 double f 1.1; \line 69 cout \'ab \ldblquote Inserindo elementos em doubleStack\\n\rdblquote ; \line 70 \line 71 while ( doubleStack.push( f ) ) \{ II sucesso: true retornado \line 72 cout\'abf\'ab \lquote  \line 73 f + 1.1; \line 74 \} \line 75 \line 76 cout \'ab \ldblquote\\nStack est\'e1 cheia. N\'e3o pode inserir \'ab f \line 77 \'ab \ldblquote\\n\\nRetirando elementos de doubleStack\\n\rdblquote ; \line 78 \line 79 while ( doubleStack.pop( f ) ) II sucesso: true retornado \line 80 cout \'ab f \'ab , \line 81 \line 82 cout \'ab \ldblquote\\nStack est\'e1 vazia. N\'e3o pode retirar\\n\rdblquote ; \line 83 \line 84 Stack< int > intStack; \line 85 inti=1; \line 86 cout \'ab \ldblquote\\nlnserindo elementos em intStack\\n\rdblquote ; \line 87 \line 88 while ( intStack.push( i ) ) \{ II sucesso: true retornado \line 89 cout \'ab i \'ab \line 90 \line 91 \} \line 92 \line 93 cout \'ab \ldblquote\\nStack est\'e1 cheia. N\'e3o pode inserir \ldblquote  \'ab i \line 94 \'ab \ldblquote\\n\\nRetirando elementos de intStack\\n\rdblquote ; \line 95 \line 96 while ( intStack.pop( i ) ) II sucesso: true retornado \line 97 cout\'abi\'ab \lquote  \line Fig. 12.3 Demonstrando o gabarito de classe Stack - figl2_03 . cpp (parte 1 de 2). \par
CAP\'cdTULO 12 - GABARITOS 687 \line 98 \line 99 cout \'ab \\nStack est\'e1 vazia. N\'e3o pode retirar\\n\rdblquote ; \line 100 return 0; \line 101 \line Inserindo elementos em doubleStack 1 \line 1.1 2.2 3.3 4.4 5.5 \line Stack est\'e1 cheia. N\'e3o pode inserir 6.6 \line Retirando elementos de doubleStack \line 5.5 4.4 3.3 2.2 1.1 \line Stack est\'e1 vazia. N\'e3o pode retirar \line Inserindo elementos em intStack \line 1 2 3 4 5 6 7 8 9 10 \line Stack est\'e1 cheia. N\'e3o pode inserir 11 \line Retirando elementos de intStack \line 10 9 8 7 6 5 4 3 2 1 \line Stack est\'e1 vazia. N\'e3o pode retirar \line Fig. 12.3 Demonstrando o gabarito de classe Stack - figl2_03 . cpp (parte 2 de 2). \line O programa de teste ent\'e3o insere, sucessivamente, os valores double 1. 1,2.2,3.3,4.4 e 5.5 em doublestack. \line O la\'e7o de push termina quando o programa de teste tenta inserir um sexto valor em doubleStack (que j\'e1 est\'e1 \line cheia, porque foi criada para manter um m\'e1ximo de cinco elementos). \line O programa de teste agora retira os cinco valores da pilha (note na Fig. 12.3 que os valores s\'e3o retirados na ordem \ldblquote\'faltimo a entrar, primeiro a sair\rdblquote ), O programa de teste tenta retirar um sexto valor, mas doubleStack agora est\'e1 vazio, assim o la\'e7o de pop termina. \line Em seguida, o programa de teste instancia a pilha de inteiros intStack com a declara\'e7\'e3o \line Stack< int > intStack; \line (pronunciada \ldblquote intStack \'e9 um Stack de int\rdblquote ). Como nenhum tamanho foi especificado, o tamanho assume o valor default 10, conforme especificado no construtor default (linha 24). Uma vez mais, o programa de teste executa um la\'e7o de inser\'e7\'e3o de valores em intStack at\'e9 que ela esteja cheia e, ent\'e3o, executa itera\'e7\'f5es de retirada de valores de intStack at\'e9 que ela esteja vazia. Uma vez mais, os valores s\'e3o retirados na ordem \ldblquote\'faltimo a entrar, primeiro a sair\rdblquote . \line As defini\'e7\'f5es de fun\'e7\'f5es membro fora da classe come\'e7am, cada uma, com o cabe\'e7alho (linha 23) \line template< class T > \line Ent\'e3o, cada defini\'e7\'e3o se assemelha a uma defini\'e7\'e3o convencional de fun\'e7\'e3o, exceto pelo fato de que o tipo de elemento de Stack \'e9 sempre listado genericamente como o par\'e2metro de tipo T. O operador de resolu\'e7\'e3o de escopo bin\'e1rio \'e9 usado com o nome do gabarito de classe Stack< T > para amarrar cada defini\'e7\'e3o de fun\'e7\'e3o membro ao escopo do gabarito de classe. Neste caso, o nome de classe \'e9 Stack< T >. Quando doubleStack \'e9 instanciado como sendo do tipo Stack< double >, o constructor de Stack usa new para criar um array de elementos do tipo double para representar a pilha (linha 28). O comando \line stackPtr = new T[ size ]; \line na defini\'e7\'e3o do gabarito de classe de Stack \'e9 gerado pelo compilador na classe gabarito Stack< double > como \line stackPtr = new double[ size ]; \par
688 C+\'f7 COMO PROGRAMAR \par
Note que o c\'f3digo na fun\'e7\'e3o main da Fig. 12.3 \'e9 quase id\'eantico a ambas as manipula\'e7\'f5es de doubleStack na metade superior de main e as manipula\'e7\'f5es de intStack na metade inferior de main. Isto nos apresenta uma outra oportunidade para usar um gabarito de fun\'e7\'e3o. A Fig. 12.4 usa o gabarito de fun\'e7\'e3o testStack para executar as mesmas tarefas que main na Fig. 12.3 - insere uma s\'e9rie de valores em uma Stack< T > e retira os valores de uma Stack< T >. O gabarito de fun\'e7\'e3o testStack usa o par\'e2metro de tipo formal T para representar o tipo de dados armazenados na Stack< T >. O gabarito de fun\'e7\'e3o aceita quatro par\'e2metros - uma refer\'eancia para um objeto do tipo Stack< T >, um valor do tipo T que ser\'e1 o primeiro valor inserido no Stack< T >, um valor do tipo T usado para incrementar os valores inseridos no Stack< T > e um string de caracteres do tipo const char \line * que representa o nome do objeto Stack< T > para fins de sa\'edda de dados. A fun\'e7\'e3o main, agora, simplesmente instancia um objeto do tipo Stack< double > chamado doubleStack e um objeto do tipo Stack< int > chamado intStack e usa estes objetos nas linhas 42 e 43 \line testStack( doubleStack, 1.1, 1.1, \lquote doubleStack\rquote  ); \line testStack( intStack, 1, 1, \ldblquote intStack\rdblquote  ); \line Note que a sa\'edda da Fig. 12.4 corresponde precisamente \'e0 sa\'edda da Fig. 12.3. \line 1 II Fig. 12.4: figl2O4.cpp \line 2 II Programa de teste para o gabarito Stack. \line 3 II A fun\'e7\'e3o main usa um gabarito de fun\'e7\'e3o para \line 4 // manipular objetos do tipo Stack< T >. \line 5 #include <iostream> \line 6 \line 7 using std: :cout; \line 8 using std: :cin; \line 9 using std: :endl; \line 10 \line #include \ldblquote tstackl .h\rquote  \line II Gabarito de fun\'e7\'e3o para \line template< class T > \line void testStack( \line Stack< T > &theStack, \line T value, \line T increment, \line const char *stackName \line cout \'ab \ldblquote\\Inserindo elementos em \'ab stackName \'ab \\I; \line while ( theStack.push( value ) ) \{ II sucesso: true retornado cout \'ab value \'ab \line value += increment; \line cout \'ab \lquote\\nPilha est\'e1 cheia. N\'e3o pode inserir \'ab value \line\'ab \ldblquote\\n\\nRetirando elementos de \'ab stackName \'ab \lquote\\n\rquote ; \line while ( theStack.pop( value ) ) II sucesso: true retornado cout \'ab value \'ab \line cout \'ab \ldblquote\\nPilha est\'e1 vazia. N\'e3o pode retirar \\n\rdblquote ; \line int main() \par
manipular Stack< T > \line II refer\'eancia ao Stack< T > \line // valor inicial a ser inserido \line // incremento para valores subseq\'fcentes \line // nome do objeto Stack < T > \par
11 \line 12 \line 13 \line 14 \line 15 \line 16 \line 17 \line 18 \line 19 \line 20 \line 21 \line 22 \line 23 \line 24 \line 25 \line 26 \line 27 \line 28 \line 29 \line 30 \line 31 \line 32 \line 33 \line 34 \line 35 \line 36 \line 37 \line 38 \par
Fig. 12.4 Passando um objeto gabarito Stack para um gabarito de fun\'e7\'e3o (parte 1 de 2). \par
CAP\'cdTULO 12 - GABARITOS 689 \line 39 Stack< double > doubleStack( 5 ); \line 40 Stack< int > intStack; \line 41 \line 42 testStack( doubleStack, 1.1, 1.1, \ldblquote doubleStack\rdblquote  ); \line 43 testStack( intStack, 1, 1, \ldblquote intStack\rdblquote  ); \line 44 \line 45 return 0; \line 46 \} \line Inserindo elementos em doubleStack \line 1.1 2.2 3.3 4.4 5.5 \line Pilha est\'e1 cheia. N\'e3o pode inserir 6.6 \line Retirando elementos de doubleStack \line 5.5 4.4 3.3 2.2 1.1 \line Pilha est\'e1 vazia. N\'e3o pode retirar \line Inserindo elementos em intStack \line 1 2 3 4 5 6 7 8 9 10 \line Pilha est\'e1 cheia. N\'e3o pode inserir 11 \line Retirando elementos de intStack \line 10 9 8 7 6 5 4 3 2 1 \line Pilha est\'e1 vazia. N\'e3o pode retirar \line Fig. 12.4 Passando um objeto gabarito Stack para um gabarito de fun\'e7\'e3o (parte 2 de 2). \line 12.5 Gabaritos de classe e par\'e2metros n\'e3o-tipo \line O gabarito de classe Stack da se\'e7\'e3o anterior usou somente par\'e2metros de tipo no cabe\'e7alho do gabarito. Tamb\'e9m \line\'e9 poss\'edvel usar par\'e2metros n\'e3o-tipo; um par\'e2metro n\'e3o-tipo pode ter um argumento default e o par\'e2metro n\'e3o-tipo \line\'e9 tratado como const. Por exemplo, o cabe\'e7alho do gabarito poderia ser modificado para aceitar um par\'e2metro \line int elements. como segue: \line template< class T, int elements > //note par\'e2metro n\'e3o-tipo \line Ent\'e3o, um declara\'e7\'e3o tal como \line Stack< double, 100 > mostRecentSalesFigures; \line iria instanciar durante a compila\'e7\'e3o) uma classe gabarito Stack de 100 elementos chamaaa mostRecentSalesFigures de valores double: esta classe gabarito seria do tipo Stack< double, 100 \line >. O cabe\'e7alho de classe pode ent\'e3o conter um membro de dados private com uma declara\'e7\'e3o de array tal como \line T stackHolder[ elements ]; // array para guardar o conte\'fado da pilha \line Dica de desempenho 12.2 \line Quando \'e9 poss\'edvelfaz\'ea-lo, especificar o tamanho de uma classe cont\'eainer (tal como uma classe array ou \line uma classe pilha) durante a compila\'e7\'e3o (possivelmente atrav\'e9s de um par\'e2metro de gabarito n\'e3o-tipo \line para o tamanho) elimina o overhead de criar o espa\'e7o dinamicamente com new durante a execu\'e7\'e3o. \line Observa\'e7\'e3o de engenharia de software 12.3 \line Quando \'e9 poss\'edvel faz\'ea-lo, especificar o tamanho de um cont\'eainer durante a compila\'e7\'e3o (possivelmente atrav\'e9s de um par\'e2metro de gabarito n\'e3o-tipo para o tamanho) evita a possibilidade de um erro potencialmente fatal durante a execu\'e7\'e3o se new ficar impossibilitado de obter a mem\'f3ria necess\'e1ria. \par
690 C++ COMO PROGRAMAR \line Nos exerc\'edcios, ser\'e1 pedido a voc\'ea para usar um par\'e2metro n\'e3o-tipo para criar um gabarito para a classe Array desenvolvida no Cap\'edtulo 8, \ldblquote Sobrecarga de operadores\rdblquote . Este gabarito possibilitar\'e1 a objetos Array serem instanciados com um n\'famero especificado de elementos de um tipo especificado durante a compila\'e7\'e3o, em vez de criar espa\'e7o dinamicamente para os objetos Array durante a execu\'e7\'e3o. \line Uma classe para um tipo espec\'edfico, o qual n\'e3o corresponde a um gabarito de classe comum, pode ser fornecida para redefinir o gabarito da classe para aquele tipo. Por exemplo, um gabarito de classe Array pode ser usado para instanciar um array de qualquer tipo. O programador pode optar por assumir o controle do instanciamento da classe Array de um tipo espec\'edfico, tal como Marciano. Isto \'e9 feito simplesmente formando a nova classe com um nome de classe Array< Marciano>. \line 12.6 Gabaritos e heran\'e7a \line Os gabaritos e a heran\'e7a se relacionam de v\'e1rios modos: \line\bullet  Um gabarito de classe pode ser derivado de uma classe gabarito. \line\bullet  Um gabarito de classe pode ser derivado de uma classe n\'e3o-gabarito. \line\bullet  Uma classe gabarito pode ser derivada de um gabarito de classe. \line\bullet  Uma classe n\'e3o-gabarito pode ser derivada de um gabarito de classe. \line 12.7 Gabaritos e friends \line Vimos que fun\'e7\'f5es e classes inteiras podem ser declaradas como friends de classes n\'e3o-gabarito. Com gabaritos de classe, os tipos \'f3bvios de friends podem ser declarados. A rela\'e7\'e3o de friend pode ser estabelecida entre um gabarito de classe e uma fun\'e7\'e3o global, uma fun\'e7\'e3o membro de outra classe (possivelmente uma classe gabarito) ou at\'e9 uma classe inteira (possivelmente uma classe gabarito). As nota\'e7\'f5es exigidas para estabelecer estas rela\'e7\'f5es de friends podem ser inc\'f4modas. \line Dentro de um gabarito de classe para a classe X que foi declarado com \line template< class T > class X \line uma declara\'e7\'e3o de friend da forma \line friend void f 10; \line torna a fun\'e7\'e3o fi um friend de toda classe gabarito instanciada a partir do gabarito de classe precedente. Dentro de um gabarito de classe para a classe X que foi declarado com \line template< class T > class X \line uma declara\'e7\'e3o de friend da forma \line friend void f2( X< T > & ); \line para um tipo particular T, tal como float, torna a fun\'e7\'e3o f2 (X< float> &) um friend somente de X< float>. Dentro de um gabarito de classe, voc\'ea pode declarar que uma fun\'e7\'e3o membro de outra classe \'e9 um friend \line de qualquer classe gabarito gerada a partir do gabarito de classe. Simplesmente nomeie a fun\'e7\'e3o membro da outra \par
CAP\'cdTULO 12 - GABARITOS 691 \par
classe usando o nome de classe e o operador de resolu\'e7\'e3o de escopo bin\'e1rio. Por exemplo, dentro de um gabarito de classe para a classe x que foi declarado com \line template< class T > class X \line uma declara\'e7\'e3o de friend da forma \line friend void A::f40; \line torna a fun\'e7\'e3o membro f4 da classe A um friend de toda classe gabarito instanciada a partir do gabarito de classe precedente. \line Dentro de um gabarito de classe para a classe X que foi declarado com \line template< class T > class X \line uma declara\'e7\'e3o de friend da forma \line frierid void C < T >: :f5( X< T > & ); \line para um tipo particular T, tal como float, torna a fun\'e7\'e3o membro \line C < float >::f5( X< float > & \line uma fun\'e7\'e3o friend somente da classe gabarito X < float > \line Dentro de um gabarito de classe para a classe X que foi declarado com \line template< class T > class X \line uma segunda classe Y pode ser declarada com \line friend class Y; \line tornando toda fun\'e7\'e3o membro da classe Y um friend de toda classe gabarito produzida a partir do gabarito de classe para X. \line Dentro de um gabarito de classe para a classe X que foi declarado com \line template< class T > class X \line uma segunda classe Z pode ser declarada com \line friend class Z< T >; \line ent\'e3o, quando uma classe gabarito \'e9 instanciada com um tipo particular para T, tal como float, todos os membros de class Z< float > tornam-se friends da classe gabarito X< float >. \line 12.8 Gabar\'edtos e membros static \line E os membros de dados static ? Lembre que, com uma classe n\'e3o-gabarito, uma c\'f3pia de um membro de dados static \'e9 compartilhada entre todos os objetos da classe e o membro de dados static deve ser inicializado em escopo de arquivo. \line Cada classe gabarito instanciada a partir de um gabarito de classe tem sua pr\'f3pria c\'f3pia de cada membro de dados static do gabarito de classe; todos os objetos daquela classe gabarito compartilham aquele membro de dados static. E como com membros de dados static de classes n\'e3o-gabarito, membros de dados static de classes gabarito devem ser inicializados em escopo de arquivo. Cada classe gabarito obt\'e9m sua pr\'f3pria c\'f3pia das fun\'e7\'f5es membro est\'e1ticas do gabarito de classe. \par
692 C++ COMO PROGRAMAR \par
\bullet  Gabaritos nos possibilitam especificar uma gama de fun\'e7\'f5es relacionadas (sobrecarregadas) - chamadas de fun\'e7\'f5es gabarito \line - ou uma gama de classes relacionadas - chamadas de classes gabarito. \line\bullet  Para usar gabaritos de fun\'e7\'e3o, o programador escreve uma \'fanica defini\'e7\'e3o de gabarito de fun\'e7\'e3o. Com base nos tipos dos argumentos fornecidos em chamadas para esta fun\'e7\'e3o, C\'f7+ gera fun\'e7\'f5es separadas para tratar de cada tipo de chamada apropriadamente. Elas s\'e3o compiladas junto com o resto do c\'f3digo-fonte de um programa. \line\bullet  Todas as defini\'e7\'f5es de gabarito de fun\'e7\'e3o come\'e7am com a palavra-chave template seguida por par\'e2metros de tipo formais para o gabarito de fun\'e7\'e3o incluso entre sinais de maior e menor (< e >); cada par\'e2metro formal deve ser precedido pela \line palavra-chave class (ou typename). A palavra-chave class (ou typename) \'e9 usada para especificar par\'e2metros de tipo de gabaritos de fun\'e7\'e3o significando \ldblquote qualquer tipo primitivo ou um tipo definido pelo usu\'e1rio\rdblquote . \line\bullet  Os par\'e2metros de tipo formais de defini\'e7\'f5es de gabaritos s\'e3o usados para especificar os tipos dos par\'e2metros para a fun\'e7\'e3o, o tipo de retorno da fun\'e7\'e3o e para declarar vari\'e1veis na fun\'e7\'e3o. \line\bullet  O nome de um par\'e2metro de tipo formal pode ser usado somente uma vez na lista de par\'e2metros de um cabe\'e7alho de gabarito. Os nomes de par\'e2metro de tipo formais de gabaritos de fun\'e7\'f5es n\'e3o necessitam ser \'fanicos. \line\bullet  Um gabarito de fun\'e7\'e3o pode ser ele pr\'f3prio sobrecarregado de v\'e1rios modos. Podemos fornecer outros gabaritos de fun\'e7\'e3o que especificam o mesmo nome de fun\'e7\'e3o, mas par\'e2metros de fun\'e7\'e3o diferentes. Um gabarito de fun\'e7\'e3o pode tamb\'e9m ser \line sobrecarregado fornecendo-se outras fun\'e7\'f5es n\'e3o-gabarito com o mesmo nome de fun\'e7\'e3o, mas par\'e2metros de fun\'e7\'e3o diferentes. \line\bullet  Gabaritos de classe fornecem os meios para descrever uma classe genericamente e instanciar classes que s\'e3o vers\'f5es espec\'edficas desta classe gen\'e9rica para um tipo. \line\bullet  Gabaritos de classe s\'e3o chamados de tipos de parametrizados; eles requerem par\'e2metros de tipo para especificar como personalizar um gabarito de classe gen\'e9rico para formar uma classe gabarito espec\'edfica. \line\bullet  O programador que deseja usar classes gabarito escreve um gabarito de classe. Quando o programador necessita de uma nova classe para um tipo espec\'edfico, o programador usa uma nota\'e7\'e3o concisa e o compilador escreve o c\'f3digo-fonte para a classe gabarito. \line\bullet  Uma defini\'e7\'e3o de gabarito de classe se parece com uma defini\'e7\'e3o de classe convencional, a n\'e3o ser que ela \'e9 precedida por template< class T > ( ou template< typeriaxne T >), para indicar que esta \'e9 uma defini\'e7\'e3o de gabarito de classe \line com o par\'e2metro de tipo T indicando o tipo da classe a ser criada. O tipo T \'e9 mencionado ao longo do cabe\'e7alho de classe e das defini\'e7\'f5es de fun\'e7\'f5es membro, como um nome de tipo gen\'e9rico. \line\bullet  As defini\'e7\'f5es de fun\'e7\'f5es membro fora da classe come\'e7am cada uma com o cabe\'e7alho template< class T > (ou template< typename T>) . Ent\'e3o, cada defini\'e7\'e3o de fun\'e7\'e3o se assemelha a uma defini\'e7\'e3o de fun\'e7\'e3o convencional, a n\'e3o ser que os \line dados gen\'e9ricos na classe s\'e3o sempre listados genericamente como par\'e2metros do tipo T. O operador de resolu\'e7\'e3o de escopo bin\'e1rio \'e9 usado com o nome do gabarito de classe para amarrar cada defini\'e7\'e3o de fun\'e7\'e3o membro ao escopo do gabarito de \line classe, como em ClassName< T>. \line\bullet  \'c9 poss\'edvel se usar par\'e2metros n\'e3o-tipo no cabe\'e7alho de um gabarito de classe. \line\bullet  Uma classe para um tipo espec\'edfico pode ser fornecida para sobrescrever o gabarito de classe para aquele tipo. \line\bullet  Um gabarito de classe pode ser derivado de uma classe gabarito. Um gabarito de classe pode ser derivado de uma classe n\'e3o- gabarito. Uma classe gabarito pode ser derivada de um gabarito de classe. Uma classe n\'e3o-gabarito pode ser derivada de um gabarito de classe. \line\bullet  Fun\'e7\'f5es e classes inteiras podem ser declaradas como friends de classes n\'e3o-gabarito. Com gabaritos de classe, os tipos \'f3bvios de friends poss\'edveis podem ser declarados. A rela\'e7\'e3o de friend pode ser estabelecida entre um gabarito de classe \line e uma fun\'e7\'e3o global, uma fun\'e7\'e3o membro de outra classe (possivelmente uma classe gabarito) ou at\'e9 uma classe inteira (possivelmente uma classe gabarito). \line\bullet  Cada classe gabarito instanciada de um gabarito de classe tem sua pr\'f3pria c\'f3pia de cada membro de dados static do gabarito de classe; todos os objetos daquela classe gabarito compartilham aquele membro de dados static. E, como com \line os membros de dados static de classes n\'e3o-gabarito, membros de dados static de classes gabarito devem ser inicializados em escopo de arquivo. \par
Resumo \par
lii \par
\bullet  Cada classe gabarito obt\'e9m uma c\'f3pia das fun\'e7\'f5es membro static do gabarito de classe. \par
CAP\'cdTULO 12 - GABARITOS 693 \par
Terminologia \line argumento de gabarito \line classe gabarito \line declara\'e7\'e3o de gabarito de fun\'e7\'e3o \line defini\'e7\'e3o de gabarito de fun\'e7\'e3o \line friend de um gabarito \line fun\'e7\'e3o gabarito \line fun\'e7\'e3o membro de classe gabarito \line fun\'e7\'e3o membro static de um gabarito de classe fun\'e7\'e3o membro static de uma classe gabarito gabarito de classe \line gabarito de fun\'e7\'e3o \line membro de dados static de um gabarito de classe membro de dados static de uma classe gabarito \line Erros comuns de programa\'e7\'e3o \par
nome de gabarito \line nome de gabarito de classe \line palavra-chave class em um par\'e2metro de tipo de gabarito palavra-chave template \line par\'e2metro de gabarito \line par\'e2metro de tipo em um cabe\'e7alho de gabarito par\'e2metro n\'e3o-tipo em um cabe\'e7alho de gabarito par\'e2metro de tipo formal em um cabe\'e7alho de gabarito sinais de menor e maior (< e>) \line sobrecarregando uma fun\'e7\'e3o gabarito \line template<class T> \line tipo parametrizado \line typename \par
12.1 N\'e3o colocar class (ou typenalne) antes de cada par\'e2metro formal de tipo de um gabarito de fun\'e7\'e3o. \line 12.2 Se um gabarito \'e9 invocado com um tipo de classe definido pelo usu\'e1rio e se esse gabarito usa operadores (como ==. <=, etc.) com objetos do tipo daquela classe, ent\'e3o aqueles operadores devem ser sobrecarregados! Esquecer de sobrecarregar tais operadores provoca erros, porque o compilador, naturalmente, ainda gera chamadas \'e0s fun\'e7\'f5es operador sobrecarregado apropriadas, apesar do fato de que estas fun\'e7\'f5es n\'e3o est\'e3o presentes. \line 12.3 O compilador executa um processo de correspond\'eancia para determinar qual fun\'e7\'e3o chamar quando uma fun\'e7\'e3o \'e9 invocada. Se nenhuma correspond\'eancia pode ser encontrada ou se o processo de correspond\'eancia produz correspond\'eancias m\'faltiplas, \'e9 gerado um erro de compila\'e7\'e3o. \line Dicas de desempenho \line 12.1 Gabaritos certamente oferecem os benef\'edcios de reutiliza\'e7\'e3o de software. Mas tenha em mente que m\'faltiplas c\'f3pias de fun\'e7\'f5es gabarito e classes gabarito ainda s\'e3o instanciadas em um programa, apesar do fato de que o gabarito \'e9 escrito somente uma vez. Estas c\'f3pias podem consumir mem\'f3ria consider\'e1vel. \line 12.2 Quando \'e9 poss\'edvel faz\'ea-lo, especificar o tamanho de uma classe cont\'eainer (tal como uma classe array ou uma classe pilha) durante a compila\'e7\'e3o (possivelmente atrav\'e9s de um par\'e2metro de gabarito n\'e3o-tipo para o tamanho) elimina o overhead de criar o espa\'e7o dinamicamente com new durante a execu\'e7\'e3o. \line Observa\'e7\'f5es de engenharia de software \line 12.1 Os gabaritos s\'e3o um dos recursos mais poderosos de C++ para a reutiliza\'e7\'e3o de software. \line 12.2 Os gabaritos de classe incentivam a reutiliza\'e7\'e3o de software, possibilitando que sejam instanciadas vers\'f5es de classes gen\'e9ricas para tipos espec\'edficos. \line 12.3 Quando \'e9 poss\'edvel faz\'ea-lo, especificar o tamanho de um cont\'eainer durante a compila\'e7\'e3o (possivelmente atrav\'e9s de um par\'e2metro de gabarito n\'e3o-tipo para o tamanho) evita a possibilidade de um erro potencialmente fatal durante a execu\'e7\'e3o se new ficar impossibilitado de obter a mem\'f3ria necess\'e1ria. \line Dica de teste e depura \'e7\'e3o \line 12.1 Gabaritos de fun\'e7\'e3o, como macros, possibilitam a reutiliza\'e7\'e3o de software. Mas, diferentemente de macros, gabaritos de fun\'e7\'e3o ajudam a eliminar muitos tipos de erros por causa do escrut\'ednio da verifica\'e7\'e3o de tipo completa de C++. \line Exerc\'edcios de auto-revis\'e3o \line 12.1 Responda a cada um dos seguintes itens com verdadeiro ou falso. Para aqueles que s\'e3o falsos, mostre por qu\'ea. \line a) Uma fun\'e7\'e3o friend de um gabarito de fun\'e7\'e3o deve ser uma fun\'e7\'e3o gabarito. \line b) Se v\'e1rias classes gabarito s\'e3o geradas a partir de um \'fanico gabarito de classe com um \'fanico membro de dados static, cada uma das classes gabarito compartilha uma c\'f3pia \'fanica do membro de dados static do gabarito de \par
classe. \par
694 C++ COMO PROGRAMAR \par
c) Uma fun\'e7\'e3o gabarito pode ser sobrecarregada por outra fun\'e7\'e3o gabarito com o mesmo nome de fun\'e7\'e3o. \line d) O nome de um par\'e2metro de tipo formal pode ser usado somente uma vez na lista de par\'e2metros de tipo formais da \line defini\'e7\'e3o do gabarito. Os nomes de par\'e2metros de tipo formais entre defini\'e7\'f5es de gabaritos devem ser \'fanicos. \line e) As palavras-chave class e typenaine. como usadas com um par\'e2metro de tipo de um gabarito, significam especificamente \lquote qualquer tipo de classe definido pelo usu\'e1rio\rdblquote . \line 12.2 Preencher os espa\'e7os em branco em cada um dos seguintes itens: \line a) Gabaritos nos possibilitam especificar, com um segmento de c\'f3digo \'fanico, uma gama inteira de fun\'e7\'f5es relacionadas chamadas de ____________ ou uma gama inteira de classes relacionadas chamadas de ____________ \line b) Todas as defini\'e7\'f5es de gabaritos de fun\'e7\'e3o come\'e7am com a palavra-chave seguida por uma lista de par\'e2metros formais do gabarito de fun\'e7\'e3o inclusos entre ___________________ \line c) As fun\'e7\'f5es relacionadas geradas a partir de um gabarito de fun\'e7\'e3o t\'eam todas o mesmo nome, de modo que o compilador usa resolu\'e7\'e3o de para invocar a fun\'e7\'e3o apropriada. \line d) Gabaritos de classes s\'e3o tamb\'e9m chamados de tipos \line e) O operador \'e9 usado com um nome de classe gabarito para amarrar cada defini\'e7\'e3o de fun\'e7\'e3o membro ao escopo do gabarito de classe. \line f) Como com os membros de dados static de classes n\'e3o-gabarito, membros de dados static de classes gabarito tamb\'e9m devem ser inicializados em escopo de \line Respostas aos exerc\'edcios de auto-revis\'e3o \line 12.1 a) Falso. Poderia ser uma fun\'e7\'e3o n\'e3o-gabarito. b) Falso. Cada classe gabarito ter\'e1 uma c\'f3pia do membro de dados static. c) Verdadeiro. d) Falso. Os nomes de par\'e2metro de tipo formais entre fun\'e7\'f5es gabarito n\'e3o precisam ser \'fanicos. \line e) Falso. A palavra-chave class, neste contexto, tamb\'e9m permite um par\'e2metro de tipo de um tipo primitivo. \line 12.2 a) fun\'e7\'f5es gabarito, classes gabarito. b) template, sinais de menor e maior (< e >). c) sobrecarga. d) parametrizados. e) resolu\'e7\'e3o de escopo bin\'e1rio. f) arquivo. \line Exerc\'edcios \line 12.3 Escreva um gabarito de fun\'e7\'e3o bubbleSort baseado no programa de classifica\'e7\'e3o da Fig. 5.15. Escreva um programa de teste que l\'ea da entrada, classifica e envia para a sa\'edda um array int e um array float. \line 12.4 Sobrecarregue o gabarito de fun\'e7\'e3o printArray da Fig. 12.2 de forma que ele aceite dois par\'e2metros do tipo inteiro adicionais, quais sejam int lowSubscript e int highSubscript. Uma chamada a esta fun\'e7\'e3o imprimir\'e1 somente a parte indicada do array. Valide lowSubscript e highSubscript: se um deles estiver fora do intervalo ou se highSubscript for menor que ou igual a lowSubscript. a fun\'e7\'e3o sobrecarregada printArray deve retornar O; caso contr\'e1rio, printArray deve retornar o n\'famero de elementos impressos. A seguir, modifique main para testar ambas as vers\'f5es de printArray com os arrays a, b, e c. N\'e3o deixe de testar todos os recursos de ambas as vers\'f5es de printArray. \line 12.5 Sobrecarregue o gabarito de fun\'e7\'e3o printArray da Fig. 12.2 com uma vers\'e3o n\'e3o-gabarito que especificamente imprime um array de strings de caracteres em formato organizado. tabular. por colunas. \line 12.6 Escreva um gabarito de fun\'e7\'e3o simples para a fun\'e7\'e3o predicado elgualA que compara seus dois argumentos com o operador de igualdade (==) e retorna true se eles forem iguais e false se eles n\'e3o forem iguais. Use este gabarito de fun\'e7\'e3o em um programa que chama elgualA somente com diversos tipos primitivos. Agora, escreva, que uma vers\'e3o separada do programa que chama e IgualA com um tipo de classe definido pelo usu\'e1rio, mas n\'e3o sobrecarrega o operador de igualdade. O que acontece quando voc\'ea tenta executar este programa? Agora sobrecarregue o operador de igualdade (com a fun\'e7\'e3o operador operator==). O que acontece, agora, quando voc\'ea tenta executar este programa? \line 12.7 Use um par\'e2metro n\'e3o-tipo numeroDeElementos e um par\'e2metro de tipo TipoDeElemento para ajudar a criar um gabarito para a classe Array que desenvolvemos no Cap\'edtulo 8, \ldblquote Sobrecarga de operadores\rdblquote . Este gabarito possibilitar\'e1 a objetos Array serem instariciados com um n\'famero especificado de elementos de um tipo de elemento especificado durante a compila\'e7\'e3o. \line 12.8 Escreva um programa com o gabarito de classe Array. O gabarito pode instanciar um Array de quaisquer tipos de \line elementos. Redefina o gabarito com uma defini\'e7\'e3o espec\'edfica para um Array de elementos float (class Array< float>). \line O programa de teste deve demonstrar a instancia\'e7\'e3o de um Array de ints a partir do gabarito e deve mostrar que uma tentativa \line de instanciar um Array de floats usa a defini\'e7\'e3o fornecida em class Array< float >. \par
1 \par
694 C++ COMO PROGRAMAR \par
c) Uma fun\'e7\'e3o gabarito pode ser sobrecarregada por outra fun\'e7\'e3o gabarito com o mesmo nome de fun\'e7\'e3o. \line d) O nome de um par\'e2metro de tipo formal pode ser usado somente uma vez na lista de par\'e2metros de tipo formais da defini\'e7\'e3o do gabarito. Os nomes de par\'e2metros de tipo formais entre defini\'e7\'f5es de gabaritos devem ser \'fanicos. \line e) As palavras-chave class e typename, como usadas com um par\'e2metro de tipo de um gabarito, significam especificamente \ldblquote qualquer tipo de classe definido pelo usu\'e1rio\rdblquote . \line 12.2 Preencher os espa\'e7os em branco em cada um dos seguintes itens: \line a) Gabaritos nos possibilitam especificar, com um segmento de c\'f3digo \'fanico, uma gama inteira de fun\'e7\'f5es relacionadas chamadas de ____________ ou uma gama inteira de classes relacionadas chamadas de ____________ \line b) Todas as defini\'e7\'f5es de gabaritos de fun\'e7\'e3o come\'e7am com a palavra-chave seguida por uma lista de par\'e2metros formais do gabarito de fun\'e7\'e3o inclusos entre ___________________ \line c) As fun\'e7\'f5es relacionadas geradas a partir de um gabarito de fun\'e7\'e3o t\'eam todas o mesmo nome, de modo que o compi lado usa resolu\'e7\'e3o de para invocar a fun\'e7\'e3o apropriada. \line d) Gabaritos de classes s\'e3o tamb\'e9m chamados de tipos \line e) O operador \'e9 usado com um nome de classe gabarito para amarrar cada defini\'e7\'e3o de fun\'e7\'e3o \line membro ao escopo do gabarito de classe. \line O Como com os membros de dados static de classes n\'e3o-gabarito, membros de dados static de classes gabarito tamb\'e9m devem ser inicializados em escopo de \line Respostas aos exerc\'edcios de auto-revis\'e3o \line 12.1 a) Falso. Poderia ser uma fun\'e7\'e3o n\'e3o-gabarito. b) Falso. Cada classe gabarito ter\'e1 uma c\'f3pia do membro de dados static. c) Verdadeiro. d) Falso. Os nomes de par\'e2metro de tipo formais entre fun\'e7\'f5es gabarito n\'e3o precisam ser \'fanicos. e) Falso. A palavra-chave class, neste contexto, tamb\'e9m permite um par\'e2metro de tipo de um tipo primitivo. \line 12.2 a) fun\'e7\'f5es gabarito, classes gabarito. b) template, sinais de menor e maior (< e >). e) sobrecarga. d) parametrizados. e) resolu\'e7\'e3o de escopo bin\'e1rio. f) arquivo. \line Exerc\'edcios \line 12.3 Escreva um gabarito de fun\'e7\'e3o bubbleSort baseado no programa de classifica\'e7\'e3o da Fig. 5.15. Escreva um programa de teste que l\'ea da entrada, classifica e envia para a sa\'edda um array int e um array float. \line 12.4 Sobrecarregue o gabarito de fun\'e7\'e3o printArray da Fig. 12.2 de forma que ele aceite dois par\'e2metros do tipo inteiro adicionais, quais sejam int lowSubscript e int highSubscript. Uma chamada a esta fun\'e7\'e3o imprimir\'e1 somente a parte indicada do array. Valide lowSubscript e highSubscript; se um deles estiver fora do intervalo ou se highSubscript for menor que ou igual a lowSubscript, a fun\'e7\'e3o sobrecarregada printArray deve retornar O; caso contr\'e1rio. printArray deve retornar o n\'famero de elementos impressos. A seguir, modifique main para testar ambas as vers\'f5es de printArray com os arrays a, b, e c. N\'e3o deixe de testar todos os recursos de ambas as vers\'f5es de priritArray. \line 12.5 Sobrecarregue o gabarito de fun\'e7\'e3o printArray da Fig. 12.2 com uma vers\'e3o n\'e3o-gabarito que especificamente imprime um array de strings de caracteres em formato organi7ado, tabular, por colunas. \line 12.6 Escreva um gabarito de fun\'e7\'e3o simples para a fun\'e7\'e3o predicado elgualA que compara seus dois argumentos com o operador de igualdade (==) e retoma true se eles forem iguais e false se eles n\'e3o forem iguais. Use este gabarito de fun\'e7\'e3o em um programa que chama elgualA somente com diversos tipos primitivos. Agora, escreva, que uma vers\'e3o separada do programa que chama elgualA com um tipo de classe definido pelo usu\'e1rio, mas n\'e3o sobrecarrega o operador de igualdade. O que acontece quando voc\'ea tenta executar este programa? Agora sobrecarregue o operador de igualdade (com a fun\'e7\'e3o operador operator==). O que acontece, agora, quando voc\'ea tenta executar este programa? \line 12.7 Use um par\'e2metro n\'e3o-tipo numeroDeElemeritos e um par\'e2metro de tipo TipoDeElemento para ajudar a criar um gabarito para a classe Array que desenvolvemos no Cap\'edtulo 8, \ldblquote Sobrecarga de operadores\rdblquote . Este gabarito possibilitar\'e1 a objetos Array serem instanciados com um n\'famero especificado de elementos de um tipo de elemento especificado durante a compila\'e7\'e3o. \line 12.8 Escreva um programa com o gabarito de classe Array. O gabarito pode instanciar um Array de quaisquer tipos de \line elementos. Redefina o gabarito com uma defini\'e7\'e3o espec\'edfica para um Array de elementos float (class Array< float>). \line O programa de teste deve demonstrar a instancia\'e7\'e3o de um Array de ints a partir do gabarito e deve mostrar que uma tentativa \line de instanciar um Array de floats usa a defini\'e7\'e3o fornecida em class Array< float >. \par
CAP\'cdTULO 12 - GABARITOS 695 \par
12.9 Qual a diferen\'e7a entre os termos \ldblquote gabarito de fun\'e7\'e3o\rdblquote  e \ldblquote fun\'e7\'e3o gabarito\rdblquote ? \line 12.10 O que se parece mais como um est\'eancil - um gabarito de classe ou uma classe gabarito? Explique sua resposta. \line 12.11 Qual \'e9 a rela\'e7\'e3o entre gabaritos de fun\'e7\'e3o e sobrecarga? \line 12.12 Por que voc\'ea optaria por usar um gabarito de fun\'e7\'e3o em vez de uma macro? \line 12.13 Que problema de desempenho pode resultar do uso de gabaritos de fun\'e7\'e3o e gabaritos de classe? \line 12.14 O compilador executa um processo de correspond\'eancia para determinar qual fun\'e7\'e3o gabarito chamar quando uma fun\'e7\'e3o \line\'e9 invocada. Em que circunst\'e2ncias uma tentativa de fazer uma correspond\'eancia pode provocar um erro de compila\'e7\'e3o? \line 12.15 Por que \'e9 apropriado chamar um gabarito de classe de um tipo parametrizado? \line 12.16 Explique por que voc\'ea poderia usar o comando \line Array< Employee > workerList( 100 ); \line em um programa em C++. \line 12.17 Revise sua resposta para o Exerc\'edcio 12.16. Agora, por que voc\'ea poderia usar o comando \line Array< Empioyee > workerList; \line em um programa em C++? \line 12.18 Explique o uso da seguinte nota\'e7\'e3o em um programa em C++: \line template< ciass T > Array< T >: :Array( int s ) \line 12.19 Por que voc\'ea poderia tipicamente usar um par\'e2metro n\'e3o-tipo com um gabarito de classe para um cont\'eainer tal como um array ou uma pilha? \line 12.20 Descreva como fornecer uma classe para um tipo espec\'edfico para sobrescrever o gabarito de classe para aquele tipo. \line 12.21 Descreva a rela\'e7\'e3o entre gabaritos de classe e heran\'e7a. \line 12.22 Suponha que um gabarito de classe tem o cabe\'e7alho \line tempiate< ciass Ti > ciass Ci \line Descreva os relacionamentos do tipo friend estabelecidos ao se colocar cada uma das seguintes declara\'e7\'f5es friend dentro deste cabe\'e7alho de gabarito de classe. Identificadores come\'e7ando com \ldblquote f \ldblquote s\'e3o fun\'e7\'f5es, identificadores come\'e7ando com \ldblquote C\rdblquote  s\'e3o classes e identificadores come\'e7ando com \ldblquote T\rdblquote  podem representar quaisquer tipos (i.e., tipos primitivos ou tipos de classe). \line a) friend void f 1Q; \line b) friend void f2( Ci< Ti > & ) \line c) friend void C2::f4( ); \line d) friend void C3< Ti >: :f5( Ci< Ti > & ) \line e) friend ciass C5; \line f) friend class C6< Ti >; \line 12.23 Suponha que o gabarito de classe Empregado tem um membro de dados static contagem. Suponha que tres classes gabarito s\'e3o instanciadas a partir do gabarito de classe. Quantas c\'f3pias do membro de dados static existir\'e3o? Como ser\'e1 restringido o uso de cada um (se for o caso)? \par
\pard\lang1033\f1\fs20\par
}
 