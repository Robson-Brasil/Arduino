{\rtf1\ansi\ansicpg1252\deff0\deflang1033{\fonttbl{\f0\froman\fprq2\fcharset0 Times New Roman;}{\f1\froman\fcharset0 Helvetica Narrow;}{\f2\froman\fcharset0 Helvetica, sans-serif;}{\f3\fmodern\fprq1\fcharset0 Courier;}{\f4\froman\fcharset0 Times New Roman;}}
\viewkind4\uc1\pard\sb100\sa240\lang2070\f0\fs16\par
 \fs24\par
\ul\b\i\f1\fs144 5 \ulnone\line\i0\f0\fs70 Ponteiros e \i\fs66 strings \par
\line\i0\f2\fs22 Objetivos \line\b0\f0\fs20\bullet  Ser capaz de usar ponteiros. \line\bullet  Ser capaz de usar ponteiros para passar argumentos para fun\'e7\'f5es atrav\'e9s de chamadas por refer\'eancia. \line\bullet  Entender as rela\'e7\'f5es pr\'f3ximas entre ponteiros, arrays e \i\fs18 strings. \line\i0\fs20\bullet  Entender o uso de ponteiros para fun\'e7\'f5es. \line\bullet  Ser capaz de declarar e usar arrays de \i\fs18 strings. \line Os endere\'e7os nos s\'e3o dados para ocultarmos nossos paradeiros. \line\i0\fs20 Saki (H. H. Munro) \line\i\fs18 Atrav\'e9s de indire\'e7\'f5es, encontre as dire\'e7\'f5es. \line\i0\fs20 William Shakespeare, Hamlet \line\i\fs18 Muitas coisas, estando em total anu\'eancia, \line podem funcionar de forma contr\'e1ria. \line\i0\fs20 William Shakespeare, King Henry V \line\i\fs18 Voc\'ea sempre pode encontrar uma pr\'e1tica muito boa para verificar suas refer\'eancias, senhor! \line\i0\fs20 Dr. Routh \line\i\fs18 Voc\'ea n\'e3o pode confiar num c\'f3digo que voc\'ea mesmo n\'e3o criou totalmente. (Especialmente um c\'f3digo feito por empresas que empregam pessoas como eu). \line\i0\fs20 Ken Thompson, 1983 Turing Award Lecture Association for Computing Machinery, mc. \fs24\par
\pard\par
\pard\sb100\sa240\b\f2\fs26 320 \fs20 C++ \b0\f0\fs18 COMO \b\f2\fs14 PROGRAMAR \line\ul\fs30 Vis\'e3o Geral \ulnone\line\fs20 5.1 Introdu\'e7\'e3o \line 5.2 Declara\'e7\'f5es e inicializa\'e7\'e3o de vari\'e1veis ponteiro \line 5.3 Operadores sobre ponteiros \line 5.4 Chamando fun\'e7\'f5es por refer\'eancia \line 5.5 Usando o qualificador \b0\f0\fs18 const \b\f2\fs20 com ponteiros \line 5.6 \i Bubbie Sort \i0 usando chamada por refer\'eancia \line\b0\fs18 57 \b\fs20 Express\'f5es com ponteiros e aritm\'e9tica de ponteiros \line 5.8 A rela\'e7\'e3o entre ponteiros e arrays \line 5.9 Arrays de ponteiros \line 5.10 Estudo de caso: uma simula\'e7\'e3o de embaralhamento e distribui\'e7\'e3o de cartas \line 5.11 Ponteiros de fun\'e7\'e3o \line 5.12 Introdu\'e7\'e3o ao processamento de caracteres e \i strings \line\i0 5.12.1 Fundamentos de caracteres e \i strings \line\i0 5.12.2 Fun\'e7\'f5es de manipula\'e7\'e3o de \i strings \i0 da biblioteca de tratamento de \i strings \line\i0 5.13 (Estudo de caso opcional) Pensando em objetos: colabora\'e7\'f5es entre objetos \line\b0\i\f0\fs18 Resumo\bullet  Terminologia Erros comuns de programa\'e7\'e3o Boas pr\'e1ticas de programa\'e7\'e3o Dicas de desempenho \i0\f2\fs12 . \i\f0\fs18 Dicas de portabilidade. Observa\'e7\'f5es de engenharia de software \i0\f2\fs12\bullet  \i\f0\fs18 Dica de teste e depura \'e7\'e3o. Exerc\'edcios de auto-revis\'e3o \i0\f2\fs12 . \i\f0\fs18 Respostas aos exerc\'edcios de auto-revis\'e3o \i0\f2\fs12\bullet  \i\f0\fs18 Exerc\'edcios Se\'e7\'e3o especial: construindo seu pr\'f3prio computador\bullet  Mais exerc\'edcios sobre ponteiros Exerc\'edcios de manipula\'e7\'e3o de \i0 strings\bullet  \i Se\'e7\'e3o especial: exerc\'edcios avan\'e7ados de manipula\'e7\'e3o de \i0 strings. \i Um projeto desafiador de manipula\'e7\'e3o de \i0 strings \line\b\f2\fs26 5.1 Introdu\'e7\'e3o \line\b0\f0\fs18 Neste cap\'edtulo, discutimos uma das caracter\'edsticas mais poderosas da linguagem de programa\'e7\'e3o C++, o ponteiro. Os ponteiros est\'e3o entre os recursos mais dif\'edceis de serem dominados de C++. No Cap\'edtulo 3, vimos que tefer\'eancias podem ser usadas para executar chamadas por refer\'eancia. Os ponteiros possibilitam aos programas simular chamadas por refer\'eancia e criar e manipular estruturas de dados din\'e2micas, i.e., estruturas de dados que podem crescer e encolher, tais como listas encadeadas, filas, pilhas e \'e1rvores. Este cap\'edtulo explica conceitos b\'e1sicos sobre ponteiros. Refor\'e7a tamb\'e9m a rela\'e7\'e3o \'edntima entre arrays, ponteiros e \i strings, \i0 e inclui uma boa rela\'e7\'e3o de exerc\'edcios de processamento de \i strings. \line\i0 O Cap\'edtulo 6 examina o uso de ponteiros com estruturas. Nos Cap\'edtulos 9 e 10, veremos que a programa\'e7\'e3o orientada a objetos \'e9 executada com ponteiros e refer\'eancias. O Cap\'edtulo 15 introduz t\'e9cnicas din\'e2micas de administra\'e7\'e3o de mem\'f3ria e apresenta exemplos de cria\'e7\'e3o e uso de estruturas de dados din\'e2micas. \line A vis\'e3o de arrays e strings como ponteiros \'e9 derivada de C. Mais \'e0 frente no livro, discutiremos arrays e \line\i strings \i0 como objetos no sentido pleno. \line\b\f2\fs26 5.2 Declara\'e7\'f5es e inicializa\'e7\'e3o de vari\'e1veis ponteiro \line\b0\f0\fs18 As vari\'e1veis ponteiro cont\'eam endere\'e7os de mem\'f3ria como seus valores. Normalmente. uma vari\'e1vel cont\'e9m dita- mente um valor espec\'edfico. Um ponteiro, por outro lado, cont\'e9m um endere\'e7o de uma vari\'e1vel que cont\'e9m um valor espec\'edfico. Neste sentido, um nome de vari\'e1vel referencia \i diretamente \i0 um valor e um ponteiro referencia \i indiretamente \i0 um valor (Fig. \i 5. \i0 1). Referenciar um valor atrav\'e9s de um ponteiro \'e9 chamado de \i indire\'e7\'e3o. \i0\fs24\par
\pard\par
\pard\sb100\sa240\b\fs14 CAP\'cdTULO \b0\i\fs18 5 \i0\f2\fs8 - \b\f0\fs14 PONTEIROS E \i STRINGS \i0\f2\fs18 321 \line\f0\fs16 count count \b0\f2\fs18 diretamente \line referencia uma \line vari\'e1vel cujo \line valor \'e9 7 \line countPtr \b\f0\fs16 count countPtr \b0\f2\fs18 indiretamente \line referencia uma \line vari\'e1vel cujo \line\fs8 _______ ______ \fs18 valor \'e9 7 \line\b Fig. 5.1 \b0 Referenciando direta e indiretamente uma vari\'e1vel. \line Ponteiros, como quaisquer outras vari\'e1veis, devem ser declarados antes de poderem ser usados. A declara\'e7ao \line\b\f3 int *countPtr, count; \line\b0\f2 declara a vari\'e1vel \b\f3 countPtr como \b0\f2 sendo do tipo int \fs12 * \fs18 (i.e., \b\f3 um \b0\f2 ponteiro para \b\f3 um \b0\f2 valor do tipo inteiro) e \'e9 lida como \ldblquote countptr \'e9 um ponteiro para int\rdblquote  ou \ldblquote countptr aponta para um objeto do tipo inteiro\rdblquote . Al\'e9m disso, a vari\'e1vel count \'e9 declarada como inteira e n\'e3o como um ponteiro para um inteiro. O \fs12 * \fs18 se aplica somente a countPtr na declara\'e7\'e3o acima. Cada vari\'e1vel que est\'e1 sendo declarada como um ponteiro deve ser precedida por um asterisco \b (*). \b0 Por exemplo, a declara\'e7\'e3o \line double \b\f0\fs16 *xptr, *yptr; \line\b0\f2\fs18 indica que tanto xPtr como yPtr s\'e3o ponteiros para valores de tipo double. Quando o \fs12 * \fs18\'e9 usado desta maneira em uma declara\'e7\'e3o, ele indica que a vari\'e1vel que est\'e1 sendo declarada \'e9 um ponteiro. Podemos declarar ponteiros para apontar para objetos de qualquer tipo. \line\b\i\f0 Erro comum de programa\'e7\'e3o 5.1 \line\b0 Assumir que o \i0\f2\fs12 * \i\f0\fs18 usado para declarar um ponteiro se aplica a todos os nomes de vari\'e1veis, em uma lista de vari\'e1veis ponteiro separadas por v\'edrgulas, pode fazer com que os ponteiros sejam declarados n\'e3o como ponteiros. Cada ponteiro deve ser declarado com o \i0\f2\fs12 * \i\f0\fs18 prefixado ao nome. \line\b Boa pr\'e1tica \b0 de programa\'e7\'e3o 5.1 \line Embora n\'e3o seja obrigat\'f3rio fazer isso, incluir as letras \b\i0\fs16 Ptr \b0\i\fs18 em nomes de vari\'e1veis ponteiro torna claro \line que estas vari\'e1veis s\'e3o ponteiros e precisam ser manipuladas de acordo. \line\i0\f2 Os ponteiros deveriam ser inicializados ou quando forem declarados ou em um comando de atribui\'e7\'e3o. Um ponteiro pode ser inicializado como O, NULL ou um endere\'e7o. Um ponteiro com o valor O ou NULL n\'e3o aponta para nada. NULL \'e9 uma constante simb\'f3lica definida no arquivo de cabe\'e7alho <iostream> (e em v\'e1rios arquivos de cabe\'e7alho da biblioteca padr\'e3o). Inicializar um ponteiro com NTJLL \'e9 equivalente a inicializar um ponteiro com O. mas, em \fs28 c++, \fs18\'e9 prefer\'edvel usar O. Quando \'e9 usado O, ele \'e9 convertido em um ponteiro do tipo apropriado. O valor O \'e9 o \'fanico valor inteiro que pode ser atribu\'eddo diretamente a uma vari\'e1vel ponteiro sem fazer primeiro a coer\'e7\'e3o do inteiro para um tipo de ponteiro. A atribui\'e7\'e3o do endere\'e7o de uma vari\'e1vel para um ponteiro \'e9 discutida na Se\'e7\'e3o 5.3. \line\b\i\f0 Dica de tes(e e depura \'e7\'e3o 5.1 \line\b0 Sempre inicialize ponteiros para evitar apontar para \'e1reas de mem\'f3ria desconhecidas ou n\'e3o-inicializadas. \i0\fs24\par
\b\f2\fs22 322 C++ \fs14 COMO PROGRAMAR \line\fs26 5.3 Operadores sobre ponteiros \line\b0\f0\fs18 O \b\f2\fs14 &, \b0\f0\fs18 ou \i operador de endere\'e7o, \i0\'e9 um operador un\'e1rio que retorna o endere\'e7o de seu operando. Por exemplo, assumindo as declara\'e7\'f5es \line int y \f2\fs10 = \f0\fs18 5; \line int \b\f3\fs16 *yptr; \line\b0\f0\fs18 o comando \line yPtr \f2\fs10 = \line\f0\fs18 atribui o endere\'e7o da vari\'e1vel y \'e0 vari\'e1vel ponteiro yPtr. Diz-se, ent\'e3o, que a vari\'e1vel yPtr \ldblquote aponta para\rdblquote  y. A Fig. 5.2 mostra uma representa\'e7\'e3o esquem\'e1tica da mem\'f3ria depois que a atribui\'e7\'e3o precedente foi executada. Na figura, mostramos a \ldblquote rela\'e7\'e3o de apontar\rdblquote  desenhando uma seta que vai do ponteiro at\'e9 o objeto por ele apontado. \line\f2\fs20 Fig. 5.2 Representa\'e7\'e3o gr\'e1fica de um ponteiro que aponta para uma vari\'e1vel inteira na mem\'f3ria. \line\f0\fs18 A Fig. 5.3 mostra a representa\'e7\'e3o do ponteiro na mem\'f3ria, assumindo que a vari\'e1vel de tipo inteiro y est\'e1 armazenada na posi\'e7\'e3o 600000 e a vari\'e1vel ponteiro yPtr est\'e1 armazenada na posi\'e7\'e3o 500000. O operando do operador de endere\'e7o deve ser um \i ivalue \i0 (i.e., algo ao qual um valor pode ser atribu\'eddo, tal como um nome de vari\'e1vel); o operador de endere\'e7o n\'e3o pode ser aplicado para constantes, para express\'f5es que n\'e3o resultam em refer\'eancias ou para vari\'e1veis declaradas com a classe de armazenamento register. \fs24\par
\f2\fs20 Fig. 5.3 Representa\'e7\'e3o de y e yptr na mem\'f3ria. \line\f0\fs18 O \i operador \b\i0\f2\fs14 *, \b0\f0\fs18 comumente chamado de \i operador de indire\'e7\'e3o \i0 ou \i operador de derrefer\'eancia, \i0 retoma um sin\'f4nimo, um nome alternativo ou um apelido para o objeto para qual seu operando (i.e., um ponteiro) aponta. Por exemplo (fazendo refer\'eancia \'e0 Fig. 5.2 novamente), o comando \line\b\f3\fs16 cout \b0\i\f0\fs18\'ab \b\i0\f3\fs16 *yptr \b0\i\f0\fs18\'ab \i0 eridi; \line imprime o valor da vari\'e1vel y, isto \'e9, 5, quase do mesmo modo como o comando \line cout \i\'ab \i0\f2 y \i\f0\'ab \i0 endJ.; \line faria. Usar \f2\fs12 * \f0\fs18 desta maneira \'e9 chamado de \i derreferenciar um ponteiro. \i0 Note que um ponteiro derreferenciado tamb\'e9m pode ser usado do lado esquerdo de um comando de atribui\'e7\'e3o, como em \line\b\f3\fs16 *yptr \b0\f2\fs10 = \f0\fs18 9; \fs24\par
\pard\par
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx714\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1211\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1709\pard\intbl\f2\fs18 yptr \f0\fs24\cell\f2\fs18 y \f0\fs24\cell\f2\fs18 y \f0\fs24\cell\fs20\row
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1709\pard\intbl\f2 5000001 \f0 600000 \f1\fs44 1 \f0\fs24\cell\fs20\row
\intbl 6000001 \fs24\cell\fs20\row
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx714\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1709\pard\intbl\fs24\cell\cell\fs20\row
\pard\fs24\par
\pard\sb100\sa240\fs16 CAP\'cdTULO \i\fs18 5 \i0\f2\fs8 - \f0\fs16 PONTEIROS E \i\fs18 STRINGS \i0\f2\fs22 323 \line\f0\fs16 que atribuiria 9 para y, na Fig. 5.3. O ponteiro derreferenciado pode ser tamb\'e9m usado para receber um valor fornecido como entrada, como em \line cm \'bb *ypt \line O ponteiro derreferenciado \'e9 um \i\f2\fs20 Ivalue \i0\f0\fs16 ou \ldblquote valor \'e0 esquerda\rdblquote . \line\i\fs18 Erro comum de programa\'e7\'e3o 5.2 \line Derreferenciar um ponteiro que n\'e3o foi corretamente inicializado, ou ao qual n\'e3o foifeita uma atribui\'e7\'e3o para apontar para uma posi\'e7\'e3o espec\'edfica na mem\'f3ria, pode causar um erro fatal durante a execu\'e7\'e3o ou, ainda, pode modificar acidentalmente dados importantes e permitir que o programa execute at\'e9 o fim, fornecendo resultados incorretos. \line Erro comum de programa\'e7\'e3o 5.3 \line Uma tentativa de derreferenciar um n\'e3o-ponteiro \'e9 um erro de sintaxe. \line Erro comum de programa\'e7\'e3o 5.4 \line Derreferenciar um ponteiro \i0\fs16 O \i\fs18 normalmente gera um erro fatal durante a execu\'e7\'e3o. \line\i0\fs16 O programa na Fig. 5.4 demonstra o uso dos operadores sobre ponteiros. As posi\'e7\'f5es de mem\'f3ria s\'e3o exibidas neste exemplo, pelo operador \'ab, como inteiros hexadecimais (ver o ap\'eandice C, \ldblquote Sistemas de numera\'e7\'e3o\rdblquote , para maiores informa\'e7\'f5es sobre inteiros hexadecimais). \line\b\f3 1 \b0\i\f0\fs18 II \b\i0\f3\fs16 Fig. 5.4: \b0\f0 figO5O4.cpp \line\b\f3 2 \b0\f0 // \b\f3 Usando os operadores & e \b0\f2\fs10 * \line\b\f3\fs16 3 #include <iostreaxn> \line 4 \line 5 using std::cout; \line 6 using std: :endl; \line 7 \line 8 int main() \line 10 int a; \b0\f0 // \b\f3 a \'e9 um inteiro \line 11 int *aPtr; \b0\i\f0\fs18 II \b\i0\f3\fs16 aPtr \'e9 um ponteiro para um inteiro \line 12 \line 13 a=7; \line 14 aPtr \b0\f2\fs10 = \b\f3\fs16 &a; \b0\f0 // \b\f3 aPtr recebe o endere\'e7o de a \line 15 \line 16 cout \'ab \ldblquote O endere\'e7o de a \'e9 \b0\f2\fs8\ldblquote  \i\f0\fs18\'ab \b\i0\f3\fs16 &a \line 17 \b0\f0\'ab \ldblquote\\nQ valor de aPtr \'e9 \f2\fs8\ldblquote  \i\f0\fs18\'ab \b\i0\f3\fs16 aPtr; \line 18 \line 19 cout \'ab \ldblquote\\n\\nO valor de a \'e9 \b0\f2\fs8\ldblquote  \i\f0\fs18\'ab \b\i0\f3\fs16 a \line 20 \'ab \b0\fs20\ldblquote\\nO \b\fs16 valor de *aptr \'e9 \b0\f2\fs8\ldblquote  \i\f0\fs18\'ab \b\i0\f3\fs16 *p \line 21 \line 22 cout \'ab \ldblquote\\n\\riMostrando \b0\f0 que \f2\fs10 * \b\f3\fs16 e & s\'e3o os inversos \line 23 \'ab \ldblquote um do outro.\\n&*aPtr \b0\f2\fs10 = \ldblquote  \i\f0\fs18\'ab \b\i0\f3\fs16 &*aptr \line 24 \'ab \lquote\\*p \b0\f2\fs10 = \ldblquote  \b\f3\fs16\'ab *&aptr \'ab endl; \line 25 return 0; \line 26 \b0\f0\} \line\f2\fs20 Fig. 5.4 Os operadores de ponteiro & e \fs10 * \fs20 (parte 1 de 2). \f0\fs24\par
\b\fs20 324 C+\'f7 \fs14 COMO PROGRAMAR \line\f3\fs16 O endere\'e7o de a \'e9 OxOO6FDF4 \line O valor de aPtr \'e9 OxOO64FDF4 \line O valor de a \'e9 7 \line O valor de \b0\f2\fs12 * \b\f3\fs16 aPtr \'e9 7 \line Mostrando \b0\f0 que \b\f3 *e \f0\fs14 & \f3\fs16 s\'e3o os inversos um do outro. \line &*aPtr \b0\f2\fs10 = \b\f3\fs16 OxOO64FDF4 \line *&aptr \b0\f2\fs10 = \b\f3\fs16 OxOO64FDF4 \line\b0\f2\fs20 Fig. 5.4 Os operadores de ponteiro \fs14 & \fs20 e \fs12 * \fs20 (parte 2 de 2). \line\ul\i\f0\fs18 Dica de portabilidade 5.1 \ulnone\line\i0\f2\fs8 ______ \i\f0\fs18 Oformato em que um ponteiro \'e9 exibido para o usu\'e1rio depende da m\'e1quina. Alguns valores de ponteiros s\'e3o exibidos por alguns sistemas como inteiros hexadecimais, enquanto outros sistemas usam inteiros \line decimais. \line\i0\fs16 Note que o endere\'e7o de a e o valor de aPtr s\'e3o id\'eanticos na sa\'edda, confirmando que o endere\'e7o de a \'e9 realmente atribu\'eddo \'e0 vari\'e1vel ponteiro aptr. Os operadores \b\fs14 & \b0\fs16 e \f2\fs12 * \f0\fs16 s\'e3o inversos um do outro \f2\fs8 - \f0\fs16 quando ambos forem aplicados consecutivamente a aPtr, em qualquer ordem, ser\'e1 impresso o mesmo resultado. A Fig. 5.5 mostra a preced\'eancia e a associatividade dos operadores apresentados at\'e9 aqui. \fs24\par
\b\f2\fs20 Fig. \b0 5.5 Preced\'eancia e associatividade de operadores. \line\b\fs26 5.4 Chamando fun\'e7\'f5es por refer\'eancia \line\b0\f0\fs18 Existem tr\'eas modos de passar argumentos para uma fun\'e7\'e3o em C \b\fs14 ++ \b0\f2\fs8 - \f0\fs18 atraves de \i chamada por vaior cnamaaa por refrr\'eancia com argumentos de refer\'eancia \i0 e \i chamada por refer\'eancia com argumentos ponteiros. \i0 No Cap\'edtulo 3, comparamos e distinguimos a chamada por valor da chamada por refer\'eancia com argumentos de refer\'eancia. Neste cap\'edtulo, concentramo-nos na chamada por refer\'eancia com argumentos ponteiros. \line Como vimos no Cap\'edtulo 3, return pode ser usado para retornar o valor de uma fun\'e7\'e3o para quem a chamou (ou para retornar o controle da fun\'e7\'e3o, sem passar de volta um valor). Vimos tamb\'e9m que argumentos podem ser passados para uma fun\'e7\'e3o usando argumentos de refer\'eancia, para permitir \'e0 fun\'e7\'e3o modificar os valores originais dos argumentos (deste modo, mais de um valor pode ser \ldblquote retornado\rdblquote  por uma fun\'e7\'e3o) ou para passar objetos de dados grandes para uma fun\'e7\'e3o e evitar o \i overhead \i0 de passar os objetos atrav\'e9s de uma chamada por valor (a qual, \'e9 claro, exige que se fa\'e7a uma c\'f3pia do objeto). Ponteiros, como refer\'eancias, podem tamb\'e9m ser usados para modi \fs24\par
\pard\par
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2317\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4158\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx5634\pard\intbl\b\f2\fs20 Operadores \b0\f0\fs24\cell\b\f2\fs20 Associatividade \b0\f0\fs24\cell\b\f2\fs20 Tipo \b0\f0\fs24\cell\fs20\row
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx377\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx763\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2317\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4158\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx5634\pard\intbl\fs18 O \fs24\cell\fs18 [) \fs24\cell\cell\fs18 esquerda para a direita \fs24\cell\fs18 mais alto \fs24\cell\fs20\row
\b\fs14\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx377\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx763\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2317\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4158\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx5634\intbl ++ \b0\fs24\cell\f2\fs8 -- \f0\fs24\cell\fs18 staticcast<type> () \fs24\cell\fs18 esquerda para a direita \fs24\cell\fs18 p\'f3s-fixo \fs24\cell\fs20\row
\b\fs14\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx377\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx763\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2317\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4158\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx5634\intbl ++ \b0\fs24\cell\f2\fs8 -- \f0\fs24\cell\b\fs14 + \b0\f2\fs8 - \b\f3\fs16 ! & \b0\f2\fs12 * \f0\fs24\cell\fs18 direita para a esquerda \fs24\cell\fs18 un\'e1rio \fs24\cell\fs20\row
\f2\fs12\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx377\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx763\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2317\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4158\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx5634\intbl * \f0\fs24\cell\b\fs20 / \b0\fs24\cell\fs18 % \fs24\cell\fs18 esquerda para a direita \fs24\cell\fs18 multiplicativo \fs24\cell\fs20\row
\b\fs14\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx377\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx763\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2317\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4158\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx5634\intbl + \b0\fs24\cell\f2\fs8 - \f0\fs24\cell\cell\fs18 esquerda para a direita \fs24\cell\fs18 aditivo \fs24\cell\fs20\row
\i\fs18\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx377\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx763\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2317\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4158\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx5634\intbl\'ab \i0\fs24\cell\fs18\'bb \fs24\cell\cell\fs18 esquerda para a direita \fs24\cell\fs18 inser\'e7\'e3o/extra\'e7\'e3o \fs24\cell\fs20\row
\b\fs14\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx377\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx763\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2317\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4158\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx5634\intbl < \b0\fs24\cell\b\fs14 <= \b0\fs24\cell\b\fs14 > >= \b0\fs24\cell\fs18 esquerda para a direita \fs24\cell\fs18 relacional \fs24\cell\fs20\row
\b\fs14\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx377\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx763\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2317\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4158\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx5634\intbl == \b0\fs24\cell\f2\fs12 1 \b\f0\fs14 = \b0\fs24\cell\cell\fs18 esquerda para a direita \fs24\cell\fs18 igualdade \fs24\cell\fs20\row
\b\fs14\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx377\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx763\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2317\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4158\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx5634\intbl & & \b0\fs24\cell\cell\cell\fs18 esquerda para a direita \fs24\cell\fs18 E l\'f3gico \fs24\cell\fs20\row
\fs18\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx377\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx763\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2317\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4158\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx5634\intbl 1 \fs24\cell\cell\cell\fs18 esquerda para a direita \fs24\cell\fs18 OU l\'f3gico \fs24\cell\fs20\row
\b\f3\fs16\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx377\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx763\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2317\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4158\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx5634\intbl ?: \b0\f0\fs24\cell\cell\cell\fs18 direita para a esquerda \fs24\cell\fs18 condicional \fs24\cell\fs20\row
\b\fs14\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx377\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx763\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2317\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4158\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx5634\intbl = \b0\fs24\cell\b\fs14 += \b0\fs24\cell\f2\fs12 -= *= \i\f0\fs18 1= \b\i0\fs14 %= \b0\fs24\cell\fs18 direita para a esquerda \fs24\cell\fs18 atribui\'e7\'e3o \fs24\cell\fs20\row
\f2\fs8\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx377\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx763\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2317\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4158\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx5634\intbl , \f0\fs24\cell\cell\cell\fs18 esquerda para a direita \fs24\cell\fs18 v\'edrgula \fs24\cell\fs20\row
\pard\fs24\par
\pard\sb100\sa240\b\fs14 CAP\'cdTULO \b0\i\fs20 5 \i0\f2\fs8 - \b\f0\fs14 PONTEIROS E \b0\i\fs16 STRINGS 325 \line\i0\fs18 ficar uma ou mais vari\'e1veis de quem chamou ou para passar ponteiros para objetos de dados grandes, evitando o \i\fs20 overhead \i0\fs18 de passar os objetos atrav\'e9s de uma chamada por valor. \line Em C++, os programadores podem usar ponteiros e o operador de indire\'e7\'e3o para simular uma chamada por refer\'eancia (exatamente como uma chamada por refer\'eancia \'e9 feita em programas em C). Quando chamarmos uma fun\'e7\'e3o com argumentos que devem ser modificados, s\'e3o passados os endere\'e7os dos argumentos. Isto normalmente \'e9 feito aplicando-se o operador de endere\'e7o (&) ao nome da vari\'e1vel cujo valor ser\'e1 modificado. \line Como vimos no Cap\'edtulo 4, arrays n\'e3o s\'e3o passados usando-se o operador \b\fs14 & \b0\fs18 porque o nome do array \'e9 a posi\'e7\'e3o inicial do array na mem\'f3ria (o nome de um array \'e9 equivalente a &nomeDoArray [ O ] \f2\fs8 , \f0\fs18 i.e.. um nome de um array \fs24 j\'e1 \fs18\'e9 um ponteiro). Quando o endere\'e7o de uma vari\'e1vel \'e9 passado para uma fun\'e7\'e3o, o operador de indire\'e7\'e3o (*) pode ser usado na fun\'e7\'e3o para criar um sin\'f4nimo, um nome alternativo ou um apelido para o nome da vari\'e1vel \f2\fs8 - \f0\fs18 este, por sua vez, pode ser usado para modificar o valor (se a vari\'e1vel n\'e3o \'e9 declarada como const) que est\'e1 na posi\'e7\'e3o de mem\'f3ria na fun\'e7\'e3o que chamou. \line As Figs. 5.6 e 5.7 apresentam duas vers\'f5es de uma fun\'e7\'e3o que eleva um inteiro ao cubo- cubeByValue e cubeByReference. A Fig. \i\fs20 5.6 \i0\fs18 passa a vari\'e1vel number para a fun\'e7\'e3o cubeByValue usando uma chamada por valor. A fun\'e7\'e3o cubeByValue eleva ao cubo o seu argumento e passa o novo valor de volta para a fun\'e7\'e3o main. usando um comando return. O novo valor \'e9 atribu\'eddo a number em main. Assim, voc\'ea tem a oportunidade de examinar o resultado da chamada \'e0 fun\'e7\'e3o antes de modificar o valor de uma vari\'e1vel. Por exemplo, neste programa, pod\'edamos ter armazenado o resultado de cubeByValue em outra vari\'e1vel, examinado seu valor e atribu\'eddo o resultado a number ap\'f3s verificar a consist\'eancia desse valor. \line\b\f3\fs16 1 \b0\i\f0\fs20 II \b\i0\f3\fs16 Fig. 5.6: \b0\f0\fs18 figO5O6.cpp \line\b\f3\fs16 2 \b0\i\f0\fs20 II \b\i0\f3\fs16 Elevar \b0\f0\fs18 uma \b\f3\fs16 vari\'e1vel ao cubo usando \b0\f0\fs18 unia \b\f3\fs16 chamada por valor \line 3 #include <iostream> \line 4 \line 5 using std::cout; \line 6 using std: :endl; \line 7 \line 8 int cubeByValue( int ); \b0\i\f0\fs20 /1 \b\i0\f3\fs16 prot\'f3tipo \line 9 \line 10 int main() \line 11 \line 12 int number \b0\f2\fs10 = \b\f3\fs16 5; \line 13 \line 14 cout \b0\i\f0\'ab \b\i0\f3\ldblquote O valor original de nuniber e \b0\f2\fs8\ldblquote  \i\f0\fs16\'ab \i0\fs18 number; \line\b\f3\fs16 15 \b0\f0\fs18 nuniber \f2\fs10 = \b\f3\fs16 cubeByValue( number ); \line 16 cout \'ab \ldblquote\\nO novo valor de nuniber \'e9 \b0\f2\fs8\ldblquote  \b\f3\fs16\'ab number \'ab endl; \line 17 return 0; \line 18 \line 19 \line 20 int cubeByValue( int n \line 21 \line 22 return n \b0\f2\fs10 * \b\f3\fs16 n \b0\f2\fs10 * \b\f3\fs16 n; \b0\f0\fs18 // \b\f3\fs16 eleva ao cubo a vari\'e1vel local \b0\i\f0\fs20 n \line\b\i0\f3\fs16 23 \b0\f0\fs24\par
\b\f2\fs18 Fig. 5.6 \b0\fs20 Elevando uma vari\'e1vel ao cubo usando uma chamada por valor. \line\f0\fs18 A Fig. 5.7 passa a vari\'e1vel nuniber usando uma chamada por refer\'eancia \f2\fs8 - \f0\fs18 o endere\'e7o de nuinber e passado para a fun\'e7\'e3o cubeByReference. A fun\'e7\'e3o cubeByReference recebe nPtr (um ponteiro para int) como argumento. A fun\'e7\'e3o derreferencia o ponteiro e eleva ao cubo o valor apontado por nPtr. Isto muda o valor de nuniber em main. As Figs. 5.8 e 5.9 analisam graficamente os programas nas Figs. 5.6 e 5.7, respectivamente. \fs24\par
\pard\par
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx205\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx902\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2008\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx3089\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx3594\pard\intbl\b\f3\fs16 O \b0\f0\fs24\cell\b\f3\fs16 valor \b0\f0\fs24\cell\b\f3\fs16 original \b0\f0\fs24\cell\b\f3\fs16 de number \b0\f0\fs24\cell\b\f3\fs16\'e9 5 \b0\f0\fs24\cell\fs20\row
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx205\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx902\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1599\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2008\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx3594\pard\intbl\b\f3\fs16 O \b0\f0\fs24\cell\b\f3\fs16 novo \b0\f0\fs24\cell\b\f3\fs16 valor \b0\f0\fs24\cell\b\f3\fs16 de \b0\f0\fs24\cell\b\f3\fs16 number \'e9 125 \b0\f0\fs24\cell\fs20\row
\pard\fs24\par
\pard\sb100\sa240\fs18 326 C++ \f2\fs20 CoMo \b\f3\fs16 PROGRAMAR \b0\f0\fs24\par
\b\f3\fs16 1 \b0\f0\fs20 // \b\f3\fs16 Fig. 5.7: figO5_07.cpp \line 2 \b0\f0\fs20 // \b\f3\fs16 Elevando ao cubo \b0\f0 urna \b\f3 vari\'e1vel usando \b0\f0 uma \b\f3 chamada \line 3 \b0\i\f0\fs20 II \b\i0\f3\fs16 por refer\'eancia com um ponteiro como argumento \line 4 #include <iostream> \line 5 \line 6 using std::cout; \line 7 using std::endl; \line 8 \line 9 void cubeByReference( int \b0\f2\fs12 * \f0\fs20 ); // \b\f3\fs16 prot\'f3tipo \line\b0\f0\fs22 lo \line\b\f3\fs16 11 int main() \line 12 \line 13 int number \b0\f2\fs10 = \b\f3\fs16 5; \line 14 \line 15 cout \'ab \b0\f0\fs20\ldblquote O valor original de number \'e9 \f2\fs8\ldblquote  \b\f3\fs16\'ab \b0\f0 number; \line\b\f3 16 cubeByReference( &nuznber ); \line 17 cout \'ab \lquote\\nO novo valor de \b0\f0 number \'e9 \f2\fs8\ldblquote  \b\f3\fs16\'ab number \'ab endl; \line 18 return 0; \line 19 \line 20 \line 21 void cubeByReference( int *nptr \line 22 \line 23 *nptr \b0\f2\fs10 = \b\f3\fs16 *nptr \b0\f2\fs12 * \b\f3\fs16 *nPtr \b0\f2\fs12 * \b\f3\fs16 *nptr; \b0\f0\fs20 // \b\f3\fs16 eleva ao cubo nuxnber em main \line 24 \b0\f0\fs24\par
\f2\fs20 Fig. 5.7 Elevando uma vari\'e1vel ao cubo usando chamada por refer\'eancia com um ponteiro como argumento. \line\i\f0 Erro comum de programa\'e7\'e3o 5.5 \line\i0\f1\fs24\'c9 \i\f0\fs18 um erro n\'e3o derreferenciar um ponteiro, quando \'e9 necess\'e1rio faz\'ea-lo para obter o valor para o qual o ponteiro aponta. \line\i0 Uma fun\'e7\'e3o que recebe um endere\'e7o como argumento deve definir um argumento ponteiro para receber o endere\'e7o. Por exemplo, o cabe\'e7alho da fun\'e7\'e3o cubeByReference \'e9 \line void cubeByReference( int *nptr \f1\fs24 ) \line\f0\fs18 O cabe\'e7alho da fun\'e7\'e3o especifica que a fun\'e7\'e3o cubeByReference recebe o endere\'e7o de uma vari\'e1vel do tipo inteiro \i (i.e., \i0 um ponteiro para inteiro) como argumento, armazena o endere\'e7o localmente em nPtr e n\'e3o retorna um valor. \line O prot\'f3tipo de fun\'e7\'e3o para cubeByReference cont\'e9m int \f2\fs12 * \f0\fs18 entre par\'eanteses. Como com outros tipos \line para fins de documenta\'e7\'e3o s\'e3o ignorados pelo compilador. \line No cabe\'e7alho e no prot\'f3tipo de uma fun\'e7\'e3o que espera um array unidimensional como argumento, pode ser usada a nota\'e7\'e3o de ponteiro usada na lista de argumentos de cubeByReference. O compilador n\'e3o distingue \line devari\'e1veis, n\'e3o \'e9 necess\'e1rio incluir nomes de ponteiros em prot\'f3tipos de fun\'e7\'f5es. Os nomes de argumentos inclu\'eddos entre uma fun\'e7\'e3o que recebe um ponteiro e uma fun\'e7\'e3o que recebe um array unidimensional. Isto, \'e9 claro, significa \line que a fun\'e7\'e3o deve saber\rdblquote  quando ela est\'e1 recebendo um array ou simplesmente uma vari\'e1vel isolada para a qual ela deve executar uma chamada por refer\'eancia. Quando o compilador encontra um argumento de fun\'e7\'e3o para um array unidimensional, da forma int b \f1\fs24 [ ], \f0\fs18 o compilador converte o argumento para a nota\'e7\'e3o de ponteiro int \f2\fs12 * \f0\fs18 const b (pronunciada como \ldblquote b \'e9 um ponteiro constante para um inteiro\rdblquote  \f2\fs8 - \f0\fs18 const \'e9 explicado na Se\'e7\'e3o 5.5). As duas formas de se declarar um argumento de fun\'e7\'e3o como um array unidimensional s\'e3o intercambi\'e1veis. \fs24\par
\f1 T \f0\par
\pard\par
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx267\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx964\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2070\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx3099\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx3554\pard\intbl\fs22 O \fs24\cell\b\f3\fs16 valor \b0\f0\fs24\cell\b\f3\fs16 original \b0\f0\fs24\cell\b\f3\fs16 de \b0\f0 nuxnber \fs24\cell\fs20\'e9 5 \fs24\cell\fs20\row
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx267\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx964\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1661\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2070\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx3554\pard\intbl\b\f3\fs16 O \b0\f0\fs24\cell\b\f3\fs16 novo \b0\f0\fs24\cell\b\f3\fs16 valor \b0\f0\fs24\cell\b\f3\fs16 de \b0\f0\fs24\cell\fs16 nuxnber \b\f3\'e9 125 \b0\f0\fs24\cell\fs20\row
\pard\fs24\par
\pard\sb100\sa240\fs16 CAP\'cdTULO \f2\fs22 5 \fs8 - \f0\fs16 PONTEIROS E \i\f2 STRINGS \i0\fs22 327 \f0\fs24\par
\i\fs18 Boa pr\'e1tica de programa\'e7\'e3o 5.2 \line Use uma chamada por valor para passar argumentos para uma fun\'e7\'e3o, a menos que o chamador exija explicitamente que a fun\'e7\'e3o modifique o valor da vari\'e1vel passada como argumento, no contexto do chamador Este \'e9 outro exemplo do princ\'edpio de menor privil\'e9gio. \i0\fs24\par
\b\fs16 int main() nuinber \line int nuntber \b0\f2\fs12 = \ul\f1\fs46 1 1 \ulnone\f2\fs16 125 \line\b\f0 number \b0\f2\fs12 = \ul\f3\fs16 CcubeByValue \ulnone\i\f0\fs20 ( \ul\b\i0\fs16 number \b0\f1\fs28 T) \ulnone\f0\fs24\par
\f3\fs16 Ap\'f3s \b main fazer a \b0 atribui\'e7\'e3o \b a number: \b0\f0\fs24\par
\f3\fs16 Antes de \b main \b0 chamar cubeByValue: \f0\fs24\par
\b\f3\fs20 int main() nuniber \line mntnumber=5; \ul\b0\f1\fs46 I 1 \ulnone\line\b\f3\fs20 nuxnber cubeByValue \b0\i\f0 ( \b\i0\f3 number ); \b0\f0\fs24\par
\f3\fs16 Depois de \b\fs18 cubeByValue \b0\fs16 receber a chamada: \line\b\fs18 int main() nuniber \line int nuniber \b0\f2\fs12 = \ul\f1\fs46 I 1 \ulnone\line\b\f3\fs18 nuxnber \b0\f2\fs12 = \b\f3\fs18 cubeByValue \b0\i\f0\fs20 ( \b\i0\f3\fs18 nuinber ); \b0\f0\fs24\par
\ul\f3\fs16 Depois de cubeByValue elevar ao cubo o par\'e2metro \ulnone n: \f0\fs24\par
\b\f3\fs20 int main() \b0\fs16 nuinber \line\b\fs20 int number \b0\f2\fs12 = \ul\f1\fs46 I 1 \ulnone\line\b\f3\fs20 nuniber \b0\f2\fs12 = \b\f3\fs20 cubeByValue \b0\i\f0 ( \b\i0\f3 nuniber ); \b0\f0\fs24\par
\f3\fs16 Depois de cubeByValue retornar a main: \f0\fs24\par
\b\f3\fs16 int \b0\f0\fs24\par
\b\f3\fs16 int mamnQ \b0\fs18 number \line\f2\fs12 = \f3\fs18 5; \ul\f1\fs28 1125 \fs46 1 \ulnone\line\f3\fs18 nuniber \f2\fs12 = \f0\fs16 cubeByValue \i\fs20 ( \i0\f3\fs18 nuniber ); \f0\fs24\par
\b\f2\fs18 Fig. \b0 5.8 An\'e1lise de uma chamada por valor t\'edpica. \f0\fs24\par
\pard\par
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx295\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1471\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2918\pard\intbl\b\fs16 int \b0\fs24\cell\b\fs14 cubeByValue(  return n \i\fs12 * fl \b0\i0\fs24\cell\b\fs16 int n  \i\fs12 * fl;  \i0\fs16 n  \b0\f2\fs36 1 \f3\fs16 indefinido \f0\fs24\cell\fs20\row
\b\fs16\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx295\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1471\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2918\intbl int \b0\fs24\cell\b\fs16 cubeByValue( \b0\fs24\cell\b\fs16 int n \b0\fs24\cell\fs20\row
\fs24\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx295\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1471\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2918\intbl\cell\b\fs14 return n \i\fs12 * fl \b0\i0\fs24\cell\b\i\fs12 * \b0\i0\fs24\cell\fs20\row
\fs24\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx295\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1471\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2918\intbl\cell\cell\b\f3\fs16 n \b0\f0\fs24\cell\fs20\row
\fs24\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx295\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1471\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2918\intbl\cell\cell\f2\fs36 I \f0\fs24\cell\fs20\row
\pard\sa240\fs24\par
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx295\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx3043\pard\intbl\b\fs16 int \b0\fs24\cell\b\fs16 cubeByVa].ue( int n \b0\fs24\cell\fs20\row
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx295\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1363\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1875\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx3043\pard\intbl\i\{ \i0\fs24\cell\f3\fs16 returnCn \f0\fs24\cell\f3\fs16 125  \b\i\f0\fs12 * * \b0\i0\fs24\cell\cell\fs20\row
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx295\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1363\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1866\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx3043\pard\intbl\fs24\cell\cell\cell\b\f3\fs16 n  \b0 indefinido \f0\fs24\cell\fs20\row
\pard\sa240\fs24\par
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1946\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2300\pard\intbl\fs16 int cubeByValue( int n \fs24\cell\cell\fs20\row
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1123\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1592\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1946\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2300\pard\intbl\b\f3\fs16 return n \i\f0\fs12 * * \b0\i0\fs24\cell\b\f3\fs16 n \b0\f0\fs24\cell\cell\cell\fs20\row
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1123\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2300\pard\intbl\fs24\cell\b\f3\fs16 n  \b0 indefinido \f0\fs24\cell\fs20\row
\pard\sa240\fs24\par
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1741\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2314\pard\intbl\fs16 cubeByValue( int n \fs24\cell\i\fs20 ) \i0\fs24\cell\fs20\row
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1137\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1741\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2314\pard\intbl\b\f3\fs16 return \f0\fs12 fl \i * fl * \b0\i0\fs24\cell\b\fs12 fl; \b0\fs24\cell\cell\fs20\row
\fs24\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1137\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1741\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2314\intbl\cell\cell\b\f3\fs16 n \b0\f0\fs24\cell\fs20\row
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1137\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2314\pard\intbl\fs24\cell\f3\fs16 indefinido \f0\fs24\cell\fs20\row
\pard\fs24\par
\pard\sb100\sa240\f3\fs20 328 C++ \b\f2\fs14 COMO PROGRAMAR \line\b0\f3\fs18 Depois de \b\fs16 cubeByValue \b0\fs18 receber a chamada por refer\'eancia: \line de a \line\b\fs16 int main() nuinber void cubeByReference( int *nptr \b0\fs18 ) \f0 refe \line\b\f3\fs16 daa \line int number \b0\f2\fs10 = \ul\f1\fs46 I 1 \ulnone\b\f3\fs16 *flPtr \b0\f2\fs10 = \b\f3\fs16 *nptr \b0\f2\fs10 * \b\f3\fs16 *flptr \b0\f2\fs10 * \b\f3\fs16 *nptr; \b0\f0\fs18 mai \line\b\f3\fs16 cubeByReference \b0\f0\fs18 ( \b\f3\fs16 &number ); nPtr \b0\f0\fs18 argi. \line\f3 indefinido funi \line\f0 fum \line\ul\f3 Lepois da chamadapor refer\'eancia para \b\fs16 cubeByReferencee \ulnone\b0\fs18 antes de \b\fs16 *nptr \b0\fs18 ser elevado ao cubo: alte \line\f2\fs20 arra \line\b\f3\fs16 int main() number void cubeByReference( mnt *nptr \b0\f0\fs18 tam \line\{ \{ \line\b\f3\fs16 int number \b0\f2\fs10 = \b\f3\fs16 5; \ul\b0\f1\fs46 1 \b\f3\fs16 5 \ulnone *nptr \b0\f2\fs10 = \b\f3\fs16 *nPtr \b0\f2\fs10 * \b\f3\fs16 *nPtr \b0\f2\fs10 * \b\f3\fs16 *nptr; \b0\fs20 la\'e7c \line\b\fs16 cubeByReference \b0\f0\fs18 ( \b\f3\fs16 &nuxnber ); nPtr \line\ul\b0\fs18\} \f2\fs36 11 \line\f3\fs18 Depois de \f0 *nptr \f3 ser elevado ao cubo: \ulnone ___________________________________ \f0 Se \line adv \line\b\f3\fs16 int main() nuniber void cubeByReference( int *nptr \line\b0\fs18\{ \{ \ul\i\f2\fs16 25 \ulnone\line\b\i0\f3 int nujuber \b0\f2\fs10 = \b\f3\fs16 5; 125 [*p \ul\b0\f2\fs10 = \b\f3\fs16 *nptr \b0\f2\fs10 * \b\f3\fs16 *nptr \b0\f2\fs10 * \b\f3\fs16 *nptr;J \ulnone\line\f0 cubeByReference \b0\fs18 ( \b\f3\fs16 &nuniber ); nPtr \line\ul\b0\f0\fs18\} \f2\fs36 i\bullet I \ulnone\line\b\fs18 Fig. 5.9 \b0\fs20 An\'e1lise de uma chamada por refer\'eancia t\'edpica com um ponteiro como argumento. \fs38 [j \line\f0\fs18 Exi \line\b\f2\fs26 5.5 Usando o qualificador \b0\f0\fs24 const \b\f2\fs26 com ponteiros \b0\fs20 tes, \line\f0\fs18 teir \line O \i qualificador \i0 const possibilita ao programador informar ao compilador que o valor de uma vari\'e1vel particular \line n\'e3o deve ser modificado. pod \line outi \line\i\f2 Observa\'e7\'e3o de engenharia de software \b\fs20 5.1 \b0\i0\f3 pod \line\f2\fs8 ______ \i\fs18 O qualificador \i0\f3\fs20 const \i\f2\fs18 pode ser usado para for\'e7ar o uso do princ\'edpio de menor privil\'e9gio. O uso do \i0\f0 mei \line\i\f2 princ\'edpio de menor privil\'e9gio para projetar software corretamente pode reduzir bastante o tempo de depu- \b\i0\fs14 S \line\b0\i\fs18 ra\'e7\'e3o e efeitos colaterais incorretos, tornando o programa mais f\'e1cil de se modificar e manter \i0\f0 rg \line\i\f2\fs24 rfl \fs18 Dica de portabilidade 5.2 \i0\f0\fs20 unte \line\fs18 per \line\f2\fs8 _____ \i\fs18 Embora \i0\f0 const \i\f2 esteja bem-definido em C e C+ \b\i0\fs14 + \b0\i\fs18 ANSI, alguns compiladores n\'e3o garantem o seu uso \i0\f0 mir \line\i\f2 correto. \i0\f0 toi \line 16. \line Ao longo dos anos, um grande volume de c\'f3digo legado foi escrito sem usar const, porque o mesmo n\'e3o estava \line dispon\'edvel nas primeiras vers\'f5es de C. Por essa raz\'e3o, existem grandes oportunidades para melhorias na engenharia qua de software do c\'f3digo escrito em vers\'f5es mais antigas de C. Al\'e9m disso, muitos programadores, que atualmente des est\'e3o usando C e C++ ANSI, n\'e3o usam const em seus programas porque come\'e7aram a programar nas primeiras um vers\'f5es de C. Estes programadores est\'e3o perdendo muitas oportunidades de fazer uso da boa engenharia de softwa- dec re. \fs24\par
\b\fs14 CAP\'cdTULO \b0\i\fs18 5 \i0\f2\fs8 - \b\f0\fs14 PONTEIROS E \b0\i\f2\fs16 STRINGS \b\i0\fs22 329 \line\b0\f0\fs18 Existem seis possibilidades para usar (ou n\'e3o usar) const com argumentos de fun\'e7\'f5es \f2\fs8 - \f0\fs18 duas com passagem de argumentos atrav\'e9s de chamadas por valor e quatro com passagem de argumentos atrav\'e9s de chamadas por refer\'eancia. Como escolher uma das seis possibilidades? Guie-se pelo princ\'edpio de menor privil\'e9gio. Sempre conceda a uma fun\'e7\'e3o um acesso suficiente aos dados em seus argumentos para realizar sua tarefa especificada, mas n\'e3o mais. \line No Capitulo 3, explicamos que, quando uma fun\'e7\'e0o \'e9 chamada usando uma chamada por valor, uma c\'f3pia do argumento (ou argumentos) \'e9 feita na chamada da fun\'e7\'e3o e passada para a mesma. Se a c\'f3pia \'e9 modificada na fun\'e7\'e3o, o valor original \'e9 mantido, sem mudan\'e7as, no chamador. Em muitos casos, um valor passado para uma fun\'e7\'e3o \'e9 modificado para que a fun\'e7\'e3o possa realizar sua tarefa. Por\'e9m, em algumas inst\'e2ncias, o valor n\'e3o deve ser alterado na fun\'e7\'e3o chamada, embora a mesma manipule apenas uma c\'f3pia do valor original. \line Considere uma fun\'e7\'e3o que recebe como argumentos um array unidimensional e seu tamanho e imprime o \line array. Tal fun\'e7\'e3o deveria iterar atrav\'e9s do array e dar sa\'edda ao valor de cada elemento do mesmo individualmente, O \line tamanho do array \'e9 usado no corpo da fun\'e7\'e3o para determinar o \'edndice de valor mais alto do array, de modo que o \line la\'e7o possa terminar quando a impress\'e3o estiver completa. O tamanho do array n\'e3o muda no corpo da fun\'e7\'e3o. \line\b\i Observa\'e7\'e3o de engenharia de software 5.2 \line\b0\i0\f2\fs8 ______ \b\i\f0\fs18 Se \b0 um valor n\'e3o muda (ou n\'e3o deve mudar) no corpo de uma fun\'e7\'e3o para a qual ele \'e9 passado, o argumento deve ser declarado \b\i0\fs20 const \b0\i\fs18 para garantir que n\'e3o seja acidentalmente modificado. \line\i0 Se for feita uma tentativa de modificar um valor const, o compilador detectar\'e1 isto e emitir\'e1 ou uma mensagem de advert\'eancia ou de erro, dependendo do compilador particular. \line\i Observa\'e7\'e3o de engenharia de software 5.3 \line\i0\f2\fs8 ______ \i\f0\fs18 Quando \'e9 usada uma chamada por valor somente um valor pode ser alterado na fun\'e7\'e3o chamada. Esse valor deve ser atribu\'eddo do valor de retorno da fun\'e7\'e3o. Para modificar m\'faltiplos valores em chamadas de \line fun\'e7\'e3o, v\'e1rios argumentos s\'e3o passados atrav\'e9s de uma chamada por refer\'eancia. \line\b Boa \b0 pr\'e1tica de programa\'e7\'e3o 5.3 \line Antes de usar uma fun\'e7\'e3o, confira seu prot\'f3tipo de fun\'e7\'e3o para determinar os argumentos que ela pode \line modificar \line\i0 Existem quatro modos de passar um ponteiro para uma fun\'e7\'e3o: um ponteiro n\'e3o-constante para dados n\'e3o-constantes, um ponteiro n\'e3o-constante para dados constantes, um ponteiro constante para dados n\'e3o-constantes e um ponteiro constante para dados constantes. Cada combina\'e7\'e3o fornece um n\'edvel diferente de privil\'e9gios de acesso. \line O n\'edvel de acesso mais alto \'e9 obtido com um ponteiro n\'e3o-constante para dados n\'e3o-constantes \f2\fs8 - \f0\fs18 os dados podem ser modificados atrav\'e9s do ponteiro derreferenciado e o ponteiro pode ser modificado para apontar para outros dados. A declara\'e7\'e3o de ponteiros n\'e3o-constantes para dados n\'e3o-constantes n\'e3o inclui const. Tal ponteiro pode ser usado para receber um \i string \i0 em uma fun\'e7\'e3o que usa aritm\'e9tica de ponteiros para processar (e, possivelmente, modificar) cada caractere no \i string. \i0 A fun\'e7\'e3o convertTouppercase da Fig. \i 5.10 \i0 declara o argumento sPtr \b\f2\fs22 ( \b0\f0\fs18 char *sPtr \b\f2\fs22 ) \b0\f0\fs18 como um ponteiro n\'e3o-constante para dados n\'e3o-constantes. A fun\'e7\'e3o processa o \i string \i0 string, um caractere por vez, usando aritm\'e9tica de ponteiros. A fun\'e7\'e3o \b\fs20 islower \b0\fs18 recebe um caractere como argumento e devolve true se o caractere for uma letra min\'fascula e false em caso contr\'e1rio. Os caracteres no intervalo \lquote a\rquote  a \lquote z\rquote  s\'e3o convertidos em suas letras mai\'fasculas correspondentes pela fun\'e7\'e3o toupper; outros permanecem inalterados. A fun\'e7\'e3o toupper aceita um caractere como argumento. Se o caractere for uma letra min\'fascula, a letra mai\'fascula correspondente \'e9 retornada; caso contr\'e1rio, \'e9 retornado o caractere original. A fun\'e7\'e3o toupper e a fun\'e7\'e3o islower fazem parte da biblioteca de manipula\'e7\'e3o de caracteres <cctype> (veja Cap\'edtulo 16, \ldblquote Bits, caracteres, \i strings \i0 e estruturas\rdblquote ). \line Um ponteiro n\'e3o-constante para dados constantes \'e9 um ponteiro que pode ser modificado para apontar para qualquer item de dado do tipo apropriado, mas os dados para os quais ele aponta n\'e0o podem ser modificados atrav\'e9s desse ponteiro. Tal ponteiro poderia ser usado para receber como argumento um array para uma fun\'e7\'e3o que processa um elemento do array por vez, sem modificar os dados. Por exemplo, a fun\'e7\'e3o printCharacters da Fig. 5.11 declara argumentos sPtr como sendo do tipo const char*. A declara\'e7\'e3o \'e9 lida, da direita para a esquerda, \fs24\par
\b\fs20 330 C++ \b0\fs14 COMO PROGRAMAR \line como \ldblquote sPtr \'e9 um ponteiro para uma constante do tipo caractere\rdblquote . O corpo da fun\'e7\'e3o usa uma estrutura for para exibir na sa\'edda cada caractere no \i\fs18 string, \i0 at\'e9 ser encontrado o caractere nulo. Depois de cada caractere ser impresso. o ponteiro sPtr \'e9 incrementado para apontar para o pr\'f3ximo caractere no \i string. \line\i0\f3\fs16 1 \i\f2\fs20 II \i0\f3\fs16 Fig. 5.10: figo5_10.cpp \line 2 \i\f2\fs22 II \i0\f3\fs16 Convertendo letras min\'fasculas para letras mai\'fasculas \line 3 \i\f2\fs22 II \i0\f3\fs16 usando um ponteiro n\'e3o-constante para dados n\'e3o-constantes \line 4 #include <iostream> \line 5 \line 6 using std::cout; \line 7 using std: :endl; \line 8 \line 9 #include<cctype> \line 1O \line 11 void convertToUppercase( char \f2\fs10 * \line\f3\fs16 12 \line 13 int main() \line 14 \f0\fs18\{ \line\f3\fs16 15 char string[] \f2\fs12 = \f3\fs16\ldblquote caracteres e $32,98\rdblquote ; \line 16 \line 17 cout \f0\fs18\'ab \f3\fs16\ldblquote O string antes da convers\'e3o \'e9: \f2\fs8\ldblquote  \fs22\'ab \f3\fs16 string; \line 18 convertTouppercase( string ); \line 19 cout \'ab \ldblquote\\nO string depois da convers\'e3o \'e9: \line 20 \'ab string \'ab endl; \line 21 return 0; \line 22 \line 23 \line 24 void convertToUppercase( char *sPtr \line 25 \f0\fs18\{ \line\f3\fs16 26 while \f0\fs18 ( != \f3\fs16\lquote\\O\rquote  \f0\fs18 ) \{ \line\f3\fs16 27 \line 28 if \f0\fs18 ( \f3\fs16 islower( *sptr \line 29 *sPtr toupper( *sPtr ); \i\f2\fs20 II \i0\f3\fs16 converte para inai\'fasculas \line 30 \line 31 ++sPtr; \i\f2\fs22 II \i0\f3\fs16 move sPtr para o pr\'f3ximo caractere \line 32 \f0\fs18 ) \line\f3\fs16 33 \f0\fs18\} \fs24\par
\f2\fs20 Fig. 5.11 Imprimindo um \i string, \i0 um caractere de cada vez, usando um ponteiro n\'e3o-constante para F dados constantes (parte 1 de 2). \f0\fs24\par
\pard\par
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx8153\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx8946\pard\intbl\f3\fs16 O string antes da convers\'e3o \'e9: caracteres e $32,98 O string depois da convers\'e3o \'e9: CARACTERES E $32,98 \f0\fs24\cell\cell\fs20\row
\f2\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx8153\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx8946\intbl Fig. 5.10 Convertendo um \i string \i0 para mai\'fasculas. \f0\fs24\cell\cell\fs20\row
\f3\fs16\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx8153\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx8946\intbl 1 \i\f2\fs20 II \i0\f3\fs16 Fig. 5.11: figOS 11.cpp \f0\fs24\cell\cell\fs20\row
\f3\fs16\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx8153\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx8946\intbl 2 \i\f2\fs20 II \i0\f3\fs16 Imprimindo um string, um caractere de cada vez, \f0\fs24\cell\f3\fs16 usando \f0\fs24\cell\fs20\row
\f3\fs16\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx8153\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx8946\intbl 3 \f0\fs18 // \f3\fs16 um ponteiro n\'e3o-constante para dados constantes \f0\fs24\cell\cell\fs20\row
\f3\fs16\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx8153\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx8946\intbl 4 #include <iostream> \f0\fs24\cell\cell\fs20\row
\f3\fs16\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx8153\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx8946\intbl 5 \f0\fs24\cell\cell\fs20\row
\f3\fs16\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx8153\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx8946\intbl 6 using std: :cout; \f0\fs24\cell\cell\fs20\row
\f3\fs16\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx8153\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx8946\intbl 7 using std: :endl; \f0\fs24\cell\cell\fs20\row
\f3\fs16\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx8153\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx8946\intbl 8 \f0\fs24\cell\cell\fs20\row
\pard\fs24\par
\pard\sb100\sa240\fs14 CAP\'cdTULO 5 \f2\fs8 - \f0\fs14 PONTEIROS E \i STRINGS \b\i0\f2\fs20 331 \b0\f0\fs24\par
\fs14 9 void printCharacters \b\f2\fs20 ( \b0\f0\fs14 const char \f2\fs10 * \f0\fs24\par
\fs16 10 \fs24\par
\f3\fs16 14 \f0\fs24\par
\fs16 int main \fs24\par
\f3\fs16 char string[] \b\f0 = \b0\f3\ldblquote imprime os caracteres de um string\rdblquote ; \f0\fs24\par
\f3\fs16 15 cout \'ab \ldblquote O string \'e9:\\n\rdblquote ; \line 16 printCharacters \b\f2\fs20 ( \b0\f3\fs16 string ); \line 17 cout \'ab endi; \line 18 return 0; \line 19 \f0\fs24\par
\fs18 20 \fs24\par
\b\f2\fs20 // \b0\f3\fs16 Em printCharacters, sPtr n\'e3o pode modificar o caractere \i\f2\fs22 II \i0\f3\fs16 para o qual ele aponta. sPtr \'e9 um ponteiro \ldblquote somente para leitura\rdblquote  void printCharacters( const char *sptr \f0\fs24\par
\f3\fs16 for \b\f2\fs20 ( \b0\f3\fs16 ; *sptr \b\f0 != \b0\f3\lquote\\O\rquote ; sPtr++ \b\f2\fs20 ) // \b0\f3\fs16 nenhuma inicializa\'e7\'e3o cout \f0\'ab \f3 *sptr; \f0\fs24\par
\f2\fs20 Fig. 5.11 Imprimindo um \i string, \i0 um caractere de cada vez, usando um ponteiro n\'e3o-constante para dados constantes (parte 2 de 2). \line\f0\fs18 A Fig. 5. 12 mostra as mensagens de erro de sintaxe produzidas quando se tenta compilar uma fun\'e7\'e3o que recebe um ponteiro n\'e3o-constante para dados constantes e ent\'e3o se tenta usar o ponteiro para modificar os dados. \line 1 \i\f2\fs22 II \i0\f3\fs16 Fig. 5.12: fig05_12.cpp \line\f0\fs18 2 \b\f2\fs20 // \b0\f3\fs16 Tentando modificar dados atrav\'e9s de um \line 3 \i\f2\fs20 II \i0\f3\fs16 ponteiro n\'e3o-constante para dados constantes. \line 4 #include <iostream> \line 5 \f0\fs24\par
\f3\fs14 6 void f \b\f2\fs20 ( \b0\f3\fs14 const int \f2\fs10 * \f0\fs24\par
\b\fs16 7 \b0\fs24\par
\f3\fs16 8 int main \f0 O \line\f3 9 \line\f0 10 int y; \fs24\par
\fs16 11 \fs24\par
\f3\fs16 12 f \b\f2\fs20 ( \b0\f3\fs16 &y ); \b\f2\fs20 // \b0\f3\fs16 f tenta modifica\'e7\'e3o ilegal \f0\fs24\par
\fs16 13 \fs24\par
\f3\fs16 14 return 0; \f0\fs24\par
\fs16 15 \line\f3 16 \f0\fs24\par
\i\f2\fs22 /1 \i0\f3\fs16 xPtr n\'e3o pode modificar o valor \i\f2\fs22 II \i0\f3\fs16 da vari\'e1vel para a qual ele aponta vojd f( const int *xptr \f0\fs24\par
\f3\fs16 *xptr \b\f0 = 100; \b0\fs24\par
\fs16 11 \line\f3 12 \line\b\f0 13 \b0\fs24\par
\b\fs16 21 \line 22 \line 23 \line 24 \line\b0\f3 25 \line 26 \line 27 \f0\fs24\par
\f3\fs16 17 \line 18 \line 19 \line\b\f0 20 \line 21 \line 22 \b0\fs24\par
\b\f2\fs20 // \b0\f3\fs16 n\'e3o se pode modificar um objeto const \f0\fs24\par
\f2\fs18 Fig. 5.12 Tentando modificar dados atrav\'e9s de um ponteiro n\'e3o-constante para dados constantes (parte \line\b\f0\fs16 1 \b0\f2\fs18 de 2). \f0\fs24\par
\pard\par
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx205\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx998\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx3711\pard\intbl\f3\fs16 O \f0\fs24\cell\f3\fs16 string \f0\fs24\cell\f3\fs16\'e9: \f0\fs24\cell\fs20\row
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx998\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx3711\pard\intbl\f3\fs16 imprime \f0\fs24\cell\f3\fs16 os caracteres de um string \f0\fs24\cell\fs20\row
\pard\fs24\par
\pard\sb100\sa240\b\f3\fs16 CAP\'cdTULO \b0\i\f0\fs18 5 \i0\f2\fs8 - \f0\fs14 PONTEIROS E \i STRINGS \b\i0\f2\fs22 333 \line\f3\fs16 4 \b0\f0\fs20 # \b\f3\fs16 include <iostream> \line 5 \line 6 int main \b0\f0\fs20 O \line\b\f3\fs16 7 \line 8 int x, y; \line 9 \line 10 int \b0\f2\fs12 * \b\f3\fs16 const ptr \b0\f2\fs10 = \b\fs16 &x; \b0\f0\fs20 // \b\f3\fs16 ptr \'e9 um ponteiro constante para um \line 11 \b0\f0\fs20 // \b\f3\fs16 inteiro. Um inteiro pode ser modificado \line 12 \b0\f0\fs20 // \b\f3\fs16 atrav\'e9s de ptr, mas ptr sempre aponta \line 13 \b0\i\f0\fs20 II \b\i0\f3\fs16 para a mesma posi\'e7\'e3o de mem\'f3ria. \line 14 *ptr \b0\f2\fs10 = \b\f3\fs16 7; \line 15 ptr \b0\f2\fs10 = \line\b\f3\fs16 16 \line 17 return O; \line 18 \line\b0\i\f0\fs18 Mensagem de erro do compilador Borland C+ + com linha de comando: \i0\fs24\par
\b\f2\fs18 Fig. 5.13 \b0\fs20 Tentando modificar um ponteiro constante para dados n\'e3o-constantes (parte 2 de 2). \line\i\f0 Erro comum de programa\'e7\'e3o 5.6 \line\i0\f1\fs26\'c9 \i\f0\fs18 erro de sintaxe n\'e3o inicializar um ponteiro declarado como \b\i0\f3\fs16 const. \line\b0\f0\fs18 Os menores privil\'e9gios de acesso s\'e3o garantidos por um ponteiro constante para dados constantes. Um ponteiro assim sempre aponta para a mesma posi\'e7\'e3o de mem\'f3ria e os dados nessa posi\'e7\'e3o de mem\'f3ria n\'e3o podem ser modificados usando o ponteiro. Assim \'e9 que um array deve ser passado para uma fun\'e7\'e3o que s\'f3 examina o pr\'f3prio array, usando a nota\'e7\'e3o de subscrito de arrays, sem modific\'e1-lo. O programa da Fig. 5.14 declara a vari\'e1vel ponteiro ptr como sendo do tipo const int \f2\fs12 * \f0\fs18 const. Esta declara\'e7\'e3o \'e9 lida, da direita para esquerda, como \ldblquote ptr \'e9 um ponteiro constante para uma constante do tipo inteiro\rdblquote . A figura mostra as mensagens de erro geradas quando foi feita uma tentativa para se modificar os dados para os quais ptr aponta e quando foi feita uma tentativa de modificar o endere\'e7o armazenado na vari\'e1vel ponteiro. Note que nenhum erro \'e9 gerado quando tentamos exibir o valor para o qual ptr aponta, porque nada est\'e1 sendo modificado no comando de sa\'edda. \fs24\par
\b\f2\fs18 Fig. 5.14 \b0 Tentando modificar um ponteiro constante para dados constantes (parte 1 de 2). \f0\fs24\par
\pard\par
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx5389\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx6470\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx7455\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx7691\pard\intbl\b\f3\fs16 Error E2024 figOs 13.cpp 15: Cannot modify a const main() \b0\f0\fs24\cell\b\f3\fs16 object in \b0\f0\fs24\cell\b\f3\fs16 function \b0\f0\fs24\cell\cell\fs20\row
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx5076\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx5389\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx6470\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx7455\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx7691\pard\intbl\i\fs16 Mensagem de erro do compilador Microsoft Visual C+ + \i0\fs24\cell\cell\cell\cell\cell\fs20\row
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx5389\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx7455\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx7691\pard\intbl\fs22 [figos \b\f3\fs16 13.cpp(15) : error C2166: 1-value specifies \b0\f0\fs24\cell\b\f3\fs16 const object \b0\f0\fs24\cell\cell\fs20\row
\pard\sa240\fs24\par
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx301\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4564\pard\intbl\b\f3\fs16 1  2  3  4 \b0\f0\fs24\cell\fs20 // \b\f3\fs16 Fig. 5.14: figO5l4.cpp  \b0\i\f0\fs20 1/ \b\i0\f3\fs16 Tentando modificar um ponteiro constante  \b0\i\f0\fs20 II \b\i0\f3\fs16 para dados constantes.  #include <iostream> \b0\f0\fs24\cell\fs20\row
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx301\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4293\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4564\pard\intbl\b\f3\fs16 5 \b0\f0\fs24\cell\cell\cell\fs20\row
\b\f3\fs16\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx301\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4293\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4564\intbl 6  7  8 \b0\f0\fs24\cell\b\f3\fs16 using std::cout; using std: :endl; \b0\f0\fs24\cell\cell\fs20\row
\b\f3\fs16\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx301\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4293\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4564\intbl 9  10  11 \b0\f0\fs24\cell\b\f3\fs16 int \b0\f0\fs22 main()  \fs20\{  \b\f3\fs16 int x \b0\f2\fs10 = \b\f3\fs16 5, y; \b0\f0\fs24\cell\cell\fs20\row
\pard\fs24\par
\pard\sb100\sa240\f2\fs22 334 C++ \fs16 COMO \f0 PROGRAMAR \line\f2 12 \line\b\f3 13 const int *const ptr \b0\f2\fs10 = \b\f3\fs16 &x; \b0\i\f2\fs20 II \b\i0\f3\fs16 ptr \'e9 um ponteiro constante para \b0\f0 uma \line\b\f3 14 \b0\i\f2\fs22 II \b\i0\f3\fs16 constante inteira. ptr sempre \line 15 \b0\f2\fs22 // \b\f3\fs16 aponta para a mesma posi\'e7\'e3o e o \line 16 \b0\i\f2\fs22 II \b\i0\f3\fs16 inteiro \b0\f0 que \b\f3 est\'e1 armazenado nessa \line 17 \b0\i\f2\fs22 II \b\i0\f3\fs16 posi\'e7\'e3o n\'e3o pode ser modificado. \line 18 cout \'ab *ptr \'ab endl; \line 19 *ptr \b0\f2\fs10 = \b\f3\fs16 7; \line 20 ptr \b0\f2\fs10 = \line\f0\fs16 21 \line\b\f2\fs18 22 \b0\f0\fs16 returnO; \line 23 \line\i\fs18 Mensagem de erro do compilador Borland C++ com linha de comando: \line\i0\fs16 Error E2024 fig05 14.cpp 19: Cannot modify a const object in funetion \b\f3 main() \line Error E2024 fig05 14.cpp 20: Cannot modify a const obect in function main() \line\b0\i\f0\fs18 Mensagem de erro do compilador Microsofi Visual C+ \i0\fs16 + \line\b\f3 figO5l4.cpp(19) : error C2166: 1-value specifies const object \line figO5l4.cpp(20) : error C2166: 1-value specifies const object \line\f2\fs18 Fig. \b0\fs20 5.14 Tentando modificar um ponteiro constante para dados constantes (parte 2 de 2). \line\b\fs26 5.6 \i Bubble sort \i0 usando chamada por refer\'eancia \line\b0\f0\fs16 Modifiquemos o programa \i\fs18 bubble sori \i0\fs16 da Fig. \f2\fs20 4.16 \f0\fs16 para usar duas fun\'e7\'f5es \f2\fs8 - \f0\fs16 bubbleSort e swap (Fig. 5.15). A fun\'e7\'e3o bubbleSort executa a ordena\'e7\'e3o do array. Ela chama a fun\'e7\'e3o swap para permutar os elementos de array array \f2\fs22 [ j 1 \f0\fs16 e array \f2\fs22 [j \b\f3\fs16 + \b0\f0 1 \f2\fs22 ]. \f0\fs16 Lembre-se de que C\'f7\'f7 for\'e7a obrigatoriamente a oculta\'e7\'e3o de informa\'e7\'e3o entre fun\'e7\'f5es, de modo que swap n\'e3o tem acesso a elementos individuais do array em bubbleSort. Como bubbleSort \i\fs18 quer \i0\fs16 que swap tenha acesso aos elementos do array que devem ser trocados de posi\'e7\'e3o, bub \f2\fs8 - \f0\fs16 bleSort passa cada um destes elementos atrav\'e9s de uma chamada por refer\'eancia para swap \f2\fs8 - \f0\fs16 o endere\'e7o de cada elemento de array \f2\fs22\'e9 \f0\fs16 passado explicitamente. Embora arrays inteiros sejam automaticamente passados por chamadas por refer\'eancia, elementos individuais de array s\'e3o escalares e s\'e3o normalmente passados por chamadas por valor. Portanto, bubbleSort usa o operador de endere\'e7o \f2\fs22 ( \b\f3\fs16 & \b0\f2\fs22 ) \f0\fs16 para cada elemento de array na chamada swap, como segue, para fazer a chamada por refer\'eancia: \line\b\f3 swap \b0\f2\fs22 ( \b\f3\fs16 &array[ \b0\f2\fs22 j 1, \b\f3\fs16 &array[ \b0\f2\fs22 j \b\f3\fs16 + \b0\f0 1 \f2\fs22 1 \i\f0\fs18 ); \line\b\i0\f3\fs16 1 \b0\i\f2\fs22 II \b\i0\f3\fs16 Fig. 5.15: figO5l5.cpp \line 2 \b0\i\f2\fs20 II \b\i0\f3\fs16 Este programa p\'f5e valores em um array, classifica os valores em \line 3 \b0\i\f2\fs20 II \b\i0\f3\fs16 ordem crescente e imprime o array resultante. \line 4 #include <iostream> \line 5 \line 6 using std::cout; \line 7 using std: :endl; \line 8 \line 9 #include <iomanip> \line\f2\fs18 Fig. 5.15 \b0\i\fs20 Bubble sort com \i0 chamada por refer\'eancia (parte 1 de 2). \f0\fs24\par
\f3\fs16 for \f0\fs22 ( \f3\fs16 i \f2\fs10 = \f3\fs16 O; i < arraySize; i++ \line cout \'ab setw( 4 \f0\fs22 ) \f3\fs16\'ab a[ i ]; \f0\fs24\par
\f3\fs16 cout \'ab endi; \f0\fs24\par
\f3\fs16 return O; \f0\fs24\par
\f3\fs16 if \f0\fs22 ( \f3\fs16 array[ \f0\fs22 j ] \f3\fs16 > array[ + 1 swap( &array[ \f0\fs22 ], \f3\fs16 &array[ \f0\fs18\'f7 \f3\fs16 1) ); \f0\fs24\par
\fs16 CAP\'cdTULO \i\f2\fs20 5 \i0\fs8 - \f0\fs16 PONTEIROS \b\fs14 E \b0\i STRINGS \i0\fs22 335 \fs24\par
\f3\fs14 void swap(int \f2\fs10 * \f3\fs14 const elementlPtr, int \f2\fs10 * \f3\fs14 const element2Ptr \f0\fs24\par
\f3\fs14 int hold \f2\fs10 = \f3\fs14 *elementlptr; \line *elementlptr \f2\fs10 = \f3\fs14 *element2ptr; \f0\fs24\par
\f3\fs14 *element2ptr \f2\fs10 = \f3\fs14 hold; \f0\fs24\par
\fs18 A fun\'e7\'e3o swap recebe &array [ j \} na vari\'e1vel ponteiro elementlPtr. Por causa do princ\'edpio de ocultamento de informa\'e7\'e3o, swap n\'e3o tem permiss\'e3o de conhecer o nome array [ j J, mas swap pode usar elementlPtr como sin\'f4nimo para array [ j 1. Deste modo, quando swap referencia elementlPtr, ela est\'e1 na realidade \fs24\par
\f3\fs16 using std::setw; \line void bubbleSort( int \f2\fs8\lquote , \f3\fs16 const int ); \line int main \f0\fs22 O \line\f3\fs16 const int arraySize \f2\fs10 = \f3\fs16 10; \line int a[ arraySize \f0\fs22 ) \f2\fs10 = \f0\fs22\{ \f3\fs16 2, 6, 4, 8, 10, 12, 89, \line int i; \line cout \'ab \ldblquote Itens de dados na ordem original\\n\rdblquote ; \line for \f0\fs22 ( \f3\fs16 i \f2\fs10 = \f3\fs16 0; i < arraySize; i++ \line cout \'ab setw( 4 \f0\fs22 ) \f3\fs16\'ab a[ i \f0\fs22 1; \line\f3\fs16 bubbleSort( a, arraySize ); \i\f2\fs20 II \i0\f3\fs16 classifica o array cout \'ab \ldblquote\\nltens de dados em ordem ascendente\\n; \f0\fs24\par
\f3\fs16 68, 45, 37 \}; \f0\fs24\par
\f3\fs20 10 \line 11 \line 12 \line 13 \line 14 \line 15 \line 16 \line 17 \line 18 \line 19 \line 20 \line 21 \line\f0\fs18 22 \line\f3\fs20 23 \line 24 \line 25 \line 26 \line 27 \line 28 \line 29 \line 30 \line\f0\fs18 31 \line\f3\fs20 32 \line 33 \line 34 \line 35 \line 36 \line 37 \line 38 \line 39 \line 40 \line 41 \line 42 \line 43 \line 44 \line 45 \line 46 \line 47 \line 48 \line 49 \line 50 \line 51 \line 52 \line\f1\fs190 E \f0\fs24\par
\f3\fs14 void bubbleSort( int *array, const int size void swap( int \f2\fs10 * \f3\fs14 const; int \f2\fs10 * \f3\fs14 const); for \f0\fs22 ( \f3\fs14 int pass \f2\fs10 = \f3\fs14 0; pass < size \f2\fs8 - \f3\fs14 1; pass++ \line for (intj =0; j<size-l; j++) \f0\fs24\par
\f2\fs20\} \f0\fs24\par
\f2\fs20 Fig. 5.15 \i Bubble sort com \i0 chamada por refer\'eancia (parte 2 de 2). \f0\fs24\par
\pard\par
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx589\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx998\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1695\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2104\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2801\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx3978\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4387\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4796\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx5205\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx5614\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx5850\pard\intbl\f3\fs16 Itens \f0\fs24\cell\f3\fs16 de \f0\fs24\cell\f3\fs16 dados \f0\fs24\cell\f3\fs16 na \f0\fs24\cell\f3\fs16 ordem \f0\fs24\cell\f3\fs16 original \f0\fs24\cell\cell\cell\cell\cell\cell\fs20\row
\f3\fs16\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx589\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx998\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1695\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2104\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2801\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx3978\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4387\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4796\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx5205\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx5614\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx5850\intbl 2 \f0\fs24\cell\cell\f3\fs16 6 \f0\fs24\cell\f3\fs16 4 \f0\fs24\cell\f3\fs16 8 \f0\fs24\cell\f3\fs16 10 12 \f0\fs24\cell\f3\fs16 89 \f0\fs24\cell\f3\fs16 68 \f0\fs24\cell\f3\fs16 45 \f0\fs24\cell\f3\fs16 37 \f0\fs24\cell\cell\fs20\row
\f3\fs16\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx589\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx998\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1695\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2104\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2801\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx3978\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4387\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4796\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx5205\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx5614\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx5850\intbl Itens \f0\fs24\cell\f3\fs16 de \f0\fs24\cell\f3\fs16 dados \f0\fs24\cell\f3\fs16 em \f0\fs24\cell\f3\fs16 ordem \f0\fs24\cell\f3\fs16 ascendente \f0\fs24\cell\cell\cell\cell\cell\cell\fs20\row
\f3\fs16\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx589\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx998\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1695\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2104\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2801\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx3978\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4387\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4796\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx5205\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx5614\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx5850\intbl 2 \f0\fs24\cell\cell\f3\fs16 4 \f0\fs24\cell\f3\fs16 6 \f0\fs24\cell\f3\fs16 8 \f0\fs24\cell\f3\fs16 10 12 \f0\fs24\cell\f3\fs16 37 \f0\fs24\cell\f3\fs16 45 \f0\fs24\cell\f3\fs16 68 \f0\fs24\cell\f3\fs16 89 \f0\fs24\cell\cell\fs20\row
\pard\fs24\par
\pard\sb100\sa240\b\fs16 CAP\'cdTULO \b0\fs20 5 \f2\fs8 - \b\f0\fs16 PONTEIROS E \b0\i\fs14 STRINGS \b\i0\f2\fs22 337 \line\b0\i\f0\fs20 Erro comum de programa\'e7\'e3o 5.7 \line Usar o operador \b\i0\fs16 si \b0\fs20 zeof \i\fs18 em uma fun\'e7\'e3o para achar o tamanho em bytes de um argumento do tipo array \line resulta no tamanho em bytes de um ponteiro e n\'e3o no tamanho em bytes do array. \line\b\i0\f3\fs16 1 \b0\i\f0\fs20 II \b\i0\f3\fs16 Fig. 5.16: fig0516.cpp \line 2 \b0\i\f0\fs20 1/ \b\i0\f3\fs16 O operador sizeof, quando usado com um nome de array, \line 3 \b0\i\f0\fs20 II \b\i0\f3\fs16 retorna o n\'famero de bytes no array. \line 4 #include <iostream> \line 5 \line 6 using std::cout; \line 7 using std: :endl; \line 8 \line 9 size_t getsize( double \b0\f2\fs12 * \line\b\f3\fs16 10 \line 11 int main() \line 12 \b0\i\f0\fs20\{ \line\b\i0\f3\fs16 13 double array \b0\i\f0\fs20 [ \b\i0\fs16 20 \b0\i\fs20 1; \line\b\i0\f3\fs16 14 \line\f0 15 cout \'ab \lquote O n\'famero de bytes no array \'e9 \line 16 \'ab sizeof( array \line 17 \'ab \ldblquote\\nO n\'famero de bytes retornados por getSize \'e9 \line 18 \'ab getSize( array \b0\i\fs20 ) \'ab \b\i0\fs16 endi; \line 19 \line\f3 20 return 0; \line\f0 21 \b0\i\fs20\} \line\b\i0\fs16 22 \line\f3 23 sizet getSize( double *ptr \line\f0 24 \line\f3 25 return sizeof( ptr ); \line 26 \b0\f0\fs24\par
\b\f2\fs18 Fig. 5.16 \b0\fs20 O operador \b\f0\fs16 sizeof, \b0\f2\fs20 quando aplicado a um nome de array, retorna o n\'famero de bytes no array. \line O \f0\fs18 n\'famero de elementos em um array pode ser tamb\'e9m determinado usando-se os resultados de duas opera\'e7\'f5es sizeof. Por exemplo, considere a seguinte declara\'e7\'e3o de array: \line doublerealArray[ 22 \b\f3\fs16 ]; \line\b0\f0\fs18 Se vari\'e1veis do tipo de dados double s\'e3o armazenadas em 8 bytes de mem\'f3ria, o array realArray cont\'e9m um total de 176 bytes. Para determinar o n\'famero de elementos no array, pode ser usada a express\'e3o seguinte: \line sizeofrealArray/ sizeof( double \line A express\'e3o determina o n\'famero de bytes no array realArray e divide esse valor pelo n\'famero de bytes de mem\'f3ria utilizados para armazenar um valor double. \line\f2\fs20 O \f0\fs18 programa da \f2\fs20 Fig. \f0\fs18 5.17 usa o operador si zeof para calcular o n\'famero de bytes usados para armazenar cada um dos tipos de dados normais dispon\'edveis no computador pessoal que estivermos usando. \line\i\fs20 Dica de portabilidade 5.3 \line\i0\f2\fs8 ______ \i\f0\fs18 O n\'famero de bytes usados para armazenar um tipo particular de dados pode variar entre sistemas. Quando estiver escrevendo programas que dependem do tamanho dos tipos de dados e que ser\'e3o executados em \i0\fs24\par
\pard\par
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx233\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1026\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1435\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2132\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx3210\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4870\pard\intbl\b\fs16 O \b0\fs24\cell\b\fs16 n\'famero \b0\fs24\cell\b\fs16 de \b0\fs24\cell\b\fs16 bytes \b0\fs24\cell\b\fs16 no \b0\fs24\cell\b\fs16 array \'e9 80 \b0\fs24\cell\fs20\row
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx233\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1026\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1435\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2132\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx3213\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4870\pard\intbl\b\f3\fs16 O \b0\f0\fs24\cell\b\f3\fs16 n\'famero \b0\f0\fs24\cell\b\f3\fs16 de \b0\f0\fs24\cell\b\f3\fs16 bytes \b0\f0\fs24\cell\b\f3\fs16 retornado \b0\f0\fs24\cell\b\f3\fs16 por getSize \'e9 4 \b0\f0\fs24\cell\fs20\row
\pard\fs24\par
\pard\sb100\sa240\f2\fs16 24 \line\f3 25 \line 26 \line 27 \line 28 \line 29 \line 30 \line 31 \line 32 \f0\fs24\par
\f3\fs16 33 \line 34 \line 35 \line 36 \line 37 \line 38 \line 39 \line 40 \f0\fs24\par
\f3\fs16 using std::cout; using std: :endl; \f0\fs24\par
\f3\fs14\'ab \ldblquote\\nsizeof \f0 $ \f3\'ab \line\'ab \ldblquote\\tsizeof(short) \f2\fs10 = \line\f3\fs14\'ab \lquote\\nsizeof i \f2\fs10 = \ldblquote  \f3\fs14\'ab \line\'ab \ldblquote\\tsizeof(int) \f2\fs10 = \line\f3\fs14\'ab \ldblquote\\nsizeof 1 \f2\fs10 = \ldblquote  \f3\fs14\'ab \line\'ab \ldblquote\\tsizeof(long) \f2\fs10 = \line\f3\fs14\'ab \lquote\\nsizeof f \f2\fs10 = \line\f3\fs14\'ab \ldblquote\\tsizeof(float) \f2\fs10 = \line\f3\fs14\'ab \ldblquote\\nsizeof d \f2\fs10 = \ldblquote  \f3\fs14\'ab \f0\fs24\par
\f3\fs16\'ab \line\'ab \line\'ab \line\'ab \line\'ab \line return 0; \f0\fs24\par
\f3\fs16 sizeof $ \line\'ab $izeof( short \line sizeof i \line\'ab sizeof( int \line sizeof 1 \'ab sizeof( lorig sizeof \i\f0 f \line\i0\f3\'ab sizeof( float sizeof d \f0\fs24\par
\f3\fs14 sizeof (char) \f2\fs10 = \f3\fs14 1 \line sizeof (short) \f2\fs10 = \f3\fs14 2 \line sizeof (int) \f2\fs10 = \f3\fs14 4 \line sizeof (long) \f2\fs10 = \f3\fs14 4 \line sizeof (float) \f2\fs10 = \i\f0\fs16 4 \line\i0\f3\fs14 sizeof (doubje) \f2\fs10 = \f3\fs14 8 \line sizeof (long double) \f2\fs10 = \f3\fs14 8 \f0\fs24\par
\f2\fs18 Fig. 5.17 Usando o operador \b\f0\fs16 sizeof \b0\f2\fs18 para determinar os tamanhos de tipos de dados padr\'e3o. \f0\fs24\par
\f2\fs18 O operador \f0 sizeof \f2 pode ser aplicado a qualquer nome de \f0\fs20 vari\'e1vel, nome de tipo ou valor constante. \f2\fs18 Quando aplicado a um nome de vari\'e1vel (o qual n\'e3o \'e9 um nome de array) ou um valor constante, o n\'famero de bytes usados \f0\fs24\par
\fs22 338 \f2\fs18 C\'f7+ COMO \f0\fs14 PROGRAMAR \fs24\par
\i\fs16 vdrios sistemas de computador use \i0\f3 sizeof \i\f0 para determinar o n\'famero de kvtes usados para armazenar os tipos de dados. \i0\fs24\par
\i\fs18 II \i0\f3\fs16 Fig. 5.17: figO5l7.cpp \line\i\f0\fs18 II \i0\f3\fs16 Demonstrando o operador sizeof #include <iostream> \f0\fs24\par
\f3\fs16 #include <iomanip> \f0\fs24\par
\f3\fs16 1 \line 2 \line 3 \line\i\f0 4 \line\i0\f3 5 \line\i\f0 6 \line\i0\f3 7 \line 8 \line 9 \line 10 \line 11 \line 12 \line 13 \line 14 \line 15 \line 16 \line 17 \line 18 \line 19 \line 20 \line 21 \line 22 \line 23 \f0\fs24\par
\f3\fs14 int main \i\f0\fs18 () \line\i0\f3\fs14 char c; \line short s; \line int i; \line long 1; \line float f; \line double d; \line long double ld; \line int array[ 20 \f0\fs22 J, \f3\fs14 *ptr \f2\fs10 = \f3\fs14 array; \line cout \'ab \ldblquote sizeof c \f2\fs10 = \f3\fs14\'ab sizeof o \line\'ab \ldblquote\\tsizeof(char) \f2\fs10 = \lquote  \f3\fs14\'ab sizeof( char \f0\fs24\par
\f2\fs20\} \f0\fs24\par
\f3\fs14\ldblquote\\tsizeof(double) \f2\fs10 = \lquote  \f3\fs14\'ab sizeof( double \ldblquote\\nsizeof ld \f2\fs10 = \f3\fs14\'ab sizeof ld \line\ldblquote\\tsizeof(long double) \f2\fs10\lquote  \f3\fs14\'ab sizeof( long double \ldblquote\\ns\'b1zeof array \'ab sizeof array \line\ldblquote\\nsizeof ptr \f2\fs10 = \ldblquote  \f3\fs14\'ab sizeof ptr \line endl; \f0\fs24\par
\f3\fs16 sizeof \f0 sizeof \line\b sizeof \line\b0 sizeof sizeof sizeof \line\b sizeof \line\b0\f3 sizeof sizeof \f0\fs24\par
\f3\fs14 c= 1 \line\b\f0\fs16 s=2 \line\b0\f3\fs14 i=4 \line 1=4 \line\b\f0\fs16 f= 4 \line\b0\f3\fs14 d=8 \line ld \f2\fs10 = \f3\fs14 8 \line\b\f0\fs16 array \b0\f2\fs10 = \f3\fs14 80 \line ptr \f2\fs10 = \f3\fs14 4 \f0\fs24\par
\b\fs14 CAP\'cdTULO \b0\fs18 5 \f2\fs8 - \b\f0\fs14 PONTEIROS E \i STRINGS \i0\fs18 339 \line\b0 para armazenar o tipo espec\'edfico de vari\'e1vel ou constante \'e9 retornado. Note que os par\'eanteses usados com \b sizeof \b0 s\'e3o exigidos se um nome de tipo \'e9 fornecido como operando. Os par\'eanteses usados com sizeof n\'e3o s\'e3o exigidos se um nome vari\'e1vel for fornecido como operando. Lembre-se, sizeof \'e9 um operador, n\'e3o uma fun\'e7\'e3o. \line\i Erro comum de programa\'e7\'e3o 5.8 \line Omitir os par\'eanteses em uma opera\'e7\'e3o \b\i0 sizeof \b0\i quando o operando \'e9 um nome de tipo \'e9 erro de sintaxe. \line\ul\i0\f2\fs36 1 \ulnone\i\f0\fs18 Dica de desempenho 5.2 \line\i0\f2\fs30 f \b\f0\fs18 sizeof \b0\i\'e9 um operado un\'e1 rio usado durante a compila\'e7\'e3o, n\'e3o uma fun\'e7\'e3o executada durante a execu\'e7\'e3o. Deste modo, usar \b\i0 sizeof \b0\i n\'e3o causa impacto negativo sobre o desempenho da execu\'e7\'e3o. \line\b\i0\f2\fs26 5.7 Express\'f5es com ponteiros e aritm\'e9tica de ponteiros \line\b0\f0\fs18 Ponteiros s\'e3o operandos v\'e1lidos em express\'f5es aritm\'e9ticas, express\'f5es de atribui\'e7\'e3o e express\'f5es de compara\'e7\'e3o. Por\'e9m, nem todos os operadores normalmente usados nestas express\'f5es s\'e3o v\'e1lidos com vari\'e1veis do tipo ponteiro. Esta se\'e7\'e3o descreve os operadores que podem ter ponteiros como operandos e como s\'e3o usados esses operadores. \line Um conjunto limitado de opera\'e7\'f5es aritm\'e9ticas pode ser executado com ponteiros. Um ponteiro pode ser \line incrementado (++) ou decrementado \f2\fs14 (--), \f0\fs18 um inteiro pode ser somado a um ponteiro (+ ou \b\f2\fs16 +), \f0\fs18 um inteiro pode ser \b0 subtra\'eddo de um ponteiro \f2\fs14 (- \f0\fs18 ou \f2\fs12 -=) \f0\fs18 ou um ponteiro pode ser subtra\'eddo de outro. \line Suponha que o array int v \b [ 5 ] \b0 tenha sido declarado e que seu primeiro elemento esteja na posi\'e7\'e3o \line 3000 da mem\'f3ria. Suponha que o ponteiro vPtr tenha sido inicializado para apontar para v \b [ O \b0\f2\fs14 ), \f0\fs18 i.e., que o \line valor de vPtr seja 3000. A Fig. 5.18 mostra com um diagrama esta situa\'e7\'e3o para uma m\'e1quina com inteiros de \line 4 bytes. Note que vPtr pode ser inicializado para apontar para o array v com qualquer um dos comandos \line seguintes \line\b vPtr \f2\fs16 = \line\f0\fs18 vPtr \f2\fs16 = \f0\fs18 &v[ O ); \line\b0\f2\fs20 posi\'e7\'e3o \line\f0\fs18 3000 3004 3008 \b\fs14 3012 3016 \line v[0] v[1] v[2) vE3] v[4) \line\b0\f2\fs20 vari\'e1vel ponteiro vPtr \line\b\fs18 Fig. 5.18 \fs26 O \b0\fs20 array \b\f0\fs16 v \b0\f2\fs20 e uma vari\'e1vel ponteiro vPtr que aponta para \b\f0\fs16 v. \line\b0\i\fs18 Dica de portabilidade 5.4 \line\i0\f2\fs8 ______ \i\f0\fs18 A maioria dos computadores atuais t\'eam inteiros de 2 bytes ou de \b\i0\f2\fs16 4 \b0\i\f0\fs18 bytes. Algumas das m\'e1quinas moo recentes usam inteiros de 8 bytes. Como os resultados da aritm\'e9tica de ponteiros dependem do tamanho \line dos objetos para os quais um ponteiro aponta, a aritm\'e9tica de ponteiros \'e9 dependente da m\'e1quina. \line\i0 Na aritm\'e9tica convencional, a adi\'e7\'e3o \b 3000 + 2 d\'e1 o valor 3002. Este normalmente n\'e3o \'e9 ocaso com a aritm\'e9tica \b0 de ponteiros. Quando um inteiro \'e9 somado a ou subtra\'eddo de um ponteiro, o ponteiro n\'e3o \'e9 simplesmente incrementado ou decrementado por esse inteiro, mas pelo tamanho do objeto inteiro ao qual o ponteiro se refere. O n\'famero de bytes depende do tipo de dado do objeto. Por exemplo, o comando \line vptr \b\f2\fs16 + 2; \b0\f0\fs24\par
\b\f2\fs14 340 \b0\f0\fs18 C++ \b\fs14 COMO PROGRAMAR \line\b0\fs18 produziria 3008 (3000 \b\fs14 + \b0\fs18 2 \f2\fs12 * \f0\fs18 4), supondo que um inteiro seja armazenado em 4 bytes de mem\'f3ria. No array v, vPtr agora apontaria para v \b\f2\fs14 [ \b0\f0\fs18 2 \b\f2\fs14 ] \b0\f0\fs18 (Fig. 5.19). Se um inteiro fosse armazenado em 2 bytes de mem\'f3ria, ent\'e3o o c\'e1lculo precedente resultaria na posi\'e7\'e3o de mem\'f3ria 3004 (3000 \b\fs14 + \b0\fs18 2 \f2\fs12 * \f0\fs18 2). Se o array fosse de um tipo de dado diferente, o comando precedente iria incrementar o ponteiro por duas vezes o n\'famero de bytes usados para armazenar um objeto desse tipo de dados. Quando se executa aritm\'e9tica de ponteiros sobre um array de caracteres, os resultados ser\'e3o consistentes com a aritm\'e9tica regular porque cada caractere tem um byte de comprimento. \line\f2\fs20 localiza\'e7\'e3o \line\f3\fs18 3000 3004 3008 3012 3016 \line\f0 v[0] \b v[1) \b0 v[2] \b v[3] v[4) \line\b0\f2\fs20 vari\'e1vel ponteiro \b\f0\fs14 vPtr \line\b0\f2\fs20 Fig. 5.19 O ponteiro \f0\fs18 vptr \f2\fs20 ap\'f3s opera\'e7\'e3o de aritm\'e9tica de ponteiros. \line\f3\fs18 Se vPtr foi incrementado para 3016, que aponta \f0 para v \b\f2\fs14 [ \b0\f3\fs18 4 \b\f2\fs14 ] \b0\fs8 , \f0\fs18 o comando \line\b vPtr \b0\f2\fs8 - \b\f0\fs18 4; \line\b0 faria vPtr apontar para 3000 \f2\fs8 - \f0\fs18 o in\'edcio do array. Se um ponteiro est\'e1 sendo incrementado ou decrementado por \line um, podem ser usados os operadores de incremento (++) e decremento \b\f2\fs14 (---). \b0\f0\fs18 Cada um dos comandos \line\b ++vPtr; \line vPtr++; \line\b0 incrementam o ponteiro para apontar para a pr\'f3xima posi\'e7\'e3o no array. Cada um dos comandos \line\b --vPtr; \line vPtr--; \line\b0 decrementa o ponteiro para apontar para o elemento precedente do array. \line Vari\'e1veis ponteiro que apontam para o mesmo array podem ser subtra\'eddas umas das outras. Por exemplo, se \line vPtr aponta para a posi\'e7\'e3o 3000 e v2Ptr cont\'e9m o endere\'e7o 3008, o comando \line\b\f2 x \b0\fs12 = \f3\fs18 v2Ptr \b\f2\fs14 - \f0\fs18 vPtr; \line\b0\f3 atribuiria a x o n\'famero de elementos de array de vPtr at\'e9 v2Ptr, neste caso, 2. A aritm\'e9tica de ponteiros n\'e3o tem \f0 sentido, a menos que executada sobre um array. N\'e3o podemos assumir que duas vari\'e1veis do mesmo tipo sejam armazenadas contiguamente na mem\'f3ria, a menos que sejam elementos adjacentes de um array. \line\b\i\fs20 Erro comum de programa\'e7\'e3o 5.9 \line\b0\fs18 Usar aritm\'e9tica de ponteiros sobre um ponteiro que n\'e3o se refere a um array de valores normalmente \'e9 um \line erro de l\'f3gica. \line\b\fs20 Erro comum \b0\fs18 de \b\fs20 programa\'e7\'e3o 5.10 \line\b0\fs18 Subtrair ou comparar dois ponteiros que n\'e3o se referem a elementos do mesmo array normalmente \'e9 um \line erro de l\'f3gica. \line\b\fs20 Erro comum de programa\'e7\'e3o 5.11 \line\b0\fs18 Endere\'e7ar al\'e9m dos extremos de um array, quando usamos aritm\'e9tica de ponteiros, normalmente \'e9 erro de \line l\'f3gica. \i0\fs24\par
\fs20 CAP\'cdTULO \f2\fs16 5 \fs8 - \b\fs16 PONTEIROS E \i\fs14 STRINGS \i0\fs22 341 \b0\f0\fs24\par
\fs18 Um ponteiro pode ser atribu\'eddo a outro ponteiro se ambos os ponteiros s\'e3o do mesmo tipo. Caso contr\'e1rio, deve ser usado um operador de convers\'e3o de tipo para converter o valor do ponteiro \'e0 direita da atribui\'e7\'e3o para o tipo de ponteiro \'e0 esquerda da atribui\'e7\'e3o. A exce\'e7\'e3o a esta regra \'e9 o ponteiro para void (i.e., void \f2 *), \f0 o qual \'e9 um ponteiro gen\'e9rico capaz de representar qualquer tipo de ponteiro. Um ponteiro void pode ser atribu\'eddo a todos os tipos de pontejro, sem convers\'e3o de tipo. Por\'e9m, um ponteiro void n\'e3o pode ser diretamente atribu\'eddo a um ponteiro de outro tipo \f2\fs8 - \f0\fs18 o ponteiro void deve primeiro ser convertido para o tipo de ponteiro apropriado. \line Um ponteiro void n\'e3o pode ser derreferenciado. Por exemplo, o compilador sabe que um ponteiro para int se refere a quatro bytes de mem\'f3ria em uma m\'e1quina com inteiros de 4 bytes, mas um ponteiro void simplesmente cont\'e9m o endere\'e7o de mem\'f3ria de um dado de tipo desconhecido \f2\fs8 - \f0\fs18 o n\'famero preciso de bytes a que o ponteiro se refere n\'e3o \'e9 conhecido pelo compilador. O compilador deve saber o tipo de dados para determinar o n\'famero de bytes a serem dereferenciados para um ponteiro particular. No caso de um ponteiro para void, este n\'famero de bytes n\'e3o pode ser determinado pelo tipo. \fs24\par
\i\fs18 Erro comum de programa\'e7\'e3o 5.12 \line Atribuir um ponteiro de um tipo a um ponteiro de outro (diferente de \i0\fs20 void \f2\fs18 *), \i\f0 sem converter o primeiro \line ponteiro para o tipo do segundo ponteiro, \'e9 erro de sintaxe. \i0\fs24\par
\i\fs18 Erro de programa\'e7\'e3o comum 5.13 \line Derreferenciar um ponteiro \i0\fs20 void \'e9 \i\fs18 um erro de sintaxe. \i0\fs24\par
\fs20 Ponteiros podem ser comparados usando-se operadores de igualdade e relacionais, mas tais compara\'e7\'f5es n\'e3o t\'eam sentido a menos que os ponteiros apontem para membros do mesmo array. As compara\'e7\'f5es de ponteiros comparam os endere\'e7os armazenados nos ponteiros. Uma compara\'e7\'e3o de dois ponteiros apontando para o mesmo array podia mostrar, por exemplo, que um ponteiro aponta para um elemento do array de \'edndice mais alto que o outro ponteiro. Um uso comum da compara\'e7\'e3o de ponteiros \'e9 determinar se um ponteiro \'e9 O. \fs24\par
\b\f2\fs28 5.8 A rela\'e7\'e3o entre ponteiros e arrays \b0\f0\fs24\par
\fs18 Em C++, arrays e ponteiros est\'e3o intimamente relacionados e podem ser usados de maneira \i quase \i0 intercambi\'e1vel, Um nome de array pode ser encarado como um ponteiro constante. Os ponteiros podem ser usados para fazer qualquer opera\'e7\'e3o envolvendo indexa\'e7\'e3o de arrays. \fs24\par
\i\fs18 Boa pr\'e1tica de programa\'e7\'e3o 5.4 \line Use a nota\'e7\'e3o de array em vez da nota\'e7\'e3o de ponteiro quando manipular arrays. Embora o programa \line possa se tornar ligeiramente mais lento para ser compilado, provavelmente ele ser\'e1 mais claro. \i0\fs24\par
\fs20 Suponha que o array de inteiros b \b\f2\fs22 [ \b0\f0\fs20 5 \b\f2\fs22 ] \b0\f0\fs20 e a vari\'e1vel ponteiro de inteiros bPtr tenham sido declarados. Como o \line nome de array (sem um subscrito) \'e9 um ponteiro para o primeiro elemento do array, podemos atribuir a bPtr o \line endere\'e7o do primeiro elemento no array b com o comando \fs24\par
\fs20 bPtr \f2\fs16 = \f0\fs24\par
\fs20 Isto \'e9 equivalente a termos atribu\'eddo o endere\'e7o do primeiro elemento do array como segue \fs24\par
\b\f2\fs14 bPtr \b0\fs12 = \b\fs14 &b[ O \b0\f0\fs24\par
\fs20 O elemento b \b\f2\fs22 [ 3 3 \b0\f0\fs20 do array pode ser alternativamente referenciado com a express\'e3o de ponteiro \fs24\par
\f2\fs12 * \f0\fs16 ( bPtr \b\i\f2\fs14 + \b0\i0\f0\fs16 3 \fs24\par
\fs18 Na express\'e3o acima, o 3 \'e9 o \i deslocamento \i0 do ponteiro. Quando o ponteiro aponta para o in\'edcio de um array, o deslocamento indica qual elemento do array devia ser referenciado, e o valor do deslocamento \'e9 id\'eantico ao \'edndice do array. A nota\'e7\'e3o precedente \'e9 conhecida como \i nota\'e7\'e3o ponteiro/deslocamento. \i0 Os par\'eanteses s\'e3o necess\'e1rios \fs24\par
\b\f2\fs22 342 \b0\fs20 C++ \b\fs14 COMO PROGRAMAR \line\b0\f0\fs18 porque a preced\'eancia de \f2\fs12 * \f0\fs18\'e9 mais alta que a preced\'eancia de \b\f2\fs14 +. \b0\f0\fs18 Sem os par\'eanteses, a express\'e3o acima somaria 3 ao valor da express\'e3o *bptr (i.e., 3 seria somado a b \b\f2\fs22 [ O ], \b0\f0\fs18 assumindo que bPtr aponta para o in\'edcio do array). Da mesma maneira que um elemento de array pode ser referenciado com uma express\'e3o de ponteiro, podemos escrever no endere\'e7o \line\b &b[ 3 \line\b0 com a express\'e3o de ponteiro \line bPtr \b\f3\fs16 + 3 \line\b0\f0\fs18 O nome do array pode ser tratado como um ponteiro e usado em aritm\'e9tica de ponteiros. Por exemplo, a express\'e3o \line\b\f2\fs14 *( b + 3 \line\b0\f0\fs18 se refere tamb\'e9m ao elemento b \b\f2\fs22 [ 3 \b0\f0\fs18 ] do array. Em geral, todas as express\'f5es com subscritos de array podem ser escritas com um ponteiro e um deslocamento. Neste caso, foi usada a nota\'e7\'e3o ponteiro/deslocamento com o nome do array como um ponteiro. Note que o comando precedente n\'e3o modifica o nome do array de nenhuma forma; b ainda aponta para o primeiro elemento no array. \line Ponteiros podem ser subscritos exatamente como podem os arrays. Por exemplo, a express\'e3o \line bPtr[ \b\f3\fs16 1 \b0\f0\fs18 ) \line se refere ao elemento de array b \b\f2\fs22 [ \b0\f0\fs18 1 \b\f2\fs22 3; \b0\f0\fs18 esta express\'e3o \'e9 chamada de \i\fs20 nota\'e7\'e3o ponteiro/subscrito. \line\i0\fs18 Lembre-se de que um nome de array \'e9 essencialmente um ponteiro constante; sempre aponta para o in\'edcio do \line array. Deste modo, a express\'e3o \line\b\f3\fs16 b + 3 \line\b0\f0\fs18\'e9 inv\'e1lida, porque tenta modificar o valor do nome de array com aritm\'e9tica de ponteiros. \line\i Erro comum de programa\'e7\'e3o \b\f2\fs20 5.14 \line\b0\f0\fs18 Embora os nomes de array sejam ponteiros para o in\'edcio do array e ponteiros possam ser modificados em express\'f5es aritm\'e9ticas, nomes de array n\'e3o podem ser modificados em express\'f5es aritm\'e9ticas porque s\'e3o ponteiros constantes. \line\i0 A Fig. 5.20 usa os quatro m\'e9todos por n\'f3s discutidos para referenciar os elementos de um array: uso de subscritos para o array, ponteiro/deslocamento com o nome do aay como ponteiro, subscritos com ponteiro e ponteiro/deslocamento com um ponteiro \f2\fs8 - \f0\fs18 para imprimir os quatro elementos do array \b b, de inteiros. \line\f3\fs16 1 \b0\i\f0\fs20 II \b\i0\f3\fs16 Fig. \f0\fs18 5.20: figO52O.cpp \line\f3\fs16 2 \b0\i\f0\fs20 II \b\i0\f3\fs16 Usando subscritos e nota\'e7\'f5es de ponteiro com arrays \line\f2\fs14 3 \line\f3\fs16 4 #include \b0\f0\fs18 <iostreain> \line\b\f2\fs14 5 \line\f3\fs16 6 using std: :cout; \line 7 using std::endl; \line 8 \line 9 int main() \line\f0\fs18 10 \b0\{ \line\b\f3\fs16 11 int b[] \b0\f2\fs10 = \f0\fs18\{ \b\f3\fs16 10, 20, 30, 40 \i\f2\fs20\}, \i0\f3\fs16 i, offset; \line 12 int *bPtr \b0\f2\fs10 = \b\f3\fs16 b;// configurar bPtr para apontar para array b \line 13 \line 14 cout \'ab \ldblquote Array b impresso com:\\n\rdblquote  \line 15 \'ab \ldblquote Nota\'e7\'e3o de subscrito de array\\n\rdblquote ; \line\b0\f2\fs20 Fig. 5.20 Usando quatro m\'e9todos de fazer refer\'eancia a elementos de array (parte 1 de 2). \f0\fs24\par
\fs14 CAP\'cdTULO \i\f2 5 \i0\fs8 - \f0\fs14 PONTEIROS E \i\fs16 STRINGS \i0\f2\fs22 343 \line\f3\fs16 16 \line\f0\fs14 17 for(i0;i<4;i++) \line\f3\fs16 18 cout \'ab \ldblquote b[\rdblquote  \'ab i \'ab \f0\fs14\ldblquote ] \f2\fs12 = \f0\fs14\'ab b[ i \fs20 1 \fs14\'ab \f3\fs16\\n\rquote ; \line 19 \line 20 \line 21 cout \'ab \ldblquote\\nNota\'e7\'e3o de ponteiro/deslocamento onde\\n\rdblquote  \line 22 \'ab \ldblquote o ponteiro \'e9 o nome do array\\n\rdblquote ; \line 23 \line 24 for \f0\fs20 ( \f3\fs16 offset \f2\fs12 = \f3\fs16 0; offset < 4; offset++ \line 25 cout\'ab \ldblquote *(b + \'ab offset \'ab \f2\fs12\ldblquote ) = \line\f3\fs16 26 \f0\fs14\'ab \f2\fs10\lquote ( \f3\fs16 b + offset \f0\fs20 ) \fs14\'ab \f3\fs16\\n; \line 27 \line 28 \line 29 cout \'ab \ldblquote\\nNota\'e7\'e3o ponteiro/subscrito\\n\rdblquote ; \line 30 \line 31 for (i0; i<4; i++) \line 32 cout \f0\fs14\'ab \f3\fs16\ldblquote bPtr[\rdblquote  \'ab i \'ab \f0\fs20 9 \f2\fs10 = \ldblquote  \f3\fs16\'ab bptr[ i \f0\fs20 1 \fs14\'ab \f3\fs16\lquote\\n\rquote ; \line 33 \line 34 cout \'ab \ldblquote\\nNota\'e7\'e3o ponteiro/deslocamento\\n\rdblquote ; \line 35 \line 36 for \f0\fs20 ( \f3\fs16 offset \f2\fs12 = \f3\fs16 0; offset < 4; offset++ \line 37 cout\'ab \ldblquote *(bptr + \f2\fs8\ldblquote  \f0\fs14\'ab \f3\fs16 offset \'ab \f2\fs12\ldblquote ) = \line\f3\fs16 38 \'ab \i\f2\fs14 ( \i0\f3\fs16 bptr + offset \f0\fs20 ) \fs14\'ab \f3\fs16\\n\rquote ; \line 39 \line 40 return 0; \line 41 \f0\fs20 ) \line\f3\fs16 Array b impresso com: \line Nota\'e7\'e3o de subscrito de array \line b[0] \f2\fs12 = \f3\fs16 10 \line b[1] \f2\fs12 = \f3\fs16 20 \line b[2] \f2\fs12 = \f3\fs16 30 \line b[3) \f2\fs12 = \f3\fs16 40 \line Nota\'e7\'e3o de ponteiro/deslocamento onde \line o ponteiro \'e9 o nome do array \line *(b + 0)= 10 \line *(b + 1)= 20 \line *(b + 2)= 30 \line *(b + 3)= 40 \line Nota\'e7\'e3o ponteiro/subscrito \line bPtr [0] \f2\fs12 = \f3\fs16 10 \line bPtr [1] \f2\fs12 = \f3\fs16 20 \line bPtr [2] \f2\fs12 = \f3\fs16 30 \line bPtr [3] \f2\fs12 = \f3\fs16 40 \line Nota\'e7\'e3o ponteiro/deslocamento \line *(bptr + O \f0\fs20 ) \f2\fs12 = \f3\fs16 10 \line *(bptr + 1 \f0\fs20 ) \f2\fs12 = \f3\fs16 20 \line *(bPtr + 2 \f0\fs20 ) \f2\fs12 = \f3\fs16 30 \line *(bptr + 3 \f0\fs20 ) \f2\fs12 = \f3\fs16 40 \line\b\f2\fs18 Fig. 5.20 \b0\fs20 Usando quatro m\'e9todos de fazer refer\'eancia a elementos de array (parte 2 de 2). \line\f0 Para ilustrarmos mais a intercambiabilidade de arrays e ponteiros, vamos examinar as duas fun\'e7\'f5es de c\'f3pia de \i\fs16 strings \i0\f2\fs8 - \f0\fs20 copyl e copy2 \f2\fs8 - \f0\fs20 no programa da Fig. 5.21. Ambas as fun\'e7\'f5es copiam um \i\fs16 string \i0\fs20 para um array de caracteres. Ap\'f3s compararmos os prot\'f3tipos de fun\'e7\'e3o de copyl e copy2, as fun\'e7\'f5es parecem id\'eanticas (por \fs24\par
\b\f2\fs22 344 \b0\fs20 C++ \b\fs14 COMO PROGRAMAR \line\b0\f0\fs20 causa da intercambiabilidade entre arrays e ponteiros). Estas fun\'e7\'f5es realizam a mesma tarefa, mas ela \'e9 executada de forma diferente. \line\b\f3\fs16 1 \b0\i\f2\fs20 II \b\i0\f3\fs16 Fig. 5.21: figO52l.cpp \f2\fs12 SI \line\f3\fs16 2 \b0\i\f2\fs22 II \b\i0\f3\fs16 Copiando um string usando nota\'e7\'e3o \line 3 \b0\i\f2\fs22 II \b\i0\f3\fs16 de array e nota\'e7\'e3o de ponteiro. \line 4 #include <iostream> co \line 5 \b0\f0\fs18 err \line\b\f3\fs16 6 using std: :cout; \b0\f0\fs20 de \line\b\f3\fs16 7 using std: :endl; \b0\f0\fs18 pa \line\b\f3\fs16 8 \b0\fs20 nu \line\b\fs16 9 void copyl( char \b0\f2\fs8\ldblquote , \b\f3\fs16 const char \b0\f2\fs10 * \b\f3\fs16 ob \line 10 void copy2( char \b0\f2\fs8 , \b\f3\fs16 const char \b0\f2\fs10 * \f0\fs20 ); ar \line\b\f3\fs16 11 \line 12 int main \b0\f0\fs20 () \line\b\f3\fs16 13 \line 14 char stringl \b0\f0\fs20 [ \b\f3\fs16 10 \f2\fs22 ], \f3\fs16 *string2 \b0\f2\fs12 = \b\f3\fs16\ldblquote Ol\'e1 ! \b0\f2\fs8\ldblquote\lquote  \b\fs24 5. \line\f3\fs16 15 string3,[ 10 \f2\fs22 ], \f3\fs16 string4[] \b0\f2\fs12 = \b\f3\fs16\ldblquote Tchau \f2\fs12 !\ldblquote ; \line\f3\fs16 16 \b0\f2\fs28 o \line\b\f3\fs16 17 copyl( stringl, string2 \b0\f0\fs20 ) \line\b\f3\fs16 18 cout \'ab \ldblquote stringl \b0\f2\fs12 = \ldblquote  \b\f3\fs16\'ab stringl \'ab endi; \line 19 \line 20 copy2( string3, string4 ); \line 21 cout \'ab \ldblquote string3 \b0\f2\fs12 = \ldblquote  \b\f3\fs16\'ab stririg3 \'ab endl; \b0\fs20 tar \line\b\fs16 22 \line 23 return 0; \line 24 \b0\f0\fs20 ) \line\b\f3\fs16 25 \line 26 \b0\i\f2\fs22 II \b\i0\f3\fs16 copia s2 para sl usando nota\'e7\'e3o de array \line 27 void copyl( char *sl, const char *s2 \b0\f0\fs20 ) \b\f3\fs16 A \line 28 \b0\f0\fs20\{ eh \line\b\f3\fs16 28 for int i \b0\f2\fs12 = \b\f3\fs16 0; \b0\f0\fs20 ( \b\f3\fs16 sl[ i \b0\f0\fs20 ] \f2\fs12 = \b\f3\fs16 s2[ i \b0\f0\fs20 ] ) \b\f2\fs14 != \f3\fs16\lquote\\O\rquote ; i++ \b0\f0\fs20 ) \line\b\f3\fs16 30 \b0\f2\fs14 ; \f0\fs20 // \b\f3\fs16 n\'e3o faz nada no corpo do for \b0\fs20 re \line\b\fs16 31 \b0\f0\fs20\} qu \line\b\f3\fs16 32 \b0\fs20 no \line\b\fs16 33 \b0\i\f2\fs22 II \b\i0\f3\fs16 copia s2 para sl usando nota\'e7\'e3o de ponteiro ro \line 34 void copy2( char *sl, const char *s2 \b0\f0\fs20 ) a \line esi \line\b\f3\fs16 36 for \b0\f0\fs20 ( \b\f3\fs16 ; \b0\f0\fs20 ( \b\f3\fs16 *sl \f2\fs14 = \f3\fs16 *s2 \b0\f0\fs20 ) \b\f2\fs14 != \f3\fs16\lquote\\O\rquote ; sl++, s2++ \line 37 \b0\f2\fs14 ; \i\fs22 II \b\i0\f3\fs16 n\'e3o faz nada no corpo do for \line 38 \b0\f0\fs20\} \fs24\par
\f2\fs20 Fig. \b\fs14 5.21 \b0\fs20 Copiando um \i string \i0 usando a nota\'e7\'e3o de array e a nota\'e7\'e3o de ponteiro. \line\f0\fs18 A \b\f3\fs16 fun\'e7\'e3o copyl \b0\f0\fs18 usa a nota\'e7\'e3o de subscrito de array para copiar o \i string \b\i0\f3\fs16 s2 para o \b0\f0\fs18 array \b\f3\fs16 de caracteres si. \b0\f0\fs18 A fun\'e7\'e3o \f2\fs8 - \f0\fs18 declara uma vari\'e1vel contadora i, do tipo inteiro, para usar como o \'edndice do array. O cabe\'e7alho da estrutura \b\f3\fs16 for Fi \line\b0\f0\fs18 executa toda a opera\'e7\'e3o de c\'f3pia \f2\fs8 - \f0\fs18 seu corpo \'e9 o comando vazio, O cabe\'e7alho especifica que i \'e9 inicializado com \line zero e incrementado de 1 a cada repeti\'e7\'e3o do la\'e7o. A condi\'e7\'e3o no for, ( si [ i 1 \b\f2\fs14 = \b0\f0\fs18 s2 [ i ] ) ! \b\f2\fs14 = \b0\f0\fs18\lquote\\O \f2\fs28 o \line\f0\fs18 executa a opera\'e7\'e3o de c\'f3pia caractere por caractere, de s2 para si. Quando o caractere nulo \'e9 encontrado em s 2, \line ele \'e9 atribu\'eddo a si e o la\'e7o termina, porque o caractere nulo \'e9 igual a \lquote\\O\rquote . Lembre-se de que o valor de um e \line comando de atribui\'e7\'e3o \'e9 o valor atribu\'eddo ao argumento da esquerda. q A fun\'e7\'e3o copy2 usa ponteiros e aritm\'e9tica de ponteiros para copiar o \i string \i0 s2 para o array de caracteres sl. pr \line Novamente, o cabe\'e7alho da estrutura for executa a opera\'e7\'e3o de c\'f3pia inteira. O cabe\'e7alho n\'e3o inclui qualquer \fs24\par
\pard\par
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx944\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1737\pard\intbl\b\f3\fs14 string 1 \f2 = \b0\f0\fs24\cell\b\f3\fs16 Ol\'e1! \b0\f0\fs24\cell\fs20\row
\b\f3\fs14\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx944\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1737\intbl string 3 \f2 = \b0\f0\fs24\cell\b\f3\fs16 Tchau! \b0\f0\fs24\cell\fs20\row
\pard\fs24\par
\pard\sb100\sa240\fs18 CAP\'cdTULO 5 \f2\fs8 - \b\f0\fs14 PONTEIROS E \i\f2\fs16 STRINGS \fs22 345 \line\b0\i0\f0\fs18 inicializa\'e7\'e3o de vari\'e1vel. Como na fun\'e7\'e3o copyi, a condi\'e7\'e3o \i ( \i0\f2\fs12 * \f0\fs18 si \f2\fs12 = * \f0\fs18 s2 \i ) ! \i0\f2\fs12 = \f0\fs18\lquote\\O executa a opera\'e7\'e3o de c\'f3pia. O ponteiro s2 \'e9 derreferenciado e o caractere resultante \'e9 atribu\'eddo ao ponteiro derreferenciado si. Depois da atribui\'e7\'e3o na condi\'e7\'e3o, os ponteiros s\'e3o incremeritados para apontar para o pr\'f3ximo elemento do array si e o pr\'f3ximo caractere do \i string \b\i0 s2, \b0 respectivamente. Quando o caractere nulo \'e9 encontrado em s2. ele \'e9 atribu\'eddo ao ponteiro derreferenciado si e o la\'e7o termina. \line Note que o primeiro argumento, tanto para copyi como copy2, deve ser um array grande o bastante para conter o \i string \i0 no segundo argumento. Caso contr\'e1rio, pode ocorrer um erro quando \'e9 feita uma tentativa de escrever em uma posi\'e7\'e3o de mem\'f3ria al\'e9m do limite do array. Note, tamb\'e9m, que o segundo argumento de cada fun\'e7\'e3o \'e9 declarado como const char \f2\fs12 * \f0\fs18 (um \i string \i0 constante). Em ambas as fun\'e7\'f5es, o segundo argumento \'e9 copiado para os primeiros argumentos-os caracteres s\'e3o copiados do segundo argumento um de cada vez, mas os caracteres nunca s\'e3o modificados. Assim, sendo o segundo argumento declarado para apontar para um valor constante, \'e9 obedecido o princ\'edpio de menor privil\'e9gio. Nenhuma das fun\'e7\'f5es necessita da capacidade de modificar o segundo argumento, assim nenhuma fun\'e7\'e3o recebe essa capacidade. \line\b\f2\fs26 59 Arrays de ponteiros \line\b0\f0\fs18 Os arrays podem conter ponteiros. Um uso comum de tal estrutura de dados \'e9 formar um array de strings, chamado simplesmente de \i array de strings. \i0 Cada entrada no array \'e9 um \i string, \i0 mas em C++ um \i string \i0\'e9 essencialmente um ponteiro para seu primeiro caractere. Assim, cada entrada em um array de \i strings \i0\'e9 realmente um ponteiro para o primeiro caractere de um \i string. \i0 Considere a declara\'e7\'e3o do array de \i string \i0 suit, que poderia ser \'fatil para representar um baralho. \line const \b char \b0 *suit[ \b 4 \b0 ] \f2\fs12 = \f0\fs18\{ \lquote Copas\rdblquote , \lquote Ouros\rdblquote , \line\ldblquote Paus\rdblquote , \ldblquote Espadas\rdblquote  \}; \line A parte \b suit \b0\i [ \b\i0\f2\fs16 4 \b0\i\f0\fs18 1 \i0 da declara\'e7\'e3o indica um array de \f2\fs20 4 \f0\fs18 elementos. A parte char \f2\fs12 * \f0\fs18 da declara\'e7\'e3o indica que cada elemento do array suit \'e9 do tipo \ldblquote ponteiro para caractere\rdblquote . Os quatro valores colocados no array s\'e3o \ldblquote Copas\rdblquote , \ldblquote Ouros\rdblquote , \ldblquote Paus\rdblquote  e \ldblquote Espadas \ldblquote .Cada um destes valores \'e9 armazenado na mem\'f3ria como um \i string \i0 de caracteres terminado com um caractere nulo \f2\fs8 - \f0\fs18 o qual tem um caractere a mais que o n\'famero de caracteres entre aspas. Os quatro \i strings \i0 t\'eam 6, 6, 5 e 8 caracteres, respectivamente. Embora pare\'e7a que estes \i strings \i0 estejam sendo colocados no array suit, s\'f3 ponteiros est\'e3o realmente armazenados no array (Fig. \f2\fs20 5.22). \f0\fs18 Cada ponteiro aponta para o primeiro caractere de seu \i string \i0 correspondente. Deste modo, embora o array suit tenha tamanho fixo, ele fornece acesso a \i strings \i0 de caracteres de qualquer comprimento. Esta flexibilidade \'e9 um exemplo das poderosas capacidades de estruturar dados de C++. \fs24\par
\b\f2\fs20 Fig. 5.22 Representa\'e7\'e3o gr\'e1fica do array \b0\f0\fs18 suit. \line Os \i strings \i0 de suit podem ser colocados em um array bidimensional, no qual cada linha representa um naipe e cada coluna representa uma das cartas de um naipe. Tal estrutura de dados deve ter um n\'famero fixo de colunas por linha e esse n\'famero deve ser t\'e3o grande quanto o maior \i string. \i0 Ent\'e3o, \'e9 perdida uma quantidade consider\'e1vel de mem\'f3ria quando um n\'famero grande de \i strings \i0\'e9 armazenado com a maioria dos strings menores que o \i string \i0 mais longo. Na pr\'f3xima se\'e7\'e3o, usamos arrays de \i slrings \b\i0 para \b0 representar um baralho. \fs24\par
\pard\par
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx648\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1271\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2027\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2741\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx3447\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4068\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4589\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx5328\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx5631\pard\intbl\b\fs18 suit[O]  suit[1)  suit[2]  suit[31 \b0\fs24\cell\fs20 . \f1\fs48 [!i \f0\fs24\cell\b\fs14\'f8. \b0\fs24\cell\b\fs18\lquote C\rquote  \b0\fs24\cell\b\fs18\lquote o\rquote ]\rquote p\rquote  \b0\fs24\cell\b\fs18\lquote a\rquote  \b0\fs24\cell\b\fs18\lquote s\rquote  \b0\fs24\cell\b\fs18 l\rquote\\O\rquote  \b0\fs24\cell\cell\fs20\row
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx648\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1271\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2027\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2741\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx5631\pard\intbl\f2\fs12 I \f0\fs24\cell\b\fs18\lquote O\rquote  \b0\fs24\cell\b\fs18 ]\lquote u\rquote ]\rquote r\rquote  \b0\fs24\cell\b\fs18\lquote o\rquote ] \b0\fs24\cell\f1\fs40 1\'b01 \f0\fs24\cell\fs20\row
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx648\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1271\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2027\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2741\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx3447\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4068\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx5631\pard\intbl\f2\fs12\lquote  \f0\fs24\cell\b\f2\fs16\lquote P\rquote  \b0\f0\fs24\cell\cell\fs18\lquote s\rquote  \fs24\cell\b\fs18\lquote\\O\rquote  \b0\fs24\cell\cell\cell\fs20\row
\f2\fs12\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx648\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1271\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2027\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2741\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx3447\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4068\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx5631\intbl\lquote  \f0\fs24\cell\b\fs18\lquote E\rquote  \b0\fs24\cell\fs28 iZ]f \fs24\cell\f1\fs42 ILZ \f0\fs24\cell\b\fs18\lquote d\rquote  \b0\fs24\cell\fs28 I\rquote a\rquote  \fs24\cell\fs28 1 \lquote s\rquote  I\rquote\\O\rquote  1 \fs24\cell\fs20\row
\pard\fs24\par
\pard\sb100\sa240\b\f2 346 \fs18 C++ COMO PROGRAMAR \line\fs26 5.10 Estudo de caso: uma simula\'e7\'e3o de embaralhamento e \b0\f0\fs18 Pararetira \line\b\f2\fs26 distribui\'e7\'e3o de cartas \b0\f0\fs18 correspon \line 12. A que \line Nesta se\'e7\'e3o, usamos a gera\'e7\'e3o de n\'fameros aleat\'f3rios para desenvolver um programa de simula\'e7\'e3o do embaralhamento assim, pat \line e distribui\'e7\'e3o de cartas. Este programa pode, ent\'e3o, ser usado para implementar programas que simulam jogos espec\'ed- guir o vali \line ficos de carta. Para revelar alguns problemas sutis de desempenho, usamos intencionalmente algoritmos de embaralha- de caracte \line mento e distribui\'e7\'e3o sub\'f3timos. Nos exerc\'edcios, desenvolveremos algoritmos mais eficientes. \ldblquote Rei \b dE \line\b0 Usando a abordagem \i top-down \i0 de refinamento passo a passo, desenvolvemos um programa que embaralhar\'e1 \line um baralho de \i 52 \i0 cartas e, ent\'e3o, far\'e1 a distribui\'e7\'e3o de cada uma das 52 cartas. A abordagem \i top-down \i0\'e9 particular- Vamos pn \line mente \'fatil para atacar problemas maiores e mais complexos do que os que vimos nos cap\'edtulos iniciais. \line Usamos um array deck de \i 4 \i0 por 13, bidimensional, para representar o baralho (Fig. 5.23). As linhas corres ponde \line aos naipes: a linha O corresponde a copas, a linha 1 a ouros, a linha 2 a paus e a linha 3 a espadas. As colunas Nosso pri \line correspondem aos valores de face das cartas: O at\'e9 9 correspondem a \'e1s at\'e9 dez, respectivamente, e as colunas 10 at\'e9 \line 12 correspondem a valete, dama e rei, respectivamente. Devemos preencher o array suit, do tipo \i string, \i0 com \line\i strings \i0 de caracteres representando os quatro naipes e o array \b face, do tipo \b0\i string, \i0 com \i strings \i0 de caracteres \line representando os treze valores das cartas. \line 2 \b\fs12 G) \line\b0\f2\fs8 . \b\f0\fs12 0 (5 \b0\f2\fs8 . \f0\fs18 Si \b\fs12 O N \b0\fs18 E \f2\fs8 ._ \b\f0\fs18\ldblquote Embaral] \line\fs12 (i) Q Q) D \f2\fs14 .E \b0\f0\fs18 w \b\fs12 O W (5 W \line\f2\fs14 1- \b0\i\f0\fs18 O \b\i0 O \b0\i\f2\fs14 (1) \b\i0 O) \b0\f0\fs18 O \b\f2\fs14 Z O > O \line\f0\fs18 O 1 2 3 4 5 6 7 8 9 101112 \line Copas O \line Ouros 1 \line\b0\f2\fs20 Paus 2 \f0\fs18\ldblquote Retire 5 \line\f2\fs20 Espadas 3 \line\b\f0\fs18 deck [2] [12] \b0\f2\fs20 representaoReidePaus A \line\b\f0\fs18 incorpc \line\b0\f2\fs20 Paus Rei \line\b\fs18 Fig. 5.23 \b0\fs20 Representa\'e7\'e3o de um baralho com um array bidimensional. \line\f0\fs18 Este baralho simulado pode ser embaralhado como segue. Primeiro, o array \b deck \b0\'e9 limpo com zeros. Ent\'e3o, uma \line\b row \b0 (0-3) e uma column (0-12) s\'e3o escolhidas ao acaso. O n\'famero \b 1 \b0\'e9 inserido no baralho no elemento deck \line\b row \b0 ] \b\f2\fs24 [ \b0\f0\fs18 coluinri \b\f2\fs24 ] \b0\f0\fs18 do array para indicar que esta carta vai ser a 1 retirada do baralho embaralhado. Este processo \line continua com os n\'fameros 2,3 52 sendo aleatoriamente inseridos no array \b deck \b0 para indicar quais cartas v\'e3o ser \line colocadas na 2, 3 e 52 posi\'e7\'e3o, no baralho embaralhado. A medida que o array \b deck \b0 come\'e7a a se encher com \line n\'fameros de cartas, \'e9 poss\'edvel que uma carta seja selecionada duas vezes, i.e., deck \b\f2\fs24 [ \f0\fs18 row \b0 ] [ coluinn \b\f2\fs24 1 \b0\f0\fs18 ser\'e1 n\'e3o- \line zero quando for selecionado. Essa sele\'e7\'e3o \'e9 simplesmente ignorada e outras \b rows \b0 e coluniris s\'e3o repetidamente \line escolhidas ao acaso, at\'e9 que seja encontrada uma carta ainda n\'e3o selecionada. Em algum momento, os n\'fameros 1 at\'e9 52 \line ocupar\'e3o as 52 posi\'e7\'f5es do array \b deck. Neste momento, \b0 o baralho est\'e1 completamente embaralhado. Coloque Este algoritmo de embaralhamento pode ficar sendo executado por um per\'edodo de tempo indefinidamente expandidi \line longo se as cartas que \fs24 j\'e1 \fs18 tenham sido embaralhadas s\'e3o repetidamente selecionadas ao acaso. Este fen\'f4meno \'e9 \line conhecido como \i adiamento indefinido. \i0 Nos exerc\'edcios, discutimos um algoritmo de embaralharamento melhor, que \line elimina a possibilidade de ocorr\'eancia de um adiamento indefinido. \line\i Dica de desempenho 5.3 \line\i0\f2\fs8 _____ \i\f0\fs18\'c0s vezes, um algoritmo que surge de um modo\rdblquote natural\rdblquote  pode conter problemas sutis de desempenho, tal \line como o adiamento indefinido. Procure algoritmos que evitam o adiamento indefinido. \i0\fs24\par
\fs18 CAP\'cdTULO 5 \f2\fs8 - \f0\fs18 PONTEIROS \b\fs14 E \b0\i\fs18 STRINGS \b\i0\fs20 347 \line\b0\fs18 Para retirar a primeira carta, fazemos uma pesquisa no array, procurando um valor de \b\fs20 deck [ row ] [ \b0\fs18 colunin correspondente a 1. Isto \i\'e9 \i0 feito com uma estrutura for aninhada que faz row variar de O at\'e9 3 e colunn de O at\'e9 12. A que carta do baralho corresponde a posi\'e7\'e3o do array? O array suit foi pr\'e9-carregado com os quatro naipes; assim, para obter o naipe, imprimiremos o \i string \i0 de caracteres suit [ linha \f2\fs14 ]. \f0\fs18 Semelhantemente, para conseguir o valor de face da carta, imprimimos o \i string \i0 de caracteres face [ column \f2\fs14 ). \f0\fs18 Imprimimos tamb\'e9m o \i string \i0 de caracteres \ldblquote de\rdblquote  Imprimir estas informa\'e7\'f5es na ordem apropriada nos habilita a imprimir cada carta na forma \ldblquote Rei de Paus\rdblquote , \ldblquote\'c1s de Ouros\rdblquote , e assim por diante. \line Vamos prosseguir com o processo \i top-down \i0 de refinamento passo a passo. O topo \'e9 simplesmente \line\i Embaralha e retira 52 cartas \line\i0 Nosso primeiro refinamento nos d\'e1: \line\i Inicialize o array naipe (suit) \line Inicialize o array face (face) \line Inicialize o array baralho (deck) \line Embaralhe o baralho \line Retire 52 cartas \line\i0\ldblquote Embaralhe o baralho\rdblquote  pode ser expandido como segue: \line\i Para cada uma das 52 cartas \line Coloque o n\'famero da carta em uma posi\'e7\'e3o desocupada do \line array baralho selecionada aleatoriamente \line\i0\ldblquote Retire 52 cartas\rdblquote  pode ser expandido como segue: \line\i Para cada uma das 52 cartas \line Ache um n\'famero de carta no array baralho e imprima face e naipe da carta \line\i0 A incorpora\'e7\'e3o destas expans\'f5es completa nosso segundo refinamento: \line\i Inicialize o array naipe \line Inicialize o array face \line Inicia lize o array baralho \line Para cada uma das 52 cartas \line Coloque o n\'famero da carta em uma posi\'e7\'e3o desocupada do \line array baralho selecionada aleatoriamente \line Para cada uma das 52 cartas \line Ache um n\'famero de carta no array baralho e imprima face e naipe da carta \line\i0\ldblquote Coloque o n\'famero da carta em uma posi\'e7\'e3o desocupada do array baralho selecionada aleatoriarnente\rdblquote  pode ser expandido como segue: \line\i Escolha uma posi\'e7\'e3o do baralho aleatoriamente \line Enquanto posi\'e7\'e3o escolhida do baralho j\'e1 foi escolhida antes \line Escolha a posi\'e7\'e3o do baralho aleatoriamente \line Coloque o n\'famero da carta na posi\'e7\'e3o escolhida do baralho \i0\fs24\par
\b\f2\fs20 348 C++ \b0 COMO \b\f0\fs14 PROGRAMAR \line\b0\fs18\ldblquote Ache um n\'famero de carta no array baralho e imprima a face e o naipe da carta\rdblquote  pode ser expandido como segue: \line\b\fs14 1 \line\b0\i\fs18 Para cada posi\'e7\'e3o do array baralho \line Se a posi\'e7\'e3o cont\'e9m um n\'famero de carta \line Imprima a face e o naipe da carta \line\i0 Incorporando estas expans\'f5es, obtemos nosso terceiro refinamento: \line\i Inicialize o array naipe \line Inicialize o array face \line Inicialize o array baralho \line Para cada uma das 52 cartas \line Escolha uma posi\'e7\'e3o do baralho aleatoriamente \line Enquanto posi\'e7\'e3o escolhida do baralho j\'e1 foi escolhida antes \line Escolha a posi\'e7\'e3o do baralho aleatoriamentc \line Coloque o n\'famero da carta na posi\'e7\'e3o escolhida do baralho \line Para cada uma das 52 cartas \line Para cada posi\'e7\'e3o do array baralho \line Se a posi\'e7\'e3o cont\'e9m um n\'famero de carta \line Imprima a face e o naipe da carta \line\i0 Isto completa o processo de refinamento. Note que esse programa \'e9 mais eficiente se as partes do algoritmo referentes ao embaralhamento e retirada da carta do baralho forem combinadas, de modo que cada carta \'e9 retirada \'e0 medida \line que \'e9 colocada no baralho. Escolhemos programar estas opera\'e7\'f5es separadamente porque, normalmente, as cartas \b\fs14 4 \line\b0\fs18 s\'e3o retiradas depois de terem sido embaralhadas (e n\'e3o \'e0 medida em que s\'e3o embaralhadas). \b\fs14 4 \line\b0\fs18 O programa de embaralhamento e distribui\'e7\'e3o de cartas \'e9 mostrado na Fig. 5.24 e um exemplo de execu\'e7\'e3o \'e9 \b\fs14 4 \line\b0\fs18 exibido na Fig. 5.25. Note a formata\'e7\'e3o da sa\'edda usada na fun\'e7\'e3o deal: \b\fs14 4 \line\f3\fs18 cout \b0\f0\'ab setw( \b\fs14 5 \b0\fs18 ) \b\f3\'ab setiosflags( ios::right \line\b0\f0\'ab \b\f3 wFace[ column \b0\f0 ] \'ab \f2\fs8\ldblquote  \b\f3\fs18 de \line\b0\f0\'ab \b\f3 setw( 8 \b0\f0 ) \'ab \b\f3 setiosflags( ios::left \line\b0\f0\'ab \b\f3 wSuit[ row \line\b0\f0\'ab ( \b\f3 card % 2 \b0\f2\fs10 == \b\f3\fs18 O ? \lquote\\n\rquote  : \line\b0\f0 O \b\f3 comando de sa\'edda precedente faz com que a face da carta seja mostrada alinhada \b0\i\f0\'e0 \b\i0\f3 direita em um campo de \b0\f0 5 caracteres e o naipe em um campo de 8 caracteres. A sa\'edda \'e9 impressa em um formato de duas colunas. Se a carta que est\'e1 sendo mostrada est\'e1 na primeira coluna, uma marca de tabula\'e7\'e3o \'e9 posta na sa\'edda, depois da carta, para mover para a segunda coluna; caso contr\'e1rio, um caractere de nova linha \'e9 posto na sa\'edda. \fs24\par
\b\f2\fs20 Fig. 5.24 \b0 Programa de embaralhamento e distribui\'e7\'e3o de cartas (parte 1 de 2). \f0\fs24\par
\pard\par
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx217\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx5675\pard\intbl\b\f3\fs18 1 \b0\f0\fs24\cell\i\fs18 II \b\i0\f3 Fig. 5.24: figO5_24.cpp \b0\f0\fs24\cell\fs20\row
\b\f3\fs18\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx217\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx5675\intbl 2 \b0\f0\fs24\cell\i\fs18 II \b\i0\f3 Programa de embaralhamento e retirada de cartas \b0\f0\fs24\cell\fs20\row
\b\f3\fs18\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx217\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx5675\intbl 3 \b0\f0\fs24\cell\b\f3\fs18 #include <iostream> \b0\f0\fs24\cell\fs20\row
\b\f3\fs18\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx217\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx5675\intbl 4 \b0\f0\fs24\cell\cell\fs20\row
\b\f3\fs18\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx217\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx5675\intbl 5 \b0\f0\fs24\cell\b\f3\fs18 using std: :cout; \b0\f0\fs24\cell\fs20\row
\b\f3\fs18\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx217\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx5675\intbl 6 \b0\f0\fs24\cell\b\f3\fs18 using std::ios; \b0\f0\fs24\cell\fs20\row
\b\fs14\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx217\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx5675\intbl 7 \b0\fs24\cell\cell\fs20\row
\b\f3\fs18\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx217\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx5675\intbl 8 \b0\f0\fs24\cell\b\f3\fs18 #include <iomanip> \b0\f0\fs24\cell\fs20\row
\b\fs14\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx217\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx5675\intbl 9 \b0\fs24\cell\cell\fs20\row
\pard\fs24\par
\pard\sb100\sa240\fs12 CAP\'cdTULO \f2\fs20 5 \fs8 - \f0\fs12 PONTEIROS E \i\f2\fs14 STRINGS \i0\fs20 349 \line\f3\fs16 10 using std::setw; \line 11 using std::setiosflags; \line 12 \line 13 #include <cstdlib> \line 14 #include <ctime> \line 15 \line 16 void shuffle(int \f2\fs20 [)[ \f3\fs16 13 \f2\fs20 1 \f3\fs16 ); \line 17 void deal( const int [][13], const char \f0 *[], \f3 const char *[] ); \line 18 \line 19 int main() \line\f0 20 \f2\fs20\{ \line\f3\fs16 21 const char *sujt[ 4 \f2\fs20 ] \fs10 = \line\f3\fs16 22 \f2\fs20\{ \f3\fs16\ldblquote Copas\rdblquote , \ldblquote Ouros\rdblquote , \ldblquote Paus\rdblquote , \ldblquote Espadas\rdblquote  \line\f0 23 \f3 const char *face[ 13 \f2\fs20 ] \fs10 = \line\f0\fs16 24 \f2\fs20\{ \f0\fs16\ldblquote\'c1s\rdblquote , \ldblquote Dois\rdblquote , \lquote Tr\'eas\rdblquote , \ldblquote Quatro\rdblquote , \line 25 \ldblquote Cinco\rdblquote , \ldblquote Seis\rdblquote , \ldblquote Sete\rdblquote , \ldblquote Oito\rdblquote , \line 26 \ldblquote Nove\rdblquote , \ldblquote Dez\rdblquote , \ldblquote Valete\rdblquote , \ldblquote Dama\rdblquote , \ldblquote Rei\rdblquote  \}; \line 27 intdeck[4][13]=\{0); \line 28 \line\f3 29 srand( time( O \f2\fs20 ) \f3\fs16 ); \line 30 \line 31 shuffle( deck ); \line 32 deal( deck, face, suit ); \line 33 \line 34 return 0; \line 35 \f2\fs20\} \line\f3\fs16 36 \line 37 void shuffle(int wDeck[)[ 13 \line 38 \line 39 int row, coluinn; \line 40 \line 41 for (int card \f2\fs10 = \f3\fs16 1; card \f0\fs12 <= \f3\fs16 52; card++ \line\f0 42 do\{ \line\f3 43 row \f0\fs12 = \f3\fs16 rand() % 4; \line 44 column \f0\fs12 = \f3\fs16 rand % 13; \line 45 \f2\fs20 ) \f3\fs16 while( wDeck[ row \f2\fs20 ] [ \f3\fs16 coluinn \f2\fs20 ] \f0\fs12 != \f3\fs16 O ); \line 46 \line 47 wDeck[ row \f2\fs20 ] [ \f3\fs16 column \f2\fs20 ] \f0\fs12 = \f3\fs16 card; \line 48 \line 49 \f2\fs20\} \line\f3\fs16 50 \line 51 void deal( const int wDeck[][ 13 \f2\fs20 ], \f3\fs16 const char *wFace[J, \line 52 const char *wSujt[] \line 53 \f2\fs20\{ \line\f3\fs16 54 for \f2\fs20 ( \f3\fs16 int card \f0\fs12 = \f3\fs16 1; card \f0\fs12 <= \f3\fs16 52; card++ \line 55 \line 56 for \f2\fs20 ( \f3\fs16 int row \f0\fs12 = \f3\fs16 0; row \f0\fs12 <= \f3\fs16 3; \b\fs14 row++ \line\b0\fs16 57 \line 58 for \f2\fs20 ( \f3\fs16 int \f0 column = \f3 0; \f0 column <= 12; coluxnn++ \line\f3 59 \line 60 if \f2\fs20 ( \f3\fs16 wDeck[ row \f2\fs20 ] [ \f3\fs16 column \f2\fs20 ] \f0\fs12 == \f3\fs16 card \line 61 cout\'ab setw( 6 \f2\fs20 ) \f3\fs16\'ab setiosflags( ios::right \line\f0 62 \'ab wFace \f2\fs20 [ \f0\fs16 column \f2\fs20 1 \'ab \fs8\ldblquote  \f0\fs16 de \line\f3 63 \'ab setw( 7 \f2\fs20 ) \f3\fs16\'ab setiosflags( ios::left \line 64 \'ab wSuit[ row \line 65 \f2\fs20\'ab ( \f3\fs16 card % 2 \f0\fs12 == \f3\fs16 O ? \lquote\\n\rquote  : \lquote\\t\rquote  \f2\fs20 ) \line\f3\fs16 66 \line\f2\fs18 Fig. 5.24 Programa de embaralhamento e distribui\'e7\'e3o de cartas (parte 2 de 2). \f0\fs24\par
\i\f2\fs22 350 \b\i0\f0\fs18 C++ \b0 COMO PROGRAMAR \fs24\par
\b\f3\fs18 Seis de Paus Sete \line\'c1s de Espadas As \line\'c1s de Copas \b0\fs16 Dama \line\b\fs18 Dama de Paus Sete \line Dez de Copas Dois \line Dez de Espadas Tres \line Dez de Ouros Quatro \line Quatro de Ouros Dez \line Seis de Ouros Seis \line Oito de Copas Tres \line Nove de Copas Tres \line Dois de Ouros Seis \line Cinco de Paus Oito \line Dois de Ouros Oito \line Cinco de Espadas Rei \line Rei de Ouros Valete \line Dois de Copas Dama \line\'c1s de Paus Rei \line Tres de Paus Rei \line Nove de Paus Nove \line Quatro de Copas \b0\fs16 Dama \line\b\fs18 Oito de Ouros Nove \line Valete de Ouros Sete \line Cinco de Copas Cinco \line Quatro de Paus Valete \line Valete de Paus Sete \line\b0\f2\fs20 Fig. \b\f3\fs18 5.25 \b0\fs20 Exemplo de execu\'e7\'e3o do programa \f2 de embaralhamento e distribui\'e7\'e3o de cartas. \line\f0\fs18 Existe uma defici\'eancia no algorilmo desenvolvido acima. Depois que uma \'e9 encontrada, ainda que seja encontrada na primeira tentativa, as duas estruturas for internas continuam a procurar nos elementos restantes do \b deck uma \b0 carta igual. Nos exerc\'edcios, corrigimos esta defici\'eancia. \line\b\f2\fs26 5.11 Ponteiros de fun\'e7\'e3o \line\b0\f0\fs18 Um ponteiro para uma fun\'e7\'e3o cont\'e9m o endere\'e7o da fun\'e7\'e3o na mem\'f3ria. No Cap\'edtulo 4, vimos que um nome de array \'e9, na realidade, o endere\'e7o na mem\'f3ria do primeiro elemento do array. De modo semelhante, um nome de fun\'e7\'e3o \'e9 realmente o endere\'e7o na mem\'f3ria do come\'e7o do c\'f3digo que executa a tarefa da fun\'e7\'e3o. Ponteiros de fun\'e7\'f5es podem ser passados para fun\'e7\'f5es, retornados por fun\'e7\'f5es, armazenados em arrays e atribu\'eddos a outros ponteiros de fun\'e7\'e3o. \line Para ilustrar o uso de ponteiros de fun\'e7\'f5es, modificamos o programa da Fig. 5.15 criando o programa da Fig. 5.26. Nosso novo programa consiste em main e as fun\'e7\'f5es bubble, swap, ascending e descending. A fun\'e7\'e3o bubbleSort recebe um ponteiro para uma fun\'e7\'e3o \f2\fs8 - \f0\fs18 ou para a fun\'e7\'e3o ascending ou para a fun\'e7\'e3o descending \f2\fs8 - \f0\fs18 como argumento (al\'e9m de um array de inteiros e do tamanho do array, tamb\'e9m passados como argumentos). O programa solicita ao usu\'e1rio escolher se o array deve ser classificado em ordem ascendente ou em ordem descendente. Se o usu\'e1rio digitar 1, um ponteiro para a fun\'e7\'e3o ascending \'e9 passado para a fun\'e7\'e3o bubble, fazendo com que o array seja classificado em ordem crescente. Se o usu\'e1rio digitar 2, um ponteiro para a fun\'e7\'e3o \b\f3 descending \b0\f0\'e9 passado para a fun\'e7\'e3o bubble. fazendo com que o array seja classificado em ordem decrescente. A sa\'edda do programa \'e9 mostrada na Fig. 5.27. \fs24\par
\b\f3\fs18 de Ouros \f0\fs16 de Ouros de Ouros \f3\fs18 de Copas \f0\fs16 de Paus de Espadas de Espadas de Paus de Espadas \f3\fs18 de Ouros \f0\fs16 de Copas de Copas de Paus \f3\fs18 de Espadas \f0\fs16 de Paus de Espadas de Espadas de Espadas de Copas de Espadas de Espadas de Ouros \f3\fs18 de Paus de Ouros \f0\fs16 de Copas de Espadas \b0\fs24\par
\b\fs16 3 \line 4 \line\f3\fs18 5 \line 6 \line 7 \line 8 \line\f0\fs16 9 \line\b0\fs20 10 \line\b\fs16 11 \line 12 \line 13 \line 14 \line 15 \line 16 \line 17 \line 18 \line 19 \line\b0\fs20 20 \line\b\fs16 21 \line\b0\f2\fs20 22 \line\f0 23 \line 24 \line 25 \line\b\fs16 26 \line 27 \line 28 \line 29 \line 30 \b0\fs24\par
\b\fs16 31 \b0\fs24\par
\b\fs16 32 \line 33 \line 34 \line 35 \b0\fs24\par
\b\fs18 36 \b0\fs24\par
\b\fs16 37 \b0\fs24\par
\b\fs16 38 \line 39 \b0\fs24\par
\b\fs16 40 \line\b0 41 \line\b 42 \line 43 \line 44 \b0\fs24\par
\f2\fs20 45 \line\b\f0\fs16 46 \line 47 \line 48 \line 49 \line 50 \line 51 \line\b0\f2\fs20 52 \line\b\f0\fs16 53 \line\b0\f2\fs20 54 \line\b\f0\fs16 55 \line\b0\f2\fs20 56 \line\b\f0\fs16 57 \b0\fs24\par
\b\f3\fs18 1 \b0\i\f2\fs22 II \b\i0\f3\fs18 Fig. 5.26: fig0526.cpp \line\f0\fs16 2 \b0 // Programa de classifica\'e7\'e3o de finalidade m\'faltipla, usando \b ponteiros para \b0 fun\'e7\'e3o \fs24\par
\b\fs16 58 \line 59 \line 60 \line 61 \b0\fs24\par
\f2\fs20 Fig. 5.26 Programa de classifica\'e7\'e3o de finalidade m\'faltipla usando ponteiros para fun\'e7\'e3o (parte 1 de 3). \f0\fs24\par
\fs14 CAP\'cdTULO \i\f2\fs20 5 \i0\fs8 - \f0\fs14 PoN1-iIRos E \i STRINGS \i0\fs20 351 \line 3 #include <iostream> \line 4 \line\f3\fs16 5 using std::cout; \line 6 using std::cin; \line 7 using std::endl; \line 8 \line 9 #include <iomanip> \line 10 \line 11 using std::setw; \line 12 \line 13 void bubble( int \f0\fs20 [], \f3\fs16 const int, bool (*) \f0\fs20 ( \f3\fs16 int, int \f0\fs20 ) ); \line\f3\fs16 14 bool ascending( int, int ); \line 15 bool descending( int, int ); \line 16 \line 17 int main() \line\f2\fs26 3 \f3\fs16 18 \line 19 const int arraySize \f2\fs10 = \f3\fs16 10; \line 20 int order, \line 21 counter, \line 22 a[ arraySize \f0\fs20 ] \f2\fs10 = \f0\fs20\{ \f3\fs16 2, 6, 4, 8, 10, 12, 89, 68, 45, 37 \}; \line 23 \line 24 cout \'ab \ldblquote Digite 1 para classifica\'e7\'e3o em ordem ascendente,\\n\rdblquote  \line 25 \'ab \ldblquote Digite 2 para classifica\'e7\'e3o em ordem descendente: \f2\fs10\ldblquote ; \line\f3\fs16 26 cm \'bb order; \line 27 cout \'ab \ldblquote\\nDados na ordem original\\n\rdblquote ; \line 28 \line 29 for \f0\fs20 ( \f3\fs16 counter \f2\fs10 = \f3\fs16 0; counter < arraySize; counter++ \line 30 cout \'ab setw( 4 \f0\fs20 ) \f3\fs16\'ab a[ counter \f0\fs20 J; \line\f3\fs16 31 \line 32 if \f0\fs20 ( \f3\fs16 order \f2\fs10 == \f3\fs16 1) \line 33 bubble( a, arraySize, ascending ); \line 34 cout \'ab \lquote\\nDados em ordem ascendente\\n\rdblquote ; \line\f0 35 \} \line\f3 36 else \f0\fs20\{ \line\f3\fs16 37 bubble( a, arraySize, descending ); \line 38 cout \'ab \ldblquote\\nDados em ordem descendente\\n\rdblquote ; \line 39 \f0\fs20\} \line\f3\fs16 40 \line 41 for \f0\fs20 ( \f3\fs16 counter 0; counter < arraySize; counter++ \line 42 cout \'ab setw( 4 \f0\fs20 ) \f3\fs16\'ab a[ counter \f0\fs20 1; \line 43 \line 44 cout \'ab endl; \line\f3\fs16 45 return 0; \line 46 \line\f0 47 \line\f3 48 void bubble( int work[ \f0\fs20 ], \f3\fs16 const int size, \line 49 bool (*compare) \f0\fs20 ( \f3\fs16 int, int) \line 50 \f0\fs20\{ \line\f3\fs16 51 void swap( int \f2\fs10 * \f3\fs16 const, int \f2\fs10 * \f3\fs16 const); \i\f2\fs20 II \i0\f3\fs16 prot\'f3tipo \line 52 \line 53 for \f0\fs20 ( \f3\fs16 int pass =1; pass < size; pass++ \line\f0 54 \line\f3 55 for \f0\fs20 ( \f3\fs16 int count \f2\fs10 = \f3\fs16 0; count < size \f2\fs8 - \f3\fs16 1; count++ \line 56 \line 57 if \f0\fs20 ( \f3\fs16 (*compare) \f0\fs20 ( \f3\fs16 work[ count \f0\fs20 ], \f3\fs16 work[ count + 1 \f0\fs20 ] \line\f3\fs16 58 swap( &work[ count \f0\fs20 ], \f3\fs16 &work[ count + 1 \f0\fs20 ] ); \line 59 \{ \line 60 \line\f3\fs16 61 void swap( int \f2\fs10 * \f3\fs16 const elementlPtr, int \f2\fs10 * \f3\fs16 const element2Ptr \line\b\f2\fs18 Fig. 5.26 \b0\fs20 Programa de classifica\'e7\'e3o de finalidade m\'faltipla usando ponteiros para fun\'e7\'e3o (parte 2 de 3). \f0\fs24\par
\i\f2\fs22 352 \i0\f0\fs20 C++ \fs14 COMO PROGRAMAR \line 62 \{ \line\b\f3\fs16 63 int temp; \line 64 \line 65 temp \b0\f2\fs10 = \b\f3\fs16 *elementlptr; \line 66 *elementlptr \b0\f2\fs10 = \b\f3\fs16 *element2ptr; \line 67 *element2ptr \b0\f2\fs10 = \b\f3\fs16 temp; \line 68 \b0\i\f2\fs22\} \line\b\i0\f3\fs16 69 \line 70 bool ascending( int a, int b \line 71 \line 72 return b < a; \b0\i\f2\fs22 II \b\i0\f3\fs16 troca se b \'e9 menor \b0\f0\fs18 que \b\f3\fs16 a \line 73 \b0\f0\fs18\} \line\b\f3\fs16 74 \line 75 bool descending( int a, int b \line 76 \line 77 return b > a; \b0\i\f2\fs22 II \b\i0\f3\fs16 troca se b \'e9 maior \b0\f0\fs18 que \b\f3\fs16 a \line 78 \b0\f0\fs18 ) \line\b\f2 Fig. 5.26 \b0\fs20 Programa de classifica\'e7\'e3o de finalidade m\'faltipla usando ponteiros para fun\'e7\'e3o (parte 3 de 3). \line\b\f3\fs16 Digite 1 para classifica\'e7\'e3o em ordem ascendente, \line Digite 2 para classifica\'e7\'e3o em ordem descendente: 1 \line Dados na ordem original \line 2 6 4 8 10 12 89 68 45 37 \line Dados em ordem ascendente \line 2 6 4 8 10 12 37 45 68 89 \line Digite 1 para classifica\'e7\'e3o em ordem ascendente, \line Digite 2 para classifica\'e7\'e3o em ordem descendente: 2 \line Dados na ordem original \line 2 6 4 8 10 12 89 68 45 37 \line Dados em ordem descendente \line 89 68 45 37 12 10 8 6 4 2 \line\f2\fs18 Fig. 5.27 \b0\fs20 Sa\'eddas do programa \i bubble sortda \i0 Fig. 5.26. \line\f0\fs18 O par\'e2metro seguinte aparece no cabe\'e7alho de fun\'e7\'e3o para bubble: \line bool ( *compare ) ( int, int \line Isto diz para bubble esperar um argumento que \'e9 um ponteiro para uma fun\'e7\'e3o que recebe dois argumentos de tipo inteiro, retornando um resultado de tipo booleano. Os par\'eanteses s\'e3o necess\'e1rios em volta de \f2\fs12 * \f0\fs18 compare porque \f2\fs12 * \f0\fs18 tem uma preced\'eancia mais baixa que os par\'eanteses em volta dos argumentos da fun\'e7\'e3o. Se n\'e3o inclu\'edssemos os par\'eanteses, a declara\'e7\'e3o teria sido \line\b\f3\fs16 bool *conpare( int, int \line\b0\f0\fs18 que declara uma fun\'e7\'e3o que recebe dois inteiros como argumentos e retorna um ponteiro para um booleano. \line O argumento correspondente, no prot\'f3tipo de fun\'e7\'e3o de bubble, \'e9 \line bool (*) ( int, int \fs24\par
\b\fs14 CAP\'cdTULO \b0\fs18 5 \f2\fs8 - \b\f0\fs14 PONTEIROS E \b0\i\fs16 STRINGS \b\f2\fs22 353 \line\b0\i0\f0\fs18 Note que foram inclu\'eddos s\'f3 tipos, mas para fins de documenta\'e7\'e3o o programador pode incluir nomes que o compilador ignorar\'e1. \line A fun\'e7\'e3o passada para bubble \'e9 chamada em um comando if como segue \line\b\f3\fs16 jf \b0\f0\fs18 ( ( \f3\fs20 *compare \f0\fs18 )( work[ courit \b\i\f2\fs22 ), \b0\i0\f0\fs18 work[ count \b\fs14 + \b0\fs18 1] \line\f3\fs20 Da mesma maneira que um ponteiro para uma vari\'e1vel \f0\fs18\'e9 \f3\fs20 derreferenciado para acessar o valor da vari\'e1vel, um \f0\fs18 ponteiro para uma fun\'e7\'e3o \'e9 derreferenciado para executar a fun\'e7\'e3o. \line A chamada para a fun\'e7\'e3o podia ter sido feita sem derreferenciar o ponteiro, como em \line\b\fs14 if \b0\fs18 ( compare( work[ count 1, work[ count \b\fs14 + 1 \line\b0\fs18 que utiliza o ponteiro diretamente como o nome da fun\'e7\'e3o. Preferimos o primeiro m\'e9todo de chamar uma fun\'e7\'e3o atrav\'e9s de um ponteiro, porque explicitamente mostra que compare \'e9 um ponteiro para uma fun\'e7\'e3o que \'e9 derreferenciado para chamar a mesma. O segundo m\'e9todo de chamar uma fun\'e7\'e3o atrav\'e9s de um ponteiro faz compare se parecer com uma fun\'e7\'e3o real. Isso pode ser confuso para um usu\'e1rio do programa que gostaria de ver a defini\'e7\'e3o da fun\'e7\'e3o compare e acha que ela nunca \'e9 definida no arquivo. \line Um uso para ponteiros de fun\'e7\'e3o \'e9 encontrado em sistemas orientados por menus. Um usu\'e1rio \'e9 solicitado a selecionar uma op\'e7\'e3o de um menu (por exemplo, de 1 at\'e9 5). Cada op\'e7\'e3o \'e9 tratada por uma fun\'e7\'e3o diferente. Os ponteiros para cada fun\'e7\'e3o s\'e3o armazenados em um array de ponteiros para fun\'e7\'f5es. A escolha do usu\'e1rio \'e9 usada como subscrito do array e o ponteiro que est\'e1 na posi\'e7\'e3o determinada por esse subscrito no array \'e9 usado para chamar a fun\'e7\'e3o. \line O programa da Fig. 5.28 fornece um exemplo gen\'e9rico do mecanismo de declarar e usar um array de ponteiros para fun\'e7\'f5es. Tr\'eas fun\'e7\'f5es s\'e3o definidas \f2\fs8 - \f0\fs18 functionl, function2 e function3 \f2\fs8 - \f0\fs18 cada uma aceitando um argumento do tipo inteiro e n\'e3o retornando nada. Os ponteiros para estas tr\'eas fun\'e7\'f5es s\'e3o armazenados no array f, que \'e9 declarado como segue: \line void ( \i\fs16 *f[ \i0\fs18 3 ] ) ( int ) \f2\fs12 = \f0\fs18\{ functionl, function2, function3 \}; \line A declara\'e7\'e3o \'e9 lida come\'e7ando no conjunto mais \'e0 esquerda de par\'eanteses, como \ldblquote f \'e9 um array de 3 ponteiros para fun\'e7\'f5es que aceitam um int como argumento e retornam void\rdblquote . O array \'e9 inicializado com os nomes das tr\'eas fun\'e7\'f5es (que, repetimos, s\'e3o ponteiros). Quando o usu\'e1rio digita um valor entre O e 2, o valor \'e9 usado como o subscrito do array de ponteiros para fun\'e7\'f5es. A chamada da fun\'e7\'e3o \'e9 feita como segue: \line\b\fs14 *f[ \b0\fs18 choice ])( choice ); \line Na chamada, f \f3\fs20 [ \f0\fs18 choice \f3\fs20 ] \f0\fs18 seleciona o ponteiro nacposi\'e7\'e3o choice do array. O ponteiro \'e9 derreferenciado para chamar a fun\'e7\'e3o e choice \'e9 passado como argumento para a fun\'e7\'e3o. Cada fun\'e7\'e3o imprime o valor do seu argumento e seu nome de fun\'e7\'e3o para indicar que a fun\'e7\'e3o foi chamada corretamente. Nos exerc\'edcios, voc\'ea desenvolver\'e1 um sistema orientado por menus. \fs24\par
\f2\fs20 Fig. 5.28 Demonstrando um array de ponteiros para fun\'e7\'f5es (parte 1 de 2). \f0\fs24\par
\pard\par
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx301\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx5676\pard\intbl\b\f3\fs16 1 \b0\f0\fs24\cell\b\i\f2\fs22 II \i0\f3\fs16 Fig. 5.28: figo5_28.cpp \b0\f0\fs24\cell\fs20\row
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx301\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2362\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx3059\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx5676\pard\intbl\b\f3\fs16 2 \b0\f0\fs24\cell\fs20 // \b\f3\fs16 Demonstrando um \b0\f0\fs24\cell\b\f3\fs16 array \b0\f0\fs24\cell\b\f3\fs16 de ponteiros para fun\'e7\'f5es \b0\f0\fs24\cell\fs20\row
\b\f3\fs16\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx301\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2362\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx3059\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx5676\intbl 3 \b0\f0\fs24\cell\b\f3\fs16 #include <iostream> \b0\f0\fs24\cell\cell\cell\fs20\row
\b\f3\fs16\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx301\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2362\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx3059\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx5676\intbl 4 \b0\f0\fs24\cell\cell\cell\cell\fs20\row
\b\f3\fs16\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx301\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2362\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx3059\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx5676\intbl 5 \b0\f0\fs24\cell\b\f3\fs16 using std: :cout; \b0\f0\fs24\cell\cell\cell\fs20\row
\b\f3\fs16\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx301\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2362\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx3059\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx5676\intbl 6 \b0\f0\fs24\cell\b\f3\fs16 using std::cin; \b0\f0\fs24\cell\cell\cell\fs20\row
\b\f3\fs16\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx301\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2362\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx3059\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx5676\intbl 7 \b0\f0\fs24\cell\b\f3\fs16 using std::endl; \b0\f0\fs24\cell\cell\cell\fs20\row
\b\f3\fs16\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx301\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2362\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx3059\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx5676\intbl 8 \b0\f0\fs24\cell\cell\cell\cell\fs20\row
\b\f3\fs16\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx301\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2362\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx3059\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx5676\intbl 9 \b0\f0\fs24\cell\b\f3\fs16 void functionl \b0\f0\fs20 ( \b\f3\fs16 int \b0\f0\fs24\cell\b\f3\fs16 ); \b0\f0\fs24\cell\cell\fs20\row
\b\f3\fs16\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx301\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2362\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx3059\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx5676\intbl 10 \b0\f0\fs24\cell\b\f3\fs16 void function2 \b0\f0\fs20 ( \b\f3\fs16 int \b0\f0\fs24\cell\b\f3\fs16 ); \b0\f0\fs24\cell\cell\fs20\row
\b\f3\fs16\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx301\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2362\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx3059\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx5676\intbl 11 \b0\f0\fs24\cell\b\f3\fs16 void function3( int \b0\f0\fs24\cell\b\f3\fs16 ); \b0\f0\fs24\cell\cell\fs20\row
\b\f3\fs16\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx301\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2362\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx3059\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx5676\intbl 12 \b0\f0\fs24\cell\cell\cell\cell\fs20\row
\b\f3\fs16\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx301\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2362\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx3059\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx5676\intbl 13 \b0\f0\fs24\cell\b\f3\fs16 int main \b0\fs20 O \f0\fs24\cell\cell\cell\fs20\row
\pard\fs24\par
\pard\sb100\sa240\i\f2\fs22 354 \i0\fs20 C++ COMO \f0\fs14 PROGRAMAR \line\f3\fs16 14 \f0\fs20\{ \f3\fs16 sam \line 15 void (*f[ 3 \f0\fs20 ]) ( \f3\fs16 int \f0\fs20 ) \f2\fs8 = \f0\fs20\{ \f3\fs16 functionl, function2, function3 \}; comi \line 16 int choice; \line 17 \line 18 cout\'ab \ldblquote Digite um n\'famero entre O e 2, 3 para terminar: \f2\fs10\ldblquote ; \b\fs22 51 \line\b0\f3\fs16 19 cm \i\f0\fs20\'bb \i0\f3\fs16 choice; \line 20 \line 21 while \f0\fs20 ( \f3\fs16 choice \f0\fs14 >= \f3\fs16 O && choice \f0\fs14 < \f3\fs16 3 \f0\fs20 ) \{ \f3\fs16 Osc \line 22 (*f[ choice \f0\fs20 J) ( \f3\fs16 choice \f0\fs20 ) \f3\fs16 deui \line 23 cout\'ab \ldblquote Digite um n\'famero entre O e 2, 3 para terminar: \f2\fs10\ldblquote ; \f3\fs16 dorc \line 24 cm \i\f0\fs20\'bb \i0\f3\fs16 choice; \i\f0\fs20 res.1 \line\i0\f3\fs16 25 \f0\fs20\} \f3\fs16 deu \line 26 repo \line 27 cout \i\f0\fs20\'ab \i0\f3\fs16\ldblquote Execu\'e7\'e3o do programa terminada.\rdblquote  \i\f0\fs20\'ab \i0\f3\fs16 endi; den \line 28 return 0; \line 29 \f0\fs20\} \i car \line\i0\f3\fs16 30 aspa \line 31 void functionl( int a \line 32 \line 33 cout \'ab \ldblquote Voc\'ea digitou \f2\fs8\ldblquote  \i\f0\fs20\'ab \i0\f3\fs16 a \line 34 \'ab \f2\fs8\ldblquote , \f3\fs16 de modo que functionl foi chamada.\\n\\n\rdblquote ; \line 35 \line 36 \line 37 void function2( int b) \line 38 \f0\fs20\{ Um \line\f3\fs16 39 cout\'ab \ldblquote Voc\'ea digitou \f2\fs8\ldblquote  \f0\fs20\'ab \fs14 b \fs20 deu \line\f3\fs16 40 \'ab \f2\fs8\ldblquote , \f3\fs16 de modo que function2 foi chamada.\\n\\n\rdblquote ; cara \line 41 \f2\fs20\} poni \line\f3\fs16 42 arra \line 43 void function3( int c \line 44 \f0\fs20\{ tipo \line\f3\fs16 45 cout \'ab \ldblquote Voc\'ea digitou \f2\fs8\lquote  \i\f0\fs20\'ab \i0\f3\fs16 c \line 46 \'ab \f2\fs8\lquote , \f3\fs16 de modo que function3 foi chamada.\\n\\n\rdblquote ; \line 47 \line\f0\fs20 inic \line Digite um n\'famero entre \f3\fs16 O e 2, 3 \f0\fs18 para terminar: \f3\fs16 O \f0\fs18 dei \line Voc\'ea \f3\fs16 digitou 0, de modo que functionl foi chamada. co: \line Digite um n\'famero entre O e 2, 3 para terminar: 1 \line Voc\'ea digitou 1, de modo que function2 foi chamada. \line Digite um n\'famero entre O e 2, 3 para terminar: 2 \line Voc\'ea digitou 2, de modo que function3 foi chamada. \line Digite um n\'famero entre O e 2, 3 para terminar: 3 \line Execu\'e7\'e3o do programa terminada \line\f2\fs20 Fig. 5.28 Demonstrando um array de ponteiros para fun\'e7\'f5es (parte 2 de 2). \line\i\fs22 Q \line\i0\f0\fs20 na \line\b\f2\fs26 5.12 Introdu\'e7\'e3o ao processamento de caracteres e \i strings \b0\i0\fs20 ba \line\f0 Nesta se\'e7\'e3o, introduzimos algumas fun\'e7\'f5es comuns da biblioteca padr\'e3o que facilitam o processamento de \i strings. \line\i0 As t\'e9cnicas discutidas aqui s\'e3o apropriadas para desenvolver editores de texto, processadores de texto, software para \line fazer layout de p\'e1ginas, sistemas computadorizados para composi\'e7\'e3o de textos e outros tipos de software de proces \fs24\par
\b\fs14 CAP\'cdTULO \b0\fs16 5 \f2\fs8 - \b\f0\fs14 PONTEIROS E \b0\i\fs18 STRINGS \b 355 \line\b0\i0\fs16 sarnento de texto. Aqui, usamos strings baseados em ponteiros. Mais \'e0 frente, neste livro, inclu\'edmos um cap\'edtulo completo sobre strings como objetos no pleno sentido. \line\b\f2\fs22 5.12.1 Fundamentos de caracteres e \i strings \line\b0\i0\f0\fs16 Os caracteres s\'e3o os blocos de constru\'e7\'e3o fundamentais dos programas-fonte em C++. Todo programa \'e9 composto de uma seq\'fc\'eancia de caracteres que \f2\fs8 - \f0\fs16 quando agrupados de modo que fa\'e7am sentido \f2\fs8 - \f0\fs16\'e9 interpretada pelo computador como urna s\'e9rie de instru\'e7\'f5es usadas para realizar uma tarefa. Um programa pode conter \b\i\fs18 constantes de caracteres. \b0\i0\fs16 Urna constante de caractere \'e9 um valor do tipo inteiro representado corno um caractere entre ap\'f3strofes. O valor de uma constante de caractere \'e9 o valor inteiro do caractere no conjunto de caracteres da m\'e1quina. Por exemplo, z representa o valor em n\'fameros inteiros de z (122 no conjunto de caracteres ASCII) e \lquote\\n\rquote  representa o valor inteiro de nova linha (lO no conjunto de caracteres ASCII). \line Um string \'e9 urna s\'e9rie de caracteres tratados corno uma unidade. Um string pode incluir letras, d\'edgitos e v\'e1rios \line\i\fs18 caracteres especiais, \i0\fs16 tais como \b\fs14 +, -, , \b0\f2 / \f0\fs16 e \f2\fs14 $. \f0\fs16 Os \i\fs18 strings literais \i0\fs16 ou \i\fs18 constantes string \i0\fs16 s\'e3o escritos em C++ entre aspas, como segue: \line\lquote Jo\'e3o \b\fs18 da \b0\fs16 Silva\rdblquote  (umnorne) \line\b\fs18\ldblquote Rua A, 1234\rdblquote  \b0\fs16 (um endere\'e7o de rua) \line\b\fs18\ldblquote Porto Alegre, RS\rdblquote  \b0\fs16 (uma cidade e um estado) \line\b\fs14\ldblquote (51) 654.3210\rdblquote  \b0\fs16 (um n\'farnero de telefone) \line Um \i\fs18 string \i0\fs16 em C++ \'e9 um array de caracteres terminado com o \i\fs18 caractere nulo \b\i0\fs14 (\lquote  \b0\fs16\\O\rquote ). Um \i\fs18 string \i0\fs16 e acessado atraves de um ponteiro para o primeiro caractere no \i\fs18 string. \i0\fs16 O valor de um \i\fs18 string \i0\fs16\'e9 o endere\'e7o (constante) de seu primeiro caractere. Deste modo, em C++, \'e9 apropriado dizermos que \i\fs18 um string \'e9 um ponteiro constante \i0\f2\fs8 - \f0\fs16 na verdade, um ponteiro para o primeiro caractere do \i\fs18 string. \i0\fs16 Neste sentido, \i\fs18 strings \i0\fs16 s\'e3o semelhantes a arrays, porque um nome de array \'e9 tamb\'e9m um ponteiro constante para o seu primeiro elemento. \line Um string pode ser inicializado em uma declara\'e7\'e3o ou atribu\'eddo a um array de caracteres ou a uma vari\'e1vel do \line tipo char \f2\fs14 . \f0\fs16 As declara\'e7\'f5es \line char color[ ] \f2\fs12 = \f0\fs16\ldblquote blue\rdblquote ; \line const char *colorptr \f2\fs12 = \f0\fs16\lquote blue\rdblquote ; \line inicializam, cada uma, uma vari\'e1vel para o \i\fs18 string \i0\fs16\ldblquote blue\rdblquote . A primeira declara\'e7\'e3o cria um array color de 5 elementos contendo os caracteres \lquote b\rquote . \lquote 1\rquote , \lquote u\rquote , \lquote e\rquote  e \\0 \f2\fs8\lquote  \b\f0\fs14 . \b0\fs16 A segunda declara\'e7\'e3o cria a vari\'e1vel ponteiro \b\fs18 colorPtr que \b0\fs16 aponta para o \f3\fs18 string \ldblquote blue\rdblquote  em algum lugar da mem\'f3ria. \line\i\f0 Dica de portabilidade \b 5.5 \line\b0\i0\f2\fs8 ______ \i\f0\fs18 Quando uma vari\'e1vel do tipo \b\i0 char \b0\f2\fs12 * \i\f0\fs18\'e9 inicializada com um \i0\fs16 string \i\fs18 literal, alguns compiladores podem colocar o \i0\fs16 string \i\fs18 em uma posi\'e7\'e3o na mem\'f3ria em que o \i0\fs16 string \i\fs18 n\'e3o pode ser modificado. Se voc\'ea precisa modificar um \i0\fs16 string \i\fs18 literal, deve armazen\'e1-lo em um array de caracteres para assegurar a possibilidade de mudan\'e7a em todos os sistemas. \line\i0\fs16 A declara\'e7\'e3o char color \b\i\fs18 [ ] \b0\i0\f2\fs12 = \f3\fs18\ldblquote blue\rdblquote  poderia tamb\'e9m ter sido escrita como \line char color[ ] \f2\fs12 = \f0\fs16\{ \lquote b\rquote , \lquote l\rquote ,\rquote u\rquote . \lquote e\rquote . \lquote\\O\rquote  \}; \line\f3\fs18 Quando declaramos um array de caracteres para guardar um string, o array deve ser grande o bastante para armazenar \f0\fs16 o string e seu caractere terminal nulo. A declara\'e7\'e3o precedente determina o tamanho do array automaticamente baseando-se no n\'famero de inicializadores fornecidos na lista de inicializadores. \line\b\i\fs18 Erro comum de programa\'e7\'e3o 5.15 \line\b0 N\'e3o alocar espa\'e7o suficiente em um array de caracteres para armazenar o caractere nulo que termina um \line\i0\fs16 string. \fs24\par
\b\i\fs20 356 \i0\f2 C++ COMO \f0\fs14 PROGRAMAR \line\ul\i\fs20 Erro comum de programa\'e7\'e3o 5.16 \ulnone\line Criar ou usar um \b0\i0\fs18\ldblquote string\rdblquote  \i que n\'e3o cont\'e9m um caractere terminal nulo. \line\ul\b\fs20 Boa pr\'e1tica de programa\'e7\'e3o 5.5 \ulnone\line\b0\fs18 Quando armazenar um \i0 string \i de caracteres em um array de caracteres, esteja certo de que o array \'e9 \line grande o bastante para manter o maior \i0 string \i que ser\'e1 armazenado. C+ \b\i0\fs14 + \b0\i\fs18 permite que \i0 strings \i de qualquer \line comprimento sejam armazenados. Se um \i0 string \i\'e9 mais longo que o array de caracteres em que ele \'e9 \line armazenado, os caracteres al\'e9m dofim do array ser\'e3o gravados em cima dos dados que estiverem ap\'f3s o \line array na mem\'f3ria. \b\i0\f2\fs20 5.12.2 \line\b0\f3\fs18 Um \i\f0 string \i0 pode ser atribu\'eddo a \f3 um \f0 array \b usando a extra\'e7\'e3o de \b0\i stream \i0 com cm. Por exemplo, o comando seguinte A biblioti \line pode ser usado para atribuir um \i string \i0 para o array de caracteres palavra \b\i\fs20 [ \i0\fs18 20 \b0\fs24 J \b\i\fs20 : \b0\i0\fs18 procurar \line comprim \line cm \b\'bb palavra; tratameni \line\b0 Nc \line O \i string \i0 fornecido como entrada pelo usu\'e1rio \'e9 armazenado em palavra. O comando precedente l\'ea caracteres at\'e9 arquivo d \line encontrar um espa\'e7o, marca de tabula\'e7\'e3o, nova linha ou indicador de fim de arquivo. Note que o \i string \i0 n\'e3o deveria vos de ca \line ter mais que 19 caracteres para deixar um espa\'e7o para o caractere terminal nulo. O manipulador de \i stream \i0 setw, ned int \line introduzido no Cap\'edtulo 2, pode ser usado para assegurar que o \i string \i0 armazenado em palavra n\'e3o exceda o \line tamanho do array. Por exemplo, o comando \line\f3 cm \f0\'bb setw( 20 ) \'bb palavra; \line especifica que cm deve ler um m\'e1ximo de 19 caracteres no array palavra e reservar a 20 \f3 posi\'e7\'e3o no \f0 array para \line armazenar o caractere nulo terminal do \i string. \i0 O manipulador de \i stream \b\i0 setw \b0 s\'f3 se aplica ao pr\'f3ximo valor fornecido \line como entrada. \line Em alguns casos, \'e9 desej\'e1vel fornecer uma linha inteira de texto como entrada para um array. Para este fim, \line C++ oferece a fun\'e7\'e3o cm \f2\fs8 . \f0\fs18 getline. A fun\'e7\'e3o cm \f2\fs8 . \f0\fs18 getline aceita tr\'eas argumentos \f2\fs8 - \f0\fs18 um array de caracteres \line em que a linha de texto ser\'e1 armazenada, um comprimento e um caractere delimitador. Por exemplo, o segmento de \line programa \line char \line\f3 char frase[ 80 J; \line cin.getline( frase, 80, \\n\rquote  ); \line char \line\f0 declara o array frase de 80 caracteres e ent\'e3o l\'ea uma linha de texto do teclado para o array. A fun\'e7\'e3o p\'e1ra de ler \line caracteres quando \i\'e9 \i0 encontrado o caractere delimitador \lquote\\n\rquote  \f2\fs8 , \f0\fs18 quando o indicador de fim de arquivo \'e9 inserido pelo \line usu\'e1rio ou quando o n\'famero de caracteres lido at\'e9 ent\'e3o \'e9 um a menos que o comprimento especificado no segundo \line argumento (o \'faltimo caractere no array \i\'e9 \i0 reservado para o caractere terminador nulo). Se o caractere delimitador \i\'e9 \i0 char \line encontrado, ele \b\i\fs20\'e9 \b0\i0\fs18 lido e descartado, O terceiro argumento para a ci getline tem \lquote\\n\rquote  como valor default, de \line modo que a chamada de fun\'e7\'e3o precedente poderia ter sido escrita como segue: \line\b cin.getline ( frase, 80 ); \line\b0\f3 int si \line O Cap\'edtulo 11 \f0 fornece \f3 uma discuss\'e3o detalhada de cm \f2\fs8 . \f3\fs18 getline e outras fun\'e7\'f5es de entradalsa\'edda. \line\b\i\f0\fs20 Erro comum de programa\'e7\'e3o 5.17 \line\b0\fs18 Processar um caractere \'fanico como um \i0\f3 string \i\f0 pode levar a um erro fatal durante a execu\'e7\'e3o. Um \i0 string \i\'e9 \b\i0 int S \b0\i um ponteiro \i0\f2\fs8 - \i\f0\fs18 provavelmente um inteiro consideravelmente grande. Por\'e9m, um caractere \'e9 um inteiro \line pequeno (valores ASC\'cdI variam de O \i0 a \i 255). Em muitos sistemas, isso causa um erro porque os endere\'e7os \line de mem\'f3ria baixos s\'e3o reservados para prop\'f3sitos especiais, tais como para tratadores de interrup\'e7\'f5es \line do sistema operacional \i0\f2\fs8 - \i\f0\fs18 assim, ocorrem \ldblquote viola\'e7\'f5es de acesso \i0\f2\fs8\ldblquote . \line\b\fs20 Fig. 5. \b0\f0\fs24\par
\b\fs14 CAP\'cdTULO \b0\f2\fs18 5 \fs8 - \b\f0\fs14 PONTEIROS E \b0\i\fs16 STRINGS 357 \line IErro comum de programa\'e7\'e3o 5.18 \line Passar um caractere como argumento para uma fun\'e7\'e3o, quando \'e9 esperado um \i0\fs20 string, \i\fs18 pode levar a um erro fatal durante a execu\'e7\'e3o. \line Erro comum de programa\'e7\'e3o 5.19 \line Passar um \i0 string \i como argumento para uma fim \'e7\'e3o, quando \'e9 esperado um caractere, \'e9 um erro de sintaxe. \line\b\i0\f2\fs22 5.12.2 Fun\'e7\'f5es de manipula\'e7\'e3o de \i strings \i0 da biblioteca de tratamento de \i strings \line\b0\i0\fs18 A \f0\fs20 biblioteca de tratamento de \i\fs18 strings \i0\fs20 fornece muitas fun\'e7\'f5es \'fateis para manipular \f2\fs18 dados de \i\f0 strings, \i0\fs20 comparar \i\fs18 strings, \i0\f2 procurar em \i\f0 strings \i0\f2 por caracteres e outros \i\f0 strings, \i0\f2 separa\'e7\'e3o de \i\f0 strings \i0\f2 em \ldblquote unidades l\'e9xicas\rdblquote  e determinar o comprimento de \i\f0\fs16 strings. \i0\f2\fs18 Esta se\'e7\'e3o apresenta algumas fun\'e7\'f5es comuns de manipula\'e7\'e3o de \i\f0\fs20 strings \i0\f2\fs18 da biblioteca de tratamento de \i\f0 strings \i0\f2 (parte da biblioteca badr\'e3o). As fun\'e7\'f5es s\'e3o resumidas na Fig. 5.29. \line Note que v\'e1rias fun\'e7\'f5es na Fig. 5.29 cont\'eam argumentos com tipo de dados \b size_t. \b0 Este tipo \'e9 definido no arquivo de cabe\'e7alho <cstddef> (um arquivo de cabe\'e7alho da biblioteca padr\'e3o inclu\'eddo em muitos outros arquivos de cabe\'e7alho da biblioteca padr\'e3o, inclusive <cstring>) como um tipo inteiro sem sinal, tal como unsig- \f0\fs20 ned \f3\fs18 int \f2 ou \f3 uns igned long. \line\i\f0\fs20 Erro comum de programa\'e7\'e3o 5.20 \line Esquecer de incluir o arquivo de cabe\'e7alho \i0 <cstring> \i\fs18 quando usarfun\'e7\'f5es da biblioteca de tratamento de \i0\fs20 strings. \fs24\par
\b\f2\fs22 Fig. 5.29 \b0\fs18 Fun\'e7\'f5es de manipula\'e7\'e3o de \i\f0\fs20 strings \i0\f2\fs18 da biblioteca de tratamento de \i\fs20 strings \i0\fs18 (parte 1 de 2). \f0\fs24\par
\pard\par
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx589\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx6373\pard\intbl\b\f3\fs20 Prot \b0\f0\fs24\cell\b\f3\fs20\'f3tipo de fun\'e7\'e3o Descri\'e7\'e3o da fun\'e7\'e3o \b0\f0\fs24\cell\fs20\row
\f3\fs18\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx589\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx6373\intbl char \f0\fs24\cell\f3\fs18 *strcpy( char *si, const char *s2 \f0\fs24\cell\fs20\row
\fs24\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx589\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx6373\intbl\cell\f2\fs18 Copia \f3 o \i\f0 string \i0\f3 s2 no array \f2 de caracteres \f3 si. \f2 Retorna o valor de \f3 si. \f0\fs24\cell\fs20\row
\f3\fs18\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx589\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx6373\intbl char \f0\fs24\cell\f3\fs18 *strncpy( char *si, const char *52, size_t ri \f0\fs24\cell\fs20\row
\fs24\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx589\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx6373\intbl\cell\f2\fs16 Copia \f3\fs18 no \f2\fs16 m\'e1ximo \f3\fs18 n \f2\fs16 caracteres do \i\f0 string \i0\f3\fs18 s2 \f2\fs16 para o array de caractere \f3\fs18 si. \f0\fs24\cell\fs20\row
\fs24\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx589\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx6373\intbl\cell\f2\fs18 Retorna \f3 o \f2 valor de \f3 si. \f0\fs24\cell\fs20\row
\f3\fs18\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx589\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx6373\intbl char \f0\fs24\cell\f3\fs18 *strcat( char *si, const char *s2 ); \f0\fs24\cell\fs20\row
\fs24\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx589\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx6373\intbl\cell\f2\fs18 Anexa a \i\f0\fs16 string \i0\f2\fs18 s2 para o \i\f0 string \i0\fs20 si. O \f2\fs18 primeiro caractere de s2 ser\'e3o gravados \f0\fs24\cell\fs20\row
\fs24\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx589\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx6373\intbl\cell\f2\fs18 em cima do caractere nulo terminal de si. Retorna o valor de si. \f0\fs24\cell\fs20\row
\f3\fs18\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx589\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx6373\intbl char \f0\fs24\cell\f3\fs16 *strncat( char *si, const char*s2, size_t \f2\fs12 ri \i\f0\fs20 ); \i0\fs24\cell\fs20\row
\fs24\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx589\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx6373\intbl\cell\f2\fs18 Anexa no m\'e1ximo n caracteres de \i\f0\fs16 string \i0\f2\fs18 s2 para o \i\f0\fs16 string \i0\f2\fs18 si. \b\fs22 O \b0\fs18 primeiro \f0\fs24\cell\fs20\row
\fs24\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx589\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx6373\intbl\cell\f2\fs18 caractere de s2 ser\'e1 gravado por cima do caractere nulo terminal de si. \f0\fs24\cell\fs20\row
\fs24\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx589\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx6373\intbl\cell\f2\fs18 Retorna o valor de si. \f0\fs24\cell\fs20\row
\f3\fs18\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx589\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx6373\intbl int \f0\fs24\cell\f3\fs18 strcmp( const char *si const char*s2 ); \f0\fs24\cell\fs20\row
\fs24\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx589\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx6373\intbl\cell\f2\fs18 Compara o \i\f0\fs16 string \i0\f2\fs18 si com o \i\f0 string \i0\fs20 s2. \f2\fs18 A fun\'e7\'e3o retorna um valor O, menor \f0\fs24\cell\fs20\row
\fs24\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx589\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx6373\intbl\cell\f2\fs18 que O, ou maior que O, se si for igual a, menor que, ou maior que s2, \f0\fs24\cell\fs20\row
\fs24\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx589\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx6373\intbl\cell\f2\fs18 respectivamente. \f0\fs24\cell\fs20\row
\f3\fs18\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx589\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx6373\intbl int \f0\fs24\cell\f3\fs18 strncmp( const char *si, const char*s2, size_t n ); \f0\fs24\cell\fs20\row
\fs24\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx589\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx6373\intbl\cell\f2\fs16 Compara at\'e9 n caracteres do \i\f0 string \i0\f3\fs18 si \f2\fs16 como o \i\f0 string \b\i0\f3\fs20 s2. \b0\f2\fs16 A \f3\fs18 fun\'e7\'e3o \f2\fs16 retorna \f0\fs24\cell\fs20\row
\fs24\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx589\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx6373\intbl\cell\f2\fs16 O, menor que O, ou maior que O se si \'e9 igual a, menor que, ou maior que \b\f3\fs20 s2, \b0\f0\fs24\cell\fs20\row
\fs24\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx589\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx6373\intbl\cell\f2\fs18 respectivamente. \f0\fs24\cell\fs20\row
\pard\fs24\par
\pard\sb100\sa240\i\f2\fs20 358 \b\i0 C++ \b0\fs14 COMO PROGRAMAR \line\b\f3\fs16 char *strtok( char *si, const char *s2 ); \line\b0\f0 Uma seq\'fc\'eancia de chamadas para s trtok quebra o \i\fs18 string \i0\fs16 si em \ldblquote tokens\rdblquote  \line -unidades l\'f3gicas tais como palavras em uma linha de texto \f2\fs8 - \f0\fs16 separados por caracteres contidos no \i\fs18 string \i0\fs16 s2. A primeira chamada tem si como o primeiro argumento, e as chamadas subseq\'fcentes para continuar separando em \lquote tokens\rdblquote  \i\fs18 [\ldblquote tokenizing\rdblquote j \i0\fs16 o mesmo \i\fs18 string \i0\fs16 cont\'e9m NULL como o primeiro argumento. Um ponteiro para o \ldblquote token\rdblquote  atual \b\f3\'e9 \b0\f0 retornado por cada chamada. Se n\'e3o existirem mais \ldblquote tokens\rdblquote  quando a fun\'e7\'e3o \'e9 chamada, NULL \i\f2\fs20\'e9 \i0\f0\fs16 retornado. \line size_t strlen( const char \f2\fs10 * \line\f0\fs16 Determina o comprimento do \i\fs18 string \i0\fs16 s. Retorna o n\'famero de caracteres que \line precedem o caractere nulo terminal. \line\b\f2\fs20 Fig. 5.29 \b0 Fun\'e7\'f5es de manipula\'e7\'e3o de \i strings \i0 da biblioteca de tratamento de \i strings \i0 (parte 2 de 2). \line\f0\fs16 A fun\'e7\'e3o strcpy copia seu segundo argumento \f2\fs8 - \f0\fs16 um \i\fs18 string \i0\f2\fs8 - \f0\fs16 para o seu primeiro argumento \f2\fs8 - \f0\fs16 um array de caracteres que deve ser grande o bastante para armazenar o \i\fs18 string \i0\fs16 e o seu caractere terminal nulo, que tamb\'e9m \'e9 copiado. A fun\'e7\'e3o strncpy \'e9 equivalente a strcpy a n\'e3o ser pelo fato de que strncpy especifica o n\'famero de caracteres a serem copiados do \i\fs18 string \i0\fs16 para o array. Note que a fun\'e7\'e3o strncpy n\'e3o copia necessariamente o caractere terminal nulo de seu segundo argumento. O caractere terminal nulo \'e9 escrito s\'f3 se o n\'famero de caracteres a ser copiado \'e9 pelo menos um a mais do que o comprimento do \i\fs18 string. \i0\fs16 Por exemplo, se \ldblquote teste\rdblquote  \'e9 o segundo argumento, um caractere nulo terminal \'e9 escrito s\'f3 se o terceiro argumento de strncpy for pelo menos 6 (5 caracteres em \ldblquote teste\rdblquote , mais 1 caractere terminal nulo). Se o terceiro argumento for maior do que 6, s\'e3o acrescentados caracteres nulos ao array at\'e9 que o n\'famero total de caracteres especificados pelo terceiro argumento sejam escritos. \line\i\fs18 Erro comum de programa\'e7\'e3o 5.21 \line N\'e3o anexar um caractere nulo terminal ao primeiro argumento de uma strncpy. quando o terceiro argumento \'e9 menor ou igual ao comprimento do \i0\fs16 string \i\fs18 no segundo argumento, pode causar erros fatais durante a execu\'e7\'e3o. \line\i0\fs16 O programa na Fig. 5.30 usa strcpy para copiar o \i\fs18 string \i0\fs16 inteiro do array x para o array y e usa strncpy para copiar os primeiros 14 caracteres do array x para o array z. O caractere nulo \b\f3 (\lquote  \b0\f0\\0\rquote ) \'e9 acrescentado ao array z porque a chamada a strncpy no programa n\'e3o escreve um caractere nulo terminal (o terceiro argumento \'e9 menor que o comprimento do \i\fs18 string \i0\fs16 do segundo argumento). \line 1 \i\fs18 II \b\i0\f3\fs16 Fig. 5.30: figO53O.cpp \line\b0\f0 2 // \b\f3 Usando strcpy e strncpy \line 3 #include <iostream> \line 4 \line 5 using std::cout; \line 6 using std::endl; \line 7 \line 8 #include <cstring> \line 9 \line 10 int main \b0\f0 O \line\b\f3 ii \line i2 char x[] \ldblquote Programando em C++\rdblquote ; \line i3 char y[ 25 \b0\i\f2\fs20 ], \b\i0\f3\fs16 z[ 15 ]; \line 14 \line iS cout \'ab \ldblquote O string no array x \'e9: \'ab x \line i6 \'ab \ldblquote\\nO string no array y \'e9: \b0\f2\fs8\ldblquote  \b\f3\fs16\'ab strcpy( y, x \line\f2\fs20 Fig. 5.30 Usando \f0\fs16 strcpy \b0\f2\fs20 e \b\f3\fs16 strncpy \b0\f2\fs20 (parte 1 de 2). + \f0\fs24\par
\b\fs14 CAP\'cdTULO \b0\f2\fs20 5 \fs8 - \fs14 PONTEIROS E \i\f0\fs18 STRJNGS \f2\fs22 359 \line\b\i0\f3\fs14 17 \'ab \\n; \line 18 strncpy( z, x, 14 ); \b0\i\f2\fs22 II \b\i0\f3\fs14 n\'e3o copia o caractere nulo \line 19 z[ 14 \b0\f0\fs20 :i \f2\fs10 = \line 1 \b\f3\fs14 20 cout \'ab \ldblquote O string no array z \'e9: \b0\f2\fs8\ldblquote  \b\f3\fs14\'ab z \'ab endl; \line 21 \line r- 22 return 0; \line a. 23 \f2\fs18\} \b0\f0\fs24\par
\b\f2\fs18 Fig. 5.30 \b0\fs20 Usando \b\f0\fs16 strcpy \b0\f2\fs20 e \f0\fs16 strncpy \f2\fs20 (parte 2 de 2). \line\f0\fs16 A fun\'e7\'e3o strcat concatena seu segundo argumento \f2\fs8 - \f3\fs18 um \i\f0 string \i0\f2\fs8 - \f0\fs16 ao seu primeiro argumento \f2\fs8 - \f3\fs18 um \f0\fs16 array de caracteres contendo um \i\fs18 string. \i0\fs16 O primeiro caractere do segundo argumento substitui o caractere nulo \b\fs14 (\lquote  \b0\fs16\\0 \f2\fs8\lquote  \fs24 ) \f0\fs16 que \line le termina o \i\fs18 string \i0\fs16 no primeiro argumento. O programador deve assegurar que o array usado para armazenar o primeiro \i\fs18 string \i0\fs16\'e9 grande o bastante para armazenar a combina\'e7\'e3o do primeiro \i\fs18 string \i0\fs16 com o segundo \i\fs18 string \i0\fs16 e, \line [e ainda, o caractere terminal nulo (copiado do segundo \i\fs18 string). \i0\fs16 A fun\'e7\'e3o strncat concatena um n\'famero especificado de caracteres do segundo string ao primeiro \i\fs18 string. \i0\fs16 Um caractere terminal nulo \'e9 acrescentado ao resultado. O programa da Fig. 5.31 demonstra a fun\'e7\'e3o strcat e a fun\'e7\'e3o strncat. \line\b\f3 1 \b0\i\f2\fs20 II \b\i0\f3\fs16 Fig. 5.31: \b0\f0 figO53l.cpp \line\b\f3 2 \b0\f0 // \b\f3 Usando strcat e strncat \line 3 #inciude <iostream> \line 4 \line 5 using std::cout; \line 6 using std: :endl; \line 7 \line 8 #include <cstring> \line 9 \line 10 int main() \line 11 \b0\f0\{ \line\b\f3 a 12 char si[ 20 \b0\f0 ] \f2\fs10 = \b\f3\fs16\ldblquote Feliz \b0\f2\fs10\lquote ; \line\b\f3\fs16 13 char s2[] \b0\f2\fs10 = \f0\fs16\ldblquote Ano \b\f3 Novo \b0\f2\fs10\lquote ; \line\b\f3\fs16 14 char s3[ 40 \b0\f0 ) \f2\fs10 = \ldblquote\ldblquote ; \line\b\f3\fs16 15 \line 16 cout \'ab \ldblquote si \b0\f2\fs10 = \ldblquote  \b\f0\fs14\'ab \f3\fs16 si \'ab \ldblquote\\ns2 \b0\f2\fs10 = \ldblquote  \b\f0\fs14\'ab s2; \line\f3\fs16 17 cout\'ab \ldblquote\\nstrcat(si, s2) \b0\f2\fs10 = \b\f3\fs16\'ab strcat( si, s2 ); \line 18 cout\'ab \ldblquote\\nstrncat(s3, si, 6) \b0\f2\fs10 = \lquote  \b\f3\fs16\'ab strncat( s3, si, 6 ); \line 19 cout\'ab \ldblquote\\nstrcat(s3, si) \b0\f2\fs10 = \b\f3\fs16\'ab strcat( s3, si \b0\f0 ) \b\fs14\'ab \f3\fs16 endl; \line 20 \line 21 return 0; \line 22 \b0\f0\} \line\b\f2\fs18 Fig. 5.31 Usando \b0\f3 strcat \f2\fs20 e \f3\fs18 strncat. \line\f0\fs16 A Fig. 5.32 compara tr\'eas \i\fs18 strings \i0\fs16 usando strcmp e strncmp. A \b\f3 fun\'e7\'e3o strcmp compara seu primeiro argumento \b0\i\f0\fs18 string \i0\fs16 a seu segundo argumento \i\fs18 string, \i0\fs16 caractere por caractere. A fun\'e7\'e3o retorna zero se os \i\fs18 strings \i0\fs16 s\'e3o iguais, um valor negativo se o primeiro \i\fs18 string \i0\fs16\'e9 menor que o segundo \i\fs18 string \i0\fs16 e um valor positivo se o primeiro \i\fs18 string \i0\fs16\'e9 maior que \fs24\par
\b\f3\fs14 si \b0\f2\fs10 = \b\f0\fs16 Feliz \line\f3\fs14 s2 \b0\f2\fs10 = \b\f3\fs14 Ano Novo \line strcat (si, s2) \b0\f2\fs10 = \b\f3\fs14 Feliz Ano Novo strncat (s3, si, 6) \b0\f2\fs10 = \b\f0\fs16 Feliz \line\b0\f3\fs18 strcat (s3, si) \f2\fs10 = \b\f0\fs16 Feliz Feliz \f3\fs14 Ano Novo \b0\f0\fs24\par
\pard\par
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx205\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx998\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1407\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2584\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx3857\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4266\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4771\pard\intbl\b\f3\fs16 O \b0\f0\fs24\cell\b\f3\fs16 string \b0\f0\fs24\cell\b\f3\fs16 no \b0\f0\fs24\cell\b\f3\fs16 array x \'e9: \b0\f0\fs24\cell\b\f3\fs16 Programando \b0\f0\fs24\cell\b\f3\fs16 em \b0\f0\fs24\cell\b\f3\fs16 C++ \b0\f0\fs24\cell\fs20\row
\b\f3\fs16\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx205\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx998\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1407\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2584\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx3857\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4266\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4771\intbl O \b0\f0\fs24\cell\b\f3\fs16 string \b0\f0\fs24\cell\b\f3\fs16 no \b0\f0\fs24\cell\b\f3\fs16 array y \'e9: \b0\f0\fs24\cell\b\f3\fs16 Programando \b0\f0\fs24\cell\b\f3\fs16 em \b0\f0\fs24\cell\b\f3\fs16 C++ \b0\f0\fs24\cell\fs20\row
\b\f3\fs16\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx205\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx998\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1407\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2584\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx3857\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4266\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4771\intbl O \b0\f0\fs24\cell\b\f3\fs16 string \b0\f0\fs24\cell\b\f3\fs16 no \b0\f0\fs24\cell\b\f3\fs16 array z \'e9: \b0\f0\fs24\cell\b\f3\fs16 Programando \b0\f0\fs24\cell\b\f3\fs16 em \b0\f0\fs24\cell\cell\fs20\row
\pard\fs24\par
\pard\sb100\sa240\b\f2\fs22 360 \b0\f0\fs20 C++ \fs14 COMO PROGRAMAR \line\fs20 o segundo \i\fs18 string. \i0\fs20 A fun\'e7\'e3o strncmp \'e9 equivalente strcmp, a n\'e3o ser pelo fato de que strncmp faz a compara\'e7\'e3o at\'e9 um n\'famero especificado de caracteres. A fun\'e7\'e3o strncmp n\'e3o compara os caracteres seguintes a um caractere nulo em um \i\fs18 string. \i0\fs20 O programa imprime o valor de tipo inteiro retornado por cada chamada da fun\'e7\'e3o. \line\b\f3\fs16 1 \b0\i\f2\fs22 II \b\i0\f3\fs16 Fig. \b0\f0\fs18 5.32: figo5_32.cpp \line\b\f3\fs16 2 \b0\i\f2\fs22 II \b\i0\f3\fs16 Usando strcmp and strncmp \line 3 #include <iostream> \line\b0\f0\fs18 4 \line\b\f3\fs16 5 using std::cout; \line 6 using std: :endl; \line 7 \line 8 #include <iomanip> \line 9 \line 10 using std::setw; \line ii \line 12 #include <cstring> \line\b0\f0\fs14 13 \line\b\f3\fs16 14 int main \b0\f2\fs30 o \line\b\f3\fs16 15 \b0\f0\fs20\{ \line\b\f3\fs16 16 char *si \b0\f2\fs10 = \b\f3\fs16\ldblquote Feliz \b0\f0 Ano \b\f3 Novo\rdblquote ; \line 17 char *s2 \b0\f2\fs10 = \b\f3\fs16\ldblquote Feliz \b0\f0 Ano \b\f3 Novo\rdblquote ; \line 18 char *3 \b0\f2\fs10 = \b\f3\fs16\ldblquote Feliz Natal\rdblquote ; \line\b0\f0\fs14 19 \line\b\f3\fs16 20 cout \'ab \ldblquote si \b0\f2\fs10 = \ldblquote  \b\f3\fs16\'ab si \'ab \ldblquote\\ns2 \b0\f2\fs10 = \ldblquote  \f0\fs20\'ab \b\f3\fs16 s2 \line 21 \'ab \ldblquote\\ns3 \b0\f2\fs10 = \ldblquote  \b\f3\fs16\'ab s3 \'ab \ldblquote\\n\\nstrcinp(si, s2) \b0\f2\fs10 = \line\b\f3\fs16 22 \'ab setw \b0\f0\fs20 ( 2 ) \b\f3\fs16\'ab strcmp( si, s2 \line 23 \'ab \ldblquote\\nstrcmp(si, s3) \b0\f2\fs10 = \ldblquote  \f0\fs20\'ab \b\f3\fs16 setw(2) \line 24 \'ab strcmp( si, s3 \b0\f0\fs20 ) \b\f3\fs16\'ab \ldblquote\\nstrcmp(s3, si) \b0\f2\fs10 = \line\b\f3\fs16 25 \'ab setw( 2 \b0\f0\fs20 ) \b\f3\fs16\'ab strcnip( s3, si ); \line\b0\f0\fs18 26 \line\b\f3\fs16 27 cout\'ab \ldblquote\\n\\nstrncntp(si, s3, 6) \b0\f2\fs10 = \ldblquote  \b\f3\fs16\'ab setw( 2 \line 28 \'ab strncmp( si, s3, 6 \b0\f0\fs20 ) \b\f3\fs16\'ab \ldblquote\\nstrncmp(si, s3, 7) \b0\f2\fs10 = \line\b\f3\fs16 29 \'ab setw( 2 \b0\f0\fs20 ) \b\f3\fs16\'ab strncmp( si, s3, 7 \line 30 \'ab \ldblquote\\nstrncmp(s3, si, 7) \b0\f2\fs10 = \line\b\f3\fs16 31 \'ab setw( 2 \b0\f0\fs20 ) \b\f3\fs16\'ab strncmp( s3, si, 7 \b0\f0\fs20 ) \'ab \b\f3\fs16 endl; \line 32 return 0; \line 33 \b0\f0\fs20 1 \line\b\f3\fs16 si \b0\f2\fs10 = \b\f3\fs16 Feliz Ano Novo \line s2 \b0\f2\fs10 = \b\f3\fs16 Feliz Ano Novo \line s3 \b0\f2\fs10 = \b\f3\fs16 Feliz Natal 2K \line strcmp(si, s2) O \line strcmp(si, s3) \b0\f2\fs10 = \b\f3\fs16 -i \line strcmp(s3, si) \b0\f2\fs10 = \b\f3\fs16 i \line strncmp(si, s3, 6) \b0\f2\fs10 = \b\f3\fs16 O \line strncmp(si, s3, 7) \b0\f2\fs10 = \b\f3\fs16 -i \line strncmp(s3, si, 7) \b0\f2\fs10 = \b\f3\fs16 1 \line\b0\f0\fs18 Fig. 5.32 Usando strcmp e \b\f3\fs16 strncmp. \line\ul\b0\i\f0\fs18 Erro comum de programa\'e7\'e3o 5.22 \ulnone\line Assumir que \i0\fs20 strcmp \i\fs18 e \i0\fs20 strncmp \i\fs18 retornam um quando seus argumentos forem iguais \i0\'e9 \i um erro de l\'f3gica. Ambas as fun\'e7\'f5es retornam zero (o valor falso em C++) para igualdade. Ent\'e3o, quando \i0\fs20 strings \i\fs18 s\'e3o testados quanto \i0\'e0 \i igualdade, o resultado das fun\'e7\'f5es \i0 strcmp \i ou \i0 strncmp \i devem ser comparados com \f1\fs20 O \f0\fs18 para determinar se os \i0\fs20 strings \i\fs18 s\'e3o iguais. \i0\fs24\par
\b\fs14 CAP\'cdTULO \b0\fs18 5 \f2\fs8 - \b\f0\fs14 PONTEIROS E \b0\i\fs18 STRINGS \b\i0\f2\fs22 361 \line\b0\f0\fs18 S\'f3 para entender o que quer dizer um \i string \i0 ser \ldblquote maior do que\rdblquote  ou \ldblquote menor do que\rdblquote  outro \i string, \i0 considere o processo de colocar uma s\'e9rie de sobrenomes em ordem alfab\'e9tica. O leitor iria, sem d\'favida alguma, colocar \ldblquote Maria\rdblquote  antes de \ldblquote Pedro\rdblquote , porque a primeira letra de \ldblquote Maria\rdblquote  vem antes da primeira letra de \ldblquote Pedro\rdblquote  no alfabeto. Mas o alfabeto \'e9 mais do que s\'f3 uma lista de 26 letras \f2\fs8 - \f0\fs18\'e9 uma lista ordenada de caracteres. Cada letra ocupa uma posi\'e7\'e3o espec\'edfica dentro da lista. \b\f2\fs22\ldblquote Z\rdblquote  \b0\f0\fs18\'e9 mais que do s\'f3 uma letra do alfabeto; \ldblquote Z\rdblquote  \'e9, especificamente, a 26 letra do alfabeto. \line Como o computador sabe que uma letra vem antes de outra? Todos os caracteres s\'e3o representados dentro do \line computador como c\'f3digos num\'e9ricos; quando o computador compara dois \i strings, \i0 ele compara na verdade os c\'f3digos num\'e9ricos dos caracteres nos \i strings. \line Dica de portabilidade 5.6 \line\i0\f2\fs8 ______ \i\f0\fs18 Os c\'f3digos num\'e9ricos internos usados para representar caracteres podem ser diferentes em computado- res dfe rentes. \line Dica de portabilidade 5.7 \line\i0\f2\fs8 _____ \i\f0\fs18 N\'e3oft\'e7a testes expl\'edcitos do valor do c\'f3digo de caracteres em ASCII, como por exemplo em: \i0 if (ch \f2\fs12 == \f0\fs18 65 ) \b\fs14 ; \b0\i\fs18 em vez disso, use sempre a constante de caractere correspondente, como em: \i0 if (ch \f2\fs12 == \f0\fs18\lquote A\rquote  ). \line Em um esfor\'e7o para padronizar as representa\'e7\'f5es de caracteres, a maioria dos fabricantes de computador projetou suas m\'e1quinas para utilizar um dos dois esquemas populares de codifica\'e7\'e3o \f2\fs8 - \i\f0\fs18 ASCI! \i0 ou \i EBCDJC. \i0 ASCII significa \ldblquote American Standard Code for Information Interchange\rdblquote  e EBCDIC significa \ldblquote Extended Binary Coded Decimal Interchange Code\rdblquote . Existem outros esquemas de codifica\'e7\'e3o, mas estes dois s\'e3o os mais populares. \line ASCII e EBCDIC s\'e3o chamados de \i c\'f3digos de caracteres \i0 ou \i conjuntos de caracteres. \i0 As manipula\'e7\'f5es de strings e caracteres envolvem, na realidade, a manipula\'e7\'e3o dos c\'f3digos num\'e9ricos apropriados e n\'e3o dos caracteres. Isto explica a intercambialidade de caracteres e valores inteiros pequenos em C++. Uma vez que \'e9 significativo se dizer que um c\'f3digo num\'e9rico \'e9 maior do que, menor do que ou igual a outro c\'f3digo num\'e9rico, torna-se poss\'edvel relacionar v\'e1rios caracteres ou strings um ao outro, referindo-se aos c\'f3digos dos caracteres. O Ap\'eandice B cont\'e9m os c\'f3digos de caracteres em ASCII. \line A fun\'e7\'e3o strtok \'e9 usada para quebrar um \i string \i0 em uma s\'e9rie de \ldblquote unidades l\'e9xicas\rdblquote . Uma unidade l\'e9xica \'e9 uma seq\'fc\'eancia de caracteres separados por \i caracteres delimitadores \i0 (normalmente por espa\'e7os ou sinais de pontua\'e7\'e3o). Por exemplo, em uma linha de texto, cada palavra pode ser considerada uma unidade l\'e9xica e os espa\'e7os que separam as palavras podem ser considerados delimitadores. \line S\'e3o necess\'e1rias m\'faltiplas chamadas a strtok para quebrar um \i string \i0 em unidades l\'e9xicas (assumindo-se que o string contenha mais do que uma unidade l\'e9xica). A primeira chamada a strtok cont\'e9m dois argumentos, um string para ser separado em unidades l\'e9xicas e outro \i string \i0 contendo caracteres que separam as unidades l\'e9xicas (i.e., delimitadores). No programa da Fig. 5.33, o comando \line tokenPtr \f2\fs12 = \f0\fs18 strtok( string, \f2\fs8\ldblquote  \line\f0\fs18 atribui a tokenPtr um ponteiro para a primeira unidade l\'e9xica em string. O segundo argumento de strtok, indica que as unidades l\'e9xicas em string s\'e3o separadas por espa\'e7os. A fun\'e7\'e3o strtok procura pelo \line primeiro caractere em string que n\'e3o \'e9 um caractere delimitador (espa\'e7o). Esse come\'e7a a primeira unidade l\'e9xica. A fun\'e7\'e3o ent\'e3o acha o pr\'f3ximo caractere delimitador no \i string \i0 e substitui este por um caractere nulo \b\fs14 (\lquote  \b0\fs18\\O\rquote ). Este termina a unidade l\'e9xica atual. A fun\'e7\'e3o strtok salva um ponteiro para o pr\'f3ximo caractere que vem em seguida \'e0 unidade l\'e9xica em string, retornando um ponteiro para a unidade l\'e9xica atual. \line As chamadas subseq\'fcentes a strtok para continuar a separar string em unidades l\'e9xicas cont\'eam NULL como o primeiro argumento. O argumento NULL indica que a chamada a strtok deve continuar o processo de separa\'e7\'e3o em unidades l\'e9xicas a partir da posi\'e7\'e3o em string salva pela \'faltima chamada a strtok. Se n\'e3o restam mais unidades l\'e9xicas quando strtok \'e9 chamada, strtok retorna NULL. O programa da Fig. 5.33 usa strtok para separar em unidades l\'e9xicas o \i string \b\i0\fs14\ldblquote Esta \b0\fs18\'e9 urna frase com 8 unidades l\'e9xicas\rdblquote . Cada unidade l\'e9xica \'e9 impressa separadamente. Note que strtok modifica o \i string \i0 fornecido como entrada; por isso, se o \i string \i0 precisar ser usado novamente no programa, ap\'f3s a chamada a strtok, deve ser feita antes uma c\'f3pia do \i string. \i0\fs24\par
\f2\fs20 362 C++ \fs14 COMO PROGRAMAR \line\b\f3\fs16 1 \b0\i\f0\fs20 II \b\i0\f3\fs16 Fig. 5.33: fig0533.cpp \line 2 \b0\f2\fs20 // \b\f3\fs16 Usando strtok 6 u \line 3 #include <iostrearn> 7 \line 5 using std::cout; 9 \line 6 using std::endl; 10 i \line 8 #include <cstring> 11 \b0\f2\fs20\{ \line\b\f3\fs16 10 int main \b0\f2\fs20 O \b\f3\fs16 14 \line 11 \b0\f2\fs20\{ \b\f3\fs16 15 \line 12 char string[] \f0\fs14 = \f3\fs16 Esta \'e9 \b0 urna \b frase com 8 unidades l\'e9xicas\rdblquote ; 16 \line 13 char *tokenptr; 17 \line 14 18 \line 15 cout\'ab \ldblquote O string a ser separado em unidades l\'e9xicas \'e9:\\n\rdblquote  \'ab string 19 \line 16 \b0\f2\fs18\'ab \b\f3\fs16\ldblquote\\n\\nAs unidades l\'e9xicas s\'e3o:\\n\rdblquote ; 20 \line 17 21 \line 18 tokenPtr \f0\fs14 = \f3\fs16 strtok( string, \b0\f2\fs8\ldblquote  \b\f3\fs16 22 \line 20 while \b0\f2\fs20 ( \b\f3\fs16 tokenPtr \f0\fs14 != \f3\fs16 NULL \b0\f2\fs20 ) \{ \line\b\f3\fs16 21 cout \'ab tokenPtr \'ab \lquote\\n\rquote ; \line 22 tokenPtr \f0\fs14 = \f3\fs16 strtok( NULL, \b0\f2\fs8\ldblquote  \ldblquote  \line\b\f3\fs16 25 return 0; \line 26 \line\b0\f2\fs18 Fig.5 \line\b\f3\fs16 O string a ser separado em unidades J.\'e9xicas \'e9: \line Esta \'e9 \b0 urna \b frase com 8 unidades l\'e9xicas \line As unidades l\'e9xicas s\'e3o: \b0\fs24 5 13 \line\b\fs16 Esta \b0\fs24 cIa \line\fs16 uma \line\b frase \b0\f2\fs18 Esta \i\f0\fs20\'e9 \line\b\i0\f3\fs16 com \b0\f0\fs18 orient \line\b\f3\fs16 8 \b0\f0\fs18 tecnic \line\b\f3\fs16 unidades \b0\f0\fs18 Parac \line\b\f3\fs16 l\'e9xicas \b0\f0\fs18 Inclu\'ed \line\f2\fs8 ________________________________- \b\f3\fs16 _________________________________________________________ \b0\f0\fs18 biblio, \line\f2\fs20 Fig. 5.33 Usando strtok. \line\f0\fs18 cam u \line erece \line\i\fs20 Erro comum de programa \'e7ao 5.23 \line N\'e3o perceber que \i0\fs18 strtok \i modifica o \i0 string \i\fs20 que ser\'e1 separado em unidades l\'e9xicas e, ent\'e3o, tentar usar \line esse \i0\fs18 string \i como se ele fosse o \i0 string \i original inalterado. \line\i0 A fun\'e7\'e3o strlen aceita um \i string \i0 como argumento e retorna o n\'famero de caracteres no \i string \i0\f2\fs8 - \f0\fs18 o caractere nulo \line terminal n\'e3o \'e9 inclu\'eddo no comprimento. O programa da Fig. 5.34 demonstra a fun\'e7\'e3o strlen. A mci no fim \line nos m \line\b\fs14 1 \b0\i\fs20 II \b\i0\f3\fs16 Fig. \b0\f0\fs18 5.34: fig0534.cpp Remo \line\b\fs14 2 \b0\i\fs20 II \b\i0\f3\fs16 Usando strlen \b0\f0\fs18 emno \line\b\fs14 3 \f3\fs16 #include <iostrearn> \b0\f2\fs18 classe \b\f3\fs16 hora\rdblquote  \line\b0\f2\fs18 Fig. 5.34 Usando \b\f3\fs16 strlen \b0\f2\fs18 (parte 1 de 2). \f0\fs24\par
\b\fs16 CAP\'cdTULO \b0\f2\fs20 5 \fs8 - \b\fs14 PONTEIROS E \i STRINGS \i0\fs20 363 \line\f0\fs16 4 \line\f3\fs14 5 using std::cout; \line 6 using std: :endl; \line 7 \line 8 #include <cstring> \line 9 \line 10 int main \b0\f0\fs20 O \line\b\f3\fs14 11 \line 12 char *stringl \b0\f2\fs10 = \b\f3\fs14\ldblquote abcdefghijklmnopqrstuvwxyz\rdblquote ; \line 13 char *string2 \ldblquote cinco; \line 14 char *string3 \b0\f2\fs10 = \b\f3\fs14\lquote Porto Alegre\rdblquote ; \line 15 \line 16 cout \'ab \ldblquote O comprimento de \b0\f2\fs10\\\lquote\ldblquote  \b\f0\fs16\'ab stringl \line\f3\fs14 17 \'ab \b0\f0\fs20\ldblquote V\rquote  \b\f3\fs14\'e9 \b0\f2\fs8\ldblquote  \b\f3\fs14\'ab strlen( stringl \line 18 \f0\fs16\'ab \b0\fs20\ldblquote\\nO comprimento de \b\fs16\\\ldblquote  \'ab string2 \line\f3\fs14 g 19 \'ab \b0\f2\fs10\ldblquote\\\ldblquote  \b\f3\fs14\'e9 \b0\f2\fs8\ldblquote  \b\f0\fs16\'ab strlen( string2 \line\f3\fs14 20 \f0\fs16\'ab \f3\fs14\ldblquote\\nO comprimento de \b0\f2\fs10\\\ldblquote  \b\f0\fs16\'ab string3 \line\f3\fs14 21 \'ab \b0\f2\fs10\ldblquote\\\ldblquote  \b\f3\fs14\'e9 \b0\f2\fs8\ldblquote  \b\f3\fs14\'ab strlen( string3 \f2\fs20 ) \f0\fs16\'ab endi; \line 22 \line\f3\fs14 23 return 0; \line\f0\fs16 24 \b0\fs24\par
\f2\fs20 Fig. 5.34 Usando \b\f0\fs16 strlen \b0\f2\fs20 (parte 2 de 2). \line\b\fs26 5.13 (Estudo de caso opcional) Pensando em objetos: \line colabora\'e7\'f5es entre objetos \line\b0\fs20 Esta \f0\'e9 a \'faltima tarefa do nosso projeto orientado a objetos antes de come\'e7armos nosso estudo da programa\'e7\'e3o orientada a objetos em C++ no Cap\'edtulo \b\f2 6. \b0\f0 Depois de discutirmos as colabora\'e7\'f5es entre objetos nesta se\'e7\'e3o e t\'e9cnicas de OOP no Cap\'edtulo 6, voc\'ea estar\'e1 preparado para come\'e7ar a codificar o simulador de elevador em C\'f7+. Para completar o simulador de elevador, voc\'ea tamb\'e9m precisar\'e1 das t\'e9cnicas de C++ discutidas nos Cap\'edtulos 7 e \b\f2 9. \b0\f0 Inclu\'edmos no fim dessa se\'e7\'e3o uma lista de recursos para UML existentes na lnternet e na World Wide Web e uma bibliografia de refer\'eancia para UML. \line Nesta se\'e7\'e3o, concentramo-nos nas colabora\'e7\'f5es (intera\'e7\'f5es) entre objetos. Quando dois objetos se comunicam um com o outro para executar determinada tarefa, diz-se que eles \i\fs18 colaboram \i0\f2\fs8 - \f0\fs20 os objetos fazem isso enviando e recebendo mensagens. Uma \i\fs18 colabora\'e7\'e3o \i0\fs20 consiste em: \line\i\fs18 usar \i0\fs20 1. um objeto de uma classe \line 2. envia uma mensagem particular \line 3. para um objeto de uma outra classe \line nulo \line A mensagem enviada pela primeira classe invoca uma opera\'e7\'e3o da segunda classe. Na se\'e7\'e3o \ldblquote Pensando em objetos\rdblquote  no fim do Cap\'edtulo \i\fs18 4, \i0\fs20 determinamos muitas das opera\'e7\'f5es das classes em nosso sistema. Nesta se\'e7\'e3o, concentramonos nas mensagens que invocam estas opera\'e7\'f5es. A Fig. 5.35 \'e9 a tabela de classes e frases com verbos da Se\'e7\'e3o 4.10. Removemos todas as frases com verbos que n\'e3o correspondem a opera\'e7\'f5es. As frases restantes s\'e3o as colabora\'e7\'f5es \b\fs16 em \b0\fs20 nosso sistema. Associamos as frases \ldblquote fornece a hora para o \i\fs18 scheduler\rdblquote  \i0\fs20 e \ldblquote fornece a hora para o elevador\rdblquote  com a classe Building porque decidimos que o edif\'edcio ir\'e1 controlar a simula\'e7\'e3o. Associamos as frases \ldblquote incrementa a hora\rdblquote  e \ldblquote obt\'e9m a hora\rdblquote  com a classe Building pela mesma raz\'e3o. \fs24\par
\pard\par
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx205\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1478\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1887\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx5272\pard\intbl\b\f3\fs16 O \b0\f0\fs24\cell\b\f3\fs16 comprimento \b0\f0\fs24\cell\b\f3\fs16 de \b0\f0\fs24\cell\b\f3\fs16\ldblquote abcdefghijklmnopqrstuvwxyz\rdblquote  \'e9 26 \b0\f0\fs24\cell\fs20\row
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx205\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1478\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1887\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx3855\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4750\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx5272\pard\intbl\b\f3\fs16 O \b0\f0\fs24\cell\b\f3\fs16 comprimento \b0\f0\fs24\cell\b\f3\fs16 de \b0\f0\fs24\cell\b\f3\fs16\ldblquote cinco\rdblquote  \b0\f0\fs24\cell\b\f3\fs16\'e9 5 \b0\f0\fs24\cell\cell\fs20\row
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx205\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1478\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1887\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx3855\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx5272\pard\intbl\b\f3\fs16 O \b0\f0\fs24\cell\b\f3\fs16 comprimento \b0\f0\fs24\cell\b\f3\fs16 de \b0\f0\fs24\cell\b\f3\fs16\ldblquote Porto \b0\f0\fs24\cell\b\f3\fs16 Alegre\rdblquote  \'e9 12 \b0\f0\fs24\cell\fs20\row
\pard\fs24\par
\pard\sb100\sa240\b\f2\fs22 364 C++ \fs16 COMO PROGRAMAR \b0\f0\fs24\par
\f2\fs20 Fig. 5.35 Lista modificada de frases com verbos para as classes no sistema. \f0\fs24\par
\fs20 Examinamos a lista de verbos para determinar as colabora\'e7\'f5es em nosso sistema. Por exemplo, a classe Elevator lista a frase \ldblquote desliga o bot\'e3o do elevador\rdblquote . Para cumprir essa tarefa, um objeto da classe Elevator precisa enviar a mensagem resetButton para um objeto da classe ElevatorButton, invocando a opera\'e7\'e3o resetButton daquela classe. A Fig. 5.36 lista todas as colabora\'e7\'f5es que podem ser percebidas a partir da nossa tabela de frases. \fs24\par
\b\fs20 Um objeto \f3\fs18 Floor \line FloorBul \line E1evato \b0\f0\fs24\par
\fs20 Door \line\b Beil \b0\fs24\par
\b\f3\fs18 Light \b0\f0\fs24\par
\b\f3\fs18 Bui1din \b0\f0\fs24\par
\b\f2\fs18 Fig. 5.36 \line\i\f0\fs22 Diagrama \line\b0\i0\fs18 Consideren do elevadoi \'e7\'e3o. Tanto objetos inte as intera\'e7\'f5t \line A Fi que objetos andar. Con ret\'e2ngulo q \fs24\par
\f2\fs20 Fig. 5.36 Colabora\'e7\'f5es no sistema do elevador (parte 1 de 2). \f0\fs24\par
\b\f2\fs18 Fig. 5.37 \b0\f0\fs24\par
\pard\par
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1330\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx8946\pard\intbl\b\fs20 Classe \b0\fs24\cell\b\fs20 Frases com verbos \b0\fs24\cell\fs20\row
\b\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1330\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx8946\intbl Elevator \b0\fs24\cell\fs20 desliga o bot\'e3o do elevador, soa a campainha do elevador, sinaliza sua chegada a um andar, abre a porta, fecha a porta \fs24\cell\fs20\row
\b\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1330\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx8946\intbl Clock \b0\fs24\cell\b\fs20 bate \b0 a cada segundo \fs24\cell\fs20\row
\intbl Scheduler \fs24\cell\fs20 diz a uma pessoa para entrar em um andar, verifica se um andar est\'e1 desocupado \fs24\cell\fs20\row
\b\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1330\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx8946\intbl Person \b0\fs24\cell\fs18 aperta o bot\'e3o do andar, aperta o bot\'e3o do elevador, entra no elevador, sai do elevador \fs24\cell\fs20\row
\intbl F].oor \fs24\cell\fs20 desliga o bot\'e3o do andar, apaga a luz, acende a luz \fs24\cell\fs20\row
\intbl FloorButton \fs24\cell\fs20 chama o elevador \fs24\cell\fs20\row
\intbl ElevatorButton \fs24\cell\fs20 avisa o elevador para se preparar para sair \fs24\cell\fs20\row
\intbl Door \fs24\cell\fs20 (abertura da porta) avisa a pessoa para sair do elevador, (abertura da porta) avisa a pessoa para entrar no elevador \fs24\cell\fs20\row
\intbl Beil \fs24\cell\cell\fs20\row
\intbl Light \fs24\cell\cell\fs20\row
\intbl Building \fs24\cell\fs20 incrementa a hora, obt\'e9m a hora, fornece a hora para o \i scheduler, \i0 fornece a hora para o elevador \fs24\cell\fs20\row
\pard\sa240\fs24\par
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1521\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx6846\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx8946\pard\intbl\b\fs20 Um objeto da classe \b0\fs24\cell\b\fs20 Envia a mensagem \b0\fs24\cell\b\fs20 Para um objeto da classe \b0\fs24\cell\fs20\row
\b\f3\fs18\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1521\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx6846\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx8946\intbl Elevator \b0\f0\fs24\cell\b\f3\fs18 resetButton ringBell elevatorArrived openDoor closeDoor \b0\f0\fs24\cell\b\f3\fs18 ElevatorButton  Beli  Floor  Door  Door \b0\f0\fs24\cell\fs20\row
\b\f3\fs18\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1521\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx6846\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx8946\intbl Clock \b0\f0\fs24\cell\cell\cell\fs20\row
\b\f3\fs18\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1521\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx6846\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx8946\intbl Scheduler \b0\f0\fs24\cell\b\f3\fs18 stepOntoFloor  isOccupied \b0\f0\fs24\cell\b\f3\fs18 Person Floor \b0\f0\fs24\cell\fs20\row
\b\f3\fs18\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1521\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx6846\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx8946\intbl Person \b0\f0\fs24\cell\b\f3\fs18 pressButton pressButton passengerEnters passengerExits personArrives \b0\f0\fs24\cell\b\f3\fs18 FloorButton  ElevatorButton  Elevator  Elevator  FJ.oor \b0\f0\fs24\cell\fs20\row
\pard\fs24\par
\pard\sb100\sa240\b\fs14 CAP\'cdTULO \b0\i\fs18 5 \i0\f2\fs8 - \b\f0\fs14 PONTEIROS E \b0\i\f2\fs16 STRINGS \i0\f0\fs24\par
\b\i\fs20 365 \b0\i0\fs24\par
\f2\fs18 Fig. \b 5.36 \b0 Colabora\'e7\'f5es no sistema do elevador (parte 2 de 2). \f0\fs24\par
\b\i\fs20 Diagramas de colabora \'e7\'f5es \line\b0\i0\fs18 Consideremos, agora, os objetos que precisam interagir para que as pessoas em nossa simula\'e7\'e3o possam entrar e sair do elevador quando ele chega em um andar. A UML oferece o \i diagrama de colabo ra\'e7\'f5es \i0 para modelar esta intera\'e7\'e3o. Tanto os diagramas de colabora\'e7\'f5es quanto os diagramas de seq\'fc\'eancia fornecem informa\'e7\'e3o sobre como os objetos interagem, mas cada diagrama tem uma \'eanfase diferente. Diagramas de seq\'fc\'eancia se concentram em \i quando \i0 as intera\'e7\'f5es ocorrem. Diagramas de colabora\'e7\'f5es se concentram em \i quais objetos participam \i0 da intera\'e7\'e3o. \line A Fig. 5.37 mostra um diagrama de colabora\'e7\'f5es que modela as intera\'e7\'f5es entre objetos no sistema \'e0 medida que objetos da classe person entram e saem do elevador. A colabora\'e7\'e3o come\'e7a quando o elevador chega em um andar. Como em um diagrama de seq\'fc\'eancia, um objeto em um diagrama de colabora\'e7\'f5es \'e9 representado por um \f3 ret\'e2ngulo que cont\'e9m o nome do objeto. \f0\fs24\par
\f2\fs20 3 : elevatorArrived() \line 4.1.1: passengerExits() \f0\fs24\par
\f2\fs20 Fig. 5.37 Diagrama de colabora\'e7\'f5es para entrada e sa\'edda de passageiros. \f0\fs24\par
\pard\par
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1563\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx3184\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx5180\pard\intbl\fs18 Um objeto da classe \fs24\cell\fs18 Envia a mensagem \fs24\cell\fs18 Para um objeto da classe \fs24\cell\fs20\row
\fs18\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1563\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx3184\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx5180\intbl Floor \fs24\cell\fs18 resetButton  turnOff  turnOn \fs24\cell\fs18 FloorButton  Light  Light \fs24\cell\fs20\row
\fs18\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1563\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx3184\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx5180\intbl FloorButton \fs24\cell\fs18 summonElevator \fs24\cell\fs18 Elevator \fs24\cell\fs20\row
\fs18\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1563\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx3184\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx5180\intbl ElevatorButton \fs24\cell\fs18 prepareToLeave \fs24\cell\fs18 Elevator \fs24\cell\fs20\row
\f3\fs18\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1563\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx3184\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx5180\intbl Door \f0\fs24\cell\f3\fs18 exitElevator  enterElevator \f0\fs24\cell\f3\fs18 Person  Person \f0\fs24\cell\fs20\row
\f3\fs18\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1563\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx3184\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx5180\intbl Bel]. \f0\fs24\cell\cell\cell\fs20\row
\f3\fs18\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1563\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx3184\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx5180\intbl Light \f0\fs24\cell\cell\cell\fs20\row
\f3\fs18\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1563\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx3184\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx5180\intbl Building \f0\fs24\cell\f3\fs18 tick  getTime  processTime  processTime \f0\fs24\cell\f3\fs18 Clock  Clock  Scheduler  Elevator \f0\fs24\cell\fs20\row
\pard\fs24\par
\pard\sb100\sa240\b\f2\fs18 366 \b0\fs28 c++ \b\fs14 COMO PROGRAMAR \line\b0\fs18 Objetos que \f0 colaboram entre si s\'e3o conectados por linhas cheias e mensagens s\'e3o passadas entre os objetos, \line ao longo destas linhas, na dire\'e7\'e3o mostrada pelas setas. O nome da mensagem aparece pr\'f3ximo \'e0 seta. \line A \i\fs20 seq\'fc\'eancia de mensagens \i0\fs18 em um diagrama de colabora\'e7\'f5es progride, em ordem num\'e9rica. do menor para o \line maior. Neste diagrama, a numera\'e7\'e3o come\'e7a com a mensagem 1 \f2\fs8 . \f0\fs18 O elevador envia esta mensagem (resetButton) \line para o bot\'e3o do elevador para desligar o bot\'e3o. O elevador, ent\'e3o, envia a mensagem ringBell (mensagem 2) para \line a campainha. Ent\'e3o, o elevador avisa o andar de sua chegada (mensagem 3), de modo que o andar possa desligar o \line bot\'e3o e acender a luz (mensagens 3.1 e 3.2, respectivamente). \line Depois que o andar desligou o bot\'e3o e acendeu a luz, o elevador abre a porta (mensagem 4). Neste ponto, a \b\i\f2\fs22 R \b0\i0\f0\fs18 porta envia a mensagem exitElevator (mensagem 4.1) para o objeto passenger.\rquote  O objeto passenger A avisa o elevador de sua inten\'e7\'e3o de sair atrav\'e9s da mensagem passengerExits (mensagem 4.1.1). es \line Depois que a pessoa que estava no elevador saiu, a pessoa que est\'e1 esperando no andar (o objeto pu waitingPassenger) pode entrar no elevador. Observe que a porta envia a mensagem enterElevator (mensagem \line 4.2) para o objeto waitingPassenger depois que o objeto passenger envia a mensagem passengerExits \line para o elevador (mensagem 4. 1 \f2\fs8 . \f0\fs18 1 \b\f2 ). \b0\f0 Esta seq\'fc\'eancia assegura que uma pessoa que est\'e1 no andar ir\'e1 esperar at\'e9 que a \line pessoa que est\'e1 no elevador saia antes de entrar no elevador. O objeto waitingPassenger entra no elevador \line atrav\'e9s da mensagem pas sengerEnters (mensagem 4.2.1). \line\i\fs20 Resumo \line\i0\fs18 Agora, temos uma listagem razoavelmente completa das classes de que precisaremos para implementar nosso \line simulador de elevador, bem como das intera\'e7\'f5es entre os objetos destas classes. No pr\'f3ximo cap\'edtulo, come\'e7amos \line nosso estudo de programa\'e7\'e3o orientada a objetos em C++. Depois de ler o Cap\'edtulo 6, estaremos prontos \line para escrever uma por\'e7\'e3o substancial do simulador do elevador em C++. Depois de completar o Cap\'edtulo 7, \line implementaremos um simulador de elevador completo que funciona. No Cap\'edtulo 9, discutimos como usar heran\'e7a \line para explorar o que h\'e1 de comum entre as classes, a fim de minimizar a quantidade de software necess\'e1ria para \line implementar um sistema. \line Vamos resumir o processo de projeto orientado a objetos que usamos nos Cap\'edtulos 2 a 5. \line O. Na fase de an\'e1lise, re\'fana-se com os clientes (as pessoas que querem que voc\'ea construa seu sistema) e \line obtenha tantas informa\'e7\'f5es sobre o sistema quanto poss\'edvel. Com essas informa\'e7\'f5es, crie os casos de uso \line que descrevem as maneiras pelas quais os usu\'e1rios interagem com o sistema (em nosso estudo de caso, n\'e3o \line nos concentramos na fase de an\'e1lise; os resultados desta fase est\'e3o representados na defini\'e7\'e3o do problema \line e o caso de uso derivado desta defini\'e7\'e3o). Lembramos novamente que sistemas do mundo real freq\'fcente- \line mente t\'eam muitos casos de uso. \line 1. Comece a localizar as classes no sistema listando os substantivos na defini\'e7\'e3o do problema. Filtre essa lista \line eliminando substantivos que claramente representam atributos de classes e outros substantivos que clara- \line mente n\'e3o fazem parte do sistema de software que est\'e1 sendo modelado. Crie um diagrama de classes que \line modele as classes no sistema e seus relacionamentos (associa\'e7\'f5es). \line 2. Extraia os atributos de cada classe da defini\'e7\'e3o do problema, listando palavras e frases que descrevem cada \line classe no sistema. \line 3. Aprenda mais sobre a natureza din\'e2mica do sistema. Crie um diagrama de mapa de estados para descobrir \line como as classes no sistema mudam ao longo do tempo. \line 4. Examine verbos e frases com verbos associados a cada classe. Use estas frases para extrair as opera\'e7\'f5es das \line classes em nosso sistema. Diagramas de atividades podem ajudar a modelar detalhes destas opera\'e7\'f5es. \line w1 \line No mundo real, uma pessoa andando no elevador ir\'e1 esperar at\'e9 que a porta abra para sair do elevador. Precisamos modelar este comportamen- \f2\fs12 W1 \f0\fs18 to; portanto, fazemos a porta enviar uma mensagem para o objeto passenger no elevador. Esta mensagem representa uma indica\'e7\'e3o visual \line para a pessoa no elevador. Quando a pessoa recebe esta indica\'e7\'e3o, ela pode sair do elevador. \fs24\par
\f2\fs16 CAPITULO 5 \fs8 - \fs16 PONTEIROS E \i\f0 STRINGS \i0\f2\fs24 367 \f0\par
\fs18 5. Examine as colabora\'e7\'f5es entre v\'e1rios objetos. Use diagramas de seq\'fc\'eancia e de colabora\'e7\'f5es para modelar essas intera\'e7\'f5es. Adicione atributos e opera\'e7\'f5es \'e0s classes \'e0 medida que o processo de projeto revelar a necessidade delas. \line 6. Nesse ponto, nosso projeto provavelmente ainda tem poucas pe\'e7as faltando. Estas se tornar\'e3o vis\'edveis \'e0 medida que implementarmos nosso simulador de elevador em C++, a partir do Cap\'edtulo 6. \line\b\i\fs22 Recursos de UML na Internet e na World Wide Web \line\b0\i0\f3\fs18 A seguir h\'e1 uma rela\'e7\'e3o de recursos para a UML na Internet e na World Wide Web. Tais recursos incluem as \f0 especifica\'e7\'f5es \f3 da UML 1.3 e outros \f0 materiais de refer\'eancia, recursos gen\'e9ricos, tutoriais, FAQs, artigos, trabalhos \f3 publicados e software. \line\b\i\f0\fs22 Refer\'eancias \line\b0\i0\f2\fs16 www. \f3\fs18 omg org \line Omg.org \f0\'e9 o site principal do Object Management Group (OMG). O OMG \'e9 o grupo respons\'e1vel por supervisionar \f3 a manuten\'e7\'e3o e as revis\'f5es futuras da UML. \f0 O \f3 site deles na Web cont\'e9m informa\'e7\'f5es sobre a UML e outras \f0 tecnologias de orienta\'e7\'e3o a objetos. \line\f2\fs16 www. \f3\fs18 rational com \line\f0 A Rational Software Corporation foi quem desenvolveu inicialmente a UML. Tal site na Web cont\'e9m informa\'e7\'e3o sobre a UML e seus criadores \f2\fs8 - \f0\fs18 Grady Booch, James Rumbaugh e Ivar Jacobson. \line\f3 www \f2\fs8 . \f3\fs18 omg org/cgi-bin/doc?ad/99-06-09 \line\f0 Esse endere\'e7o cont\'e9m vers\'f5es das especifica\'e7\'f5es oficiais da UML 1.3 nos formatos PDF e ZTP. \line\f3 www.omg.org/techprocess/meetings/schedule/UMLl.4RTF.htm1 \line A OMG mant\'e9m nesse site informa\'e7\'f5es \f0 a respeito das especifica\'e7\'f5es da UML 1.4. \line\f3 www. rational \f2\fs8 . \f3\fs18 com/uml/resources/quick/index. \f2\fs24 j \fs18 tmpl \line\f3 O manual de refer\'eancia r\'e1pida para UML da Rational Software Corporation. \line www \f2\fs8 . \f3\fs18 holub. com/class/oo design/uml html \line Esse sue oferece uma ficha de refer\'eancia r\'e1pida para UML detalhada, com comentarios adicionais. \line softdocwiz com/UML \f2\fs8 . \f0\fs18 htm \line\f3 Kendall Scott. autor de diversos recursos para UML, mant\'e9m um dicion\'e1rio de UML nesse site. \line\b\i\f0\fs22 Recursos \line\b0\i0\f2\fs16 www. \f3\fs18 omg. org/uml/ \line\f0 A p\'e1gina de recursos \f3 para UML da OMG. \line www. rational \f2\fs8 . \f3\fs18 com/uml/index. jtmp]. \line A p\'e1gina de \f0 recursos para UML da Rational Software Corporation. \line\f3 www.p1atinum.com/corp/um1/um1.htxn \line\f0 A Platinum Technology, s\'f3cia da UML Partners, mant\'e9m uma \f3 p\'e1gina de recursos para UML nesse endere\'e7o. \line\f0 www. cetus-].ink \f2\fs8 . \f0\fs18 org/oo um].. htm]. \line Este site cont\'e9m centenas de links para sites sobre UML, incluindo informa\'e7\'f5es, tutoriais e software. \line www. um].-zone \f2\fs8 . \f3\fs18 com \line Este \f0 site cont\'e9m uma enorme quantidade de informa\'e7\'f5es \f3 sobre UML, incluindo artigos e links para grupos de not\'edcias e para outros sites. \f0\fs24\par
\b\f2\fs22 368 \b0\f0\fs20 C++ \f2\fs18 CoMo \b\f0\fs14 PROGRAMAR \b0\fs24\par
\fs18 home .pacbeil net/ckobryn/umi htini \line Este site \'e9 mantido por \f2\fs20 Cris \f0\fs18 Kobryn, arquiteto de software com experi\'eancia em UML. Cont\'e9m informa\'e7\'f5es gerais e links para sites importantes na Web. \line www \f2\fs8 . \f0\fs18 methods-toois com/cgi-bin/DiscussionUML. cgi \line Esse site cont\'e9m a p\'e1gina inicial para um grupo de discuss\'e3o sobre UML. \line www \f2\fs8 . \f0\fs18 pois co. uk/usecasezone/index htm \line Esse site oferece recursos e artigos sobre aplica\'e7\'f5es de casos de uso. \line www. ics uci edu/pub/arch/uini/umi books and toois htmi \line Esse site cont\'e9m links para informa\'e7\'f5es sobre outros livros sobre a UML, bem como uma lista de ferramentas que suportam a nota\'e7\'e3o da UML. \line home earthiink net/-saihir/ \line Sinan Si Alhir, autor de \b\i\fs20 UML \b0\fs18 in a Nutshell, \i0 mant\'e9m um site nesse endere\'e7o que inclui links para muitos recursos para UML. \line\b\i\f2\fs22 Software \line\b0\i0\fs18 www. \f0 rationai com/products/rose/index. tmpl \line Este site \'e9 a homepage para a ferramenta de modelagem visual para UML, Rational RoseTM, da Rational Software Corporation. Voc\'ea pode baixar uma vers\'e3o de teste deste endere\'e7o e us\'e1-la sem custo por um per\'edodo de tempo limitado. \line www. rosearchitect. comi \line\i Rosearchitect.com \i0\'e9 uma revista on-line, publicada pela Rational Software Corporation, que trata da modelagem em UML usando Rational Rose. \line www \f2\fs8 . \f0\fs18 advancedsw. comi \line A Advanced Software Technologies \'e9 autora do GDPro, uma ferramenta de modelagem visual para UML. Voc\'ea pode baixar uma vers\'e3o de teste do site da Web deles e us\'e1-la sem custo por um per\'edodo de tempo limitado. \line www visualobject. comi \line A Visual Object Modelers criou uma ferramenta de modelagem visual para UML. Voc\'ea pode baixar uma vers\'e3o limitada de demonstra\'e7\'e3o do site da Web deles e us\'e1-la sem custo por um per\'edodo de tempo limitado. \line www .microgoid. comibversion2istage/product htmi \line A Microgold Software, lnc. criou WithClass, um aplicativo para projeto de software que suporta a nota\'e7\'e3o da UML. \line www. iysator. iiu. sei-ai].aidiaidia htini \line Dia \'e9 uma ferramenta de diagrama\'e7\'e3o gtk+ que pode desenhar diagramas de classes UML. Dia roda sob UNIX, mas o site da Web tamb\'e9m inclui um link para uma vers\'e3o para Windows. \line dir. iycos comiComputersiSoftwareiObjectOrientediMethodoiogiesiUiTooisi Este site lista dezenas de ferramentas de modelagem para UML e suas homepages. \line www methods-toois comitoois,/modeiing htmi \line Este site cont\'e9m uma lista de muitas ferramentas de modelagem de objetos, incluindo aquelas que suportam a UML. \line\b\i\fs20 Artigos e publica \'e7\'f5es \line\b0\i0\f2\fs18 www. \f0 omg. orginewsipr99iUML 2001 CACMOct99y29-Kobryn pdf \line Este artigo, escrito por Cris Kobryn, explora o passado, o presente e o futuro da UML. \fs24\par
\b\fs14 CAP\'cdTULO \b0\fs18 5 \f2\fs8 - \b\f0\fs14 PONTEIROS E \i\f2 STRINGS \i0\fs22 369 \line\b0\f0\fs18 www. sdmagazine \f2\fs8 . \f0\fs18 com/umi/focus \f2\fs8 . \f0\fs18 rosenberg. \f2 htm \line\f0 se Aqui voc\'ea encontrar\'e1 um artigo com dicas sobre como incorporar a UML a seus projetos. \line www. db. informatik \f2\fs8 . \f0\fs18 uni-bremen. de/urnlbib/ \line A Bibliografia de UML oferece nomes e autores de muitos artigos relacionados \'e0 UML. Voc\'ea pode pesquisar artigos por autor ou t\'edtulo. \line usecasehelp. com/wp/white_papers \f2\fs8 . \fs18 htm \line\f0 Este site mant\'e9m uma lista de publica\'e7\'f5es sobre aplica\'e7\'f5es da modelagem de casos de uso \'e0 an\'e1lise e projeto de sistemas. \line ue www.ratio.co.uk/white. html \line Voc\'ea pode ler uma publica\'e7\'e3o que descreve um processo para OOAD usando a UML neste site. O artigo tamb\'e9m \line inclui alguma implementa\'e7\'e3o em C++. \line www. tucs. fiipublicationsitechreportsiTR234 .pdf \line Este arquivo cont\'e9m um estudo de caso de OOAD para um gravador de som digital usando a UML. \line www. conailen. com/whitepapers/webapps/ModelingWebApplications \f2\fs8 . \fs18 htm \line\f0 Este site cont\'e9m um estudo de caso que modela aplica\'e7\'f5es para a Web usando a UML. \line are www. sdmagazine \f2\fs8 . \f0\fs18 com/ \line p0 O site da Software Development Magazine Online tem um reposit\'f3rio de muitos artigos sobre a UML. Voc\'ea pode procurar por assunto ou navegar pelos t\'edtulos dos artigos. \line\b\i\fs22 Tutoriais \line\b0\i0\fs18 www. qoses \f2\fs8 . \f0\fs18 com/education/ \line Este site cont\'e9m um banco de tutoriais criados pelo autor da UML Kendall Scott e mantidos por Qoses. \line\f3 www. qoses \f2\fs8 . \f0\fs18 com/education/tests/testO2 \f2\fs8 . \f0\fs18 html \line\f3 Voc\'ea pode fazer um teste on-line sobre UML neste \f0 endere\'e7o. Os resultados lhe s\'e3o enviados por e-mail. \line\f3 www. rational \f2\fs8 . \f3\fs18 comiproductsiroseitryititutorialiindex. \f1\fs24 j \f2\fs18 trnpl \line\f3\'e3o A Rational \f0 Software Corporation oferece um arquivo com um tutorial para o Rational Rose neste site. \line\b\i\fs22 FAQs (Perguntas mais freq\'fcentes) \line\b0\i0\f3\fs18 www. rational \f2\fs8 . \f3\fs18 com/uml/gstart/\rquote faq. jtmpl \line Este \'e9 o endere\'e7o de \f0 FAQs sobre UML da Rational Software Corporation. \line\f3 usecasehelp. com/faqifaq.htm \line as Este \f0 site cont\'e9m um pequeno arquivo de FAQs mantido por \i\fs20 usecasehelp.com. \line\i0\f3\fs18 www. jguru. comi jguruifaqi \line Digite UML na \f0 caixa de procura para acessar uma lista de FAQs sobre UML deste site. \line\f3 www.uml-zone \f2\fs8 . \f3\fs18 comiumlfaq. asp \line\f0 Este site cont\'e9m uma pequena lista de FAQs sobre UML mantida por \i\fs20 uml-zone.com. \line\b\fs22 Bibliografia \line\b0\i0\f3\fs18 (A198) Alhir, \i\f0\fs20 S. UML in a Nutshell. \i0\fs18 Cambridge: O\rquote Reily & Associates, \fs24 mc. \fs18 1998. \line (Bo99) Booch, G., Rumbaugh, J. e Jacobson, \f3 1. \i\f0\fs20 The Unified Modeling Language User Guide. \i0\f3\fs18 Reading, MA: \line\f0 Addison-Wesley, 1999. \fs24\par
\fs16 370 \f2\fs26 c++ \b\fs14 COMO PROGRAMAR \line\b0\f0\fs16 (Fi98) Firesmith, D. G. e B. Henderson-Sellers. \ldblquote Clarifying Specialized Forms ofAssociation in UML and OML\rquote . \f2\fs10\bullet  \fs26 o \f0\fs16 quali \line\i\fs18 Journal ofObject-oriented Programming, \i0\fs16 May 1998: 47-50. ser mod \line (Fo97) FowlerM. e Scott, K. \i\fs18 UML Distilled. Applying the Standard Object Modeling Language. \i0\fs16 Reading, MA: \f2\fs10\bullet  \f0\fs16 Se for f \line Addison-Wesley, 1997. mensag \line (JoOO) Johnson, L.J. \ldblquote Model Behavior\rdblquote . \i\fs18 Enterprise Development \i0\fs16 May 2000: 20-28. \f2\fs10\bullet  \f0\fs16 Existem \line ponteirc \line (Mc98) McLaughlin, M. e A. Moore. \ldblquote Real-Time Extensions to the UML\rdblquote . \i\fs18 Dr Dobb\rquote s Journal \i0\fs16 December 1998: dados a \line 82-93. \line\bullet  Arrays \line (Me98) Melewski, D. \ldblquote UML Gains Ground\rdblquote . \i\fs18 Application Development Trends \i0\fs16 October 1998: 34-44. primem \line (Me97) Melewski, D. \ldblquote UML: Ready for Prime \i\fs18 Time?\rdblquote Application Development Trends \i0\fs16 November 1997: 30-44. Para pa \line\'e7o do ei \line (Me99) Melewski, D. \ldblquote Wherefore and what 110w, \i\fs18 UML?\rdblquote  Application Development Trends \i0\fs16 December 1999: 61- \line 68. \f2\fs10\bullet  \f0\fs16 C++ foi \line dados), \line (Mu97) Muiler, \i\fs18 P. Instant UML. \i0\fs16 Birmingham, UK: Wrox Press Ltd., 1997. \line\bullet  Quandc \line (Pe99) Perry, P. \ldblquote UML Steps to the Plate\rdblquote . \i\fs18 Application Development Trends \i0\fs16 May 1999: 33-36. \f2\fs10\bullet  \fs26 o \f0\fs16 opere \line (Ru99) Rumbaugh, J., Jacobson, 1. e Booch, \i\fs18 G. The Unified Modeling Language Reference Manual. \i0\fs16 Reading, \f2\fs10\bullet  \f0\fs16 As opei \line MA: Addison-Wesley, 1999. pontein \line outro. \line (Sc99) Schmuller, J. \i\fs18 Sam\rquote s Teach Yourself UML in 24 Ilours. \i0\fs16 Indianapolis: Macmillan Computer Pubhshing, \line 1999. \f2\fs10\bullet  \f0\fs16 Quand \line\f2\fs8 - . . . . . . \f0\fs16 objeto \line (UML99) \i\fs18 The UnifiedModeling Language Specification: Version 1.3. \i0\fs16 Framingham, MA: Object Management Group \line (OMG), 1999. \f2\fs10\bullet  \f0\fs16 Opera\'e7 \line Todos \line\bullet  Ao exe \line\b\i\f2\fs26 Resumo \b0\i0\f0\fs16 cada ca \line\bullet  Ponteiros s\'e3o vari\'e1veis que cont\'eam como seus valores os endere\'e7os de outras vari\'e1veis. \f2\fs10\bullet  \f0\fs16 Ponteir \line opera\'e7 \line\bullet  A declara\'e7\'e3o ponteir \line int *ptr; atribu\'edi \line declara ptr como um ponteiro para um objeto de tipo int e \'e9 lida, \ldblquote ptr \'e9 um ponteiro para int\rdblquote . O \f2\fs10 *, \f0\fs16 como usado aqui em \f2\fs10\bullet  \f0\fs16 Um po: \line uma declara\'e7\'e3o, indica que a vari\'e1vel \i\fs18\'e9 \i0\fs16 um ponteiro. \f2\fs10\bullet  \f0\fs16 Ponteir \line\bullet  Existem tr\'eas valores que podem ser usados para inicializar um ponteiro: O. NULL ou um endere\'e7o de um objeto do mesmo mente \line tipo. Inicializar um ponteiro com O e inicializar esse mesmo ponteiro com NULL s\'e3o id\'eanticos. \f2\fs10\bullet  \f0\fs16 Ponteir \line\bullet  O \'fanico inteiro que pode ser atribu\'eddo a um ponteiro sem coer\'e7\'e3o \'e9 zero. \f2\fs10\bullet  \f0\fs16 Um no \line\bullet  O operador & (endere\'e7o) retoma o endere\'e7o de seu operando. Na not: \line\bullet  O operando do operador de endere\'e7o deve ser um nome de vari\'e1vel (ou outro ivalue); o operador de endere\'e7o n\'e3o pode ser \f2\fs10\bullet  \f0\fs16 Todas \line aplicado a constantes, a express\'f5es que n\'e3o retomam um ivalue ou a vari\'e1veis declaradas com a classe de armazenamento do arra \line register. \line\bullet  Umno \line\bullet  O operador \f2\fs12 *, \f0\fs16 chamado de indire\'e7\'e3o, referenciamento indireto ou operador de derreferencia, retorna um sinonimo, nome \line alternativo ou apelido para o nome do objeto a que seu operando aponta na mem\'f3ria. Isto \'e9 chamado de \ldblquote derreferenciar o \f2\fs10\bullet  \f0\fs16 Arrays \line ponteiro\rdblquote . \line\bullet  Umpo \line\bullet  Ao chamar uma fun\'e7\'e3o com um argumento que a fun\'e7\'e3o que chamou quer modificar, o endere\'e7o do argumento pode ser \f2\fs10\bullet  \line\f0\fs16 passado. A fun\'e7\'e3o chamada ent\'e3o usa o operador de indire\'e7\'e3o (*) para modificar o valor do argumento na fun\'e7\'e3o que \line chamou. \line\bullet  Uma fun\'e7\'e3o que recebe um endere\'e7o como argumento deve incluir um ponteiro como seu argumento correspondente. \line\bullet  N\'e3o \'e9 necess\'e1rio incluir os nomes de ponteiros em prot\'f3tipos de fun\'e7\'e3o; s\'f3 \'e9 necess\'e1rio incluir os tipos dos ponteiros. Os \f2\fs10\bullet  \f0\fs16 A fun \line nomes de ponteiro podem ser inclu\'eddos por raz\'f5es de documenta\'e7\'e3o, mas o compilador os ignorar\'e1. prograi \line termin: \fs24\par
\b\fs14 CAP\'cdTULO \i\f2\fs12 5 \b0\i0\fs8 - \b\f0\fs14 PONTEIROS E \i STRINGS \i0\f2 371 \line\b0\f0\fs16\bullet  O qualificador const possibilita ao programador informar ao compilador que o valor de uma vari\'e1vel particular n\'e3o deve ser modificado. \line\bullet  Se for feita uma tentativa para modificar um valor const, o compilador a detecta e emite ou uma advert\'eancia ou uma mensagem de erro, dependendo do compilador particular usado. \line\bullet  Existem quatro meios para passar um ponteiro para uma fun\'e7\'e3o: um ponteiro n\'e3o-constante para dados n\'e3o-constantes, um ponteiro n\'e3o constante para dados constantes, um ponteiro constante para dados n\'e3o-constantes e um ponteiro constante para dados constantes. \line\bullet  Arrays s\'e3o automaticamente passados por refer\'eancia usando ponteiros porque o valor do nome do array \'e9 o endere\'e7o do primeiro elemento do array. \line\bullet  Para passar um \'fanico elemento de array atrav\'e9s de uma chamada por refer\'eancia usando ponteiros, deve ser passado o endere\'e7o do elemento espec\'edfico do array. \line\bullet  C++ fornece o operador un\'e1rio especial sizeof para determinar o tamanho de um array (ou de qualquer outro tipo de dados), em bytes, durante a compila\'e7\'e3o do programa. \line\bullet  Quando aplicado ao nome de um array, o operador sizeof retoma o n\'famero total de bytes no array como um valor inteiro. \line\bullet  O operador sizeof pode ser aplicado a qualquer nome de vari\'e1vel, tipo ou constante. \line\bullet  As opera\'e7\'f5es aritm\'e9ticas que podem ser executadas com ponteiros s\'e3o incrementar (++) um ponteiro, decrementar \b\f2\fs14 (- -) \b0\f0\fs16 um ponteiro, somar (+ ou \b\i\f2\fs12 +=) \b0\i0\f0\fs16 um ponteiro e um inteiro, subtrair \b\f2\fs14 (- \b0\f0\fs16 ou \f2\fs12 -=) \f0\fs16 um ponteiro e um inteiro e subtrair um ponteiro de outro. \line\bullet  Quando um inteiro \'e9 somado ou subtra\'eddo de um ponteiro, o ponteiro \'e9 incrementado ou decrementado pelo tamanho que um objeto do tipo apontado por esse ponteiro ocupa, multiplicado pelo inteiro. \line\bullet  Opera\'e7\'f5es de aritm\'e9tica de ponteiros s\'f3 devem ser executadas sobre por\'e7\'f5es cont\'edguas de mem\'f3ria, tais como um array. Todos os elementos de um array s\'e3o armazenados contiguamente na mem\'f3ria. \line\bullet  Ao executar aritm\'e9tica de ponteiros sobre um array de caracteres, os resultados s\'e3o iguais aos da aritm\'e9tica regular porque cada caractere \'e9 armazenado em um (1) byte de mem\'f3ria. \line\bullet  Ponteiros podem ser atribu\'eddos um ao outro se ambos os ponteiros s\'e3o do mesmo tipo. Caso contr\'e1rio, deve ser feita uma opera\'e7\'e3o de coer\'e7\'e3o. A exce\'e7\'e3o a esta regra \'e9 um ponteiro para void. o qual \'e9 um tipo de ponteiro gen\'e9rico que pode manter ponteiros de qualquer tipo. Ponteiros de outros tipos podem ser atribu\'eddos a ponteiros para void. Um ponteiro nulo pode ser atribu\'eddo a um ponteiro de outro tipo s\'f3 com uma convers\'e3o de tipo expl\'edcita. \line\bullet  Um ponteiro void n\'e3o pode ser derreferenciado. \line\bullet  Ponteiros podem ser comparados usando-se os operadores relacionais e de igualdade. As compara\'e7\'f5es de ponteiros normalmente s\'f3 t\'eam significado se os ponteiros apontam para membros do mesmo array. \line\bullet  Ponteiros podem ser indexados exatamente como os nomes de array. \line\bullet  Um nome de array \'e9 equivalente a um ponteiro constante para o primeiro elemento do array. \line\bullet  Na nota\'e7\'e3o ponteiro/deslocamento, o deslocamento \'e9 o mesmo que um \'edndice de array. \line\bullet  Todas as express\'f5es de array com subscritos podem ser escritas com um ponteiro e um deslocamento, usando-se ou o nome do array como um ponteiro ou um ponteiro separado que aponta para o array. \line\bullet  Um nome de array \'e9 um ponteiro constante que sempre aponta para a mesma posi\'e7\'e3o na mem\'f3ria. \line\bullet  Arrays podem conter ponteiros. \line\bullet  Um ponteiro de uma fun\'e7\'e3o cont\'e9m o endere\'e7o da posi\'e7\'e3o de mem\'f3ria onde inicia o c\'f3digo da fun\'e7\'e3o na mem\'f3ria. \line\bullet  Ponteiros de fun\'e7\'f5es podem ser passados para fun\'e7\'f5es, retornados por fun\'e7\'f5es, armazenados em arrays e atribu\'eddos a outros ponteiros. \line\bullet  Um uso comum de ponteiros de fun\'e7\'e3o se encontra em sistemas orientados por menos. O ponteiro de fun\'e7\'e3o \'e9 usado para chamar a fun\'e7\'e3o correspondente a um item particular do menu. \line\bullet  A fun\'e7\'e3o strcpy copia seu segundo argumento \f2\fs8 - \f0\fs16 um \i string \i0\f2\fs8 - \f0\fs16 para o seu primeiro argumento \f2\fs8 - \f0\fs16 um array de caracteres. O programador deve assegurar que o array de destino seja suficientemente grande para armazenar o \i string \i0 e seu caractere terminal nulo. \fs24\par
\b\f2\fs22 372 \b0\fs28 c++ \b\fs14 COMO PROGRAMAR \line\b0\f0\fs16 A fun\'e7\'e3o strncpy \'e9 equivalente a strcpy, a n\'e3o ser pelo fato de que uma chamada a strncpy especifica o n\'famero de caracteres a serem copiados do \i string \i0 para o array. O caractere terminal nulo s\'f3 ser\'e1 copiado se o n\'famero de caracteres a serem copiados for um a mais que o comprimento do \i string. \line\i0\bullet  A fun\'e7\'e3o strcat concatena seu segundo argumento \i srring \i0\f2\fs8 - \f0\fs16 inclusive com o caractere terminal nulo \f2\fs8 - \f0\fs16 a seu primeiro argumento \i string. \i0 O primeiro caractere do segundo \i string \i0 substitui o caractere nulo ( \\O \b\f2\fs22 ) \b0\f0\fs16 do primeiro \i string. \i0 O programador deve assegurar que o array usado para armazenar o primeiro \i string \i0\'e9 grande o bastante para armazenar tanto o primeiro \i string \i0 como o segundo \i string. \line\i0\bullet  A fun\'e7\'e3o strncat concatena um n\'famero especificado de caracteres do segundo \i string \i0 ao primeiro \i string. \i0 Um caractere terminal nulo \'e9 acrescentado ao resultado. \line\bullet  A fun\'e7\'e3o strcmp compara seu primeiro argumento \i string \i0 com seu segundo argumento \i string, \i0 caractere por caractere. A fun\'e7\'e3o retoma O se os \i strings \i0 s\'e3o iguais, um valor negativo se o primeiro \i string \i0\'e9 menor que o segundo \i string \i0 e um valor positivo se o primeiro \i string \i0 for maior que o segundo \i string. \line\i0\bullet  A fun\'e7\'e3o strncmp \'e9 equivalente a strcmp, a n\'e3o ser pelo fato de que strncmp compara um n\'famero de caracteres especificado. Se o n\'famero de caracteres em um dos \i strings \i0\'e9 menor que o n\'famero de caracteres especificado, strncmp compara os caracteres at\'e9 encontrar o caractere nulo no \i string \i0 menor. \line\bullet  Uma seq\'fc\'eancia de chamadas a strtok separa um \i string \i0 em unidades l\'e9xicas que s\'e3o separadas por caracteres contidos em um segundo argumento \i string. \i0 A primeira chamada cont\'e9m o \i string \i0 para ser separado em unidades l\'e9xicas como primeiro argumento e chamadas subseq\'fcentes para continuar a separar em unidades l\'e9xicas o mesmo \i string \i0 podem conter NULL como primeiro argumento. Cada chamada retoma um ponteiro para a unidade l\'e9xica atual. Se n\'e3o existirem mais unidades l\'e9xicas quando strtok \'e9 chamado, o valor \f2 NULL \f0\'e9 retomado. \line\bullet  A fun\'e7\'e3o strlen aceita um \i string \i0 como um argumento e retorna o n\'famero de caracteres no \i string \i0\f2\fs8 - \f0\fs16 o caractere terminal nulo n\'e3o \'e9 inclu\'eddo no comprimento do \i string. \line\b\f2\fs24 Terminologia \b0\i0\f0\par
\fs16 adiamento indefinido \line anexar strings a outros \i strings \line\i0 aritm\'e9tica de ponteiros \line array de ponteiros \line array de strings \line ASCII \line atribui\'e7\'e3o de ponteiro \line chamada por refer\'eancia \line chamada por refer\'eancia simulada \line chamada por valor \line classes, responsabilidades e colabora\'e7\'f5es (CRC) c\'f3digo de caractere \line c\'f3digo num\'e9rico de um caractere \line compara\'e7\'e3o de ponteiros \line compara\'e7\'e3o de \i strings \line\i0 comprimento de um \i string \line\i0 concatena\'e7\'e3o de \i string \line\i0 conjunto de caracteres \fs24\par
\fs18 corist \fs24\par
\fs16 constante de caractere constante de \i string \i0 copiar \i strings \i0\fs24\par
\fs18 <cstririg> \line decrementar um ponteiro delimitador \line derreferenciar um ponteiro deslocamento \line EBCDIC \line express\'e3o de ponteiro \fs24\par
\fs16 incrementar um ponteiro \line indexa\'e7\'e3o de ponteiro \line indire\'e7\'e3o \line inicializar um ponteiro \line islower \line literal \line nota\'e7\'e3o ponteiro/deslocamento operador de derreferenciamento (*) operador de endere\'e7o (&) \line operador de indire\'e7\'e3o (*) \line ponteiro \line ponteiro constante \line ponteiro constante para dados constantes ponteiro constante para dados n\'e3o-constantes ponteiro de caractere \line ponteiro de fun\'e7\'e3o \line ponteiro n\'e3o-constante para dados constantes ponteiro n\'e3o-constante para dados n\'e3o-constantes ponteiro NULL \line ponteiro para uma fun\'e7\'e3o \line ponteiro para void (void *) princ\'edpio do menor privil\'e9gio processamento de \i string \line\i0 processamento de texto \line referenciar diretamente uma variael referenciar indiretamente uma vari\'e1vel separar \i strings \i0 em unidades l\'e9xicas \fs24\par
\fs16 strca \line\f2 strcnT \line\f0 strcp \line\i string \line string \i0 Ii \line strle strnc \fs24\par
\fs18 strnc \line strnc \fs24\par
\b\i\f2 Tem \b0\i0\f0\par
\fs18 colabor diagran intera\'e7 linha cl da U \fs24\par
\fs18 linha cl \fs24\par
\b\i\f2 Erro \b0\i0\f0\par
\fs18 5.1 \line 5.2 \line\i\f2 5.3 \line\i0\f0 5.4 \line\i\f2 5.5 \line\i0\f0 5.6 \line 5.7 \line 5.8 \line 5.9 \line 5.10 \line 5.11 \line 5.12 \line 5.13 \line 5.14 \line 5.15 \line 5.16 \line 5.17 \line 5.18 \line 5.19 \line 5.20 \line 5.21 \line 5.22 \fs24\par
\fs18 sizeof \line somando um ponteiro e um inteiro \fs24\par
\b\fs14 CAP\'cdTULO \b0\i\f2\fs18 5 \i0\fs8 - \b\f0\fs14 PONTEIROS E \b0\i\fs16 STRINGS \b\i0\f2\fs22 373 \line\f3\fs18 strcat strtok \line\b0\f0\fs16 strcmp subscritar um ponteiro \line strcpy subtraindo dois ponteiros \line\i string \i0 subtraindo um inteiro de um ponteiro \line\i string \i0 literal tipos de ponteiros \line\b\f3\fs18 strleri toupper \line\b0\f0\fs16 strncat unidade l\'e9xica \line strncmp void \f2\fs10 * \f0\fs16 (ponteiro para void) \line\b\f3\fs18 strncpy \line\i\f2\fs24 Terminologia de \ldblquote Pensando em objetos\rdblquote  \line\b0\i0\f0\fs16 colabora\'e7\'e3o mensagem \line diagrama de colabora\'e7\'f5es n\'fameros em diagramas de colabora\'e7\'f5es da UML \line intera\'e7\'e3o entre objetos objetos que participam de intera\'e7\'f5es \line linha cheia com seta na ponta em diagramas de colabora\'e7\'f5es quando ocorrem as intera\'e7\'f5es \line da UML ret\'e2ngulo em diagrama de colabora\'e7\'f5es da UML \line linha cheia em diagramas de colabora\'e7\'f5es da UML seq\'fc\'eancia de mensagens \line\b\i\f2\fs24 Erros comuns de programa\'e7\'e3o \line\b0\i0\f0\fs16 5.1 Assumir que o usado para declarar um ponteiro se aplica a todos os nomes de vari\'e1veis, em uma lista de vari\'e1veis ponteiro separadas por v\'edrgulas, pode fazer com que os ponteiros sejam declarados n\'e3o como ponteiros. Cada ponteiro \line deve ser declarado com o prefixado ao nome. \line 5.2 Derreferenciar um ponteiro que n\'e3o foi corretamente inicializado, ou ao qual n\'e3o foi feita uma atribui\'e7\'e3o para apontar para uma posi\'e7\'e3o espec\'edfica na mem\'f3ria, pode causar um erro fatal durante a execu\'e7\'e3o ou, ainda, pode modificar acidentalmente dados importantes e permitir que o programa execute at\'e9 o fim, fornecendo resultados incorretos. \line 5.3 Uma tentativa de derreferenciar um n\'e3o-ponteiro \'e9 um erro de sintaxe. \line 5.4 Derreferenciar um ponteiro O normalmente gera um erro fatal durante a execu\'e7\'e3o. \line\i\f2\fs18 5.5 \i0\f0\fs16 E um erro n\'e3o derreferenciar um ponteiro, quando \'e9 necess\'e1rio faz\'ea-lo para obter o valor para o qual o ponteiro aponta. \line 5.6 E erro de sintaxe n\'e3o inicializar um ponteiro declarado como const. \line 5.7 Usar o operador \b sizeof \b0 em uma fun\'e7\'e3o para achar o tamanho em bytes de um argumento do tipo array resulta no tamanho em bytes de um ponteiro e n\'e3o no tamanho em bytes do array. \line 5.8 Omitir os par\'eanteses em uma opera\'e7\'e3o sizeof quando o operando \'e9 um nome de tipo \'e9 erro de sintaxe. \line 5.9 Usar aritm\'e9tica de ponteiros sobre um ponteiro que n\'e3o se refere a um array de valores normalmente \'e9 um erro de l\'f3gica. \line 5.10 Subtrair ou comparar dois ponteiros que n\'e3o se referem a elementos do mesmo array normalmente \'e9 um erro de l\'f3gica. \line 5.1 \b\f2\fs18 1 \b0\f0\fs16 Endere\'e7ar al\'e9m dos extremos de um array, quando usamos aritm\'e9tica de ponteiros, normalmente \'e9 erro de l\'f3gica. \line 5.12 Atribuir um ponteiro de um tipo a um ponteiro de outro (diferente de void \b\fs14 *), \b0\fs16 sem converter o primeiro ponteiro para o tipo do segundo ponteiro, \'e9 erro de sintaxe. \line 5.13 Derreferenciar um ponteiro void \'e9 um erro de sintaxe. \line 5.14 Embora os nomes de array sejam ponteiros para o in\'edcio do array e ponteiros possam ser modificados em express\'f5es aritm\'e9ticas, nomes de array n\'e3o podem ser modificados em express\'f5es aritm\'e9ticas porque s\'e3o ponteiros constantes. \line 5.15 N\'e3o alocar espa\'e7o suficiente em um array de caracteres para armazenar o caractere nulo que termina um \i string. \line\i0 5.16 Criar ou usar um \i\ldblquote string\rdblquote  \i0 que n\'e3o cont\'e9m um caractere terminal nulo. \line 5.17 Processar um caractere \'fanico como um \i string \i0 pode levar a um erro fatal durante a execu\'e7\'e3o. Um \i string \i0\'e9 um ponteiro \line\f2\fs8 - \f0\fs16 provavelmente um inteiro consideravelmente grande. Por\'e9m, um caractere \'e9 um inteiro pequeno (valores ASCII variam de O a 255). Em muitos sistemas, isso causa um erro porque os endere\'e7os de mem\'f3ria baixos s\'e3o reservados para prop\'f3sitos especiais, tais como para tratadores de interrup\'e7\'f5es do sistema operacional \f2\fs8 - \f0\fs16 assim, ocorrem \ldblquote viola\'e7\'f5es de acesso\rdblquote . \line 5.18 Passar um caractere como argumento para uma fun\'e7\'e3o, quando \'e9 esperado um \i string, \i0 pode levar a um erro fatal durante a execu\'e7\'e3o. \line 5.19 Passar um \i string \i0 como argumento para uma fun\'e7\'e3o, quando \'e9 esperado um caractere, \'e9 um erro de sintaxe. \line 5.20 Esquecer de incluir o arquivo de cabe\'e7alho <cstring> quando usar fun\'e7\'f5es da biblioteca de tratamento de \i strings. \line\i0 5.21 N\'e3o anexar um caractere nulo terminal ao primeiro argumento de uma strncpy, quando o terceiro argumento \'e9 menor ou igual ao comprimento do \i string \i0 no segundo argumento, pode causar erros fatais durante a execu\'e7\'e3o. \line 5.22 Assumir que strcmp e strncmp retomam um quando seus argumentos forem iguais \'e9 um erro de l\'f3gica. Ambas as fun\'e7\'f5es retornam zero (o valor falso em C++) para igualdade. Ent\'e3o, quando \i strings \i0 s\'e3o testados quanto \'e0 igualdade, o \line resultado das fun\'e7\'f5es strcmp ou strncmp devem ser comparados comO para determinar se os \i strings \i0 s\'e3o iguais. \fs24\par
\b\f2\fs20 374 C++ \fs14 COMO PROGRAMAR \line\b0\f0\fs18 5.23 N\'e3o perceber que strtok modifica o \i\fs16 string \i0\fs18 que ser\'e1 separado em unidades l\'e9xicas e, ent\'e3o, tentar usar esse \i\fs16 string \i0\fs18 como se ele fosse o \i\fs16 string \i0\fs18 original inalterado. \line\b\i\f2\fs24 Boas pr\'e1ticas de programa\'e7\'e3o \line\b0\i0\f0\fs18 5.1 Embora n\'e3o seja obrigat\'f3rio fazer isso, incluir as letras Ptr em nomes de vari\'e1veis ponteiro torna claro que estas vari\'e1veis s\'e3o ponteiros e precisam ser manipuladas de acordo. \line 5.2 Use uma chamada por valor para passar argumentos para uma fun\'e7\'e3o, a menos que o chamador exija explicitamente que a fun\'e7\'e3o modifique o valor da vari\'e1vel passada como argumento, no contexto do chamador. Este \'e9 outro exemplo do princ\'edpio de menor privil\'e9gio. \line 5.3 Antes de usar uma fun\'e7\'e3o, confira seu prot\'f3tipo de fun\'e7\'e3o para determinar os argumentos que ela pode modificar. \line 5.4 Use a nota\'e7\'e3o de array em vez da nota\'e7\'e3o de ponteiro quando manipular arrays. Embora o programa possa se tornar ligeiramente mais lento para ser compilado, provavelmente ele ser\'e1 mais claro. \line 5.5 Quando armazenar um \i\fs16 string \i0\fs18 de caracteres em um array de caracteres, esteja certo de que o array \'e9 grande o bastante para manter o maior \i\fs16 string \i0\fs18 que ser\'e1 armazenado. C++ permite que strings de qualquer comprimento sejam armazenados. Se um \i\fs16 string \i0\fs18\'e9 mais longo que o array de caracteres em que ele \'e9 armazenado, os caracteres al\'e9m do fim do array ser\'e3o gravados \ldblquote em cima\rdblquote  dos dados que estiverem ap\'f3s o array na mem\'f3ria. \line\b\i\f2\fs24 Dicas de desempenho \line\b0\i0\f0\fs18 5.1 Passe objetos grandes, tais como estruturas, usando ponteiros para dados constantes ou refer\'eancias para dados constantes, para obter os benef\'edcios de desempenho de uma chamada por refer\'eancia e a seguran\'e7a de uma chamada por valor. \line 5.2 sizeof \'e9 um operado un\'e1rio usado durante a compila\'e7\'e3o, n\'e3o uma fun\'e7\'e3o executada durante a execu\'e7\'e3o. Deste modo, usar sizeof n\'e3o causa impacto negativo sobre o desempenho da execu\'e7\'e3o. \line 5.3 As vezes, um algoritmo que surge de um modo \ldblquote natural\rdblquote  pode conter problemas sutis de desempenho, tal como o adiamento indefinido. Procure algoritmos que evitam o adiamento indefinido. \line\b\i\f2\fs24 Dicas de portabilidade \line\b0\i0\f0\fs18 5.1 O formato em que um ponteiro \'e9 exibido para o usu\'e1rio depende da m\'e1quina. Alguns valores de ponteiros s\'e3o exibidos por alguns sistemas como inteiros hexadecimais, enquanto outros sistemas usam inteiros decimais. \line 5.2 Embora const esteja bem-definido em C e C++ ANSI, alguns compiladores n\'e3o garantem o seu uso correto. \line 5.3 O n\'famero de bytes usados para armazenar um tipo particular de dados pode variar entre sistemas. Quando estiver escrevendo programas que dependem do tamanho dos tipos de dados e que ser\'e3o executados em v\'e1rios sistemas de computador, use sizeof para determinar o n\'famero de bytes usados para armazenar os tipos de dados. \line 5.4 A maioria dos computadores atuais t\'eam inteiros de 2 bytes ou de 4 bytes. Algumas das m\'e1quinas mais recentes usam inteiros de 8 bytes. Como os resultados da aritm\'e9tica de ponteiros dependem do tamanho dos objetos para os quais um ponteiro aponta, a aritm\'e9tica de ponteiros \'e9 dependente da m\'e1quina. \line 5.5 Quando uma vari\'e1vel do tipo char \f2\fs10 * \f0\fs18\'e9 inicializada com um \i\fs16 string \i0\fs18 literal, alguns compiladores podem colocar o \i\fs16 string \i0\fs18 em uma posi\'e7\'e3o na mem\'f3ria em que o \i\fs16 string \i0\fs18 n\'e3o pode ser modificado. Se voc\'ea precisa modificar um \i\fs16 string \i0\fs18 literal, deve armazen\'e1-lo em um array de caracteres para assegurar a possibilidade de mudan\'e7a em todos os sistemas. \line 5.6 Os c\'f3digos num\'e9ricos internos usados para representar caracteres podem ser diferentes em computadores diferentes. \line 5.7 N\'e3o fa\'e7a testes expl\'edcitos do valor do c\'f3digo de caracteres em ASCII, como por exemplo em: if ( ch \f2\fs10 == \f0\fs18 65 ) em vez disso, use sempre a constante de caractere correspondente, como em: if (ch \f2\fs10 == \f0\fs18 A\rquote  ). \line\b\i\f2\fs24 Observa\'e7\'f5es de engenharia de software \line\b0\i0\f0\fs18 5.1 O qualificador corist pode ser usado para for\'e7ar o uso do princ\'edpio de menor privil\'e9gio. O uso do princ\'edpio de menor privil\'e9gio para projetar software corretamente pode reduzir bastante o tempo de depura\'e7\'e3o e efeitos colaterais incorretos, tornando o programa mais f\'e1cil de se modificar e manter. \line 5.2 Se um valor n\'e3o muda (ou n\'e3o deve mudar) no corpo de uma fun\'e7\'e3o para a qual ele \'e9 passado, o argumento deve ser declarado const para garantir que n\'e3o seja acidentalmente modificado. \line 5.3 Quando \'e9 usada uma chamada por valor, somente um valor pode ser alterado na fun\'e7\'e3o chamada. Esse valor deve ser atribu\'eddo do valor de retorno da fun\'e7\'e3o. Para modificar m\'faltiplos valores em chamadas de fun\'e7\'e3o, v\'e1rios argumentos s\'e3o \line passados atrav\'e9s de uma chamada por refer\'eancia. \fs24\par
\b\f2\fs14 CAP\'cdTULO \b0\i\fs20 5 \i0\fs8 - \b\fs14 PONTEIROS E \i\f0 STRINGS \f2\fs24 375 \line\b0\i0\f0\fs16 g como 5.4 Colocar prot\'f3tipos de fun\'e7\'e3o nas defini\'e7\'f5es de outras fun\'e7\'f5es for\'e7a o princ\'edpio de menor privil\'e9gio, restringindo chama da para as fun\'e7\'f5es \'e0s fun\'e7\'f5es em que os prot\'f3tipos aparecerem. \line 5.5 Quando passar um array para uma fun\'e7\'e3o, passe tamb\'e9m o tamanho do array (em vez de incluir na fun\'e7\'e3o o conhecimen t do tamanho do array). Isto ajuda a tornar a fun\'e7\'e3o mais gen\'e9rica. Fun\'e7\'f5es gen\'e9ricas s\'e3o freq\'fcentemente reutiliz\'e1veis \line em muitos programas. \line\f1\fs18 ue \f0\fs16 estas \b\i\f2\fs24 Dica de teste e depura \'e7\'e3o \line\b0\i0\f0\fs16 mte que \f2\fs8 . . . \line\f0\fs16 iplo do 5.1 Sempre inicialize ponteiros para evitar apontar para \'e1reas de mem\'f3ria desconhecidas ou n\'e3o-inicializadas. \line omar \b\i\f2\fs24 Exerc\'edcios de auto-revis\'e3o \line\b0\i0\f0\fs16 nte para 5.1 Responda a cada uma das seguintes frases: \line idos. Se a) Um ponteiro \'e9 uma vari\'e1vel que cont\'e9m como seu valor o \f2\fs8 _______________ \f0\fs16 de outra vari\'e1vel. \line iy ser\'e3o b) Os tr\'eas valores que podem ser usados para inicializar um ponteiro s\'e3o \f2\fs8 _______________. ______ \f0\fs16 ou \line c) O \'fanico inteiro que pode ser atribu\'eddo a um ponteiro \'e9 \f2\fs8 ____________________ \line\f0\fs16 5.2 Afirme se a frase seguinte \'e9 \i verdadeira ou falsa. \i0 Se a resposta for \i falsa, \i0 explique por qu\'ea. \line a) O operador de endere\'e7o \b\i\fs14 & \b0\i0\fs16 s\'f3 pode ser aplicado a constantes, express\'f5es e vari\'e1veis declaradas com a classe de armazenamento regis ter. \line onstan- b) Um ponteiro que \'e9 declarado como void pode ser derreferenciado. \line c) Ponteiros de tipos diferentes n\'e3o podem ser atribu\'eddos um ao outro sem uma opera\'e7\'e3o de convers\'e3o de tipo. \line orno 5.3 Responda a cada um dos seguintes \'edtens. Assuma que n\'fameros de ponto flutuante com precis\'e3o simples s\'e3o armazenados \line\b\fs12 O \b0\fs16 em 4 bytes e que o endere\'e7o de in\'edcio do array \'e9 na posi\'e7\'e3o 1002500 da mem\'f3ria. Cada parte do exerc\'edcio deve usar os resultados \line de partes anteriores, quando necess\'e1rio. \line a) Declare um array nuinbers. de tipo double, com 10 elementos, e inicialize os elementos com os valores O \f2\fs8 . \f0\fs16 0, 1 \f2\fs8 . \f0\fs16 1, 2.2 9. 9. Suponha que a constante simb\'f3lica \b SIZE \b0 tenha sido definida como 10. \line b) Declare um ponteiro nPtr que aponta para um objeto de tipo double. \line c) Imprima os elementos do array nuinbers usando a nota\'e7\'e3o de subscrito para arrays. Use uma estrutura for e xibidos assuma que a vari\'e1vel de controle do for, do tipo inteiro, tenha sido declarada. Imprima cada n\'famero com precis\'e3o \line de 1 posi\'e7\'e3o \'e0 direita da casa decimal. \line d) D\'ea dois comandos separados que atribuem o endere\'e7o do in\'edcio do array numbers \'e0 vari\'e1vel ponteiro nPtr. \line rescre- e) Imprima os elementos do array nunibers usando a nota\'e7\'e3o ponteiro/deslocamento com o ponteiro nPtr. \line mputa- f) Imprima os elementos do array nuinbers usando a nota\'e7\'e3o ponteiro/deslocamento com o nome do array como \line ponteiro. \line usam g) Imprima os elementos do array numbers indexando o ponteiro nPtr. \line ais um h) Refira-se ao elemento 4 do array numbers. usando as nota\'e7\'f5es de \'edndice de array, ponteiro/deslocamento e a nota \'e7\'e3 com o nome do array como ponteiro, a nota\'e7\'e3o de \'edndice de ponteiro com nPtr e a nota\'e7\'e3o ponteiro/desloca strin mento com nPtr. \line 1, deve i) Assumindo-se que nPtr aponta para o in\'edcio do array numbers. que endere\'e7o \'e9 referenciado por nPtr \b\i\fs14 + \b0\i0\fs16 8? Que \line valor est\'e1 armazenado nessa posi\'e7\'e3o? \line ates. \fs24 j) \fs16 Assumindo-se que nPtr aponta para riumbers \i\f2\fs20 [ \i0\f0\fs16 5 \i\f2\fs20 1 \i0\fs8 , \f0\fs16 qual endere\'e7o \'e9 referenciado por nPtr depois de riPtr \f2\fs8 - \line\f0\fs16 elo vez \f2\fs12 = \f0\fs16 4 ser executado? Qual valor est\'e1 armazenado nessa posi\'e7\'e3o? \line 5.4 Para cada um dos seguintes itens, escreva um \'fanico comando para executar a tarefa indicada. Assuma que as vari\'e1veis de ponto flutuante numberi e number2 foram declaradas e que numberi foi inicializado com 7 \f2\fs8 . \f0\fs16 3. Assuma, tamb\'e9m, que a vari\'e1vel ptr \'e9 do tipo char \f2\fs10 * \f0\fs16 e os arrays si \i\f2\fs20 [ \i0\f0\fs16 100 \i ] \i0 e s2 \i [ \b\i0 100 \b0\i 1 \i0 s\'e3o do tipo char. \line a) Declare a vari\'e1vel fPtr como um ponteiro para um objeto do tipo double. \line menor b) Atribua o endere\'e7o da vari\'e1vel numberi \'e0 vari\'e1vel ponteiro fPtr. \line rretos. c) Imprima o valor do objeto apontado por fptr. \line d) Atribua o valor do objeto apontado por fPtr \'e0 vari\'e1vel number2. \line ve ser e) Imprima o valor de nuxnber2. \line t) Imprima o endere\'e7o de nuinberl. \line\lquote ve ser g) Imprima o endere\'e7o armazenado em fPtr. O valor impresso \'e9 o mesmo que o endere\'e7o de nuinberi? \line os s\'e3o h) Copie o \i string \i0 armazenado no array s2 para o array si. \line 1) Compare o \i string \i0 em si ao \i string \i0 em s2. Imprima o resultado. \fs24\par
\b\f2\fs20 376 \b0\fs28 c++ \b\fs14 COMO PROGRAMAR \line\fs20 i) \b0\f0\fs16 Anexe lO caracteres do \i string \i0 em s2 ao \i string \i0 em si. \line k) Determine o comprimento do \i string \i0 em si. Imprima o resultado. \line 1) Atribua a ptr a posi\'e7\'e3o da primeira unidade l\'e9xica em s2. Unidades l\'e9xicas em s2 s\'e3o separadas por v\'edrgulas. \line 5.5 Fa\'e7a cada um dos seguintes itens: \line a) Escreva o cabe\'e7alho da fun\'e7\'e3o para uma fun\'e7\'e3o exchange que aceita como argumentos dois ponteiros para os n\'fameros de ponto flutuante com precis\'e3o dupla x e y e n\'e3o retoma um valor. \line b) Escreva o prot\'f3tipo da fun\'e7\'e3o para a fun\'e7\'e3o do item (a). \line c) Escreva o cabe\'e7alho da fun\'e7\'e3o para uma fun\'e7\'e3o evaluate que retoma um inteiro e que aceita como argumentos um inteiro x e um ponteiro para a fun\'e7\'e3o poiy. A fun\'e7\'e3o poiy aceita um argumento de tipo inteiro, retornando um \line inteiro. \line\f3 d) Escreva o prot\'f3tipo da fun\'e7\'e3o para a fun\'e7\'e3o do item (c). \line\f0 e) Mostre dois m\'e9todos diferentes de inicializar o array de caracteres vogal com o \i string \i0 de vogais \ldblquote AEIOU\rdblquote . \line 5.6 Ache o erro em cada um dos segmentos do programa seguinte. Suponha que existam as seguintes declara\'e7\'f5es: \line\f3 int *zptr; \b\f2\fs20 // \b0\f3\fs16 zPtr referenciar\'e1 o array z \line int *aptr \f2\fs12 = \f3\fs16 O; \line void *sptr \f2\fs12 = \f3\fs16 0; \line int nuinber, i; \line int z [5] \f2\fs12 = \f0\fs16 (1, \f3 2, 3, 4, 5 \}; \line sPTr \f2\fs10 = \f3\fs16 z; \line a) ++zPtr; \line b) //usa o ponteiro para obter o primeiro valor do array \line number \f2\fs12 = \f3\fs16 zPtr; \line c) \i\f2\fs22 II \i0\f3\fs16 atribui o elemento 2 do array (o valor 3) a nuniber \line number *zptr[ 2 ]; \line d) //imprime todo o array z \line for \b\f2\fs20 ( \b0\f3\fs16 i \f2\fs12 = \f3\fs16 0; i \f2\fs12 <= \f3\fs16 5; i++ \line cout \f0\'ab \f3 zPtr[ i \b\f2\fs20 ] \b0\f0\fs16\'ab \f3 endl; \line e) //atribui o valor apontado por sPtr para number \line nuriber \f2\fs12 = \f3\fs16 *sptr; \line f) ++z; \line g) char s[ 10 ]; \line cout \f0\'ab \f3 strncpy(s, \ldblquote oi!\rdblquote , 3) \'ab endi; \line h) char s[ 12 ]; \line strcpy( s, \ldblquote Bem-vindo ao lar!\rdblquote  ); \line i) if \b\f2\fs20 ( \b0\f3\fs16 strcmp( stringi, string2 \line cout \'ab\ldblquote Os strings s\'e3o iguais\rdblquote  \f0\'ab \f3 endi; \line 5.7 O que \'e9 impresso, se for o caso, quando cada um dos comandos seguintes \'e9 executado? Se o comando contem um erro, descreva o erro e indique como corrigi-lo. Assuma as seguintes declara\'e7\'f5es de vari\'e1veis: \line char si[ 50] \f2\fs12 = \f3\fs16\ldblquote jack\rdblquote , s2[ 50 \b\f2\fs20 ] \b0\fs12 = \f3\fs16\ldblquote jill\rdblquote , s3[ 50 \b\f2\fs20 ], \b0\f3\fs16 *sptr; \line a)cout \'ab strcpy( s3, s2 \b\f2\fs20 ) \b0\f0\fs16\'ab \f3 endi; \line b)cout \f0\'ab \f3 strcat( strcat( strcpy( s3, si),\rdblquote  e \f2\fs8\ldblquote  \f3\fs16 ),s2 )\'ab endi; \line c)cout \f0\'ab \f3 strlen( si \b\f2\fs20 ) \b0\f0\fs16 + \f3 strlen( s2 \b\f2\fs20 ) \b0\f0\fs16\'ab \f3 endl; \line d)cout \f0\'ab \f3 strlen( \f0 s3 \b\f2\fs20 ) \b0\f0\fs16\'ab \f3 endi; \line\b\i\f2\fs24 Respostas dos exerc\'edcios de auto-revis\'e3o \line\b0\i0\f0\fs16 5.1 a) endere\'e7o. b) 0, \f2\fs12 NULL, \f0\fs16 um endere\'e7o. c) 0. \line 5.2 a) Falsa. O operador de endere\'e7o s\'f3 pode ser aplicado a vari\'e1veis e n\'e3o pode ser aplicado a constantes, express\'f5es ou vari\'e1veis declaradas com a classe de armazenamento regis ter. \line b) Falsa. Um ponteiro void n\'e3o pode ser derreferenciado porque n\'e3o existe nenhum modo de saber exatamente quantos bytes de mem\'f3ria deveriam ser derreferenciados. \fs24\par
\fs16 CAP\'cdTULO \i\f2 5 \i0\fs8 - \f0\fs16 PONTEIROS E \i\fs18 STRINGS \b\i0\f2 377 \line\b0\f0\fs16 c) Falsa. Aos ponteiros de tipo void podem ser atribu\'eddos ponteiros de outros tipos. Os ponteiros de tipo void podem \line ser atribu\'eddos a ponteiros de outros tipos somente com uma convers\'e3o expl\'edcita de tipo. \line 5.3 a) double nuiubers[ SIZE] \i\f2 =\{ \i0\f0 0.0, 1.1, \b\f3 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9 \}; \line\b0\f0 b) double *nptr; \line\f3 c) cout\'ab setiosflags( ios::I fixed ios::showpoint \line\i\f0\fs18\'ab \i0\f3\fs16 setprecision( 1 ); \line for \i\f2 ( \i0\f3 i \i\f2 = \b\i0\f3 O; i < SIZE; i++ \line\b0 cout \i\f0\fs18\'ab \i0\f3 numbers[ i \i\f2\fs16 ] \f0\fs18\'ab \line\i0\fs16 d) nPtr \i\f2 = \i0\f3 numbers; \line nPtr \i\f2 = \i0\f0 &numbers \i\f2 [ \i0\f3 O ]; \line e) cout\'ab setiosflags( ios::fixed \i\f2 1 \i0\f3 ios::showpoint \line\i\f0\fs18\'ab \i0\fs16 setprecisiori( 1 ); \line\f3 for \i\f2 ( \i0\f3 i \i\f2 = \i0\f3 O; i \f0 < \f3 SIZE; i++ \line cout\'ab *(nptr + i \i\f2 ) \f0\fs18\'ab \line\i0\f2\fs32 o \f3\fs16 cout \'ab setiosflags \i\f2 ( \i0\f3 ios : : \i\f2 1 \i0\f3 fixed ios : showpoint \line\f0 j \i\fs18\'ab \i0\f3\fs16 setprecision \i\f2 ( \i0\f0 1 ); \line\f3 for \i\f2 ( \i0\f3 i \i\f2 = \i0\f3 O; i < SIZE; i++ \line cout \'ab \f2\fs10 * \i\fs16 ( \i0\f0 riumbers + \f3 i \i\f2 ) \f0\fs18\'ab \i0\f2\fs8\lquote  \line\f3\fs16 g) cout \'ab setiosflags (ios : : \i\f2 1 \i0\f3 fixo ios : : showpoirit \line\'absetprecision(1 ); \line for \i\f2 ( \i0\f3 i \i\f2 = \i0\f3 0; i < SIZE; i ++ \line cout\'ab nPtr[ i \i\f2 ] \i0\f0\'ab \line\f3 h) nuxnbers[ 3 \line *( nunibers + 3) \line nPtr[ 3 \line *( nPtr + 3 \line i) Oendere\'e7o\'e9loo2500 +8 \f2\fs10 * \f3\fs16 4 =1002532. Ovalor\'e98.8. \line\f1\fs24 j) \f3\fs16 Oendere\'e7odenumbers[5 \i\f2 ] \i0\f3\'e91002500 + 5 *4 \i\f2 = \i0\f3 1002520. \line Oendere\'e7odenPtr-=4 \'e91002520 \f2\fs8 - \b\f0\fs16 4 \b0\f2\fs10 * \b\f0\fs16 4 \b0\i\f2 = \b\i0\f0 1002504. \line\b0\f3 O valor nessa posi\'e7\'e3o \'e9 1 \f2\fs8 . \b\f0\fs16 1. \line\b0\f3 5.4 a) doubie *fPtr; \line b) fPtr \i\f2 = \i0\f3 &numberl; \line c) cout \'ab \ldblquote O valor de *fptr \'e9 \f2\fs8\ldblquote  \f3\fs16\'ab *f \'ab endi; \line d) nuinber2 \i\f2 = \i0\f3 *fptr; \line\b\f0 e) cout \'ab \ldblquote O valor de number2 \'e9 \b0\f2\fs8\ldblquote  \f0\fs16\'ab \f3 number2 \'ab endi; \line\b\f0 f) cout \b0\'ab \b\ldblquote O endere\'e7o de numberi \'e9 \b0\f2\fs8\ldblquote  \b\f0\fs16\'ab &numberl \'ab endi; \line\b0\f3 g) cout \'ab \b\f0\ldblquote O endere\'e7o armazenado em \b0\f3 fPtr \'e9 \f2\fs8\ldblquote  \b\f0\fs16\'ab \b0 fPtr \'ab \b endi; \line\b0\f3 Sim, o valor \'e9 o mesmo. \line h) strcpy( si, s2 \line i) cout \'ab \ldblquote strcmp(sl, s2) \i\f2 = \i0\fs8\ldblquote  \f3\fs16\'abstrcmp( si, s2 \i\f2 ) \i0\f0\'ab \f3 endi; \line\b\f2\fs18 j) \b0\f3\fs16 strncat( si, s2, 10 \line k) cout \'ab \ldblquote strlen(sl) \i\f2 = \i0\fs8\ldblquote  \f3\fs16\'abstrlen( si \i\f2 ) \i0\f3\'abendi; \line 1) ptr \i\f2 = \b\i0\f0 strtok( s2, \b0\f2\fs8\ldblquote ,\ldblquote  \f0\fs16 ); \line\f3 5.5 a) void exchange( doubie \f2\fs10 *, \f3\fs16 doubie *y \line\f0 b) void \b exchange \b0\i\f2 ( \i0\f0 double \f2\fs10 *, \f0\fs16 doubie \f2\fs10 * \line\b\f0\fs16 c) int evaluate( int x, int (*poly) \b0\i\f2 ( \i0\f3 int \line\b\f0 d) int evaluate( int, int (*) \b0\i\f2 ( \b\i0\f0 int \b0\i\f2 ) ); \line\b\i0\f0 e) char vogai[) \b0\i\f2 = \i0\f0\ldblquote AEIOU\rdblquote ; \line\f3 char vogai[) \i\f2 = \{ \b\i0\f0\lquote A\rquote , \lquote E\rquote , \lquote 1\rquote , \lquote O\rquote , \lquote U\rquote , \lquote\\O\rquote  ); \line\b0 5.6 a) Erro: zPtr n\'e3o tinha sido inicializado. \line Corre\'e7\'e3o: inicialize zPtr com zPtr \i\f2 = \line\i0\f3\fs18 b) Erro: o ponteiro n\'e3o \'e9 derreferenciado. \line\f0\fs16 Corre\'e7\'e3o: mude o comando para number \i\f2 = \b\i0\f0 *zptr; \line\b0 c) Erro: \b zPtr \b0\i\f2 [ \b\i0\f0 2 \b0\i\f2 ] \i0\f0 n\'e3o \'e9 um ponteiro e n\'e3o devia ser derreferenciado. \line\f3\fs18 Corre\'e7\'e3o: mude *zptr[ 2 \i\f2\fs16 ] \i0\f0 para \b zPtr[ 2 \f2\fs18 ]. \line\b0\f0\fs16 d) Erro: referindo-se a um elemento do array fora dos limites do mesmo com indexa\'e7\'e3o de ponteiro. Corre\'e7\'e3o: mude o operador relacional na estrutura for para < para evitar ultrapassar o fim do array. \line e) Erro: derreferenciar um ponteiro void. \line Corre\'e7\'e3o: a fim de desreferenciar o ponteiro, ele deve primeiro ser convertido para um ponteiro para dados de tipo \line inteiro. \fs24\par
\b\f2\fs20 378 \b0\fs30 c++ \b\fs14 COMO PROGRAMAR \line\b0\f0\fs16 Mude o comando acima para riumber \f2\fs12 = \b\f0 * \b0\fs16 (int *) sPtr; \line f) Erro: tentar modificar um nome de array com aritm\'e9tica de ponteiros. \line Corre\'e7\'e3o: use uma vari\'e1vel ponteiro, em vez do nome do array, para poder efetuar aritm\'e9tica de ponteiros ou use um \line subscrito junto com o nome do array para se referir a um elemento espec\'edfico. \line g) Erro: a fun\'e7\'e3o strncpy n\'e3o escreve um caractere nulo terminal no array s porque seu terceiro argumento \'e9 igual ao \i Nota: \line\i0 comprimento do \i string \i0 Oi ! \f2\fs8\ldblquote  . \i\f0\fs16 capaz \line\i0 Corre\'e7\'e3o: mude o valor do terceiro argumento de s trncpy para 4 ou atribua \b\f2\fs20\\ \b0\f0\fs16 O \f2\fs8\lquote  \f0\fs16 a s \b\f2\fs20 [ \b0\f0\fs16 3 \b\f2\fs20 ] \b0\f0\fs16 para assegurar que \line o caractere nulo terminal \'e9 anexado ao \i string. \i0 5.12 \line h) Erro: o array de caracteres s n\'e3o \'e9 grande o bastante para armazenar o caractere nulo terminal. p\'f4quer \line Corre\'e7\'e3o: declare o array com mais elementos. \line i) Erro: a fun\'e7\'e3o strcmp retornar\'e1 O se os \i strings \i0 forem iguais; ent\'e3o, a condi\'e7\'e3o na estrutura if ser\'e1 falsa e a \line exibi\'e7\'e3o/impress\'e3o do comando n\'e3o ser\'e1 executada. \line Corre\'e7\'e3o: compare, explicitamente, o resultado de strcmp com O na condi\'e7\'e3o da estrutura \i if. \line\i0 5.7 a) jili \line\f3\fs18 b) jack e jili \line c)8 \f2\fs8 - \line\f0\fs16 d) 13 :l3 \line\f3\fs18 poquei \line\b\i\f2\fs24 Exerc\'edcios \b0\i0\f0\fs16 5.14 \line cartea \line 5.8 Afirme se o item seguinte \'e9 \i verdadeiro oufalso. Sefalso, \i0 explique por qu\'ea. avaliai \line a) Dois ponteiros que apontam para dois arrays diferentes n\'e3o podem ser comparados de modo que a compara\'e7\'e3o fa\'e7a substit \line sentido. dor. (( \line b) Como o nome de um array \'e9 um ponteiro para o primeiro elemento do array, nomes de array podem ser manipulados \line exatamente da mesma maneira que ponteiros. 5.15 \line\f3\fs18 sendo, \line\f0\fs16 5.9 Responda a cada um dos seguintes \'edtens. Assuma que inteiros sem sinal s\'e3o armazenados em 2 bytes e que o endere\'e7o maos \line inicial do array est\'e1 na posi\'e7\'e3o 1002500 na mem\'f3ria. voce \line a) Declare um array do tipo unsigned int chamado value. com 5 elementos, e inicialize os elementos com os result \line inteiros pares de 2 at\'e9 10. Assuma que a constante simb\'f3lica SIZE tenha sido definida como 5. dificil \line b) Declare um ponteiro vPtr que aponta para um objeto de tipo unsigned int. \line e) Imprima os elementos do array values usando a nota\'e7\'e3o de subscrito para array. Use uma estrutura for e assuma \line que a vari\'e1vel inteira de controle i tenha sido declarada. inefic \line d) D\'ea dois comandos separados que atribuem o endere\'e7o do in\'edcio do array values \'e0 vari\'e1vel ponteiro vPtr. um aI \line e) Imprima os elementos do array values usando a nota\'e7\'e3o ponteiro/deslocamento. \line\f2\fs30 o \f0\fs16 Imprima os elementos do array values usando a nota\'e7\'e3o ponteiro/deslocamento, com o nome do array como ponteiro. para \line g) Imprima os elementos do array values indexando o ponteiro para o array. deves \line h) Retira-se ao quinto elemento de values usando a nota\'e7\'e3o de subscrito de array, a nota\'e7\'e3o ponteiro/deslocamento esta \line com o nome do array como o ponteiro, a nota\'e7\'e3o de \'edndice de ponteiro e a nota\'e7\'e3o ponteiro/deslocamento. \b\fs12 ShU\'b1 \line\b0\fs16 i) Qual endere\'e7o \'e9 referenciado por vPtr \f2\fs14 + \f0\fs16 3? Qual valor est\'e1 armazenado nesta posi\'e7\'e3o? \f2\fs8 - \line\f0\fs24 j) \fs16 Assumindo-se que vPtr aponta para values \b\f2\fs20 [ \b0\i\f0\fs16 4 \b\i0\f2\fs20 ], \b0\f0\fs16 qual endere\'e7o \'e9 \f3\fs18 referenciado por vptr? Qual \f0\fs16 valor est\'e1 \'e7ao ai \line armazenado nessa posi\'e7\'e3o? depoi \line progr \line 5.10 Para cada um dos seguintes itens, escreva um comando \'fanico que executa a tarefa indicada. Assuma que as vari\'e1veis parar \line inteiras longas valuel e value2 tenham sido declaradas e que valuel tenha sido inicializado. \line a) Declare a vari\'e1vel lPtr como um ponteiro para um objeto do tipo long. \line b) Atribua o endere\'e7o da vari\'e1vel valuel \'e0 vari\'e1vel ponteiro lPtr. \line e) Imprima o valor do objeto apontado por lPtr. A \line\f3\fs18 d) Atribua \f0\fs16 o valor do objeto apontado por lPtr \'e0 vari\'e1vel value2. \line e) Imprima o valor de value2. \line f) Imprima o endere\'e7o de valuel. \line g) Imprima o endere\'e7o armazenado em lPtr. O valor impresso \'e9 o mesmo que o endere\'e7o de valuel? \line 5.11 Fa\'e7a cada um dos seguintes itens. 2 \line a) Escreva o cabe\'e7alho da fun\'e7\'e3o para a fun\'e7\'e3o zero que aceita como argumento um array biglntegers de intei ro \line longos e n\'e3o retoma um valor. \line b) Escreva o prot\'f3tipo da fun\'e7\'e3o para a fun\'e7\'e3o do item (a). \f2\fs8 - \line\b\fs18 Fig. \b0\f0\fs24\par
\b\fs16 380 C++ COMO PROGRAMAR \b0\fs24\par
\f2\fs20 Fig. 5.39 Exemplo de embaralhamento do array deck. \line 5.1 7 \i\f0\fs16 (Simula\'e7\'e3o: a tartaruga e a lebre) \i0\fs18 Neste problema, voc\'ea recriar\'e1 a cl\'e1ssica corrida da tartaruga e a lebre. Voc\'ea usar\'e1 a gera\'e7\'e3o de n\'fameros aleat\'f3rios para desenvolver uma simula\'e7\'e3o deste evento memor\'e1vel. \line Nossos contendores come\'e7am a corrida no \ldblquote quadrado 1\rdblquote  de 70 quadrados. Cada quadrado representa uma posi\'e7\'e3o poss\'edvel ao longo do percurso da corrida. A linha de chegada o quadrado 70. O primeiro contendor que alcan\'e7ar, ou passar, pelo quadrado 70 \'e9 recompensado com um balde de cenouras e alface frescas. O percurso \'e9 em uma montanha escorregadia, ladeira acima. Assim, ocasionalmente os contendores perdem terreno. \line Existe um rel\'f3gio que marca cada segundo. A cada \ldblquote tique\rdblquote  do rel\'f3gio, seu programa deve ajustar a posi\'e7\'e3o dos animais de \line acordo com as seguintes regras: \fs24\par
\fs16 Escorregada 20% 6 quadrados \'e0 esquerda \line Caminhada lenta 30% 1 quadrado \'e0 direita \line Lebre Dorme 20% Nenhum movimento \line Grande pulo 20% 9 quadrados \'e0 direita \line Grande escorregada 1 0% 1 2 quadrados \'e0 esquerda \line Pulo pequeno 30% 1 quadrado \'e0 direita \line Pequena escorregada 20% 2 quadrados \'e0 esquerda \line S\'e3o usadas vari\'e1veis para manter o acompanhamento das posi\'e7\'f5es dos animais (posi\'e7\'f5es s\'e3o os n\'fameros 1 a 70). Cada animal \line come\'e7a na posi\'e7\'e3o 1 (i.e., a \ldblquote faixa de largada\rdblquote ). Se um animal, ao partir do quadrado 1 \f2\fs8 , \f0\fs16 escorregar, volte o animal para o \line quadrado 1. \line Gere as porcentagens na tabela precedente por um meio da gera\'e7\'e3o aleat\'f3ria de um inteiro no intervalo 1 \b\fs14 < \b0\i\fs16 i \b\i0\fs14 < \b0\fs16 10. Para a \line tartaruga, execute uma \ldblquote caminhada r\'e1pida\rdblquote  quando 1 \b\fs14 < \b0\i\fs16 i \b\i0\fs14 < \b0\i\fs16 5, \i0 uma \ldblquote escorregada\rdblquote  quando 6 \f2\fs12 < \i\f0\fs16 i \b\i0\fs14 < \b0\i\fs16 7 \i0 ou uma \ldblquote caminhada lenta\rdblquote  quando 8 \b\fs14 < \b0\i\fs16 i \b\i0\fs14 < \b0\fs16 lO. Use uma t\'e9cnica semelhante para mover a lebre. \line Comece a corrida imprimindo \line\f2 BANG ! l \b\f0\fs14\lquote  !\lquote  \line\f3\fs16 E ELES PARTIRAM \b0\f2\fs12\lquote  \i\f0\fs16 ! \i0\f2\fs8 . \b\f0\fs14 !\lquote  \line\b0\fs16 Para cada \ldblquote tique\rdblquote  do rel\'f3gio (i.e., cada repeti\'e7\'e3o do la\'e7o), imprima uma linha de 70 posi\'e7\'f5es mostrando a letra \b\fs14 T \b0\fs16 na posi\'e7\'e3o da tartaruga e a letra \b\fs14 L \b0\fs16 na posi\'e7\'e3o da lebre. Ocasionalmente, os contendores caem sobre o mesmo quadrado. Neste caso, a tartaruga morde a lebre e seu programa deve imprimirAl \f2\fs12\lquote  \i\f0\fs16 ! ! \i0 come\'e7ando naquela posi\'e7\'e3o. Todas as outras posi\'e7\'f5es de impress\'e3o diferentes de T, L ou o AI ! ! (no caso de um empate) devem estar em branco. \line Depois de imprimir cada linha, teste se um ou outro animal alcan\'e7ou ou passou pelo quadrado 70. Nesse caso, imprima o vencedor e termine a simula\'e7\'e3o. Se a tartaruga ganhar, imprima TARTARUGA VENCE 1 \b\fs14\lquote  \b0\fs16 VALEU \f2\fs8 . \i\f0\fs16 ! ! \i0 Se a lebre ganhar, imprima Lebre ganha \f2\fs8 . \f0\fs16 Ohhh \f2\fs8 . . . \f0\fs16 Se ambos os animais chegarem \'e0 posi\'e7\'e3o 70 no mesmo \ldblquote tique\rdblquote  do rel\'f3gio, voc\'ea pode optar por favorecer a tartaruga (\ldblquote o menos favorecido dos dois\rdblquote ) ou imprimir \'c9 \b\fs14 EMPATE. \b0\fs16 Se nenhum animal ganhar, execute o la\'e7o para simular novamente o pr\'f3ximo \ldblquote tique\rdblquote  do rel\'f3gio. Quando voc\'ea estiver pronto para executar seu programa, junte um grupo de torcedores para assistir \'e0 corrida. Voc\'ea ficar\'e1 admirado ao ver como o p\'fablico fica envolvido! \fs24\par
\pard\par
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx398\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1240\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2031\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx3572\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx3968\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4364\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4760\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx5156\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx5552\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx5948\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx6344\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx6740\pard\intbl\b\f2\fs18 Exe \b0\f0\fs24\cell\b\f2\fs18 mplo do \b0\f0\fs24\cell\b\f2\fs18 array d \b0\f0\fs24\cell\b\f2\fs18 eck embaralhado \b0\f0\fs24\cell\cell\cell\cell\cell\cell\cell\cell\cell\fs20\row
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx398\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1240\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2031\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2544\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx3057\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx3572\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx3968\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4364\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4760\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx5156\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx5552\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx5948\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx6344\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx6740\pard\intbl\fs24\cell\b\f2\fs18 O \b0\f0\fs24\cell\b\f2\fs18 1 \b0\f0\fs24\cell\b\f2\fs18 2 \b0\f0\fs24\cell\b\f2\fs18 3 \b0\f0\fs24\cell\b\f2\fs18 4 \b0\f0\fs24\cell\i\fs16 5 \i0\fs24\cell\i\fs16 6 \i0\fs24\cell\i\fs16 7 \i0\fs24\cell\b\f2\fs18 8 \b0\f0\fs24\cell\b\f2\fs18 9 \b0\f0\fs24\cell\b\f2\fs18 10 \b0\f0\fs24\cell\b\f2\fs18 11 \b0\f0\fs24\cell\b\f2\fs18 12 \b0\f0\fs24\cell\fs20\row
\b\f2\fs18\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx398\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1240\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2031\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2544\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx3057\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx3572\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx3968\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4364\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4760\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx5156\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx5552\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx5948\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx6344\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx6740\intbl O \b0\f0\fs24\cell\b\f2\fs18 19 \b0\f0\fs24\cell\b\f2\fs18 40 \b0\f0\fs24\cell\b\f2\fs18 27 \b0\f0\fs24\cell\b\f2\fs18 25 \b0\f0\fs24\cell\b\f2\fs18 36 \b0\f0\fs24\cell\b\f2\fs18 46 \b0\f0\fs24\cell\b\f2\fs18 10 \b0\f0\fs24\cell\b\f2\fs18 34 \b0\f0\fs24\cell\b\f2\fs18 35 \b0\f0\fs24\cell\b\f2\fs18 41 \b0\f0\fs24\cell\b\f2\fs18 18 \b0\f0\fs24\cell\b\f2\fs18 2 \b0\f0\fs24\cell\b\f2\fs18 44 \b0\f0\fs24\cell\fs20\row
\b\f2\fs18\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx398\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1240\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2031\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2544\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx3057\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx3572\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx3968\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4364\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4760\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx5156\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx5552\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx5948\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx6344\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx6740\intbl 1 \b0\f0\fs24\cell\b\f2\fs18 13 \b0\f0\fs24\cell\b\f2\fs18 28 \b0\f0\fs24\cell\b\f2\fs18 14 \b0\f0\fs24\cell\b\f2\fs18 16 \b0\f0\fs24\cell\b\f2\fs18 21 \b0\f0\fs24\cell\b\f2\fs18 30 \b0\f0\fs24\cell\b\f2\fs18 8 \b0\f0\fs24\cell\b\f2\fs18 11 \b0\f0\fs24\cell\b\f2\fs18 31 \b0\f0\fs24\cell\b\f2\fs18 17 \b0\f0\fs24\cell\b\f2\fs18 24 \b0\f0\fs24\cell\b\f2\fs18 7 \b0\f0\fs24\cell\b\f2\fs18 1 \b0\f0\fs24\cell\fs20\row
\fs18\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx398\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1240\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2031\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2544\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx3057\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx3572\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx3968\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4364\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4760\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx5156\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx5552\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx5948\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx6344\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx6740\intbl 2 \fs24\cell\b\f2\fs18 12 \b0\f0\fs24\cell\b\f2\fs18 33 \b0\f0\fs24\cell\b\f2\fs18 15 \b0\f0\fs24\cell\b\f2\fs18 42 \b0\f0\fs24\cell\b\f2\fs18 43 \b0\f0\fs24\cell\b\f2\fs18 23 \b0\f0\fs24\cell\b\f2\fs18 45 \b0\f0\fs24\cell\b\f2\fs18 3 \b0\f0\fs24\cell\b\f2\fs18 29 \b0\f0\fs24\cell\b\f2\fs18 32 \b0\f0\fs24\cell\b\f2\fs18 4 \b0\f0\fs24\cell\b\f2\fs18 47 \b0\f0\fs24\cell\b\f2\fs18 26 \b0\f0\fs24\cell\fs20\row
\fs18\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx398\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1240\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2031\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2544\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx3057\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx3572\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx3968\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4364\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4760\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx5156\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx5552\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx5948\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx6344\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx6740\intbl 3 \fs24\cell\b\f2\fs18 50 \b0\f0\fs24\cell\b\f2\fs18 38 \b0\f0\fs24\cell\b\f2\fs18 52 \b0\f0\fs24\cell\b\f2\fs18 39 \b0\f0\fs24\cell\b\f2\fs18 48 \b0\f0\fs24\cell\b\f2\fs18 51 \b0\f0\fs24\cell\b\f2\fs18 9 \b0\f0\fs24\cell\b\f2\fs18 5 \b0\f0\fs24\cell\b\f2\fs18 37 \b0\f0\fs24\cell\b\f2\fs18 49 \b0\f0\fs24\cell\b\f2\fs18 22 \b0\f0\fs24\cell\b\f2\fs18 6 \b0\f0\fs24\cell\b\f2\fs18 20 \b0\f0\fs24\cell\fs20\row
\pard\sa240\fs24\par
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx808\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2515\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4501\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx5267\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx6503\pard\intbl\b\fs20 Animal \b0\fs24\cell\b\f2\fs18 Tipo de movimento \b0\f0\fs24\cell\b\f2\fs18 Porcentagem do tempo \b0\f0\fs24\cell\b\f2\fs18 Movim \b0\f0\fs24\cell\b\f2\fs18 ento efetivo \b0\f0\fs24\cell\fs20\row
\fs18\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx808\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2515\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4501\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx5267\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx6503\intbl Tartaruga \fs24\cell\fs18 Caminhada r\'e1pida \fs24\cell\fs18 50% \fs24\cell\fs18 3 quad \fs24\cell\fs18 rados \'e0 direita \fs24\cell\fs20\row
\pard\fs24\par
\pard\sb100\sa240\fs14 CAP\'cdTULO \i\fs16 5 \i0\f2\fs8 - \f0\fs14 PONTEIROS E \i\f2\fs16 STRINGS \b\i0\fs22 381 \b0\f0\fs24\par
\b\i\f2\fs26 Se\'e7\'e3o especial: construindo seu pr\'f3prio computador \b0\i0\f0\fs24\par
\fs16 Nos pr\'f3ximos problemas, faremos um desvio tempor\'e1rio do mundo da programa\'e7\'e3o em linguagens de alto n\'edvel. \ldblquote Descascaremos\rdblquote  um computador e examinaremos sua estrutura interna. Introduziremos a programa\'e7\'e3o em linguagem de m\'e1quina e escreve- remos v\'e1rios programas em linguagem de m\'e1quina. Para fazer desta experi\'eancia uma coisa realmente valiosa, construiremos ent\'e3o um computador (atrav\'e9s da t\'e9cnica de simula\'e7\'e3o por software do mesmo) com o qual voc\'ea poder\'e1 executar seus programas em linguagem de m\'e1quina! \line 5.1k \i (Programa\'e7\'e3o em linguagem de m\'e1quina) \i0 Vamos criar um computador ao qual chamaremos de Simpletron. Como seu nome indica, \'e9 uma m\'e1quina simples, mas, como logo veremos, tamb\'e9m poderosa. O Simpletron executa programas escritos na \'fanica linguagem que ele entende diretamente; isto \'e9, a Simpletron Machine Language ou, abreviadamente, SML. \line\f2\fs26 o \f0\fs16 Simpletron cont\'e9m um registrador especial \i acumulador \i0 em que as informa\'e7\'f5es s\'e3o postas antes do Simpletron usar essas informa\'e7\'f5es em c\'e1lculos ou examin\'e1-la de v\'e1rios modos. Todas as informa\'e7\'f5es no Simpletron s\'e3o manipuladas em termos de palavras. Uma palavra \'e9 um n\'famero decimal de quatro d\'edgitos, com sinal, tal como +3364. -1293, +0007. -0001, etc. O Simpletron \'e9 equipado com uma mem\'f3ria de 100 palavras e estas palavras s\'e3o referenciadas por seus n\'fameros de posi\'e7\'e3o na mem\'f3ria: 00, 01 99. \line Antes de executar um programa em SML, devemos \i carregar \i0 ou colocar o programa na mem\'f3ria. A primeira instru\'e7\'e3o (ou \line comando) de todo programa em SML \'e9 sempre colocada na posi\'e7\'e3o 00 O simulador come\'e7ar\'e1 a execu\'e7\'e3o nesta posi\'e7\'e3o. \line Cada instru\'e7\'e3o escrita em SML ocupa uma palavra da mem\'f3ria do Simpletron (portanto, instru\'e7\'f5es s\'e3o n\'fameros decimais de quatro d\'edgitos com sinal). Devemos assumir que o sinal de uma instru\'e7\'e3o de SML \'e9 sempre mais, por\'e9m o sinal de uma palavra de dados pode ser ou mais ou menos. Cada posi\'e7\'e3o na mem\'f3ria do Simpletron pode conter uma instru\'e7\'e3o, o valor de um dados usado por um programa ou uma \'e1rea de mem\'f3ria n\'e3o-usada (e, conseq\'fcentemente, indefinida). Os primeiros dois d\'edgitos de cada instru\'e7\'e3o em SML s\'e3o o \i c\'f3digo de opera\'e7\'e3o, \i0 que especifica a opera\'e7\'e3o a ser executada. Os c\'f3digos de opera\'e7\'e3o da SML s\'e3o mostrados na Fig. 5.40. \fs24\par
\f2\fs12 e \f0\fs24\par
\b\f2\fs20 Fig. 5.40 C\'f3digos \b0 de opera\'e7\'e3o da Simpletron Machine Language (SML) (parte 1 de 2). \f0\fs24\par
\pard\par
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2108\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx8946\pard\intbl\b\f2\fs20 C\'f3digo de opera\'e7\'e3o \b0\f0\fs24\cell\b\f2\fs20 Significado \b0\f0\fs24\cell\fs20\row
\i\fs16\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2108\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx8946\intbl Opera\'e7\'f5es de entrada/sa\'edda:  \i0\fs14 corist int READ \f2\fs10 = \f0\fs14 10 \fs24\cell\fs18 L\'eaumapalavradotecladoparaumaposi\'e7\'e3oespec\'edficana mem\'f3ria. \fs24\cell\fs20\row
\fs14\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2108\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx8946\intbl const int WRITE \f2\fs10 = \f0\fs14 1 1 ; \fs24\cell\fs18 Escreve uma palavra de uma posi\'e7\'e3o espec\'edfica da mem\'f3ria na tela. \fs24\cell\fs20\row
\i\fs16\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2108\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx8946\intbl Opera\'e7\'f5es de cargaJarmazenamento:  \i0 const int LOAD \f2\fs10 = \f0\fs16 20 ; \fs24\cell\fs18 Carrega uma palavra de uma posi\'e7\'e3o espec\'edfica na me- m\'f3ria para o acumulador. \fs24\cell\fs20\row
\fs16\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2108\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx8946\intbl const int STORE \f2\fs10 = \f0\fs16 21 ; \fs24\cell\fs18 Armazena uma palavra do acumulador em uma posi\'e7\'e3o espec\'edfica da mem\'f3ria. \fs24\cell\fs20\row
\i\fs16\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2108\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx8946\intbl Opera\'e7\'f5es aritm\'e9ticas:  \i0 const int ADD \f2\fs10 = \f0\fs16 30 ; \fs24\cell\fs18 Soma uma palavra de uma posi\'e7\'e3o espec\'edfica na mem\'f3ria \'e0 palavra no acumulador (deixa o resultado no acumula- dor). \fs24\cell\fs20\row
\fs16\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2108\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx8946\intbl const int SUBTRACT \f2\fs10 = \f0\fs16 31 ; \fs24\cell\fs18 Subtrai uma palavra de uma posi\'e7\'e3o espec\'edfica na mem\'f3ria da palavra no acumulador (deixa o resultado no acumulador). \fs24\cell\fs20\row
\fs16\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2108\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx8946\intbl const int DIVIDE \f2\fs10 = \f0\fs16 32 ; \fs24\cell\fs18 Divide a palavra que est\'e1 no acumulador pela palavra de uma posi\'e7\'e3o espec\'edfica na mem\'f3ria (deixa o resultado no acumulador). \fs24\cell\fs20\row
\fs16\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2108\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx8946\intbl const int MULTIPLY \f2\fs10 = \f0\fs16 33 ; \fs24\cell\fs18 Multiplica uma palavra de uma posi\'e7\'e3o espec\'edfica na me- m\'f3ria pela palavra no acumulador (deixa o resultado no acumulador). \fs24\cell\fs20\row
\pard\fs24\par
\pard\sb100\sa240\b\f2\fs16 3S2 C++ COMO PROGRAMAR \b0\f0\fs24\par
\b\f2\fs20 Fig. 5.40 \b0 C\'f3digos de opera\'e7\'e3o da Simpletron Machine Language (SML) (parte 2 de 2). \line\f0\fs16 Os \'faltimos dois d\'edgitos de uma instru\'e7\'e3o de SML s\'e3o o \i operando \i0\f2\fs8 - \f0\fs16 o endere\'e7o da posi\'e7\'e3o de mem\'f3ria que cont\'e9m a palavra \'e0 qual a opera\'e7\'e3o se aplica. \line Agora, vamos examinar v\'e1rios programas simples em SML. O primeiro programa em SML (Exemplo 1 \f2\fs22 ) \f0\fs16 l\'ea dois n\'fameros do teclado e calcula e imprime sua soma. A instru\'e7\'e3o +1007 l\'ea o primeiro n\'famero do teclado e o coloca na posi\'e7\'e3o 07 (que foi inicializada com zero). Ent\'e3o, a instru\'e7\'e3o +1008 l\'ea o pr\'f3ximo n\'famero para a posi\'e7\'e3o 08 \f2\fs8 . \f0\fs16 A instru\'e7\'e3oloadcarrega (copia) o primeiro n\'famero no acumulador e a instru\'e7\'e3o \i add, \i0\f2\fs20 +3008. \f0\fs16 soma o segundo n\'famero ao n\'famero no acumulador. \i Todas as instru\'e7\'f5es aritm\'e9ticas de SML deixam seu resultado no acumulador. \i0 A instru\'e7\'e3o \i store, \i0 +2109. armazena (copia) o resultado de volta na posi\'e7\'e3o de mem\'f3ria 09 de onde a instru\'e7\'e3o \i write, \i0 +1109. pega o n\'famero e imprime o mesmo (como um n\'famero decimal de quatro d\'edgitos com sinal). A instru\'e7\'e3o \i halt, \i0 +4300, termina a execu\'e7\'e3o. \fs24\par
\fs18 O programa em SML do Exemplo 2 l\'ea dois n\'fameros do teclado e determina e imprime o de valor maior. Note o uso da instru\'e7\'e3o +4107 como uma transfer\'eancia de controle condicional, quase a mesma coisa que faz o comando if em C++. \fs24\par
\b\f3\fs16 00 +1009 (Read A) \line 01 +1010 (Read B) \line 02 +2009 (Load A) \line 03 +3110 (Subtract B) \line 04 +4107 (Branch negative to 07) \line 05 +1109 (Write A) \line 06 +4300 (Halt) \line 07 +1110 (Write B) \line 08 +4300 (Halt) \line 09 +0000 (Vari\'e1vel A) \line 10 +0000 (Vari\'e1vel B) \b0\f0\fs24\par
\pard\par
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2703\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx8577\pard\intbl\b\f2\fs20 C\'f3digo de opera\'e7\'e3o \b0\f0\fs24\cell\b\f2\fs20 Sign\'edficado \b0\f0\fs24\cell\fs20\row
\i\fs16\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2703\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx8577\intbl Opera\'e7\'f5es de transfer\'eancia de controle:  \i0 const int BRANCH \f2\fs10 = \f0\fs16 40; \fs24\cell\fs18 Desvia para uma posi\'e7\'e3o espec\'edfica na mem\'f3ria. \fs24\cell\fs20\row
\fs16\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2703\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx8577\intbl const int BRANCHNEG \f2\fs10 = \f0\fs16 41; \fs24\cell\fs18 Desvia para uma posi\'e7\'e3o espec\'edfica na mem\'f3ria se o acumulador for negativo. \fs24\cell\fs20\row
\fs16\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2703\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx8577\intbl const int BRANCHZERO \f2\fs10 = \f0\fs16 42; \fs24\cell\fs18 Desvia para uma posi\'e7\'e3o espec\'edfica na mem\'f3ria se o acumulador for zero. \fs24\cell\fs20\row
\fs16\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2703\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx8577\intbl const int \f2 HALT \fs10 = \f0\fs16 43; \fs24\cell\fs18 Parada-o programa completou sua tarefa. \fs24\cell\fs20\row
\pard\sa240\fs24\par
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1708\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2624\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx3705\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4114\pard\intbl\b\f2\fs20 Exemplo 1 Posi\'e7\'e3o \b0\f0\fs24\cell\b\f2\fs20 N\'famero \b0\f0\fs24\cell\b\f2\fs20 Instru\'e7\'e3o \b0\f0\fs24\cell\cell\fs20\row
\b\f3\fs16\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1708\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2624\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx3705\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4114\intbl 00 \b0\f0\fs24\cell\b\f3\fs16 +1007 \b0\f0\fs24\cell\b\f3\fs16 (Read A) \b0\f0\fs24\cell\cell\fs20\row
\b\f3\fs16\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1708\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2624\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx3705\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4114\intbl 01 \b0\f0\fs24\cell\b\f3\fs16 +1008 \b0\f0\fs24\cell\b\f3\fs16 (Read B) \b0\f0\fs24\cell\cell\fs20\row
\b\f3\fs16\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1708\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2624\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx3705\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4114\intbl 02 \b0\f0\fs24\cell\b\f3\fs16 +2007 \b0\f0\fs24\cell\b\f3\fs16 (Load A) \b0\f0\fs24\cell\cell\fs20\row
\b\f3\fs16\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1708\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2624\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx3705\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4114\intbl 03 \b0\f0\fs24\cell\b\f3\fs16 +3008 \b0\f0\fs24\cell\b\f3\fs16 (Add B) \b0\f0\fs24\cell\cell\fs20\row
\b\f3\fs16\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1708\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2624\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx3705\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4114\intbl 04 \b0\f0\fs24\cell\b\f3\fs16 +2109 \b0\f0\fs24\cell\b\f3\fs16 (Store C) \b0\f0\fs24\cell\cell\fs20\row
\fs18\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1708\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2624\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx3705\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4114\intbl 05 \fs24\cell\b\f3\fs16 +1109 \b0\f0\fs24\cell\b\f3\fs16 (Write C) \b0\f0\fs24\cell\cell\fs20\row
\b\f3\fs16\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1708\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2624\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx3705\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4114\intbl 06 \b0\f0\fs24\cell\b\f3\fs16 +4300 \b0\f0\fs24\cell\b\f3\fs16 (Halt) \b0\f0\fs24\cell\cell\fs20\row
\fs18\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1708\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2624\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx3705\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4114\intbl 07 \fs24\cell\fs18 +0000 \fs24\cell\b\f3\fs16 (Vari\'e1vel \b0\f0\fs24\cell\b\f3\fs16 A) \b0\f0\fs24\cell\fs20\row
\b\f3\fs16\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1708\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2624\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx3705\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4114\intbl 08 \b0\f0\fs24\cell\b\f3\fs16 +0000 \b0\f0\fs24\cell\b\f3\fs16 (Vari\'e1vel \b0\f0\fs24\cell\b\f3\fs16 B) \b0\f0\fs24\cell\fs20\row
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1708\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2624\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4114\pard\intbl\b\f3\fs16 09 \b0\f0\fs24\cell\b\f3\fs16 +0000 \b0\f0\fs24\cell\b\f3\fs12 (C \b0\f2\fs8 - \b\f3\fs12 Resultado) \b0\f0\fs24\cell\fs20\row
\pard\sa240\fs24\par
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2375\pard\intbl\b\f2\fs20 Exemplo 2 \b0\f0\fs24\cell\fs20\row
\b\f2\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2375\intbl Posi\'e7\'e3o N\'famero Instru\'e7\'e3o \b0\f0\fs24\cell\fs20\row
\pard\fs24\par
\pard\sb100\sa240\b\fs14 CAP\'cdTULO \b0\fs16 5 \f2\fs8 - \b\f0\fs14 PONTEIROS E \i STRINGS \i0\f2\fs22 383 \line\b0\f0\fs16 Agora, escreva programas em SML para realizar cada uma das seguintes tarefas. \line a) Use um la\'e7o controlado por uma sentinela para ler n\'fameros positivos e calcular e imprimir sua soma. \line b) Use um la\'e7o controlado por um contador para ler sete n\'fameros, alguns positivos e alguns negativos, e calcular e imprimir sua m\'e9dia. \line c) Leia uma s\'e9rie de n\'fameros e determine e imprima o maior n\'famero. O primeiro n\'famero lido indica quantos n\'fameros devem ser processados. \line o acu 5.1 \line\i (Um simulador de computador) \i0 Poder\'e1, a princ\'edpio, parecer estranho, mas nesse problema voc\'ea vai construir seu pr\'f3prio o acu- 1 computador. N\'e3o, voc\'ea n\'e3o estar\'e1 soldando componentes de hardware. Em vez disso, voc\'ea usar\'e1 a poderosa t\'e9cnica da \i simula\'e7\'e3o \line baseada em software \i0 para criar um \i modelo em software \i0 do Simpletron. Voc\'ea n\'e3o ficar\'e1 desapontado. Seu simulador do Simpletron tornar\'e1 o computador que voc\'ea est\'e1 usando um Simpletron e voc\'ea realmente ser\'e1 capaz de executar. testar e depurar os programas em SML escritos no Exerc\'edcio 5.18. \line Quando voc\'ea executar seu simulador do Simpletron, deve come\'e7ar imprimindo: \line\f2\fs10 *** \b\f3\fs16 Bem-vindo ao Simpletron\rquote  \line\b0\f0 lavra \'e0 \line\f2\fs10 *** \b\f3\fs16 Por favor, digite seu programa, \b0 uma \b instru\'e7\'e3o \line\b0 imeros \f2\fs10 *** \b\f3\fs16 (ou palavra de dados) de cada vez. Eu digitarei o \line\b0 uefoi \f2\fs10 *** \f3\fs16 n\'famero da posi\'e7\'e3o e um ponto de interroga\'e7\'e3o (?) \f2\fs8 . \line\f3\fs16 pia)o \f2\fs10 *** \b\f3\fs16 Ent\'e3o voc\'ea digita a palavra para aquela posi\'e7\'e3o. \line\b0\i instru- \i0\f2\fs10 *** \b\f3\fs16 Digite a sentinela \b0\f2\fs8 - \b\f3\fs16 99999 para terminar a entrada \b0\f2\fs10 *** \line\f0\fs16 evolta \f2\fs10 *** \b\f3\fs16 do seu programa. \b0\f2\fs10 *** \line\f0\fs16 roalde \line Simule a mem\'f3ria do Simpletron com um array memory com 100 elementos. Agora, assuma que o simulador est\'e1 sendo executado, e examinemos o di\'e1logo na medida em que digitamos o programa do Exemplo 2 do Exerc\'edcio 5.18: \line\b\f3 00 ? +1009 \line\b0\f0 01 ? +1010 \line\b\f3 02 ? +2009 \line 03 ? +3110 \line 04 ? +4107 \line 05 ? +1109 \line 06 ? +4300 \line\b0\f0 07 ? +1110 \line\b\f3 08 ? +4300 \line 09 ? +0000 \line\b0\f0 10 ? +0000 \line\b\f3 11 ? -99999 \line\b0\f2\fs10 *** \b\f3\fs16 Carga do programa completa \line\b0 al\'e7\'e3o ***Come\'e7a a execu\'e7\'e3o do programa \line\f0 Agora, o programa em SML foi armazenado no array memory. A seguir, o Simpletron executa seu programa em SML. A execu\'e7\'e3o come\'e7a com a instru\'e7\'e3o na posi\'e7\'e3o 00 e, como em C++, continua na seq\'fc\'eancia, a menos que seja desviada para alguma outra parte do programa por uma transfer\'eancia de controle. \line Use a vari\'e1vel accumulator para representar o registrador acumulador. Use a vari\'e1vel counter para manter o controle da posi\'e7\'e3o na mem\'f3ria que cont\'e9m a instru\'e7\'e3o que est\'e1 sendo executada. Use a vari\'e1vel operationCode para indicar a opera\'e7\'e3o que est\'e1 sendo atualmente executada, i.e., os dois d\'edgitos da esquerda da palavra que cont\'e9m a instru\'e7\'e3o. Use a vari\'e1vel operand para indicar a posi\'e7\'e3o da mem\'f3ria sobre a qual a instru\'e7\'e3o atual opera. Deste modo, operand \'e9 composto pelos dois d\'edgitos mais \'e0 direita da instru\'e7\'e3o que est\'e1 sendo atualmente executada. N\'e3o execute instru\'e7\'f5es diretamente da mem\'f3ria. Em vez disso, transfira apr\'f3xima instru\'e7\'e3o que vai serexecutadadamem\'f3riaparauma vari\'e1vel instructionRegister. Ent\'e3o, \ldblquote retire\rdblquote  os doisd\'edgitos da esquerda e coloque-os em operationCode: \ldblquote retire\rdblquote  os dois d\'edgitos da direita e coloque os mesmos em operand. Quando o Simpletron come\'e7a a execu\'e7\'e3o, os registradores especiais s\'e3o todos inicializados com zero. \line Agora, vamos fazer um \ldblquote passeio\rdblquote  pela execu\'e7\'e3o da primeira instru\'e7\'e3o de SML. +1009, na posi\'e7\'e3o de mem\'f3ria 00. Isto \line\'e9 chamado de um \i ciclo de execu\'e7\'e3o de instru\'e7\'e3o. \line\b\i0\f3 O counter nos diz \b0\f0 a posi\'e7\'e3o da pr\'f3xima instru\'e7\'e3o a ser executada. Pegamos o conte\'fado dessa posi\'e7\'e3o de memory usando o comando de \b\f3 C++ \line instructionRegister \b0\f2\fs10 = \b\f3\fs16 memory[ counter ]; \b0\f0\fs24\par
\f1\fs122 J \f0\fs24\par
\b\f2\fs22 384 \b0\fs26 c++ \b\fs16 COMO \f0\fs14 PROGRAMAR \line\b0\f2\fs26 o \f0\fs16 c\'f3digo de opera\'e7\'e3o e o operando s\'e3o extra\'eddos do registrador de instru\'e7\'e3o pelos comandos \line\f3\fs18 operationCode \f2\fs10 = \f3\fs18 instructionRegister \b\f2\fs22 / \b0\f3\fs18 100; \line operand \f2\fs10 = \f3\fs18 instructionRegister % 100; \line\f0\fs16 Agora, o Simpletron deve determinar que o c\'f3digo da opera\'e7\'e3o \'e9 realmente um \i\f2\fs18 read (versus \i0\f0\fs16 um \i\f2\fs18 write, \i0\f0\fs16 um \i\f2\fs18 load, \i0\f0\fs16 etc.). Um comando \b switch \b0 diferencia as doze opera\'e7\'f5es de SML. \line Na estrutura switch, o comportamento de v\'e1rias instru\'e7\'f5es de SML \'e9 simulado como segue (deixamos as outras para o \line leitor): \line\i\f2\fs18 read: \b\i0\f0\fs16 cm \'bb memory[ operand ]; \line\b0\i load: \i0 accumulator \f2\fs10 = \b\f0\fs16 memory \f2\fs22 [ \f0\fs16 operand ]; \line\b0\i\f3\fs18 add: \i0 accumulator \b\f0\fs14 += \b0\f3\fs18 memory[ operand ]; \line\i\f0\fs16 branch: \i0 Discutiremos as instru\'e7\'f5es de desvio em breve. \line\i halt: \i0 Esta instru\'e7\'e3o imprime a mensagem \line\f3\fs18 ***Execu\'e7\'e2o do Simpletron terminada \f2\fs10 *** \line\f0\fs16 Ela ent\'e3o imprime o nome e conte\'fado de cada registrador, como tamb\'e9m o conte\'fado completo de mem\'f3ria. Tal relat\'f3rio \'e9 freq\'fcentemente chamado de \i dump de computador \i0 (n\'e3o, um \i dump \i0 de computador n\'e3o \'e9 um lugar para onde os computadores velhos v\'e3o). Para ajud\'e1-lo a programar sua fun\'e7\'e3o \i dump, \i0 um exemplo do formato do \i dump \'e9 \i0 mostrado na Fig.5.41 \f2\fs8 . \f0\fs16 Note que um \i dump, \i0 depois de ser executado um programa de Simpletron, mostraria os valores reais de instru\'e7\'f5es e dados no momento do t\'e9rmino da execu\'e7\'e3o. \line\f2 REGISTRADORES: \line\f3\fs18 acumulator +0000 \line\b\f0\fs16 counter 00 \line\b0\f3\fs18 iristructionRegister +0000 \line operationCode 00 \line operand 00 \line\f0\fs16 MEM\'d3RIA: \line O 1 2 3 4 5 6 7 8 9 \line O +0000 +0000 +0000 +0000 +0000 +0000 +0000 +0000 +0000 +0000 \line\f3\fs18 10 +0000 +0000 +0000 +0000 +0000 +0000 +0000 +0000 +0000 +0000 \line 20 +0000 +0000 +0000 +0000 +0000 +0000 +0000 +0000 +0000 +0000 \line 30 +0000 +0000 +0000 +0000 +0000 +0000 +0000 +0000 +0000 +0000 \line\b\f0\fs16 40 +0000 +0000 +0000 +0000 +0000 +0000 +0000 +0000 +0000 +0000 \line\b0 50 +0000 +0000 +0000 +0000 +0000 +0000 +0000 +0000 +0000 +0000 \line\f3\fs18 60 +0000 +0000 +0000 +0000 +0000 +0000 +0000 +0000 +0000 +0000 \line 70 +0000 +0000 +0000 +0000 +0000 +0000 +0000 +0000 +0000 +0000 \line 80 +0000 +0000 +0000 +0000 +0000 +0000 +0000 +0000 +0000 +0000 \line 90 +0000 +0000 +0000 +0000 +0000 +0000 +0000 +0000 +0000 +0000 \line\b\f2 Fig. \b0\fs20 5.41 Exemplo de \i\fs18 dump. \line\i0\f0\fs16 Vamos continuar com a execu\'e7\'e3o da primeira instru\'e7\'e3o do nosso programa \f2\fs8 - \b\f0\fs16 +100 9 na posi\'e7\'e3o de mem\'f3ria 00. Como \b0 indicamos, o comando switch simula esta execu\'e7\'e3o com o comando de C++ \line\f3\fs18 cm \f2\fs20\'bb \b\f0\fs16 memory[ operarid ]; \line\b0\f3\fs18 Um \f0\fs16 ponto de interroga\'e7\'e3o \f3\fs18 (?)deve ser exibido na tela, antes do cm ser executado, para solicitar que o usu\'e1rio forne\'e7a um dado de \f0\fs16 entrada. O Simpletron espera o usu\'e1rio digitar um valor e apertar a tecla \i Return. \b\i0 O valor \'e9 ent\'e3o \b0 armazenado na posi\'e7\'e3o \f3\fs18 09. \f0\fs24\par
\fs16 CAP\'cdTULO \i\f2\fs20 5 \i0\fs8 - \f0\fs16 PONTEIROS E \b\i\fs14 STRJNGS \i0\f2\fs22 385 \line\b0\f0\fs16 Nesse momento, a simula\'e7\'e3o da primeira instru\'e7\'e3o est\'e1 completa. Tudo que falta \'e9 preparar o Simpletron para executar a pr\'f3xima instru\'e7\'e3o. Uma vez que a instru\'e7\'e3o que acabou de ser executada n\'e3o era uma transfer\'eancia de controle, necessitamos somente incrementar o registrador contador de instru\'e7\'f5es, como segue: \line ++counter; \line isso completa a execu\'e7\'e3o simulada da primeira instru\'e7\'e3o. O processo inteiro (i.e., o ciclo de execu\'e7\'e3o da instru\'e7\'e3o) come\'e7a novamente, com a busca da pr\'f3xima instru\'e7\'e3o a ser executada. \line Consideremos, agora, como instru\'e7\'f5es de desvio \f2\fs8 - \f0\fs16 transfer\'eancias de controle \f2\fs8 - \f0\fs16 s\'e3o simuladas. Tudo o que necessitamos \line fazer \'e9 ajustar o valor no contador de instru\'e7\'f5es apropriadamente. Ent\'e3o, a instru\'e7\'e3o de branch incondicional ( 4 O ) \'e9 simulada dentro da estrutura switch como \line\b\f3 counter \b0\f2\fs12 = \b\f3\fs16 operand; \line\b0\f2\fs26 o \f0\fs16 desvio condicional branchzero (desvia se o acumulador for zero) \'e9 simulado como \line if \i\f2\fs20 ( \i0\f0\fs16 accumulator \f2\fs12 == \b\f3\fs16 O) \line couriter \b0\f2\fs12 = \b\f3\fs16 operand; \line\b0\f0 Nesse ponto, voc\'ea deveria implementar seu simulador do Simpletron e executar cada um dos programas em SML que voc\'ea escreveu no Exerc\'edcio 5.18. Voc\'ea pode enfeitar a SML com caracter\'edsticas adicionais e incorporar essas ao seu simulador. \line Seu simulador deve verificar v\'e1rios tipos de erros. Durante a fase de carga do programa, por exemplo, cada n\'famero que o usu\'e1rio digita para memory no Simpletron deve estar no intervalo -9999 a +999. Seu simulador deve usar um la\'e7o while para testar se cada n\'famero fornecido est\'e1 nesse intervalo e, se n\'e3o estiver, continuar solicitando ao usu\'e1rio paira redigitar o n\'famero at\'e9 que forne\'e7a um n\'famero correto. \line Durante a fase de execu\'e7\'e3o, seu simulador deveria testar a ocorr\'eancia de v\'e1rios erros s\'e9rios, tais como tentativas de divis\'e3o por zero, tentativas de execu\'e7\'e3o de c\'f3digos de opera\'e7\'f5es inv\'e1lidas, estouros \i (overflow) \i0 do acumulador (i.e., opera\'e7\'f5es aritm\'e9ticas que resultam em valores maiores do que + 9 9 9 9 ou menores do que \f2\fs8 - \f0\fs16 9 9 9 9) e coisas semelhantes. Tais erros s\'e9rios s\'e3o chamados de \i errosfatais. \i0 Quando um erro fatal \'e9 descoberto, seu simulador deveria imprimir uma mensagem de erro tal como: \line\f2\fs10 *** \b\f3\fs16 Tentativa de dividir por zero \line\b0\f2\fs10 *** \b\f3\fs16 Execu\'e7\'e3o do Simpletron terminada anormalmente \b0\f2\fs10 *** \line\f0\fs16 e imprimir um \i dump \i0 completo de computador no formato que \fs20 j\'e1 \fs16 discutimos anteriormente. Isto ajudar\'e1 o usu\'e1rio a localizar o erro no programa. \line\b\i\f2\fs24 Mais exerc\'edcios sobre ponteiros \line\b0\i0\f0\fs16 5.20 Modifique o programa de embaralhar e distribuir cartas da Fig. 5.24, de maneira que o embaralharamento e a retirada sejam executados pela mesma fun\'e7\'e3o (shuffleAndDeai). A fun\'e7\'e3o deveria conter uma estrutura de la\'e7os aninhados semelhante \'e0 fun\'e7\'e3o shuffle na Fig. 5.24. \line 5.21 O que faz esse programa? \line\b\f3 1 \b0\i\f2\fs20 II \i0\f0\fs16 ex0521.cpp \line\b\f3 2 #include <iostream> \line 3 \line 4 using std::cout; \line 5 using std::cin; \line 6 using std::endl; \line 7 \line 8 void mysteryl( char \b0\f2\fs8\lquote , \b\f3\fs16 const char \b0\f2\fs10 * \line\f0\fs16 9 \line\b\f3 10 int main \f2\fs22 O \line\f3\fs16 11 \line 12 char stringl \f2\fs22 [ \f3\fs16 80 \f2\fs22 ) \b0\fs8 , \b\f3\fs16 string2 \f2\fs22 [ \f3\fs16 80 \f2\fs22 ] \line\f3\fs16 13 \b0\f0\fs24\par
\f2\fs20 386 \fs28 c++ \f0\fs14 COMO \f2 PROGRAMAR \line\f3\fs16 14 cout \f2\fs20\'ab \f3\fs16\ldblquote Forne\'e7a dois strings: \f2\fs10\ldblquote ; \line\f3\fs16 15 cio \'bb stringl \'bb string2; \line 16 mysteryl( stringl, string2 ); \line 17 cout \'ab stringl \'ab endi; \line 18 return O; \line\f0\fs14 19 \f2\fs20\} \line\f3\fs16 20 \line 21 void mysteryl \f2\fs20 ( \f3\fs16 char *sl, const char *s2 \line 22 \line 23 while \f2\fs20 ( \f3\fs16 *sl \f0\fs14 ! \f3\fs16\lquote\\O\rquote  \line 24 ++sl; \line 25 \line 26 for \f2\fs20 ( \f0\fs14 ; \f3\fs16 si *s2; si++, s2++ \line 27 \f0\fs14 ; \i\f3\fs20 II \i0\fs16 comando vazio \line 28 \f2\fs20\} \line 5.22 O \f0\fs16 que faz este programa ? \line\f3 1 \i\fs20 II \i0\fs16 exOS_22.cpp \line 2 #inciude <iostream> \line 3 \line 4 using std::cout; \line 5 using std::cin; \line 6 using std: :endi; \line 7 \line 8 int miystery2 \f2\fs20 ( \f3\fs16 const char \f2\fs10 * \f3\fs16 ); \line 9 \line\fs24 io \fs16 int main O \line\f0\fs14 ii \f2\fs20\{ \line\f3\fs16 12 char string[ 80 \f2\fs20 1; \line\f3\fs16 13 \line 14 cout \'ab Forne\'e7a um string: ; \line 15 cm \'bb string; \line 16 cout \'ab mystery2( string \f2\fs20 ) \'ab \f3\fs16 endi; \line 17 return 0; \line 18 J \line 19 \line 20 int mystery2( const char *s \line 21 \f2\fs20\{ \line\f3\fs16 22 int x; \line 23 \line 24 for \f2\fs20 ( \b\fs16 x \b0\f0\fs14 = \f3\fs16 0; \lquote\\O\rquote ; s++ \line 25 ++x; \line 26 \line 27 return x; \line 28 \f2\fs20\} \line\f0\fs16 5.23 Ache o erro em cada um dos seguintes segmentos de programa. Se o erro puder ser corrigido, explique como. \line a) int \line cout \f2\fs20\'ab \f0\fs16 nuinber \f2\fs20\'ab \f0\fs16 endi; \line b) double *realptr; \line\f3 long *mntegerPtr; \line integerPtr \f0\fs14 = \f3\fs16 realPtr; \line c) int \f2\fs10 * \b\fs16 x, \b0\f3 y; \line\b\f2 x \b0\f0\fs14 = \f3\fs16 y; \f0\fs24\par
\fs16 CAP\'cdTULO 5 \f2\fs8 - \b\fs14 PONTEIROS E \i\f0 STRINGS \i0\f2\fs22 387 \line\b0\f0\fs16 d) char s[ ] \ldblquote este \'e9 um array de caracteres; \line\b\f3 for \f2\fs22 ( \b0\f0\fs16 ; \b\f3 *s \b0\fs14 != \lquote\\O\rquote ; \b\fs16 s++) \line cout \b0\f0\'ab \b\f3 *s \b0\f0\'ab \f2\fs8\lquote  \line\f0\fs16 e) short *fljjflp, result; \line\b\f3 void *genericptr \b0\fs14 = numPtr; \line\f0\fs16 result=*genericPtr + 7; \line\f3\fs14 f) double x 19.34; \line double xPtr = \line\b\fs16 cout \'ab xPtr \'ab endi; \line g) char *S; \line cout \'ab s\'ab endi; \line\b0\f0 5.24 \i (Quicksort) \i0 Nos exemplos e exerc\'edcios do Cap\'edtulo 4, discutimos as t\'e9cnicas de classifica\'e7\'e3o \i bubble sort, bucket sort \i0 e \i selection sort. \i0 Agora, apresentamos a t\'e9cnica recursiva de classifica\'e7\'e3o \i Quicksort. \i0 O algoritmo b\'e1sico para um array unidimensional de valores \'e9 como segue: \line a) \i Etapa de particionamento: \i0 pegue o primeiro elemento do array n\'e3o-classificado e determine sua posi\'e7\'e3o final no array classificado, i.e., todos os valores \'e0 esquerda de um elemento no array s\'e3o menores que o elemento e todos os valores \'e0 direita de um elemento no array s\'e3o maiores que o elemento. Agora, temos um elemento em sua posi\'e7\'e3o correta e dois subarrays n\'e3o-classificados. \line b) \i Etapa recursiva: \i0 execute a etapa 1 para cada subarray n\'e3o-classificado. \line Cada vez que a etapa 1 \'e9 executada sobre um subarray, outro elemento \'e9 colocado em sua posi\'e7\'e3o final do array classificado e dois subarrays n\'e3o-classificados s\'e3o criados. Quando um subarray consiste em apenas um elemento, ele deve estar classificado, ent\'e3o esse elemento est\'e1 em sua posi\'e7\'e3o final. \line\f2\fs26 o \f0\fs16 algoritmo b\'e1sico parece bastante simples, mas como \'e9 que n\'f3s determinamos a posi\'e7\'e3o final do primeiro elemento de cada subarray? Por exemplo, considere o seguinte conjunto de valores (o elemento em negrito \'e9 o elemento particionador, que ser\'e1 colocado em sua posi\'e7\'e3o final no array classificado): \line\b\f3 37 \b0 2 6 4 89 8 10 12 68 45 \line\f0 a) A partir do elemento mais \'e0 direita do array, compare cada elemento at\'e9 que um elemento menor que 37 seja achado, e ent\'e3o troque 37 e esse elemento de posi\'e7\'e3o. O primeiro elemento menor que 37 \'e9 12, assim 37 e 12 s\'e3o trocados. \f2\fs26 o \f0\fs16 novo array fica: \line\i 12 \i0 2 6 4 89 8 10 37 68 45 \line\f2\fs26 o \f0\fs16 elemento 12 est\'e1 em it\'e1lico para indicar que acabou de ser trocado com 37. \line b) A partir da esquerda do array, mas come\'e7ando com o elemento depois de 12, compare cada elemento at\'e9 que um elemento maior que 37 seja encontrado, ent\'e3o troque 37 com esse elemento. O primeiro elemento maior que 37 \'e9 89, assim 37 e 89 s\'e3o trocados. O novo array fica: \line\b\f3 12 \b0\f0 2 6 4 37 8 10 \i 89 \i0 68 45 \line e) A partir da direita, mas come\'e7ando com o elemento antes de 89, compare cada elemento at\'e9 que um elemento menor que 37 seja achado, ent\'e3o troque 37 com esse elemento. O primeiro elemento menor que 37 \'e9 10, assim 37 e 10 s\'e3o trocados. O novo array fica: \line\b\f3 12 \b0\f0 2 6 4 \i 10 \i0 8 37 89 68 45 \line d) A partir da esquerda, mas come\'e7ando com o elemento depois de 10, compare cada elemento at\'e9 que um elemento maior que 37 seja achado, ent\'e3o troque 37 com esse elemento. N\'e3o existem mais elementos maiores que 37, de modo que, quando comparamos 37 com ele mesmo, sabemos que 37 foi colocado em sua posi\'e7\'e3o final no array ordenado. \line\b\f2\fs14\lquote  \b0\f0\fs16 Uma vez que a parti\'e7\'e3o tenha sido aplicada sobre o array acima, existem dois subarrays n\'e3o-classificados. O subarray com valores menores que 37 cont\'e9m 12, 2, 6, 4, lO e 8. O subarray com valores maiores que 37 cont\'e9m 89, 68 e 45. A classifica\'e7\'e3o \line continua com ambos os subarrays sendo particionados da mesma maneira que o array original. \line Baseado na discuss\'e3o precedente, escreva a fun\'e7\'e3o recursiva quickSort para classificar um array de inteiros unidimensional. A fun\'e7\'e3o deveria receber como argumentos um array de inteiros, um subscrito de in\'edcio e um subscrito de fim. A fun\'e7\'e3o partition deveria ser chamada por quickSort para executar o passo de particionamento. \fs24\par
\b\f2\fs18 388 \b0\fs28 c++ \f0\fs16 COMO PROGRAMAR \line 5.25 \i (Travessia de um labirinto) \i0 A seguinte grade de sustenidos (#) e pontos ( \f2\fs8 . \b\fs18 ) \b0\i\f0\fs16\'e9 \i0 uma representa\'e7\'e3o de um labirinto como um array bidimensional \line ############ \line\f2\fs12 #_ \b . \b0 _# \b .....- \line ###.#. . . \line #. . . _###.#. \b0\fs8 - \line\f0\fs16 #### \b\f2\fs12 . # . # . # . # \line\b0\f0\fs16 # \f2\fs8 . \b\fs12 . # . # . # . # . \line\b0\f0\fs16 # # \f2\fs8 - \b\fs18 # \b0\fs8 - \b\fs18 # \b0\fs8 . \b\fs18 # \b0\fs8 . \b\fs18 # \fs12 - # \line\fs18 # \fs12 . #.# \line\fs18 ###### \fs12 . ### . # \line\fs18 # \fs12 . \b0 #_ \b . \line\fs18 ############ \line\b0\f0\fs16 No array bidimensional precedente, os sustenidos (#) representam as paredes do labirinto e os pontos representam quadrados nos caminhos poss\'edveis atrav\'e9s do labirinto. Os movimentos s\'f3 podem ser feitos para uma posi\'e7\'e3o no array que cont\'e9m um ponto. \line Existe um algoritmo simples para atravessar um labirinto que garante que se encontre a sa\'edda (assumindo-se que exista uma sa\'edda). Se n\'e3o existir uma sa\'edda, voc\'ea chegar\'e1 novamente \'e0 posi\'e7\'e3o de in\'edcio no labirinto. Coloque sua m\'e3o direita sobre a parede \'e0 sua direita e comece a caminhar para frente. Nunca remova a m\'e3o da parede. Se o labirinto vira para a direita, voc\'ea segue a parede \'e0 direita. Desde que n\'e3o remova a m\'e3o da parede, eventualmente voc\'ea chegar\'e1 \'e0 sa\'edda do labirinto. Pode haver um caminho menor que aquele que voc\'ea tomou, mas voc\'ea estar\'e1 seguro de que sair\'e1 do labirinto se seguir o algoritmo proposto. \line Escreva a fun\'e7\'e3o recursiva mazeTraverse para caminhar atrav\'e9s do labirinto. A fun\'e7\'e3o deveria receber como argumentos um array de caracteres 1 2 por 1 2 representando o labirinto e a posi\'e7\'e3o inicial no mesmo. A medida que mazeTraverse tenta localizar a sa\'edda do labirinto. deve colocar o caractere x em cada quadrado no caminho. A fun\'e7\'e3o deveria exibir o labirinto depois de cada movimento; assim; o usu\'e1rio pode assistir como a travessia do labirinto \'e9 resolvida. \line\b\f2\fs18 5.26 \b0\i\f0\fs16 (Gerando labirintos aleatoriamente) \i0 Escreva uma fun\'e7\'e3o mazeGenerator que aceita como um argumento um array de caracteres bidimensional, de 12 por 12, e produz aleatoriamente um labirinto. A fun\'e7\'e3o deveria tamb\'e9m fornecer as posi\'e7\'f5es de in\'edcio e de fim do labirinto. Teste sua fun\'e7\'e3o mazeTraverse do Exerc\'edcio \i 5.25 \i0 usando v\'e1rios labirintos gerados aleatoriamente. \line\b\f2\fs12 5.27 \b0\i\f0\fs16 (Labirintos de qualquer tamanho) \i0 Generalize as fun\'e7\'f5es mazeTraverse e mazeGenerator dos Exerc\'edcios 5.25 e \line\b\f2\fs12 5.26 \b0\f0\fs16 para trabalhar com labirintos de qualquer largura e comprimento. \line 5.28 \i (Arrays de ponteiros de fun\'e7\'f5es) \i0 Reescreva o programa da Fig. 4.23 para usar uma interface orientada por menus. O programa deveria oferecer ao usu\'e1rio 5 op\'e7\'f5es, como segue (estas deveriam ser exibidas na tela): \line Digite uma op\'e7\'e3o: \line\f3\fs24 o \b\fs16 Imprimir o array de notas \line 1 Achar a nota m\'ednima \line\f2\fs12 2 \f3\fs16 Achar a nota m\'e1xima \line 3 Imprimir a m\'e9dia de todas as provas para cada estudante \line\b0\i\f0 4 \b\i0\f3 Encerrar o programa \line\b0\f0 Uma restri\'e7\'e3o sobre o uso de arrays de ponteiros para fun\'e7\'f5es \'e9 que todos os ponteiros devem ser do mesmo tipo. Os ponteiros devem apontar para fun\'e7\'f5es com o mesmo tipo de retorno e que recebem argumentos do mesmo tipo. Por essa raz\'e3o, as fun\'e7\'f5es na Fig. 4.23 devem ser modificadas, de modo que elas retomem o mesmo tipo e aceitem os mesmos argumentos. Modifique as fun\'e7\'f5es minimum e maximum para imprimir o valor do m\'ednimo ou do m\'e1ximo e n\'e3o retomar nada. Para a op\'e7\'e3o 3, modifique a fun\'e7\'e3o average da Fig. 4.23 para mostrar na sa\'edda a m\'e9dia para cada estudante (n\'e3o um estudante espec\'edfico). A fun\'e7\'e3o average n\'e3o deveria retomar valores e aceitar os mesmos argumentos que printArray, minimum e \b maximum. \b0 Armaze \fs24\par
\fs16 ne os ponteiros para as quatro fun\'e7\'f5es no array processGrades e use a op\'e7\'e3o digitada pelo usu\'e1rio como \'edndice para o array para chamar cada fun\'e7\'e3o. \line 5.29 \i (Modifica\'e7\'f5es no simulator do Simpletron) \i0 No Exerc\'edcio 5. 1 9, voc\'ea escreveu uma simula\'e7\'e3o, em software, de um computador que executa programas escritos na Simpletron Machine Language (SML). Neste exerc\'edcio, propomos-lhe v\'e1rias modifica- \'e7\'f5es e melhnria para o Simulator Simpletron. Nos Exerc\'edcios 15.26 e 15.27. propomos construir um compilador que converte programas escritos em uma linguagem de programa\'e7\'e3o de alto n\'edvel (uma varia\'e7\'e3o de BASIC) para a SML. Algumas das modifica\'e7\'f5es e melhorias seguintes podem ser necess\'e1rias para executar os programas produzidos pelo compilador. \i (Nota: \i0 algumas modifica\'e7\'f5es podem conflitar com outras e, portanto, precisam ser feitas separadamente.) \line a) Estenda a mem\'f3ria do Simulador do Simpletron para conter 1000 posi\'e7\'f5es de mem\'f3ria para possibilitar ao Simpletron processar programas maiores. \line b) Permita que o simulador execute c\'e1lculos com o operador m\'f3dulo. Isto exige uma instru\'e7\'e3o adicional na Simpletron Machine Language. \line e ) Permita que o simulador execute c\'e1lculos de exponencia\'e7\'e3o. Isto exige uma instru\'e7\'e3o adicional na Simpletron Machine Language. \line d) Modifique o simulador para usar valores hexadecimais em lugar de valores inteiros para representar instru\'e7\'f5es da Simpletron Machine Language. \line e) Modifique o simulador para permitir a exibi\'e7\'e3o/impress\'e3o de um caractere nova linha. Isto exige uma instru\'e7\'e3o adicional na Simpletron Machine Language. \line f) Modifique o simulador para processar valores de ponto flutuante, al\'e9m de valores inteiros. \line g) Modifique o simulador para tratar entrada por \i strings. \i0 Sugest\'e3o: cada palavra do Simpletron pode ser dividida em dois grupos, cada um mantendo um inteiro de dois d\'edgitos. Cada inteiro de dois d\'edgitos representa o equivalente, em decimal, ao c\'f3digo ASCII de um caractere. Adicione uma instru\'e7\'e3o de linguagem de m\'e1quina que aceitar\'e1 como entrada um \i string \i0 e armazenar\'e1 o in\'edcio do mesmo em uma posi\'e7\'e3o de mem\'f3ria espec\'edfica do Simpletron. A primeira metade da palavra nessa posi\'e7\'e3o ser\'e1 o n\'famero de caracteres no \i string \i0 (i.e., o comprimento do \i string). \i0 Cada meia palavra sucessiva conter\'e1 um caractere ASCII expresso como dois d\'edgitos decimais. A instru\'e7\'e3o de linguagem de m\'e1quina converte cada caractere para o seu equivalente em ASCII e atribui o mesmo a uma meia palavra. \line h) Modifique o simulador para tratar a sa\'edda de \i strings \i0 armazenados no formato do item (g). Sugest\'e3o: acrescente uma instru\'e7\'e3o de linguagem de m\'e1quina que imprimir\'e1 um \i string \i0 que come\'e7a em uma determinada posi\'e7\'e3o de mem\'f3ria do Simpletron. A primeira metade da palavra nessa posi\'e7\'e3o \'e9 o n\'famero de caracteres no \i string \i0 (i.e., o comprimento do \i string). \i0 Cada meia palavra subseq\'fcente cont\'e9m um caractere ASCII expresso como dois d\'edgitos decimais. A instru\'e7\'e3o de linguagem de m\'e1quina confere o comprimento e imprime o \i string, \i0 traduzindo cada n\'famero de dois d\'edgitos para o seu caractere equivalente. \line i) Modifique o simulador para incluir a instru\'e7\'e3o SMLDEBUG. que imprime um \i dump \i0 de mem\'f3ria depois que cada instru\'e7\'e3o \'e9 executada. Atribua o c\'f3digo de opera\'e7\'e3o 44 a S4LDEBUG. A palavra +4401 liga o modo de depura\'e7\'e3o e +4400 desliga o modo de depura\'e7\'e3o. \line 5.3() O que faz esse programa? \line\b\f3 1 \b0\i\fs20 II \b\i0\fs16 ex0530.cpp \line 2 #include <iostream> \line 3 \line 4 using std: :cout; \line 5 using std::cin; \line 6 using std::endl; \line 7 \line 8 bool mystery3( const char \b0\f2\fs8\lquote , \b\f3\fs16 corist char \b0\f2\fs10 * \line\f0\fs16 9 \line\f3\fs18 lo \b\fs16 int main \b0\f0 O \line\f3\fs18 11 \f0\fs16\{ \line\b\f3 12 char stringl[ 80 \b0\f0 ], \b\f3 string2[ 80 ]; \line 13 \line 14 cout \'ab \lquote Forne\'e7a dois strings: \b0\f2\fs10\ldblquote ; \line\b\f3\fs16 15 cm \'bb stringl \'bb string2; \line 16 cout \'ab \ldblquote O resultado \'e9 \line 17 \b0\f0\'ab \b\f3 miystery3( stringl, string2 \b0\f0 ) \'ab \b\f3 endi; \line 18 \b0\f0\fs24\par
\fs16 CAP\'cdTULO 5 \f2\fs8 - \b\fs14 PONTEIROS E \i\f0 STRINGS \i0\f2\fs22 389 \b0\f0\fs24\par
\f1\fs134 1 \f0\fs24\par
\b\f3\fs16 19 return O; \line 20 \b0\f0\fs24\par
\b\f2\fs18 390 \b0\fs28 c++ \b\fs14 COMO PROGRAMAR \line\f3\fs16 21 \line 22 bool mystery3( const char *s1, const char *s2 \line 23 \f2\fs18\{ \line\f3\fs16 24 for \f2\fs18 ( ; \f3\fs16 *s1 \f2\fs14 != \f3\fs16\lquote\\O\rquote  && *s2 \f2\fs14 = \f3\fs16\lquote\\O\rquote ; sl++, s2++ \line 25 \line 26 if \f2\fs18 ( \f3\fs16 *s1 \f2 != \f3 *s2 \line 27 return false; \line 28 \line 29 return true; \line\f2 30 \line\i\fs24 Exerc\'edcios de manipula\'e7\'e3o de strings \line\i0\fs16 5.31 \b0\f0 Escreva um programa que usa a fun\'e7\'e3o strcmp para comparar dois \i strings \i0 fornecidos como entrada pelo usu\'e1rio. O programa deveria informar se o primeiro \i string \i0\'e9 menor do que, igual a ou maior do que o segundo \i sfring. \line\b\i0\f2 5.32 \b0\f0 Escreva um programa que usa a fun\'e7\'e3o s trncmp para comparar dois \i strings \i0 fornecidos pelo usu\'e1rio. O programa deveria receber como entrada o n\'famero de caracteres a serem comparados. O programa tamb\'e9m deveria informar se o primeiro string \'e9 menor do que, igual a ou maior do que o segundo \i string. \line\i0 5.33 Escreva um programa que usa a gera\'e7\'e3o de n\'fameros aleat\'f3rios para criar frases. O programa deve usar quatro arrays de ponteiros do tipo char, chamados artigo, substantivo, verbo e preposicao. O programa deve criar uma senten\'e7a selecionando uma palavra ao acaso de cada array, na seguinte ordem: artigo. substantivo, verbo. preposicao. ar- tigo e substantivo. A medida que cada palavra \'e9 escolhida, ela deve ser concatenada com as palavras precedentes em um array grande o bastante para conter toda a frase. As palavras devem ser separadas por espa\'e7os. Quando a frase final for mostrada na sa\'edda, ela deve come\'e7ar com uma letra mai\'fascula e terminar com um ponto final. O programa deve gerar 20 dessas frases. \line Os arrays devem ser preenchidos como segue: o array artigo deve conter os artigos \ldblquote o\rdblquote , \ldblquote a\rdblquote . \ldblquote um\rdblquote , \ldblquote uma, \ldblquote ai- gum\rdblquote  e \ldblquote qualquer\rquote ; o array substantivo deve conteros substantivos menino. \ldblquote menina\rdblquote , \ldblquote cachorro\rdblquote . \ldblquote cidade \f2\fs8\lquote  \f0\fs16 e \f2\fs8\ldblquote  \f0\fs16 carro \f2\fs8\ldblquote  \b\f3\fs16 ; \b0\f0 o array verbo deve conter os verbos \ldblquote dirigiu\rdblquote , \lquote pulou\rdblquote  \f2\fs8 , \ldblquote  \f0\fs16 correu \f2\fs8\ldblquote  , \ldblquote  \f0\fs16 caminhou \f2\fs8\ldblquote  \f0\fs16 e \f2\fs8\lquote  \f0\fs16 saltou \f2\fs8\ldblquote  \b\f3\fs16 ; \b0\f0 o array preposi\'e7\'e3o deve conter as preposi\'e7\'f5es \ldblquote para\rdblquote , \lquote de\rdblquote , \ldblquote acima de\rdblquote , \ldblquote debaixo de\rdblquote  e \ldblquote sobre\rdblquote . \line Depois do programa precedente estar escrito e funcionando, modifique o programa para produzir uma pequena hist\'f3ria \line consistindo em v\'e1rias destas frases (que tal a possibilidade de um escritor aleat\'f3rio de trabalhos de conclus\'e3o \b\f2\fs18 ?!). \line\b0\f0\fs16 5.34 \i (Limericks) \i0 Um \i limerick \i0\'e9 um poema humor\'edstico de cinco linhas, no qual a primeira e a segunda linhas rimam com a quinta e a terceira linha rima com a quarta. Usando t\'e9cnicas semelhantes \'e0quelas desenvolvidas no Exerc\'edcio \i 5.33, \i0 escreva um programa em C++ que produza \i 1imerick \i0 aleatoriamente. Sofisticar este programa para produzir bons \i limericks \i0\'e9 um problema desafiador, mas o resultado compensa o esfor\'e7o! \line 5.35 Escreva um programa que codifica frases da l\'edngua inglesa em pig \i latin. \i0 O \ldblquote pig \i latin\rdblquote  \i0\'e9 uma forma de linguagem codificada, freq\'fcentemente usada para divers\'e3o. Existem muitas varia\'e7\'f5es nos m\'e9todos usados para formar frases em \ldblquote pig \i latin\rdblquote . \i0 Para simplificar, use o seguinte algoritmo: \line Para formar uma frase em \ldblquote pig \i latin\rdblquote  \i0 partindo de uma frase inglesa, separe a frase em palavras, com a fun\'e7\'e3o strtok. Para traduzir cada palavra inglesa para uma palavra de \ldblquote pig latim\rdblquote , coloque a primeira letra da palavra inglesa no fim da mesma e acrescente as letras \ldblquote ay\rdblquote . Deste modo, a palavra \ldblquote jump\rdblquote  se toma \ldblquote uxnpj ay\rdblquote . a palavra \ldblquote the\rdblquote  se toma hetay\rdblquote  e a palavra \lquote computer\rdblquote  se torna omputercay\rquote . Espa\'e7os entre palavras permanecem como espa\'e7os. Assuma o seguinte: a frase inglesa consiste em palavras separadas por espa\'e7os, n\'e3o existe nenhum sinal de pontua\'e7\'e3o e todas as palavras t\'eam duas ou mais letras. A fun\'e7\'e3o printLatinWord deve exibir cada palavra. Sugest\'e3o: toda vez que uma unidade l\'e9xica \'e9 encontrada em uma chama- da a strtok, passe a unidade l\'e9xica por ponteiro para a fun\'e7\'e3o printLatinWord e imprima a palavra em \ldblquote pig \i latin\rdblquote . \line\b\i0\f2 5.36 \b0\f0 Escreva um programa que recebe como entrada um n\'famero de telefone como um \i string \i0 na forma (555) 555-5555. O programa deve usar a fun\'e7\'e3o strtok para extrair o c\'f3digo de \'e1rea como uma unidade l\'e9xica, os primeiros tr\'eas d\'edgitos do n\'famero do telefone como uma unidade l\'e9xica e os \'faltimos quatro d\'edgitos do n\'famero do telefone tamb\'e9m como uma unidade l\'e9xica. Os sete d\'edgitos do n\'famero do telefone devem ser concatenados em um \i string. \i0 O programa deve converter o \i string \i0 do c\'f3digo de \'e1rea para int e converter o \i string \i0 do n\'famero do telefone para iong. Tanto o c\'f3digo de \'e1rea como o n\'famero do telefone devem ser impressos. \fs24\par
\fs16 CAP\'cdTULO 5 \f2\fs8 - \f0\fs16 PONTEIROS E \i STRINGS \b\i0\f2\fs20 391 \line\b0\f0\fs16 5.37 Escreva um programa que recebe como entrada uma linha de texto, separa a linha em unidades l\'e9xicas usando a fun\'e7\'e3o strtok e mostra na sa\'edda as unidades l\'e9xicas na ordem inversa. \line 5.3S Use as fun\'e7\'f5es de compara\'e7\'e3o de \i string \i0 discutidas na Se\'e7\'e3o 5. 1 2.2 e as t\'e9cnicas para classifica\'e7\'e3o de arrays desenvolvi- das no Cap\'edtulo 4 para escrever um programa que coloca em ordem alfab\'e9tica uma lista de \i strings. \i0 Use os nomes de 10 ou 15 cidades de sua regi\'e3o como dados para seu programa. \line\b\i\f2\fs18 5.39 \b0\i0\f0\fs16 Escreva duas vers\'f5es de cada uma das fun\'e7\'f5es de c\'f3pia e concatena\'e7\'e3o de \i strings \i0 da Fig. 5.29. A primeira vers\'e3o deve usar subscritos de arrays e a segunda vers\'e3o deve usar ponteiros e aritm\'e9tica de ponteiros. \line 5.40 Escreva duas vers\'f5es de cada fun\'e7\'e3o de compara\'e7\'e3o de \i strings \i0 da Fig. 5.29. A primeira vers\'e3o deve usar subscritos de arrays e a segunda vers\'e3o deve usar ponteiros e aritm\'e9tica de ponteiros. \line 5.41 Escreva duas vers\'f5es da fun\'e7\'e3o strlen na Fig. 5.29. A primeira vers\'e3o deve usar subscritos de arrays e a segunda vers\'e3o deve usar ponteiros e aritm\'e9tica de ponteiros. \line\b\i\f2\fs24 Se\'e7\'e3o especial: exerc\'edcios avan\'e7ados de manipula\'e7\'e3o de strings \line\b0\i0\f0\fs16 Os exerc\'edcios precedentes est\'e3o ligados ao texto e foram concebidos para testar a compreens\'e3o pelo leitor dos conceitos funda- mentais de manipula\'e7\'e3o de \i strings. \i0 Esta se\'e7\'e3o inclui uma rela\'e7\'e3o de exerc\'edcios de manipula\'e7\'e3o de \i strings \i0 intermedi\'e1ria e avan\'e7ada. O leitor vai achar estes problemas dif\'edceis e desafiadores, mas, ainda assim, agrad\'e1veis. Os problemas variam consideravelmente em dificuldade. Alguns exigem uma hora ou duas de codifica\'e7\'e3o e implementa\'e7\'e3o de programas. Outros s\'e3o \'fateis para trabalhos de laborat\'f3rio que podem exigir duas ou tr\'eas semanas de estudo e implementa\'e7\'e3o. Alguns s\'e3o projetos de conclus\'e3o desafiadores. \line 542 \i (An\'e1lise de texto) \i0 A disponibilidade de computadores com capacidades de manipula\'e7\'e3o de \i strings \i0 resultou em algumas abordagens bastante interessantes para analisar a obra escrita de grandes autores. Muita aten\'e7\'e3o foi concentrada sobre se William Shakespeare at\'e9 mesmo existiu. Alguns estudiosos acreditam que existe evid\'eancia significativa indicando que Christopher Marlowe ou outros autores escreveram realmente as obras primas atribu\'eddas a Shakespeare. Os investigadores usaram computadores para achar semelhan\'e7as na escrita destes dois autores. Este exerc\'edcio examina tr\'eas m\'e9todos para analisar textos por computador. \line a) Escreva um programa que l\'ea v\'e1rias linhas de texto digitadas no teclado e imprime uma tabela indicando o n\'famero de ocorr\'eancias de cada letra do alfabeto no texto. Por exemplo, a frase \line\b\f3 To be, or not be: that is the question: \line\b0\f0 cont\'e9m a letra \ldblquote a\rdblquote  tr\'eas vezes, a letra \ldblquote b\rdblquote  duas vezes, nenhum \ldblquote e\rdblquote , etc. \line b) Escreva um programa que l\'ea v\'e1rias linhas de texto e imprime uma tabela indicando o n\'famero de palavras de uma \line letra, palavras de duas letras, palavras de tr\'eas letras, etc. que aparecem no texto. Por exemplo, a frase \line\b\f3 Whether \lquote tis nobler in the mmd to suffer \line\b0\f0 a cont\'e9m \line a \fs24\par
\b\f2\fs20 Comprimento da palavra Ocorr\'eancias \b0\f1\fs60 1 \f0\fs24\par
\b\f3\fs16 1 O \line\b0\f0 2 2 \line 3 1 \line 4 2 (incluindo tis) \line 5 O \line 6 2 \line 7 \b\f3 1 \b0\f0\fs24\par
\b\f2\fs22 392 \b0\fs28 c++ \b\fs14 COMO PROGRAMAR \line\b0\f0\fs16 c) Escreva um programa que l\'ea v\'e1rias linhas de texto e imprime uma tabela indicando o n\'famero de ocorr\'eancias de cada palavra diferente no texto. A primeira vers\'e3o de seu programa deveria incluir as palavras na tabela na mesma ordem \line em que aparecem no texto. Por exemplo, as linhas \line\b\f3 To be or not be: that is the question: \line Whether tis nobler \b0\fs14 iii \b\fs16 the mmd to suffer \line\b0\f0 cont\'eam tr\'eas vezes a palavra \ldblquote tu\rdblquote , duas vezes a palavra \ldblquote be\rdblquote , uma vez a palavra \ldblquote or\rdblquote , etc. Um relat\'f3rio mais interessante (e \'fatil) seria um no qual as palavras est\'e3o classificadas em ordem alfab\'e9tica. \line 5.43 \i (Processamento de texto) \i0 Uma fun\'e7\'e3o importante em sistemas de processamento de texto \i\'e9justiflcar \i0\f2\fs8 - \f0\fs16 fazer o alinhamento das palavras tanto pela margem esquerda como pela margem direita de uma p\'e1gina. Isto gera um documento com apar\'eancia profissional, que d\'e1 a impress\'e3o de ter sido preparado em um equipamento de composi\'e7\'e3o de textos profissional e n\'e3o em uma m\'e1quina de escrever. Ajustifica\'e7\'e3o do texto pode ser feita, em sistemas de computador, inserindo-se caracteres em branco entre cada uma das palavras em uma linha, de forma que a palavra mais \'e0 direita fica alinhada com a margem direita. \line Escreva um programa que l\'ea v\'e1rias linhas de texto e imprime esse texto em formato justificado. Assuma que o texto ser\'e1 impresso em papel de 8 1/2 polegadas de largura e que s\'e3o deixadas margens de uma polegada, tanto no lado esquerdo como no lado direito da p\'e1gina impressa. Assuma que o computador imprime 10 caracteres por polegada horizontal. Portanto, seu programa deve imprimir 6 1/2 polegadas de texto ou 65 caracteres por linha. \line 5.44 \i (Imprimindo datas em v\'e1riosformatos) \i0 Datas s\'e3o comumente impressas em v\'e1rios formatos diferentes na correspond\'eancia comercial. Dois dos formatos mais comuns s\'e3o: \line\b\f3 21/07/55 e 21 de julho de 1955 \line\b0\f0 Escreva um programa que l\'ea uma data no primeiro formato e imprime essa data no segundo formato. \line 5.45 \i (Prote\'e7\'e3o de cheques) \i0 Computadores s\'e3o freq\'fcentemente empregados em sistemas de impress\'e3o de cheques, tais como folha de pagamento e aplicativos de contas a pagar. Circulam muitas hist\'f3rias estranhas relativas a cheques de pagamento semanais sendo impressos (por engano) com quantias de mais de \b\f2\fs22 $ \b0\f0\fs16 1 milh\'e3o. As quantias misteriosas s\'e3o impressas por sistemas de impress\'e3o de cheques computadorizados por causa de erros humanos e/ou falhas de m\'e1quina. Os projetistas de sistemas introduzem controles em seus sistemas para prevenir a emiss\'e3o de tais cheques errados. \line Outro problema s\'e9rio \'e9 a altera\'e7\'e3o intencional do valor de um cheque por algu\'e9m que pretende obter dinheiro em esp\'e9cie usando um desses cheques de forma fraudulenta. Para impedir que uma quantia de dinheiro seja alterada, a maioria dos sistemas de impress\'e3o de cheques computadorizados empregam uma t\'e9cnica chamada de \i prote\'e7\'e3o de cheque. \line\i0 Os cheques destinados a serem impressos por computador cont\'eam um n\'famero fixo de espa\'e7os em que o computador pode imprimir uma quantia. Suponha que um cheque de pagamento cont\'e9m oito espa\'e7os em branco nos quais o computador deve imprimir a quantia de um cheque de pagamento semanal. Se a quantia for grande, ent\'e3o todos aqueles oito espa\'e7os ser\'e3o preenchidos; por exemplo: \line 1 \f2\fs8 . \f0\fs16 230 \f2\fs8 , \f0\fs16 60 (valor do cheque) \line 12345678 (n\'fameros de posi\'e7\'f5es) \line Por outro lado, se a quantidade fosse menor que \b\f2\fs22 $ \b0\f0\fs16 1 .000,00, v\'e1rios dos espa\'e7os seriam normalmente deixados em branco. Por exemplo, \line\b\f3 99,87 \line 12345678 \line\b0\f0 cont\'e9m tr\'eas espa\'e7os em branco. Se um cheque for impresso com os espa\'e7os em branco, \'e9 mais f\'e1cil para algu\'e9m alterar a quantia do cheque. Para impedir que um cheque seja alterado, muitos sistemas de impress\'e3o de cheques inserem \i asteriscos \'e0 esquerda \i0 para proteger a quantia impressa, como a seguir: \line\b\f3 ***99,87 \line 12345678 \b0\f0\fs24\par
\b\fs14 CAP\'cdTULO \b0\fs18 5 \f2\fs8 - \b\f0\fs14 PONTEIROS E \i STRINGS \i0\f2\fs22 393 \b0\f0\fs24\par
\fs16 Escreva um programa que recebe como entrada uma quantia de dinheiro para ser impressa em um cheque e ent\'e3o imprime a quantia no formato de cheque protegido, com asteriscos \'e0 esquerda, se necess\'e1rio. Assuma que nove espa\'e7os est\'e3o dispon\'edveis para imprimir uma quantia. \line 5.46 \i (Escrevendo o equivalente \'e0 quantia do cheque por extenso) \i0 Continuando a discuss\'e3o do exemplo anterior, que- remos reiterar a import\'e2ncia de projetar sistemas de impress\'e3o de cheques para impedir a altera\'e7\'e3o dos valores dos mesmos. Um m\'e9todo de seguran\'e7a comum exige que o valor do cheque seja impresso tanto em n\'fameros como tamb\'e9m por extenso. Ainda que algu\'e9m possa alterar o valor num\'e9rico do cheque, \'e9 extremamente dif\'edcil mudar as palavras que espressam a quantia. \line Muitos sistemas de impress\'e3o de cheques computadorizados n\'e3o imprimem o valor do cheque por extenso. Talvez a raz\'e3o principal para esta omiss\'e3o seja o fato de que a maioria das linguagens de alto n\'edvel usadas em aplicativos comerciais n\'e3o cont\'e9m recursos de manipula\'e7\'e3o de strings adequados. Outra raz\'e3o \'e9 que a l\'f3gica para escrever o equivalente em palavras do valor num\'e9rico de um cheque \'e9 um pouco elaborada. \line Escreva um programa que recebe como entrada o valor num\'e9rico de um cheque e escreve o equivalente por extenso desse valor. Por exemplo, a quantia R$ l 12,43 deveria ser impressa como \line\b Cento e doze reais e quarenta e tr\'eas centavos \b0\fs24\par
\i\fs16 5.47 (C\'f3digo Morse).Talvez \i0 o mais famoso de todos os esquemas de codifica\'e7\'e3o seja o c\'f3digo Morse, desenvolvido \b por Samuel Morse em \b0 1832 para ser usado com o sistema de tel\'e9grafo. O c\'f3digo Morse atribui uma s\'e9rie de pontos e tra\'e7os para cada letra do alfabeto, cada d\'edgito e alguns caracteres especiais (tais como ponto, v\'edrgula, dois-pontos e ponto-e-v\'edrgula). Em sistemas que usam sons, o ponto \'e9 representado por um som curto e o tra\'e7o representado por um som longo. Outras representa\'e7\'f5es dos pontos e tra\'e7os s\'e3o usadas em sistemas que utilizam luzes e sistemas de sinaliza- \'e7\'e3o por meio de bandeiras. \line Um espa\'e7o ou simplesmente a aus\'eancia de um ponto ou um tra\'e7o indica uma separa\'e7\'e3o entre palavras. Em um sistema que usa sons, um espa\'e7o \'e9 indicado por um pequeno per\'edodo de tempo durante o qual nenhum som \'e9 transmitido. A vers\'e3o internacional do c\'f3digo Morse \'e9 mostrada na Fig. 5.42. \fs24\par
\b\f2\fs20 Fig. 5.42 \b0 As letras do alfabeto expressas em c\'f3digo Morse internacional. \f0\fs24\par
\fs18 Escreva um programa que l\'ea uma frase da l\'edngua portugesa e converte a frase em c\'f3digo Morse (obviamente, n\'e3o use \line acentos nem caracteres especiais, tais como cedilha). Escreva tamb\'e9m um programa que l\'ea uma frase codificada em \fs24\par
\pard\par
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1114\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1760\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2831\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx3659\pard\intbl\f1\fs60 1 \b\f0\fs16 Caractet \b0\fs24\cell\b\fs16 :9O \b0\fs24\cell\b\f2\fs20 Caractere \b0\f0\fs24\cell\b\f2\fs20 C\'f3digo \b0\f0\fs24\cell\fs20\row
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1114\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1517\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1760\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2831\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx3659\pard\intbl\b\fs16 1 \b0\fs24\cell\f2\fs8 . . \f0\fs24\cell\cell\i\fs16 D\'edgitos \i0\fs24\cell\cell\fs20\row
\b\fs16\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1114\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1517\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1760\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2831\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx3659\intbl J \b0\fs24\cell\f2\fs8 .-- \f0\fs24\cell\f2\fs8 - \f0\fs24\cell\fs18 1 \fs24\cell\f2\fs8 .--- \f0\fs24\cell\fs20\row
\b\fs16\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1114\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1517\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1760\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2831\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx3659\intbl K \b0\fs24\cell\f2\fs8 -.- \f0\fs24\cell\cell\fs18 2 \fs24\cell\f2\fs8 ..--- \f0\fs24\cell\fs20\row
\b\fs16\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1114\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1517\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1760\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2831\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx3659\intbl L \b0\fs24\cell\f2\fs8 .-.. \f0\fs24\cell\cell\fs18 3 \fs24\cell\f2\fs8 ...-- \f0\fs24\cell\fs20\row
\b\fs16\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1114\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1517\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1760\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2831\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx3659\intbl M \b0\fs24\cell\f2\fs8 -- \f0\fs24\cell\cell\fs18 4 \fs24\cell\f2\fs8 ....- \f0\fs24\cell\fs20\row
\fs18\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1114\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1517\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1760\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2831\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx3659\intbl N \fs24\cell\f2\fs8 -. \f0\fs24\cell\cell\fs18 5 \fs24\cell\cell\fs20\row
\f1\fs26\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1114\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1517\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1760\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2831\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx3659\intbl o \f0\fs24\cell\f2\fs8 --- \f0\fs24\cell\cell\fs18 6 \fs24\cell\f2\fs8 -.... \f0\fs24\cell\fs20\row
\b\fs16\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1114\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1517\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1760\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2831\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx3659\intbl P \b0\fs24\cell\f2\fs8 .--. \f0\fs24\cell\cell\fs18 7 \fs24\cell\f2\fs8 --... \f0\fs24\cell\fs20\row
\b\f2\fs22\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1114\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1517\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1760\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2831\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx3659\intbl Q \b0\f0\fs24\cell\f2\fs8 --. \f0\fs24\cell\f2\fs8 - \f0\fs24\cell\fs18 8 \fs24\cell\f2\fs8 ---.. \f0\fs24\cell\fs20\row
\b\fs16\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1114\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1517\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1760\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2831\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx3659\intbl R \b0\fs24\cell\f2\fs8 .-. \f0\fs24\cell\cell\fs18 9 \fs24\cell\f2\fs8 ----. \f0\fs24\cell\fs20\row
\f1\fs26\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1114\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1517\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1760\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2831\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx3659\intbl s \f0\fs24\cell\f2\fs8 ... \f0\fs24\cell\cell\f1\fs26 o \f0\fs24\cell\cell\fs20\row
\pard\fs24\par
\pard\sb100\sa240\b\f2\fs22 394 \b0\fs28 c++ \b\fs14 COMO PROGRAMAR \line\b0\f0\fs16 Morse e converte a mesma para o seu equivalente na l\'edngua portuguesa. Use um branco entre cada letra codificada em Morse e tr\'eas brancos entre cada palavra codificada em Morse. \line 5.48 \b\f2\fs22 ( \b0\i\f0\fs16 Um programa de convers\'e3o de medidas) \i0 Escreva um programa que ajudar\'e1 o usu\'e1rio a fazer convers\'f5es de medidas. Seu programa deve permitir ao usu\'e1rio especificar os nomes das unidades como \i strings \i0 (i.e., cent\'edmetros, litros, gramas, etc. para o sistema m\'e9trico decimal e polegadas, quartos, libras, etc. para o sistema ingl\'eas) e deve responder a perguntas simples, tais como \line\b\f3\ldblquote Quantas polegadas correspondem a 2 metros?\rdblquote  \line\ldblquote Quantos litros correspondem a 10 quartos?\rdblquote  \line\b0\f0 Seu programa deve reconhecer convers\'f5es inv\'e1lidas. Por exemplo, a pergunta \line\b\f3\ldblquote Quantos p\'e9s correspondem a 5 quilogramas?\rdblquote  \line\b0\f0 n\'e3o tem significado porque p\'e9\rdblquote  \'e9 uma unidade de comprimento, enquanto que quilograma\rdblquote  \'e9 uma unidade de peso. \line\b\i\f2\fs24 Um projeto desafiador de manipula\'e7\'e3o de strings \line\i0\fs18 5.49 \b0\i\f0\fs16 (Um gerador de palavras cruzadas) \i0 A maioria das pessoas \fs20 j\'e1 \fs16 resolveu problemas de palavras cruzadas, mas poucas tentaram criar um. Criar um problema de palavras cruzadas \'e9 uma tarefa dif\'edcil. Aqui \'e9 sugerido, como um projeto de manipula- \'e7\'e3o de \i strings, \i0 um gerador de palavras cruzadas, \i o \i0 que exige sofistica\'e7\'e3o e esfor\'e7o significativos. O programador deve solucionar muitos problemas para fazer funcionar at\'e9 o mais simples programa gerador de palavras cruzadas. Por exemplo, como representar a grade de um problema de palavras cruzadas no computador? Dever\'edamos usar uma s\'e9rie de \i strings, \i0 ou usar arrays bidimensionais? O programador necessita de uma fonte de palavras (por exemplo, um dicion\'e1rio computadorizado) e o programa necessita fazer refer\'eancia a essa fonte diretamente. De que forma deveriam ser armazenadas estas palavras para facilitar as manipula- \'e7\'f5es complexas exigidas pelo programa? O leitor ambicioso desejar\'e1 gerar a \ldblquote parte de dicas\rdblquote  do quebra-cabe\'e7a, na qual breves sugest\'f5es para cada palavra na horizontal e cada palavra na vertical est\'e3o impressas para os solucionadores do quebra-cabe\'e7a. Somente imprimir uma vers\'e3o do pr\'f3prio quebra-cabe\'e7a em branco j\'e1 n\'e3o \'e9 um problema simples.\par
\par
\pard\lang1033\f4\fs20\par
}
 