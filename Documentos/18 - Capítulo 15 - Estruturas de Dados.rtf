{\rtf1\ansi\ansicpg1252\deff0\deflang1033{\fonttbl{\f0\fswiss\fprq2\fcharset0 Arial;}{\f1\froman\fcharset0 Times New Roman;}}
\viewkind4\uc1\pard\sb100\sa240\lang2070\f0\fs24\par
\par
\par
15\par
Estruturas de dados \line Objetivos \line\bullet  Ser capaz de formar estruturas de dados encadeadas usando ponteiros, classes auto-referentes e recurs\'e3o. \line\bullet  Ser capaz de criar e manipular estruturas de dados din\'e2micas tais como listas encadeadas, filas, pilhas e \'e1rvores bin\'e1rias. \line\bullet  Entender v\'e1rias aplica\'e7\'f5es importantes de estruturas de dados encadeadas. \line\bullet  Entender como criar estruturas de dados reutiliz\'e1veis com gabaritos de classes, heran\'e7a e composi\'e7\'e3o. \line Much that 1 bound, 1 could notfree; \line Much that lfreed returned to me. \line Lee Wilson Dodd \line\lquote Will you walk a littlefaster? \lquote saida whiting to a snail, \lquote There \lquote s a porpoise dose behind us, and he \lquote s treading on mv tail.\rquote  \line Lewis Carroil \line H\'e1 sempre espa\'e7o no topo. \line Daniel Webster \line Prossiga - continue andando. \line Thomas Morton \line 1 think that 1 shall never see \line A poem lovely as a tree. \line Joyce Kilmer \par
15 \par
4 \par
0 \par
760 C++ COMO PROGRAMAR \line\ul Vis\'e3o Geral \ulnone\line 15.1 Introdu\'e7\'e3o \line 15.2 Classes auto-referentes \line 15.3 Aloca\'e7\'e3o din\'e2mica de mem\'f3ria \line 15.4 Listas encadeadas \line 15.5 Pilhas \line 15.6 Filas \line 15.7 \'c1rvores \line Resumo\bullet  Terminologia Erros comuns de programa\'e7\'e3o Boas pr\'e1ticas de programa\'e7\'e3o Dicas de desempenho Dica de portabilidade \bullet  Exerc\'edcios de auto-revis\'e3o Respostas aos exerc\'edcios de auto-revis\'e3o Exerc\'edcios Se\'e7\'e3o especial: construindo seu pr\'f3prio compilador \line 15.1 Introdu\'e7\'e3o \line Estudamos estruturas de dados de tamanho fixo tais como arrays unidimensionais, arrays bidimensionais e structs. Este cap\'edtulo introduz estruturas de dados din\'e2micas, que crescem e encolhem durante a execu\'e7\'e3o do programa. Listas encadeadas s\'e3o cole\'e7\'f5es de itens de dados \ldblquote alinhadas em uma fila\rdblquote  - as inser\'e7\'f5es e retiradas s\'e3o feitas em qualquer lugar em uma lista encadeada. Pilhas (stacks) s\'e3o importantes em compiladores e sistemas operacionais - as inser\'e7\'f5es e retiradas s\'e3o feitas somente em uma extremidade de uma pilha - seu topo. Filas representam filas de espera; as inser\'e7\'f5es s\'e3o feitas no fim (tamb\'e9m chamado de cauda) de uma fila e as retiradas s\'e3o feitas na frente (tamb\'e9m chamada de cabe\'e7a da fila) de uma fila. Arvores bin\'e1rias facilitam a busca e a classifica\'e7\'e3o de dados em alta velocidade, a elimina\'e7\'e3o eficiente de itens de dados duplicados, a representa\'e7\'e3o de diret\'f3rios de sistemas de arquivos e a compila\'e7\'e3o de express\'f5es para linguagem de m\'e1quina. Estas estruturas de dados t\'eam muitas outras aplica\'e7\'f5es interessantes. \line Discutiremos os principais tipos de estruturas de dados e implementaremos programas que criam e manipulam essas estruturas de dados. Usamos classes, gabaritos de classe, heran\'e7a e composi\'e7\'e3o para criar e empacotar essas estruturas de dados para reutiliza\'e7\'e3o e facilidade de manuten\'e7\'e3o. \line Estudar este cap\'edtulo \'e9 uma prepara\'e7\'e3o s\'f3lida para o Cap\'edtulo 20, \ldblquote A biblioteca padr\'e3o de gabaritos (STL)\rdblquote . A STL \'e9 uma parte importante da biblioteca padr\'e3o de C++. A STL fornece cont\'eaineres, iteradores para percorrer aqueles cont\'eaineres e algoritmos para processar os elementos daqueles cont\'eaineres. Voc\'ea ver\'e1 que a STL pegou cada uma das estruturas de dados que discutimos aqui no Cap\'edtulo 15 e as empacotou em gabaritos de classes. O c\'f3digo da STL foi cuidadosamente escrito para ser port\'e1vel, eficiente e extens\'edvel. Uma vez que entenda os princ\'edpios e a constru\'e7\'e3o de estruturas de dados conforme apresentados no Cap\'edtulo 15, voc\'ea ser\'e1 capaz de fazer o melhor uso das estruturas de dados, iteradores e algoritmos pr\'e9 empacotados da STL. A STL \'e9 de longe a melhoria isolada mais importante no padr\'e3o C++. E um conjunto de componentes de n\'edvel internacional para ajudar a p\'f4r em pr\'e1tica o enfoque de \ldblquote reutilize, reutilize, reutilize\rdblquote . \line Os exemplos do cap\'edtulo s\'e3o programas pr\'e1ticos que voc\'ea ser\'e1 capaz de usar em cursos mais avan\'e7ados e em \line aplica\'e7\'f5es em empresas. Os programas s\'e3o especialmente pesados no t\'f3pico manipula\'e7\'e3o de ponteiros. Os exerc\'edcios incluem uma rica cole\'e7\'e3o de aplica\'e7\'f5es \'fateis. \line Incentivamo-lo a tentar fazer o projeto principal descrito na se\'e7\'e3o especial intitulada \ldblquote Construindo seu pr\'f3prio compilador\rdblquote . Voc\'ea tem usado um compilador para traduzir seus programas em C+-t- para linguagem de m\'e1quina de forma que possa executar estes programas em seu computador. Neste projeto, voc\'ea construir\'e1 realmente seu pr\'f3prio compilador. E ler\'e1 um arquivo de comandos escritos em uma linguagem simples, mas ainda assim poderosa, de alto n\'edvel, semelhante \'e0s primeiras vers\'f5es da popular linguagem BASIC. Seu compilador traduzir\'e1 estes comandos para um arquivo de instru\'e7\'f5es em Simpletron Machine Language (SML) - a SML \'e9 a linguagem que voc\'ea aprendeu no Cap\'edtulo 5, se\'e7\'e3o especial, \ldblquote Construindo seu pr\'f3prio computador\rdblquote . Seu programa simulador do Simpletron ent\'e3o executar\'e1 o programa em SML produzido por seu compilador! Implementar esse projeto usando uma abordagem fortemente orientada a objetos lha dar\'e1 uma oportunidade maravilhosa para exercitar a maioria daquilo que voc\'ea aprendeu neste curso. A se\'e7\'e3o especial o orienta cuidadosamente atrav\'e9s da \par
CAP\'cdTULO 15 - ESTRUTURAS DE DADOS 761 \line descri\'e7\'e3o da linguagem de alto n\'edvel e descreve os algoritmos de que voc\'ea necessita para converter cada tipo de comando da linguagem de alto n\'edvel em instru\'e7\'f5es de linguagem de m\'e1quina. Se voc\'ea aprecia ser desafiado, pode tentar implementar as muitas melhorias tanto do compilador como do simulador do Simpletron sugeridas nos exerc\'edcios. \line 15.2 Classes auto-referentes \line Uma classe auto-referente cont\'e9m um membro ponteiro que aponta para um objeto de classe do mesmo tipo da classe. Por exemplo, a def\'efni\'e7\'e3o \line class Node \line public: \line Node( int ); \line void setData( int ); \line int getData() const; \line void setNextPtr( Node * \line const Node *getNextptr() const; \line private: \line int data; \line Node *nextptr; \line define um tipo, Node. O tipo Node tem dois membros de dados privados - o inteiro data e o membro ponteiro nextptr. O membro nextPtr aponta para um objeto de tipo Node - um objeto do mesmo tipo que o que est\'e1 sendo declarado aqui, da\'ed o termo \ldblquote classe auto-referente\rdblquote . O membro nextPtr \'e9 chamado de link- i.e., nextPtr pode ser usado para \ldblquote vincular\rdblquote  um objeto do tipo Node a outro objeto do mesmo tipo. O tipo Node tamb\'e9m tem cinco fun\'e7\'f5es membro: um construtor que recebe um inteiro para inicializar o membros data, uma fun\'e7\'e3o setData para inicializar o valor do membro dados, uma fun\'e7\'e3o getData para retornar o valor do membro data, uma fun\'e7\'e3o setNextPtr para inicializar o valor do membro nextPtr e uma fun\'e7\'e3o getNextPtr para retornar o valor do membro nextptr. \line Os objetos de classes auto-referentes podem ser vinculados para formar estruturas de dados \'fateis, tais como listas, filas, pilhas e \'e1rvores. A Fig. 15.1 ilustra dois objetos de classes auto-referentes vinculados para formar uma lista. Note que uma barra invertida (\\), representando um ponteiro nulo (O), \'e9 colocada no membro link do segundo objeto da classe auto-referente, para indicar que o link n\'e3o aponta para outro objeto. A barra \'e9 usada somente para fins de ilustra\'e7\'e3o; ela n\'e3o corresponde ao caractere barra invertida (\\) usado em C\'f7+. Um ponteiro nulo normalmente indica o fim de uma estrutura de dados da mesma maneira que o caractere nulo (\lquote  \\O T) indica o fim de um string. \line Fig. 15.1 Dois objetos vinculados de uma classe auto-referente. \line Erro comum de programa\'e7\'e3o 15.1 \line N\'e3o inicializar o link no \'faltimo nodo de uma lista com nulo (O). \line 15.3 Aloca\'e7\'e3o din\'e2mica de mem\'f3ria \line Criar e manter estruturas de dados din\'e2micas exige aloca\'e7\'e3o din\'e2mica de mem\'f3ria - a possibilidade de um programa obter mais espa\'e7o de mem\'f3ria durante a execu\'e7\'e3o para manter novos nodos e para liberar espa\'e7o n\'e3o mais \par
762 C++ COMO PROGRAMAR \line necess\'e1rio. O limite para aloca\'e7\'e3o din\'e2mica de mem\'f3ria pode ser t\'e3o grande quanto a quantidade de mem\'f3ria f\'edsica dispon\'edvel no computador ou a quantidade de mem\'f3ria virtual dispon\'edvel em um sistema de mem\'f3ria virtual. Freq\'fcentemente, os limites s\'e3o muito pequenos porque a mem\'f3ria dispon\'edvel deve ser compartilhada entre muitos usu\'e1rios. \line Os operadores new e dele te s\'e3o essenciais para a aloca\'e7\'e3o din\'e2mica de mem\'f3ria. O operador new recebe \line como argumento o tipo do objeto que est\'e1 sendo alocado dinamicamente e retorna um ponteiro para um objeto daquele tipo. Por exemplo, o comando \line Node *newptr = new Node( 10 ); \line aloca sizeof ( Node ) bytes, executa o construtor de Node e armazena um ponteiro para esta mem\'f3ria em newPtr. Se n\'e3o h\'e1 mem\'f3ria dispon\'edvel, new dispara uma exce\'e7\'e3o bad alloc. O 10 \'e9 o dado do objeto Node. \line O operador delete executa o destruidor de Node e desaloca a mem\'f3ria alocada com new - a mem\'f3ria \'e9 retornada para o sistema de forma que a mem\'f3ria possa ser realocada no futuro. Para liberar a mem\'f3ria alocada dinamicamente pelo new precedente, use o comando \line delete newPtr; \line Note que newPtr em si mesmo n\'e3o \'e9 deletado, mas sim o espa\'e7o para o qual newPtr aponta. Se newPtr tem o valor O (indicando um ponteiro para nada), o comando precedente n\'e3o tem nenhum efeito. \line As se\'e7\'f5es seguintes discutem listas, pilhas, filas e \'e1rvores. Estas estruturas de dados s\'e3o criadas e mantidas \line com aloca\'e7\'e3o din\'e2mica de mem\'f3ria e classes auto-referentes. \line Dica de portabilidade 15.1 \line O tamanho de um objeto de uma classe n\'e3o \'e9 necessariamente a soma dos tamanhos de seus membros de dados. Isto ocorre por causa de v\'e1rios requisitos de alinhamento de limites de endere\'e7os dependentes de m\'e1quina (ver o Cap\'edtulo 16) e por outras raz\'f5es. Use o operador sizeof para determinar o tamanho de um objeto. \line Erro comum de programa\'e7\'e3o 15.2 \line Assumir que o tamanho de um objeto de uma classe \'e9 simplesmente a soma dos tamanhos de seus membros \line de dados. \line Erro comum de programa\'e7\'e3o 15.3 \line N\'e3o liberar a mem\'f3ria alocado dinamicamente quando ela n\'e3o \'e9 mais necess\'e1ria pode fazer com que o \line sistema fique prematuramente sem mem\'f3ria. Isto \'e9 \'e0s vezes chamado de \lquote perda de mem\'f3ria.\rdblquote  \line Boa pr\'e1tica de programa\'e7\'e3o 15.1 \line Quando a mem\'f3ria que foi alocada dinamicamente com new n\'e3o \'e9 mais necess\'e1ria, use delete para \line liberar a mem\'f3ria imediatamente para o sistema. \line Erro comum de programa\'e7\'e3o 15.4 \line Apagar com delete mem\'f3ria que n\'e3o foi alocada dinamicamente com new. \line Erro comum de programa\'e7\'e3o 15.5 \line Referenciar mem\'f3ria que foi deletada. \line Erro comum de programa\'e7\'e3o 15.6 \line Tentar dei etar mem\'f3 ria que j\'e1 foi deletada pode levar a resultados imposs\'edveis de predizer durante a \line execu\'e7\'e3o. \par
CAP\'cdTULO 15 - ESTRUTURAS DE DADOS 763 \par
15.4 Listas encadeadas \line Uma lista encadeada \'e9 um cole\'e7\'e3o linear de objetos de uma classe auto-referente, chamados de nodos, conectados por ponteiros de encadeamento - da\'ed o termo lista \ldblquote encadeada\rdblquote . Uma lista encadeada \'e9 acessada atrav\'e9s de um ponteiro para o primeiro nodo da lista. Os nodos subseq\'fcentes s\'e3o acessados atrav\'e9s do membro ponteiro de encadeamento armazenado em cada nodo. Por conven\'e7\'e3o, o ponteiro de encadeamento do \'faltimo nodo de uma lista \'e9 inicializado com nulo (zero), para marcar o fim da lista. Os dados s\'e3o armazenados em uma lista encadeada dinamicamente - cada nodo \'e9 criado conforme necess\'e1rio. Um nodo pode conter dados de qualquer tipo, inclusive objetos de outras classes. Se os nodos cont\'eam ponteiros de classes base - ou refer\'eancias para classes base e objetos de classes derivadas relacionadas por heran\'e7a, podemos ter uma lista encadeada de tais nodos e usar chamadas de fun\'e7\'f5es virtual para processar estes objetos polimorficamente. As pilhas e filas s\'e3o tamb\'e9m estruturas de dados lineares e, como veremos, s\'e3o vers\'f5es de listas encadeadas com restri\'e7\'f5es. As \'e1rvores s\'e3o estruturas de dados n\'e3o-lineares. \line Listas de dados podem ser armazenadas em arrays, mas as listas encadeadas oferecem v\'e1rias vantagens. Uma lista encadeada \'e9 apropriada quando \'e9 imposs\'edvel se predizer o n\'famero de elementos de dados a ser representado na estrutura de dados ao mesmo tempo. As listas encadeadas s\'e3o din\'e2micas, assim o comprimento de uma lista pode aumentar ou diminuir conforme necess\'e1rio. O tamanho de um array C++ \ldblquote convencional\rdblquote , por\'e9m, n\'e3o pode ser alterado, porque o tamanho de um array \'e9 fixado durante a compila\'e7\'e3o. Arrays \ldblquote convencionais\rdblquote  ficam cheios. Listas encadeadas enchem-se somente quando o sistema n\'e3o tiver mem\'f3ria suficiente para satisfazer a solicita\'e7\'f5es din\'e2micas de aloca\'e7\'e3o de mem\'f3ria. \line\ul 1 \ulnone Dica de desempenho 15.1 \line ______ Um array pode ser declarado para conter mais elementos que o n\'famero de itens esperados, mas isto pode desperdi\'e7ar mem\'f3ria. As listas encadeadas podem fornecer uma utiliza\'e7\'e3o de mem\'f3ria melhor nestas situa\'e7\'f5es. As listas encadeadas permitem ao programa se adaptar durante a execu\'e7\'e3o. \line As listas encadeadas podem ser mantidas classificadas de acordo com uma ordem simplesmente inserindo-se cada novo elemento no ponto apropriado da lista. Os elementos existentes na lista n\'e3o necessitam ser movidos. \line Dica de desempenho 15.2 \line ______ A inser\'e7\'e3o e exclus\'e3o em um array ordenado pode consumir tempo - todos os elementos em seguida ao elemento inserido ou exclu\'eddo devem ser movidos deforma apropriada. \line Dica de desempenho 15.3 \line Os elementos de um array s\'e3o armazenados contiguamente na mem\'f3ria. Isto permite o acesso imediato a qualquer elemento do array porque o endere\'e7o de qualquer elemento pode ser calculado diretamente com base na posi\'e7\'e3o de in\'edcio do array. As listas encadeadas n\'e3o disp\'f5em de tal \ldblquote acesso direto\rdblquote  imediato a seu.s elementos. \line Os nodos de uma lista encadeada normalmente n\'e3o est\'e3o armazenados contiguamente na mem\'f3ria. Logicamente, por\'e9m, os nodos de uma lista encadeada parecem ser cont\'edguos. A Fig. 15.2 ilustra uma lista encadeada com v\'e1rios nodos. \line I)ica de desempenho 15.4 \line ______ Usar aloca\'e7\'e3o de mem\'f3ria din\'e2mica (em vez de arrays) para estruturas de dados que crescem e encolhem durante a execu\'e7\'e3o pode economizar me\'edn\'f3 ria. Tenha em mente, por\'e9m, que ponteiros ocupam espa\'e7o e que a aloca\'e7\'e3o de mem\'f3ria din\'e2mica incorre no overhead das chamadas de fun\'e7\'f5es. \line O programa da Fig. 15.3 (cuja sa\'edda \'e9 mostrada na Fig. 15.4) usa um gabarito de classe List (\lquote veja Cap\'edtulo 12, \ldblquote Gabaritos\rdblquote ) para manipular uma lista de valores inteiros e uma lista de valores de ponto flutuante. O programa de teste (fig 1503. cpp) oferece cinco op\'e7\'f5es: 1) insira um valor no in\'edcio da lista (fun\'e7\'e3o insertAtFront), 2) insira um valor no fim da lista (fun\'e7\'e3o insertAtBack). 3) retire um valor do in\'edcio da lista (fun\'e7\'e3o removeFromFront), 4) retire um valor do fim da lista (fun\'e7\'e3o removeFromBack) e 5) termine o processamento \par
764 c++ COMO PROGRAMAR \par
da lista. Uma discuss\'e3o detalhada do programa vem a seguir. O exerc\'edcio 15.20 lhe pede para implementar um fun\'e7\'e3o recursiva que imprime uma lista encadeada de tr\'e1s para diante e o Exerc\'edcio 15.21 lhe pede para implementar um fun\'e7\'e3o recursiva que pesquisa uma lista encadeada procurando por um item de dados particular. \line A Fig. 15.3 consiste em dois gabaritos de classe - ListNode e List. Encapsulado em cada objeto List est\'e1 uma lista encadeada de objetos Lis tNode. O gabarito de classe Lis tNode consiste nos membros privados data e nextptr. O membro data ListNode armazena um valor do tipo NODETYPE, o par\'e2metro de tipo passado para o gabarito de classe. O membro nextPtr de Lis tNode armazena um ponteiro para o pr\'f3ximo objeto Lis tNode na lista encadeada. \par
firstPtr lastPtr \par
Fig. 15.3 Manipulando uma lista encadeada - list.h (parte 1 de 4). \par
\pard\par
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx6245\pard\intbl Fig. 15.2 Uma representa\'e7\'e3o gr\'e1fica de uma lista. \cell\row
\intbl 1 // Fig. 15.3: listnd.h \cell\row
\intbl 2 1/ Defini\'e7\'e3o do gabarito ListNode \cell\row
\intbl 3 #ifndef LISTNDH \cell\row
\intbl 4 #define LISTNDH \cell\row
\intbl 5 \cell\row
\intbl 6 template< class NODETYPE > class List; II declara\'e7\'e3o antecipada \cell\row
\intbl 7 \cell\row
\intbl 8 template<class NODETYPE> \cell\row
\intbl 9 class ListNode \cell\row
\intbl 10 friend class List< NODETYPE >; II torna List uni friend \cell\row
\intbl 11 public: \cell\row
\intbl 12 ListNode( const NODETYPE & ); II construtor \cell\row
\intbl 13 NODETYPE getData() const; II retorna dados do nodo \cell\row
\intbl 14 private: \cell\row
\intbl 15 NODETYPE data; // dados \cell\row
\intbl 16 ListNode< NODETYPE > *nextPtr; II pr\'f3ximo nodo na lista \cell\row
\intbl 17 \}; \cell\row
\intbl 18 \cell\row
\intbl 19 // Construtor \cell\row
\intbl 20 template<class NODETYPE> \cell\row
\intbl 21 ListNode< NODETYPE >::ListNode( const NODETYPE &info \cell\row
\intbl 22 : data( info ), nextptr( O ) \{ \} \cell\row
\intbl 23 \cell\row
\intbl 24 // Retorna unia c\'f3pia dos dados no nodo \cell\row
\intbl 25 template< class NODETYPE > \cell\row
\intbl 26 NODETYPE ListNode< NODETYPE >::getData() const \{ return data; \cell\row
\intbl 27 \cell\row
\intbl 28 #endif \cell\row
\intbl Fig. 15.3 Manipulando uma lista encadeada - listnd. h. \cell\row
\intbl 29 II Fig. 15.3: list.h \cell\row
\intbl 30 II Defini\'e7\'e3o da classe gabarito List \cell\row
\intbl 31 #ifndef LISTH \cell\row
\intbl 32 #define LISTH \cell\row
\pard\par
\pard\sb100\sa240 CAP\'cdTULO 15 - ESTRUTURAS DE DADOS 765 \line 33 \line 34 #include <iostream> \line 35 #include <cassert> \line 36 #include \ldblquote listnd.h\rdblquote  \line 37 \line 38 using std::cout; \line 39 \line 40 template< class NODETYPE > \line 41 class List \{ \line 42 public: \line 43 Listo; /1 construtor \line 44 List(); /1 destruidor \line 45 void insertAtFront( const NODETYPE & ); \line 46 void insertAtBack( const NODETYPE & ); \line 47 bool removeFromFront( NODETYPE & ); \line 48 bool removeFromBack( NODETYPE & ); \line 49 bool isEmptyO) const; \line 50 void print() const; \line 51 private: \line 52 ListNode< NODETYPE > *fjrstptr; II ponteiro para o primeiro nodo \line 53 ListNode< NODETYPE > *lastPtr; II ponteiro para o \'faltimo nodo \line 54 \line 55 // Fun\'e7\'e3o utilit\'e1ria para alocar um novo nodo \line 56 ListNode< NODETYPE > *getNewNode( const NODETYPE & ); \line 57 \}; \line 58 \line 59 // Construtor default \line 60 template< class NODETYPE > \line 61 List< NODETYPE >::List() : firstPtr( O ), lastptr( O ) \{ \} \line 62 \line 63 // Destruidor \line 64 template< class NODETYPE > \line 65 List< NODETYPE >::-List() \line 66 \{ \line 67 if ( !isEmpty() ) \{ // A lista n\'e3o est\'e1 vazia \line 68 cout \'ab \ldblquote Destruindo nodos .\\n\rdblquote ; \line 69 \line 70 ListNode< NODETYPE > *currentptr = firstPtr, *tempptr; \line 71 \line 72 while ( currentPtr O ) \{ // elimina nodos restantes \line 73 tempPtr currentPtr; \line 74 cout \'ab tempPtr->data \'ab \lquote\\n\rquote ; \line 75 currentPtr = currentPtr->nextPtr; \line 76 delete tempPtr; \line 77 \line 78 \line 79 \line 80 cout \'ab \ldblquote Todos os nodos destru\'eddos\\n\\n\rdblquote ; \line 81 \} \line 82 \line 83 // Insere um nodo no in\'edcio da lista \line 84 template < class NODETYPE > \line j. 85 void List< NODETYPE >::insertAtFront( const NODETYPE &value \line 86 \{ \line 87 ListNode< NODETYPE > *newptr = getNewNode( value ); \line 88 \line 89 if ( isEmptyO) ) II A lista est\'e1 vazia \line 90 firstptr = lastPtr = newPtr; \line Fig. 15.3 Manipulando uma lista encadeada - list.h (parte 2 de 4). \par
766 C++ COMO PROGRAMAR \line 91 else \{ II A lista n\'e3o est\'e1 vazia \line 92 newPtr->nextPtr = firstPtr; \line 93 firstPtr = newPtr; \line 94 \line 95 \} \line 96 \line 97 // Insere um nodo no fim da lista \line 98 template< class NODETYPE > \line 99 void List< NODETYPE >::insertAtBack( const NODETYPE &value \line 100 \line 101 ListNode< NODETYPE > *Pt = getNewNode( value ); \line 102 \line 103 if ( isEmpty() ) II A lista est\'e1 vazia \line 104 firstPtr = lastPtr = newPtr; \line 105 else \{ // A lista n\'e3o est\'e1 vazia \line 106 lastPtr->nextPtr = newPtr; \line 107 lastPtr = newPtr; \line 108 \line 109 \} \line 110 \line 111 II Retira um nodo do in\'edcio da lista \line 112 template< class NODETYPE > \line 113 bool List< NODETYPE >::removeFromFront( NODETYPE &value \line 114 \{ \line 115 if ( isEmpty() ) // A lista est\'e1 vazia \line 116 return return; II retirada sem sucesso \line 117 else \{ \line 118 ListNode< NODETYPE > *tempPtr = firstPtr; \line 119 \line 120 if ( firstPtr == lastPtr \line 121 firstPtr = lastPtr = 0; \line 122 else \line 123 firstPtr = firstPtr->nextPtr; \line 124 \line 125 value = tempPtr->data; II dado sendo removido \line 126 delete tempptr; \line 127 return return; // retirada com sucesso \line 128 \} \line 129 \} \line 130 \line 131 // Retira um nodo do fim da lista \line 132 template< class NODETYPE > \line 133 bool List< NODETYPE >::removeFromBack( NODETYPE &value \line 134 \{ \line 135 if ( isEmpty() \line 136 return return; II retirada sem sucesso \line 137 else \{ \line 138 ListNode< NODETYPE > *tempptr = lastPtr; \line 139 \line 140 if ( firstPtr == lastPtr \line 141 firstPtr = lastPtr = 0; \line 142 else \{ \line 143 ListNode< NODETYPE > *currentptr = firstPtr; \line 144 \line 145 while ( currentPtr->nextPtr != lastPtr \line 146 currentPtr = currentPtr->nextPtr; \line 147 \line 148 lastPtr = currentPtr; \line Fig. 15.3 Manipulando uma lista encadeada - list. h (parte 3 de 4). \par
149 \line 150 \line 151 \line 152 \line 153 \line 154 \line 155 \line 156 \} \line 157 \line 158 \line 4 159 \line 160 \line 161 \line 162 \line ;i163 \line 164 \line 165 \line 166 \line 167 \{ \line 168 \line 169 \line 170 \line 171 \line 172 \} \line 173 \line 174 \line 175 \line 176 \line 177 ( \line 178 \line 179 \line 180 \line 181 \line 182 \par
184 \par
185 cout \'ab \ldblquote A lista \'e9: \ldblquote ; \par
186 \line 187 \line 188 \line 189 \line 190 \line 191 \line 192 \line 193 \} \line 194 \par
r \par
while ( currentPtr != O ) \{ \line cout \'ab currentPtr->data \'ab currentPtr = currentPtr->nextPtr; \par
cout \'ab \ldblquote\\n\\n\rdblquote ; \par
195 #endif \par
Fig. 15.3 Manipulando uma lista encadeada - list.h (parte 4 de 4). \par
CAP\'cdTULO 15 - ESTRUTURAS DE DADOS 767 \par
currentPtr->nextPtr = O; \line value = tempPtr->data; \line delete tempPtr; \line return return; 1/ retirada com sucesso \line 1/ A lista est\'e1 vazia? \line template< class NODETYPE > \line bool List< NODETYPE >::isEmpty() const \line return firstPtr 0; \} \line II retorna um ponteiro para uni nodo rec\'e9m alocado \line template< class NODETYPE > \line ListNode< NODETYPE > *List< NODETYPE >: :getNewNode( const NODETYPE &value \line ListNode< NODETYPE > *ptr = \line new ListNode< NODETYPE >( value ); \line assert( ptr != O ); \line return ptr; \line II Exibe o conte\'fado da lista \line template< class NODETYPE > \line void List< NODETYPE >: :print() const \line if ( isEmpty() ) \{ \line cout \'ab \ldblquote A lista est\'e1 vazia\\n\\n\rdblquote ; \line return; \line 183 ListNode< NODETYPE > *currentptr = firstPtr; \par
( \par
Fig. 15.3 Manipulando uma lista encadeada (parte 1 de 3). \par
\pard\par
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx397\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx3039\pard\intbl 196 \cell II Fig. 15.3: figl5O3.cpp \cell\row
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx397\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2438\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx3039\pard\intbl 197 \cell // Teste da classe \cell List \cell\row
\intbl 198 \cell #include <iostream> \cell\cell\row
\intbl 199 \cell #include \ldblquote list.h\rdblquote  \cell\cell\row
\intbl 200 \cell\cell\cell\row
\intbl 201 \cell using std::cin; \cell\cell\row
\intbl 202 \cell using std::endl; \cell\cell\row
\pard\par
\pard\sb100\sa240 768 C++ COMO PROGRAMAR \line 203 \line 204 // Fun\'e7\'e3o para testar urna lista integer \line 205 template< class T > \line 206 void testList( List< T > &listObject, const char *type \line 207 \line 208 cout \'ab \ldblquote Testando uma List de valores \'ab type \'ab \ldblquote\\n; \line 209 \line 210 instructionsQ; \line 211 int choice; \line 212 T value; \line 213 \line 214 do \{ \line 215 cout \'ab \ldblquote ? \line 216 cm \'bb choice; \line 217 \line 218 switch ( choice ) \{ \line 219 case 1: \line 220 cout \'ab \ldblquote Digite um valor \ldblquote  \'ab type \'ab \line 221 cm \'bb value; \line 222 listObject.insertAtFront( value ); \line 223 listObject.print \line 224 break; \line 225 case 2: \line 226 cout \'ab \ldblquote Digite uni valor \'ab type \'ab \line 227 cm \'bb value; \line 228 listObject.insertAtBack( value ); \line 229 listObject.printO; \line 230 break; \line 231 case 3: \line 232 if ( listObject.removeFromFront( value \line 233 cout \'ab value \'ab removido da lista\\n\rdblquote ; \line 234 \line 235 listObect.prmntO; \line 236 break; \line 237 case 4: \line 238 if ( listObject.removeFrornBack( value \line 239 cout \'ab value \'ab \ldblquote  removido da lista\\n; \line 240 \line 241 listObject.printO; \line 242 break; \line 243 ) \line 244 \} while ( choice != 5 ); \line 245 \line 246 cout \'ab \ldblquote Fim do teste da lista\\n\\n\rquote ; \line 247 \line 248 \line 249 void instructions() \line 250 \{ \line 251 cout \'ab \ldblquote Digite um dos seguintes:\\n\rdblquote  \line 252 \'ab \ldblquote  1 para inserir no in\'edcio da lista\\n\rdblquote  \line 253 \'ab 2 para inserir no fim da lista \\n\rdblquote  \line 254 \ldblquote  3 para retirar do in\'edcio da lista\\n\rdblquote  \line 255 \'ab \ldblquote  4 para retirar do fim da lista \\n\rdblquote  \line 256 5 para terminar o processamento da lista\\n\rdblquote ; \line 257 \} \line 258 \line 259 int main() \line 260 \par
Fig. 15.3 Manipulando uma lista encadeada (parte 2 de 3). \par
\pard\par
\pard\sb100\sa240 CAP\'cdTULO 15 - ESTRUTURAS DE DADOS 769 \line 261 List< int > integerList; \line 262 testList( integerList, \ldblquote integer\rdblquote  ); II testa integerList \line 263 \line 264 List< double > doubleList; \line 265 testList( doubleList, \ldblquote double\rdblquote  ); II testa doubleList \line 266 \line 267 return O; \line\ul 268 \ulnone\line Fig. 15.3 Manipulando uma lista encadeada (parte 3 de 3). \line Testando uma List de valores integer \line Digite um dos seguintes: \line 1 para inserir no in\'edcio da lista \line 2 para inserir no fim da lista \line 3 para retirar do in\'edcio da lista \line 4 para retirar do fim da lista \line 5 para terminar o processamento da lista \line Digite um valor integer: 1 \line A lista \'e9: 1 \line ?l \line Digite um valor integer: 2 \line A lista \'e9: 2 1 \line ?2 \line Digite um valor integer: 3 \line A lista \'e9: 2 1 3 \line Digite um valor integer: 4 \line A lista \'e9: 2 1 3 4 \line 2 removido da lista \line A lista \'e9: 1 3 4 \line ?3 \line 1 removido da lista \line A lista \'e9: 3 4 \line ?4 \line 4 removido da lista \line A lista \'e9: 3 \line 3 removido da lista \line A lista est\'e1 vazia \line Fim do teste da lista \line Testando uma List de valores double \line Digite um dos seguintes: \line 1 para inserir no in\'edcio da lista \line Fig. 15.4 Exemplo de sa\'edda para o programa da Fig. 15.3 (parte 1 de 2). \par
770 C++ CoMo PROGRAMAR \line 2 para inserir no fim da lista \line 3 para retirar do in\'edcio da lista \line 4 para retirar do fim da lista \line 5 para terminar o processamento da lista \line ?l \line Digite um valor double: 1.1 \line A lista \'e9: 1.1 \line ?l \line Digite um valor double: 2.2 \line A lista \'e9: 2.2 1.1 \line ?2 \line Digite um valor double: 3.3 \line A lista \'e9: 2.2 1.1 3.3 \line Digite um valor double: 4.4 \line A lista \'e9: 2.2 1.1 3.3 4.4 \line 2.2 removido da lista \line A lista \'e9: 1.1 3.3 4.4 \line 1.1 removido da lista \line A lista \'e9: 3.3 4.4 \line\lquote 4 \line 4.4 removido da lista \line A lista \'e9: 3.3 \line 3.3 removido da lista \line A lista est\'e1 vazia \line Fim do teste da lista \line Todos os nodos destruidos \line Todos os nodos destru\'eddos \line Fig. 15.4 Exemplo de sa\'edda para o programa da Fig. 15.3 (parte 2 de 2). \line O gabarito de classe List consiste nos membros private firstPtr (um ponteiro para o primeiro ListNode em um objeto List) e lastPtr (um ponteiro para o \'faltimo ListNode em um objeto List). O construtor default inicializa ambos os ponteiros com O (nulos). O destruidor assegura que todos os objetos Lis tNode em um objeto List s\'e3o destru\'eddos quando aquele objeto List \'e9 destru\'eddo. As fun\'e7\'f5es prim\'e1rias do gabarito de classe Lis t s\'e3o insertAtFront, insertAtBack. removeFromFront e removeFromBack. \line A fun\'e7\'e3o isEmpty \'e9 chamada de fun\'e7\'e3o predicado - ela n\'e3o altera List. mas sim determina se List est\'e1 vazia (i.e., o ponteiro para o primeiro nodo de List \'e9 nulo). Se List est\'e1 vazia, retorna true: caso contr\'e1rio, ela retorna false. A fun\'e7\'e3o print exibe o conte\'fado de List. \line Boa pr\'e1tica de programa\'e7\'e3o 15.2 \line Atribua nulo (zero) ao membro de encadeamento (link) de um novo nodo. Os ponteiros devem ser inicializados antes de serem usados. \par
CAP\'cdTULO 15 - ESTRUTURAS DE DADOS 771 \line Durante as pr\'f3ximas v\'e1rias p\'e1ginas, discutiremos cada uma das fun\'e7\'f5es membro da classe List em detalhes. A fun\'e7\'e3o insertAtFront (Fig. 15.5) coloca um novo nodo na frente da lista. A fun\'e7\'e3o consiste em v\'e1rios passos: \line 1. Chama a fun\'e7\'e3o getNewNode passando para esta value. o qual \'e9 uma refer\'eancia constante para o valor do nodo a ser inserido. \line 2. A fun\'e7\'e3o getNewNode usa o operador new para criar um novo nodo da lista e retorna um ponteiro para este nodo da lista. Se este ponteiro for diferente de zero, getNewNode retoma um ponteiro para este nodo \line rec\'e9m-alocado para newPtr em insertAtFront. \line 3. Se a lista est\'e1 vazia, ent\'e3o tanto o firstPtr como o lastPtr s\'e3o inicializados com newptr. \line 4. Se a lista n\'e3o est\'e1 vazia, ent\'e3o o nodo apontado por newPtr \'e9 introduzido na lista copiando firstPtr para newPtr->nextPtr. de forma que o novo nodo aponte para o que era o primeiro nodo da lista, e newPtr \'e9 copiado para firstPtr. de forma que firstptr agora aponte para o novo primeiro nodo da lista. \line A Fig.l5.5 ilustra a fun\'e7\'e3o insertAtFront. A parte a) da figura mostra a lista e o novo nodo antes da opera\'e7\'e3o insertAtFront. As setas pontilhadas na parte b) ilustram os passos 2 e 3 da opera\'e7\'e3o insertAtFront, que possibilitam que o nodo contendo 12 se torne a nova cabe\'e7a de lista. \line o) firstPtr \line L1 __ \line newPtr \line\ul I12N \ulnone\line b) firstPtr \line newPtr \line Fig.15.5 A opera\'e7\'e3o insertAtFront. \line A fun\'e7\'e3o insertAtBack (Fig. 15.6) coloca um novo nodo no fim da lista. A fun\'e7\'e3o consiste em v\'e1rios passos: \line 1. Chama a fun\'e7\'e3o getNewNode passando para ela value. o qual \'e9 uma refer\'eancia constante para o valor do nodo a ser inserido. \line 2. A fun\'e7\'e3o getNewNode usa o operador new para criar um novo nodo da lista e retornar um ponteiro para este nodo da lista. Se este ponteiro for diferente de zero. getNewNode retorna um ponteiro para este nodo \line rec\'e9m-alocado para newPtr em insertAtBack. \line 3. Se a lista est\'e1 vazia, ent\'e3o tanto firstptr como lastPtr s\'e3o inicializados com newptr. \line 4. Se a lista n\'e3o est\'e1 vazia, ent\'e3o o nodo apontado por newPtr \'e9 introduzido na lista copiando-se newPtr para lastPtr->nextPtr, de forma que o novo nodo seja apontado pelo que era o \'faltimo nodo da lista, \line e copiando-se newPtr para lastPtr, deforma que las tPtr agora aponte para o novo \'faltimo nodo da \par
LL \par
lista. \par
772 C++ COMO PROGRAMAR \line 1 \line A Fig.15.6 ilustra uma opera\'e7\'e3o insertAtBack. A parte a) da figura mostra a lista e o novo nodo antes da opera\'e7\'e3o. As setas pontilhadas na parte b) ilustram os passos da fun\'e7\'e3o insertAtBack que possibilitam que um novo nodo seja acrescentado ao fim de uma lista que n\'e3o est\'e1 vazia. \line a) firstptr lastPtr newPtr \line b) firstptr lastPtr newPtr \line __ I11II---5N \line Fig. 15.6 Uma representa\'e7\'e3o gr\'e1fica da opera\'e7\'e2o insertAtBack. \line A fun\'e7\'e3o removeFromFront (Fig. 15.7) remove o primeiro nodo da lista e copia o valor do nodo para o par\'e2metro de refer\'eancia. A fun\'e7\'e3o retorna false se for feita uma tentativa para remover um nodo de uma lista vazia e retorna true se a remo\'e7\'e3o \'e9 bem-sucedida. A fun\'e7\'e3o consiste em v\'e1rios passos: \line 1. Atribui a tempPtr o endere\'e7o para o qual firstPtr aponta. Em algum momento, tempPtr ser\'e1 usado para deletar o nodo que est\'e1 sendo retirado. \line 2. Se firstPtr \'e9 igual a las tPtr, i.e., se a lista tem somente um elemento antes da tentativa de retirada, ent\'e3o inicializa firstPtr e lastPtr com zero para retirar aquele nodo da lista (deixando a lista \line vazia). \line 3. Se a lista tem mais de um nodo antes da retirada, ent\'e3o deixa las tPtr como est\'e1 e simplesmente inicializa firstPtr para firstptr->nextPtr, i.e., modifica firstPtr para apontar para o que era o segundo nodo antes da retirada (e \'e9 o novo primeiro nodo agora). \line 4. Depois de todas estas manipula\'e7\'f5es de ponteiro estarem completas, copia para o par\'e2metro de refer\'eancia value o membro data do nodo que est\'e1 sendo retirado. \line 5. Agora deleta o nodo apontado por tempptr. \line 6. Retorna true. indicando retirada bem-sucedida. \line A Fig. 15.7 ilustra a fun\'e7\'e3o removeFromFront. A parte a) ilustra a lista antes da opera\'e7\'e3o de remo\'e7\'e3o. A parte h) mostra as manipula\'e7\'f5es de ponteiro realizadas. \line a) \par
Fig. 15.7 Uma representa\'e7\'e3o gr\'e1fica da opera\'e7\'e3o removeFromFront (parte 1 de 2). \par
CAP\'cdTULO 15 - ESTRUTURAS DE DADOS 773 \line b) firstPtr lastPtr \line E1 \line Et \line tempPtr \line Fig.15.7 Uma representa\'e7\'e3o gr\'e1fica da opera\'e7\'e3o removeFromFront (parte 2 de 2). \line A fun\'e7\'e3o removeFromBack (Fig. 15.8) remove o \'faltimo nodo da lista e copia o valor do nodo para o par\'e2metro de refer\'eancia. A fun\'e7\'e3o retorna false se for feita uma tentativa de retirar um nodo de uma lista vazia e retorna true se a retirada \'e9 bem-sucedida. A fun\'e7\'e3o consiste em v\'e1rios passos: \line 1. Atribui a tempPtr o endere\'e7o para o qual lastPtr aponta. Em algum momento, tempPtr ser\'e1 usado para deletar o nodo que est\'e1 sendo retirado. \line 2. Se firstPtr \'e9 igual a lastPtr. i.e., se a lista tem somente um elemento antes da tentativa de retirada, ent\'e3o inicializa firstPtr e lastPtr com zero para retirar aquele nodo da lista (deixando a lista vazia). \line 3. Se a lista tem mais de um nodo antes da retirada, ent\'e3o atribui a currentPtr o endere\'e7o para o qual firstptr aponta. \line 4. Agora, \ldblquote percorre a lista\rdblquote  com currentPtr at\'e9 que ele aponte para o nodo antes do \'faltimo nodo. Isto \'e9 feito com um la\'e7o while que fica substituindo currentPtr por currentPtr->nextPtr enquanto currentPtr->nextPtr n\'e3o \'e9 lastptr. \line 5. Atribui a lastPtr o endere\'e7o para o qual currentPtr aponta para retirar o \'faltimo nodo da lista. \line 6. Inicializa currentPtr->nextPtr com zero no novo \'faltimo nodo da lista. \line 7. Depois de todas as manipula\'e7\'f5es de ponteiro estarem completas, copia para o par\'e2metro de refer\'eancia va].ue o membro data do nodo que est\'e1 sendo retirado. \line 8. Agora, deleta o nodo apontado por tempPtr. \line 9. Retorna true, indicando retirada bem-sucedida. \line A Fig. 15.8 ilustra a fun\'e7\'e3o removeFromFront. A parte a) da figura ilustra a lista antes da opera\'e7\'e3o de retirada. A parte b) da figura mostra as manipula\'e7\'f5es de ponteiro realizadas. \line a) \line b) firstPtr \line tempPtr \par
lastPtr \par
currentPtr lastPtr \line El \par
Fig. 15.8 Uma representa\'e7\'e3o gr\'e1fica da opera\'e7\'e3o removeFroinBack. \par
774 C++ COMO PROGRAMAR \par
A fun\'e7\'e3o print primeiro determina se a lista est\'e1 vazia. Nesse caso, print imprime \ldblquote A lista est\'e1 vazia\rdblquote  e termina. Caso contr\'e1rio, imprime os dados que est\'e3o na lista. A fun\'e7\'e3o inicializa currentPtr como uma c\'f3pia de firstptr e ent\'e3o imprime o string \lquote A lista \'e9: \ldblquote . Enquanto currentPtr n\'e3o \'e9 nulo, currentPtr >dado \'e9 impresso e o valor de currentPtr->nextPtr \'e9 atribu\'eddo a currentPtr. Note que se o link no 4 \'faltimo nodo da lista n\'e3o for nulo, o algoritmo de impress\'e3o erroneamente imprimir\'e1 dados que est\'e3o ap\'f3s o fim da \line lista. O algoritmo de impress\'e3o \'e9 id\'eantico para listas encadeadas, pilhas e filas. \line O tipo de lista encadeada que estivemos discutindo \'e9 uma lista simplesmente encadeada - a lista come\'e7a com um ponteiro para o primeiro nodo e cada nodo cont\'e9m um ponteiro para o pr\'f3ximo nodo \ldblquote na seq\'fc\'eancia\rdblquote . Esta lista termina com um nodo cujo membro ponteiro \'e9 0. Uma lista simplesmente encadeada pode ser percorrida somente em uma dire\'e7\'e3o. \line Uma lista circular simplesmente encadeada come\'e7a com um ponteiro para o primeiro nodo e cada nodo cont\'e9m um ponteiro para o pr\'f3ximo nodo. O \ldblquote\'faltimo nodo\rdblquote  n\'e3o cont\'e9m um ponteiro 0; em vez disso, o ponteiro no \'faltimo nodo aponta de volta para o primeiro nodo, fechando deste modo o \ldblquote c\'edrculo\rdblquote . \line Uma lista duplamente encadeada pode ser percorrida tanto para frente como para tr\'e1s. Tal lista \'e9 freq\'fcentemente implementada com dois \ldblquote ponteiros de in\'edcio\rdblquote  - um que aponta para o primeiro elemento da lista para permitir o percurso da lista da frente para tr\'e1s e um que aponta para o \'faltimo elemento da lista para permitir o percurso da lista de tr\'e1s para frente. Cada nodo tem tanto um ponteiro \ldblquote para a frente\rdblquote , para o pr\'f3ximo nodo da lista na dire\'e7\'e3o para a frente e um ponteiro \ldblquote para tr\'e1s\rdblquote , para o pr\'f3ximo nodo na lista na dire\'e7\'e3o para tr\'e1s. Se sua lista cont\'e9m uma lista telef\'f4nica em ordem alfab\'e9tica, por exemplo, para se procurar algu\'e9m cujo nome come\'e7a com uma letra pr\'f3xima ao in\'edcio do alfabeto, poder\'edamos come\'e7ar pela frente da lista. Para se procurar algu\'e9m cujo nome come\'e7a com uma letra pr\'f3xima ao fim do alfabeto, poder\'edamos come\'e7ar pelo fim da lista. \line Em uma lista circular duplamente encadeada, o ponteiro \ldblquote para a frente\rdblquote  do \'faltimo nodo aponta para o primeiro nodo e o ponteiro \ldblquote para tr\'e1s\rdblquote  do primeiro nodo aponta para o \'faltimo nodo, fechando deste modo o \ldblquote c\'edrculo\rdblquote . \line 15.5 Pilhas \line No Capitulo 12, Gabaritos\rdblquote , explicamos a no\'e7\'e3o de um gabarito de classe pilha com uma implemenrn\'e7\'e3o subjacente de array. Nesta se\'e7\'e3o, usamos uma implementa\'e7\'e3o de lista encadeada baseada em ponteiros subjacentes. Tamb\'e9m discutimos pilhas no Cap\'edtulo 20, \ldblquote A biblioteca padr\'e3o de gabaritos (STL).\rdblquote  \line Uma pilha \'e9 uma vers\'e3o sujeita a restri\'e7\'f5es de uma lista encadeada - novos nodos podem ser acrescentados e removidos de uma pilha somente no topo. Por essa raz\'e3o, uma pilha \'e9 chamada de uma estrutura de dados \'faltimo a entrar primeiro a sair (LIFO - last in,first out). O membro de encadeamento no \'faltimo nodo da pilha \'e9 inicializado com nulo (zero) para indicar a parte inferior da pilha. \line Erro comum de programa\'e7\'e3o 15.7 \line N\'e3o inicializar o link no nodo da parte inferior de uma pilha como nulo (zero). \line As fun\'e7\'f5es membro prim\'e1rias usadas para manipular uma pilha s\'e3o push e pop. A fun\'e7\'e3o push insere um novo nodo no topo da pilha. A fun\'e7\'e3o pop retira um nodo do topo da pilha, armazena o valor desempilhado em uma vari\'e1vel de refer\'eancia que \'e9 passada para a fun\'e7\'e3o que chamou e retorna true se a opera\'e7\'e3o pop foi bem-sucedida (false caso contr\'e1rio). \line As pilhas t\'eam muitas aplica\'e7\'f5es interessantes. Por exemplo, quando \'e9 feita uma chamada de fun\'e7\'e3o, a fun\'e7\'e3o chamada deve saber como retornar \'e0 fun\'e7\'e3o que chamou, assim o endere\'e7o de retorno \'e9 empurrado para o topo de uma pilha. Se acontece uma s\'e9rie de chamadas de fun\'e7\'f5es, os valores sucessivos de retorno s\'e3o empurrados para a pilha na ordem \'faltimo a entrar primeiro a sair, de forma que cada fun\'e7\'e3o pode retornar a seu chamador. Pilhas suportam as chamadas recursivas de fun\'e7\'f5es da mesma maneira que chamadas convencionais n\'e3o-recursivas. \line As pilhas cont\'eam o espa\'e7o criado para as vari\'e1veis autom\'e1ticas em cada invoca\'e7\'e3o de uma fun\'e7\'e3o. Quando a fun\'e7\'e3o retorna a seu chamador ou dispara uma exce\'e7\'e3o, \'e9 chamado o destruidor (se houver) para cada objeto local, o espa\'e7o para aquelas vari\'e1veis autom\'e1ticas da fun\'e7\'e3o \'e9 retirado (desempilhado) da pilha e aquelas vari\'e1veis n\'e3o s\'e3o mais conhecidas no programa. \line As pilhas s\'e3o usadas por compiladores no processo de avaliar express\'f5es e gerar c\'f3digo em linguagem de m\'e1quina. Os exerc\'edcios exploram v\'e1rios aplica\'e7\'f5es de pilhas, inclusive usando-as para desenvolver um compilador completo que funciona. \par
CAP\'cdTULO 15 - ESTRUTURAS DE DADOS 775 \line Aproveitar-nos-emos da rela\'e7\'e3o \'edntima entre listas e pilhas para implementar uma classe pilha reutilizando principalmente uma classe lista. Usamos duas formas diferentes de reutiliza\'e7\'e3o. Primeiro, implementamos a classe pilha atrav\'e9s de heran\'e7a privada da classe lista. Ent\'e3o implementamos uma classe pilha que executa de forma id\'eantica atrav\'e9s do uso da composi\'e7\'e3o, incluindo uma classe lista como um membro privado de uma classe pilha. Naturalmente, todas as estruturas de dados neste cap\'edtulo, inclusive estas duas classes pilha, s\'e3o implementadas como gabaritos (veja Cap\'edtulo 12, \ldblquote Gabaritos\rdblquote ) para encorajar uma reutiliza\'e7\'e3o adicional. \line O programa da Fig. 15.9 (cuja sa\'edda \'e9 mostrada na Fig. 15. 10) cria um gabarito de classe Stack principalmente atrav\'e9s de heran\'e7a private do gabarito de classe List da Fig. 15.3. Queremos que Stack tenha as fun\'e7\'f5es membro push, pop. isStackEinpty e printStack. Note que estas fun\'e7\'f5es s\'e3o essencialmente as fun\'e7\'f5es insertAtFront, removeFromFront. isEmpty e print do gabarito de classe List. Naturalmente, o gabarito de classe List cont\'e9m outras fun\'e7\'f5es membro (i.e., insertAtBack e removeFromBack) que n\'e3o queremos tornar acess\'edveis atrav\'e9s da interface public para a classe Stack. Assim, quando indicarmos que o gabarito de classe Stack deve herdar do gabarito de classe List, especificamos heran\'e7a private. Isto torna private todas as fun\'e7\'f5es membro do gabarito de classe List no gabarito de classe Stack. Quando implementarmos as fun\'e7\'f5es membro de Stack, ent\'e3o faremos cada uma destas chamar a fun\'e7\'e3o membro apropriada da classe List - push chama insertAtFront. pop chama removeFromFront. isStackEmpty chama isEmpty e printStack chama print. \line 1 II Fig. 15.9: stack.h \line 2 II Defini\'e7\'e3o do gabarito de classe Stack \line 3 II Derivado da classe List \line 4 #ifndef STACKH \line 5 #define STACKH \line 6 \line 7 #include \ldblquote list.h\rdblquote  \line 8 \line 9 template< class STACKTYPE > \line 10 class Stack : private List< STACKTYPE > \line 11 public: \line 12 void push( const STACKTYPE &d ) \{ insertAtFront( d ); \line 13 bool pop( STACKTYPE &d ) \{ return removeFromFront( d ); \line 14 bool isStackEmpty() const \{ return isEmptyO; \line 15 void printStack() const \{ printO; \line 16 \line 17 \line 18 #endif \line Fig. 15.9 Um programa simples de pilha- stack.h. \line 19 II Fig. 15.9: figl5O9.cpp \line 20 II Programa para testar a classe gabarito Stack \line 21 #include <iostream> \line 22 #include \ldblquote stack.h\rdblquote  \line 23 \line 24 using std::endl; \line 25 \line 26 int main() \line 27 \{ \line 28 Stack< int > intStack; \line 29 int poplnteger, i; \line 30 cout \'ab \lquote processando um Stack integer\rdblquote  \'ab endl; \line 31 \line 32 for(i=Q;i<4;i+f)\{ \line Fig. 15.9 Um programa simples de pilha - figls 09. cpp (parte 1 de 2). \par
776 C++ COMO PROGRAMAR \line 33 intStack.push( i ); \line 34 intStack.printStack \line 35 \line 36 \line 37 while ( !intStack.isStackEmpty() \line 38 intStack.pop( poplnteger ); \line 39 cout \'ab poplnteger \'ab \ldblquote  retirado da pilha\rdblquote  \'ab endi; \line 40 intStack.printStackQ; \line 41 \line 42 \line 43 Stack< double > doubleStack; \line 44 double vai = 1.1, popdouble; \line 45 cout \'ab \lquote processando um Stack double\rdblquote  \'ab endi; \line 47 for(i0;i<4;i++)\{ \line 48 doubleStack.push( vai ); \line 49 doubleStack.printStack \line 50 vai += 1.1; \line 51 \line 52 \line 53 while ( !doubleStack.isStackEmpty() \line 54 doubleStack.pop( popdouble ); \line 55 cout \'ab popdouble \'ab \ldblquote  retirado da pilha\rdblquote  \'ab endl; \line 56 doubleStack.printStack \line 57 \line 58 return 0; \line 59 \line Fig. 15.9 Um programa simples de pilha - figl5_09. cpp (parte 2 de 2). \line processando um Stack integer \line A lista \'e9: O \line A lista \'e9: 1 O \line A lista \'e9: 2 1 O \line A lista \'e9: 3 2 1 O \line 3 retirado da pilha \line A lista \'e9: 2 1 O \line 2 retirado da pilha \line A lista \'e9: 1 O \line 1 retirado da pilha \line A lista \'e9: O \line o retirado da pilha \line A lista est\'e1 vazia \line processando um Stack double \line A lista \'e9: 1.1 \line A lista \'e9: 2.2 1.1 \line Fig. 15.10 Exemplo de sa\'edda do programa da Fig. 15.9 (parte 1 de 2). \par
CAP\'cdTULO 15 - ESTRUTURAS DE DADOS 777 \line A lista \'e9: 3.3 2.2 1.1 \line A lista \'e9: 4.4 3.3 2.2 1.1 \line 4.4 retirado da pilha \line A lista \'e9: 3.3 2.2 1.1 \line 3.3 retirado da pilha \line A lista \'e9: 2.2 1.1 \line 2.2 retirado da pilha \line A lista \'e9: 1.1 \line 1.1 retirado da pilha \line A lista est\'e1 vazia \line Todos os nodos destru\'eddos \line Todos os nodos destruidos \line Fig. 15.10 Exemplo de sa\'edda do programa da Fig. 15.9 (parte 2 de 2). \line O gabarito da classe pilha \'e9 usado em main para instanciar a pilha de inteiros intStack do tipo Stack< int >. Inteiros de O a 3 s\'e3o inseridos em intStack e ent\'e3o retirados de intStack. O gabarito de classe pilha \'e9 ent\'e3o usado para instanciar a pilha doubleStack do tipo Stack< double >. Os valores 1.1, 2.2, 3.3 e 4.4 s\'e3o inseridos em doubleStack e ent\'e3o retirados de doubleStack. \line Outro caminho para implementar um gabarito de classe Stack \'e9 reutilizar um gabarito da classe List atrav\'e9s de composi\'e7\'e3o. O programa da Fig. 15.11 usa os arquivos list . h e listnd. h do programa de List. Tamb\'e9m usa o mesmo programa de teste que o programa de pilha anterior, exceto que o novo arquivo de cabe\'e7alho \line - stack_c . h - \'e9 inclu\'eddo e substitui stack . h. A sa\'edda tamb\'e9m \'e9 a mesma. A defini\'e7\'e3o do gabarito da classe Stack agora inclui o objeto membro s, do tipo List< STACKTYPE>. \line 1 II Fig. 15.11: stack_c.h \line 2 II Defini\'e7\'e3o da classe Stack composta com o objeto List \line 3 #ifndef STACKC \line 4 #define STACKC \line 5 #include \ldblquote list.h\rquote  \line 6 \line 7 template< class STACKTYPE > \line 8 class Stack \line 9 public: \line 10 // sem construtor; o construtor de List faz a inicializa\'e7\'e3o \line 11 void push( const STACKTYPE &d ) \{ s.insertAtFront( d ); \line 12 bool pop( STACKTYPE &d ) \{ return s.removeFromFront( d ); \line 13 bool isStackEmpty() const \{ return s.isEmptyO; \line 14 void printStack() const ( s.print \} \line 15 private: \line 16 List< STACKTYPE > s; \line 17 \}; \line 18 \line 19 #endif \line Fig. 15.11 Um programa simples com pilha usando composi\'e7\'e3o - stackc.h. \par
77S C++ COMO PROGRAMAR \par
15.6 Filas \line Uma,fila \'e9 semelhante a uma fila no caixa de um supermercado - a primeira pessoa na fila \'e9 atendida primeiro e os outros clientes entram no fim da fila e esperam para ser atendidos. Os nodos da fila s\'e3o retirados somente do in\'edcio da fila e s\'e3o inseridos somente no fim da fila. Por essa raz\'e3o, uma fila \'e9 chamada de estrutura de dados primeiro a entrar primeiro a sair (FIFO, first in, flrst out). As opera\'e7\'f5es de inser\'e7\'e3o e retirada s\'e3o conhecidas como enqueue e dequeue respectivamente. \line As filas t\'eam muitas aplica\'e7\'f5es em sistemas de computadores. A maioria dos computadores t\'eam somente um \'fanico processador, assim somente um usu\'e1rio pode ser atendido de cada vez. Os pedidos dos outros usu\'e1rios s\'e3o colocadas em uma fila. Cada pedido avan\'e7a gradualmente para a frente da fila \'e0 medida que os usu\'e1rios s\'e3o atendidos. O pedido no in\'edcio da fila \'e9 a pr\'f3ximo a ser atendido. \line As filas s\'e3o tamb\'e9m usadas para suportar a impress\'e3o em spool. Um ambiente multiusu\'e1rio pode ter somente uma \'fanica impressora. Muitos usu\'e1rios podem estar gerando sa\'eddas para serem impressas. Se a impressora estiver ocupada, outras sa\'eddas podem ainda ser geradas. Estas s\'e3o postas em um spool no disco (da mesma forma que uma linha \'e9 colocada em um carretel), onde eles esperam em uma fila at\'e9 a impressora se tornar dispon\'edvel. \line Pacotes de informa\'e7\'f5es tamb\'e9m esperam em filas em redes de computador. Toda vez que um pacote chega em um nodo de rede, ele deve ser direcionado para o pr\'f3ximo nodo na rede ao longo do caminho para o destino final do pacote. O nodo de direcionamento encaminha um pacote de cada vez, assim pacotes adicionais s\'e3o enfileirados at\'e9 que o direcionador possa encaminh\'e1-los. \line Um servidor de arquivos em uma de rede de computador trata solicita\'e7\'f5es de acesso a arquivos de muitos clientes na rede. Os servidores t\'eam uma capacidade limitada para tratar solicita\'e7\'f5es de clientes. Quando essa capacidade \'e9 excedida, as solicita\'e7\'f5es de clientes esperam em filas. \line Erro comum de programa\'e7\'e3o 15.8 \line N\'e3o inicializar o link no \'faltimo do \'faltimo nodo de uma fila com nulo (zero). \line A Fig. 15.12 (cuja sa\'edda \'e9 mostrada na Fig. 15.13) cria um gabarito de classe Queue principalmente atrav\'e9s do uso de heran\'e7a private do gabarito de classe List da Fig 15.3. Queremos que Queue tenha as fun\'e7\'f5es membro enqueue. dequeue. isQueueEmpty e printQueue. Percebemos que estas s\'e3o essencialmente as fun\'e7\'f5es do gabarito de classe List: insertAtBack, removeFromFront. isEmpty e print. Naturalmente, o gabarito de classe List cont\'e9m outras fun\'e7\'f5es membro (i.e., insertAtFront e removeFromBack) que n\'e3o queremos tornar acess\'edveis atrav\'e9s da interface public da classe Queue. Assim, quando indicamos que o gabarito de classe Queue deve herdar do gabarito de classe List, especificamos heran\'e7a private. Isto torna private todas as fun\'e7\'f5es membro do gabarito de classe List no gabarito de classe Queue. Quando implementamos as \line j fun\'e7\'f5es membro de Queue, simplesmente fazemos cada uma destas chamar a fun\'e7\'e3o membro apropriada da classe lista - enqueue chama insertAtBack. dequeue chama rexnoveFromFront, isQueueEmpty chama isEmpty e printQueue chama print. \par
Fig. 15.12 Processando uma fila - queue . h (parte 1 de 2). \par
\pard\par
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx301\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx3110\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4383\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx6474\pard\intbl 1 \cell II Fig. 15.12: queue.h \cell\cell\cell\row
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx301\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx3110\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx6474\pard\intbl 2 \cell // Defini\'e7\'e3o do gabarito de \cell classe Queue \cell\row
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx301\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx3110\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4383\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx6474\pard\intbl 3 \cell // Derivado da classe List \cell\cell\cell\row
\intbl 4 \cell #ifndef QUEUEH \cell\cell\cell\row
\intbl 5 \cell #define QUEUEH \cell\cell\cell\row
\intbl 6 \cell\cell\cell\cell\row
\intbl 7 \cell #include \ldblquote list.h\rdblquote  \cell\cell\cell\row
\intbl 8 \cell\cell\cell\cell\row
\intbl 9 \cell template< class QUEUETYPE > \cell\cell\cell\row
\intbl 10 \cell class Queue: private List< \cell QUEUETYPE > \cell\{ \cell\row
\intbl 11 \cell public: \cell\cell\cell\row
\intbl 12 \cell void enqueue( const QUEU \cell ETYPE &d ) \cell\{ insertAtBack( d ); \cell\row
\intbl 13 \cell bool dequeue( QtJEUETYPE \cell &d \cell\cell\row
\pard\par
\pard\sb100\sa240 CAP\'cdTULO 15 - ESTRUTURAS DE DADOS 779 \line 14 \{ return removeFromFront( d \line 15 bool isQueueEmpty() const \{ return isEmptyO; \line 16 void printQueue() const \{ printO; \line 17 \line 18 \line 19 #endif \line Fig. 15.12 Processando uma fila - queue .h (parte 2 de 2). \line 20 II Fig. 15.12: figl5l2.cpp \line 21 II Programa de teste para a classe gabarito Queue \line 22 #include <iostream> \line 23 #inciude \ldblquote queue.h\rdblquote  \line 24 \line 25 using std: :endi; \line 26 \line 27 int main() \line 28 \{ \line 29 Queue< int > intQueue; \line 30 int dequeuelnteger, i; \line 31 cout \'ab \ldblquote processando uma fila mnteger\rdblquote  \'ab endl; \line 32 \line 33 for(i=0;i<4;j++)\{ \line 34 intQueue.enqueue( i ); \line 35 intQueue.printQueueO; \line 36 \line 37 \line 38 while ( !intQueue.isQueueEmpty() \line 39 intQueue.dequeue( dequeuelnteger ); \line 40 cout \'ab dequeuelnteger \'ab retirado da fila \'ab endl; \line 41 intQueue.prmntQueue \line 42 \line 43 \line 44 Queue< double > doubleQueue; \line 45 double val = 1.1, dequeuedouble; \line 46 \line 47 cout \'ab processando uma fila double\rdblquote  \'ab endl; \line 48 \line 49 for ( i = 0; i < 4; i++ \line 50 doubleQueue.enqueue( vai ); \line 51 doubleQueue.printQueueQ; \line 52 vai += 1.1; \line 53 \line 54 \line 55 while ( !doubleQueue.isQueueEmpty() ) \line 56 doubleQueue . dequeue ( dequeuedouble ); \line 57 cout \'ab dequeuedouble \'ab \ldblquote  retirado da fila\rdblquote  \'ab endl; \line 58 doubleQueue.printQueueO.; \line 59 \line 60 \line 61 return 0; \line 62 \} \line Fig. 15.12 Processando uma fila - figl5_12 . cpp. \par
780 C++ COMO PROGRAMAR \line processando uma fila integer \line A lista \'e9: O \line A lista \'e9: O 1 \line A lista \'e9: O 1 2 \line A lista \'e9: O 1 2 3 \line O retirado da fila \line A lista \'e9: 1 2 3 \line 1 retirado da fila \line A lista \'e9: 2 3 \line 2 retirado da fila \line A lista \'e9: 3 \line 3 retirado da fila \line A lista est\'e1 vazia \line processando uma fila double \line A lista \'e9: 1.1 \line A lista \'e9: 1.1 2.2 \line A lista \'e9: 1.1 2.2 3.3 \line A lista \'e9: 1.1 2.2 3.3 4.4 \line 1.1 retirado da fila \line A lista \'e9: 2.2 3.3 4.4 \line 2.2 retirado da fila \line A lista \'e9: 3.3 4.4 \line 3.3 retirado da fila \line A lista \'e9: 4.4 \line 4.4 retirado da fila \line A lista est\'e1 vazia \line Todos os nodos destruidos \line Todos os nodos destru\'eddos \line Fig. 15.13 Exemplo de sa\'edda do programa da Fig. 15.12. \line O gabarito de classe de fila \'e9 usado em main para instanciar a fila de inteiros intQueue do tipo Queue<int>. \line Os inteiros O a 3 s\'e3o inseridos em intQueue e ent\'e3o retirados de intQueue na ordem primeiro a entrar, primeiro \line a sair. O gabarito de classe de fila \'e9 ent\'e3o usado para instanciar a fila doubleQueue do tipo Queue<double>. \line Os valores 1.1, 2.2, 3.3 e 4.4 s\'e3o inseridos em doubleQueue e ent\'e3o retirados de doubleQueue na ordem \line primeiro a entrar, primeiro a sair. \par
CAPfTULO 15 - ESTRUTURAS DE DADOS 781 \line 15.7 \'c1rvores \line Listas encadeadas, pilhas e filas s\'e3o estruturas de dados lineares. Uma \'e1rvore \'e9 uma estrutura de dados n\'e3o-linear, bidimensional, com propriedades especiais. Os nodos de uma \'e1rvore cont\'eam dois ou mais links. Esta se\'e7\'e3o discute \'e1rvores bin\'e1rias (Fig. 15.14) - \'e1rvores cujos nodos cont\'eam dois links (dos quais nenhum, um ou ambos podem ser nulos). O nodo raiz \'e9 o primeiro nodo em uma \'e1rvore. Cada link no nodo raiz referencia um filho. O filho esquerdo \'e9 o nodo raiz da sub\'e1rvore esquerda e ofilho direito \'e9 o nodo raiz da sub\'e1rvore direita. Os filhos de um mesmo nodo s\'e3o chamados de irm\'e3os. Um nodo sem filhos \'e9 chamado de nodo folha. Os cientistas de computa\'e7\'e3o normalmente desenham \'e1rvores do nodo raiz para baixo - exatamente o oposto das \'e1rvores na natureza. \line Nesta se\'e7\'e3o, \'e9 criada uma \'e1rvore bin\'e1ria especial chamada de \'e1rvore de pesquisa bin\'e1ria. Uma \'e1rvore de pesquisa bin\'e1ria (sem valores de nodo duplicados) tem a propriedade de que os valores em qualquer sub\'e1rvore esquerda s\'e3o menores do que o valor em seu nodo pai e os valores em qualquer sub\'e1rvore direita s\'e3o maiores do que o valor em seu nodo pai. A Fig.l5.15 ilustra uma \'e1rvore de pesquisa bin\'e1ria com 12 valores. Note que a forma da \'e1rvore de pesquisa bin\'e1ria que corresponde a um conjunto de dados pode variar, dependendo da ordem em que os valores s\'e3o inseridos na \'e1rvore. \line Erro com um de programa\'e7\'e3o 15.9 \line N\'e3o inicializar com nu/o (zero) os links dos nodos folhas de uma \'e1rvore. \line Fig. 15.14 Uma representa\'e7\'e3o gr\'e1fica de uma \'e1rvore bin\'e1ria. \line (7\{4N8 \line Fig. 15.15 Uma \'e1rvore de pesquisa bin\'e1ria. \line O programa da Fig. 15.16 (cuja sa\'edda \'e9 mostrada na Fig. 15.17) cria uma \'e1rvore de pesquisa bin\'e1ria e a percorre (i.e., caminha atrav\'e9s de todos os seus nodos) de tr\'eas modos - usando percursos recursivos em ordem, em pr\'e9-ordem e em p\'f3s-ordem. \par
782 C++ COMO PROGRAMAR \line 1 II Fig. 15.16: treenode.h \line 2 II Defini\'e7\'e3o da classe TreeNode \line 3 #ifndef T1EENODEH \line 4 #define TREENODEH \line 5 \line 6 template< class NODETYPE > class Tree; II declara\'e7\'e3o antecipada \line 7 \line 8 template< class NODETYPE > \line 9 class TreeNode \line 10 friend class Tree< NODETYPE >; \line 11 public: \line 12 TreeNode( const NODETYPE &d \line 13 : leftPtr( O ), data( d ), rightPtr( O ) \{ \line 14 NODETYPE getData() const \{ return data; \line 15 private: \line 16 TreeNode< NQDETYPE > *leftptr; // ponteiro para sub\'e1rvore esquerda \line 17 NQDETYPE data; \line 18 TreeNode< NODETYPE > *rightptr; II ponteiro para sub\'e1rvore direita \line 19 \line 20 \line 21 #endif \line Fig. 15.16 Criando e percorrendo uma \'e1rvore bin\'e1ria - treenode . h \line 22 II Fig. 15.16: tree.h \line 23 II Defini\'e7\'e3o da classe gabarito Tree \line 24 #ifndef TREEH \line 25 #define TREEH \line 26 \line 27 #include <iostream> \line 28 #include <cassert> \line 29 #include \ldblquote treenode.h\rdblquote  \line 30 \line 31 using std: :endl; \line 32 \line 33 template< class NODETYPE > \line 34 class Tree \{ \line 35 public: \line 36 TreeO; \line 37 void insertNode( const NODETYPE & ); \line 38 void preOrderTraversal() const; \line 39 void inOrderTraversal() const; \line 40 void postOrderTraversal() const; \line 41 private: \line 42 TreeNode< NODETYPE > *rootptr; \line 43 \line 44 II fun\'e7\'f5es utilit\'e1rias \line 45 void insertNodeHelper( \line 46 TreeNode< NODETYPE > const NODETYPE & ); \line 47 void preOrderHelper( TreeNode< NODETYPE > * ) const; \line 48 void inOrderHelper( TreeNode< NODETYPE > * ) const; \line 49 void postOrderHelper( TreeNode< NODETYPE > * ) const; \line 50 \line 51 \line 52 template< class NODETYPE > \line 53 Tree< NODETYPE >::Tree() \{ rootPtr = 0; \} \line Fig. 15.16 Criando e percorrendo uma \'e1rvore bin\'e1ria - tree .h (parte 1 de 3). \par
CAP\'cdTULO 15 - ESTRUTURAS DE DADOS 783 \line 54 \line 55 template< class NODETYPE > \line 56 void Tree< NODETYPE >: :insertNode( const NODETYPE &value \line 57 \{ insertNodeHelper( &rootPtr, value ); \line 58 \line 59 II Esta fun\'e7\'e3o recebe um ponteiro para um ponteiro, \line 60 II de modo que o ponteiro pode ser modificado. \line 61 template< class NODETYPE > \line 62 void Tree< NODETYPE >: :insertNodeHelper( \line 63 TreeNode< NODETYPE > **ptr, const NODETYPE &value \line 64 \line 65 if ( *ptr O ) \{ II \'e1rvore est\'e1 vazia \line 66 *ptr = new TreeNode< NODETYPE >( value ); \line 67 assert( *ptr != O ); \line 68 \line 69 else II \'e1rvore n\'e3o est\'e1 vazia \line 70 if ( value < ( *ptr )->data \line 71 insertNodeHelper( &( ( *ptr )->leftPtr ), value ); \line 72 else \line 73 if ( value > ( *p )->data \line 74 insertNodeHelper( &( ( *ptr )->rightPtr ), value ); \line 75 else \line 76 cout \'ab value \'ab duplo\rdblquote  \'ab endi; \line 77 \} \line 78 \line 79 template< class NODETYPE > \line 80 void Tree< NODETYPE >::preOrderTraversal() const \line 81 \{ preOrderHelper( rootPtr ); \line 82 \line 83 template< class NODETYPE > \line 84 void Tree< NODETYPE >: :preOrderHelper( \line 85 TreeNode< NODETYPE > *ptr ) const \line 86 \line 87 if ( ptr != O \line 88 cout \'ab ptr->data \'ab \line 89 preOrderHelper( ptr->leftPtr ); \line 90 preOrderHelper( ptr->rightPtr ); \line 91 ) \line 92 \} \line 93 \line 94 template< class NODETYPE > \line 95 void Tree< NODETYPE >::inOrderTraversal() const \line 96 \{ inOrderHelper( rootPtr ); \line 97 \line 98 template< class NODETYPE > \line 99 void Tree< NODETYPE >::inOrderHelper( \line 100 TreeNode< NODETYPE > *ptr ) const \line 101 \{ \line 102 if ( ptr != O ) \{ \line 103 inOrderHelper ( ptr->leftPtr ); \line 104 cout \'ab ptr->data \'ab \line 105 inOrderHelper( ptr->rightPtr ); \line 106 \} \line 107 ) \line 108 \line 109 template< class NODETYPE > \line 110 void Tree< NODETYPE >: :postOrderTraversal() const \line 111 \{ postOrderHelper( rootPtr ); ) \line Fig. 15.16 Criando e percorrendo uma \'e1rvore bin\'e1ria - tree . h (parte 2 de 3). \par
784 C++ COMO PROGRAMAR \line 112 \line 113 template< class NODETYPE > \line 114 void Tree< NODETYPE >: :postOrderHelper( \line 115 TreeNode< NODETYPE > *p ) const \line 116 \line 117 if ( ptr ! O \line 118 postOrderHelper( ptr->leftPtr ); \line 119 postOrderHelper( ptr->rightPtr ); \line 120 cout \'ab ptr->data \'ab \line 121 \line 122 \} \line 123 \line 124 #endif \line Fig. 15.16 Criando e percorrendo uma \'e1rvore bin\'e1ria - tree .h (parte 3 de 3). \line 125 II Fig. 15.16: figl5l6.cpp \line 126 II Programa para testar a classe Tree \line 127 #include <iostreain> \line 128 #include <iomanip> \line 129 #include \ldblquote tree.h\rdblquote  \line 130 \line 131 using std::cout; \line 132 using std::cin; \line 133 using std::setiosflags; \line 134 using std::ios; \line 135 using std: :setprecision; \line 136 \line 137 int main() \line 138 \{ \line 139 Tree< int > intTree; \line 140 int intVal, i; \line 141 \line 142 cout \'ab \ldblquote Digite 10 valores inteiros:\\n\rdblquote ; \line 143 for ( i = 0; i < 10; i++ \line 144 cm \'bb intVal; \line 145 intTree.insertNode( intVal ); \line 146 \} \line 147 \line 148 cout \'ab \ldblquote\\nPercorrendo na pr\'e9-ordem\\n; \line 149 intTree.preOrderTraversalO; \line 150 \line 151 cout \'ab \ldblquote\\nPercorrendo em ordem\\n\rdblquote ; \line 152 intTree.inOrderTraversa1 \line 153 \line 154 cout \'ab \ldblquote\\nPercorrendo na p\'f3s-ordem\\n; \line 155 intTree.postOrderTraversal(); \line 156 \line 157 Tree< double > doubleTree; \line 158 double doubleVal; \line 159 \line 160 cout \'ab \ldblquote\\n\\n\\nDigite 10 valores double:\\n \line 161 \'ab setiosflags( ios::fixed 1 ios::showpoint \line 162 \'ab setprecision( 1 ); \line 163 for ( i = O; i < 10; i++ ) \line 164 cm \'bb doubleVal; \line Fig. 15.16 Criando e percorrendo uma \'e1rvore bin\'e1ria - figl5_16 . cpp (parte 1 de 2). \par
CAP\'cdTULO 15 - ESTRUTURAS DE DADOS 785 \par
165 doubleTree.insertNode( doubleVal ); \line 166 \line 167 \line 168 cout \'ab \ldblquote\\nPercorrendo na pr\'e9-ordem\\n\rdblquote ; \line 169 doub1eTree.preOrderTraversa1 \line 170 \line 171 cout \'ab \\nPercorrendo em ordem\\n\rdblquote ; \line 172 doubleTree.inOrderTraversalO; \line 173 \line 174 cout \'ab \ldblquote\\nPercorrendo na pos-ordem\\n\rquote ; \line 175 doubleTree . postOrderTraversal O; \line 176 \line 177 return 0; \line 178 \} \line Fig. 15.16 Criando e percorrendo uma \'e1rvore bin\'e1ria - figl5_16 . cpp (parte 2 de 2). \line A fun\'e7\'e3o main come\'e7a por instanciar a \'e1rvore de inteiros intTree do tipo Tree<int>. O programa solicita ao usu\'e1rio 10 inteiros, cada um dos quais \'e9 inserido na \'e1rvore bin\'e1ria atrav\'e9s de uma chamada a insertnNode. O programa ent\'e3o percorre a \'e1rvore inttree na pr\'e9-ordem, em ordem e na p\'f3s-ordem (que ser\'e3o explicadas em breve), O programa ent\'e3o instancia a \'e1rvore de ponto flutuante doubleTree do tipo Tree<double>. O programa solicita ao usu\'e1rio 10 valores double, cada um dos quais \'e9 inserido na \'e1rvore bin\'e1ria atrav\'e9s de uma chamada a insertNode. O programa ent\'e3o percorre a \'e1rvore doubleTree na pr\'e9-ordem, em ordem e na p\'f3s-ordem. \line Digite 10 valores inteiros: \line 50 25 75 12 33 67 88 6 13 68 \line Percorrendo na pr\'e9-ordem \line 50 25 12 6 13 33 75 67 68 88 \line Percorrendo na ordem \line 6 12 13 25 33 50 67 68 75 88 \line Percorrendo na p\'f3s-ordem \line 6 13 12 33 25 68 67 88 75 50 \line Digite 10 valores double: \line 39.2 16.5 82.7 3.3 65.2 90.8 1.1 4.4 89.5 92.5 \line Percorrendo na pr\'e9-ordem \line 39.2 16.5 3.3 1.1 4.4 82.7 65.2 90.8 89.5 92.5 \line Percorrendo na ordem \line 1.1 3.3 4.4 16.5 39.2 65.2 82.7 89.5 90.8 92.5 \line Percorrendo na p\'f3s-ordem \line 1.1 4.4 3.3 16.5 65.2 89.5 92.5 90.8 82.7 39.2 \line Fig. 15.17 Exemplo de sa\'edda do programa da Fig. 15.16. \line Agora, discutiremos as defini\'e7\'f5es do gabarito de classe. Come\'e7amos com o gabarito de classe TreeNode que declara como friend o gabarito de classe Tree. A classe TreeNode tem como dado private o valor dados do nodo e os ponteiros leftPtr (para a sub\'e1rvore esquerda do nodo) e rightPtr (para a sub\'e1rvore direita do nodo). O construtor inicializa data com o valor fornecido como um par\'e2metro do construtor e inicializa os ponteiros leftPtr e rightPtr com zero (inicializando deste modo este nodo como um nodo folha). A fun\'e7\'e3o membro getData retorna o valor de data. \par
786 C++ COMO PROGRAMAR \line A classe Tree tem como dado private rootptr. um ponteiro para o nodo raiz da \'e1rvore. A classe tem as fun\'e7\'f5es membro p\'fablicas insertNode (que insere um novo nodo na \'e1rvore) e preOrderTraversal, inOrderTraversal e pos tOrderTraversal, cada uma percorrendo a \'e1rvore da maneira designada. Cada uma destas fun\'e7\'f5es membro chama sua pr\'f3pria fun\'e7\'e3o utilit\'e1ria recursiva separada para executar as opera\'e7\'f5es apropriadas sobre a representa\'e7\'e3o interna da \'e1rvore, O construtor de Tree inicializa rootPtr com zero para indicar que a \'e1rvore est\'e1 inicialmente vazia. \line A fun\'e7\'e3o utilit\'e1ria insertNodeHelper da classe Tree insere recursivamente um nodo na \'e1rvore. Um nodo em uma \'e1rvore de pesquisa bin\'e1ria somente pode ser inserido como um nodo folha. Se a \'e1rvore est\'e1 vazia, um novo TreeNode \'e9 criado, inicializado e inserido na \'e1rvore. \line Se a \'e1rvore n\'e3o est\'e1 vazia, o programa compara o valor a ser inserido com o valor de data no nodo raiz. Se o valor a inserir \'e9 menor, o programa chama recursivamente insertNodeHelper para inserir o valor na sub- \line\'e1rvore esquerda. Se o valor a inserir \'e9 maior, o programa recursivamente chama insertNodeHelper para inserir o valor na sub-\'e1rvore direita. Se o valor a ser inserido \'e9 id\'eantico ao valor de dados no nodo raiz, o programa imprime a mensagem \lquote duplo e retorna sem inserir o valor duplicado na \'e1rvore. \line Cada uma das fun\'e7\'f5es membro inOrderTraversal, preOrderTraversal e postOrderTraversal percorre a \'e1rvore (Fig. 15.18) e imprime os valores dos nodos. \line Os passos para um inOrderTraversal s\'e3o: \line 1. Percorra a sub\'e1rvore esquerda com um inOrderTraversal. \line 2. Processe o valor no nodo (i.e., imprima o valor do nodo). \line 3. Percorra a sub\'e1rvore direita com um inOrderTraversal. \line O valor em um nodo n\'e3o \'e9 processado at\'e9 os valores em sua sub\'e1rvore esquerda serem processados. O inOrderTraversal da \'e1rvore na Fig. 15.18 \'e9: \line 6 13 17 27 33 42 48 \line\lquote 1 Note que o inOrderTraversal de uma \'e1rvore de pesquisa bin\'e1ria imprime os valores dos nodos em ordem ascendente. O processo de criar uma \'e1rvore de pesquisa bin\'e1ria realmente classifica os dados - e deste modo este processo \'e9 chamado de classifica\'e7\'e3o da \'e1rvore bin\'e1ria. \line Os passos para um preOrderTraversal s\'e3o: \line 1. Processe o valor no nodo. \line 2. Percorra a sub\'e1rvore esquerda com um preOrderTraversal. \line 3. Percorra a sub\'e1rvore direita com um preOrderTraversal. \line O valor em cada nodo \'e9 processado \'e0 medida que o nodo \'e9 visitado. Depois do valor em um dado nodo ser processado, os valores na sub\'e1rvore esquerda s\'e3o processados e, ent\'e3o, os valores na sub\'e1rvore direita s\'e3o processados. O pre\'f8rderTraversal da \'e1rvore na Fig. 15.18 \'e9: \line 27 13 6 17 42 33 48 \line Os passos para um postOrderTraversal s\'e3o: \line 1. Percorra a sub\'e1rvore esquerda com um pos tOrderTraversal. \line 2. Percorra a sub\'e1rvore direita com um postOrderTraversal. \line 3. Processe o valor no nodo. \line O valor em cada nodo n\'e3o \'e9 impresso at\'e9 os valores de seus filhos serem impressos. O pos tOrderTraversal da \'e1rvore na Fig. 15.18 \'e9: \line 6 17 13 33 48 42 27 \line A \'e1rvore de pesquisa bin\'e1ria facilita a elimina\'e7\'e3o de duplicatas. \'c0 medida que a \'e1rvore vai sendo criada, uma tentativa de inser\'e7\'e3o de um valor duplicado ser\'e1 reconhecida porque uma duplicata seguir\'e1 as mesmas decis\'f5es \ldblquote v\'e1 \par
CAP\'cdTULO 15 - ESTRUTURAS DE DADOS 787 \par
para a esquerda\rdblquote  ou \ldblquote v\'e1 para a direita\rdblquote  em cada compara\'e7\'e3o que o valor original seguiu. Deste modo, em algum momento, a duplicata ser\'e1 comparada com um nodo contendo o mesmo valor. Neste momento, o valor duplicado pode simplesmente ser descartado. \line 27 \line 13 42 \line 6 17 33 48 \line Fig. 15.18 Uma \'e1rvore de pesquisa bin\'e1ria. \line Pesquisar uma \'e1rvore bin\'e1ria para encontrar um valor que corresponde ao valor de uma chave tamb\'e9m \'e9 r\'e1pido. Se a \'e1rvore est\'e1 balanceada, ent\'e3o cada n\'edvel cont\'e9m aproximadamente duas vezes o n\'famero de elementos do n\'edvel anterior. Assim, uma \'e1rvore de pesquisa bin\'e1ria com n elementos teria um m\'e1ximo de log2n n\'edveis e, deste modo, um m\'e1ximo de log2n compara\'e7\'f5es teria que ser feito ou para achar uma correspond\'eancia ou para determinar que n\'e3o existe nenhuma correspond\'eancia. Isto significa, por exemplo, que, quando pesquisarmos uma \'e1rvore de pesquisa bin\'e1ria (balanceada) de 1.000 elementos, n\'e3o mais do que 10 compara\'e7\'f5es precisam ser feitas, porque 210> 1.000. Quando pesquisarmos uma \'e1rvore de pesquisa bin\'e1ria (balanceada) de 1.000.000 elementos, n\'e3o mais do que 20 compara\'e7\'f5es precisam ser feitas, porque 220> 1.000.000. \line Nos exerc\'edcios, s\'e3o apresentados algoritmos para v\'e1rias outras opera\'e7\'f5es com \'e1rvores bin\'e1rias, tais como eliminar um item de uma \'e1rvore bin\'e1ria, imprimir uma \'e1rvore bin\'e1ria em um formato de \'e1rvore bidimensional e percorrer uma \'e1rvore bin\'e1ria em ordem de n\'edvel. O percurso em ordem de n\'edvel de uma \'e1rvore bin\'e1ria visita os nodos da \'e1rvore linha por linha, come\'e7ando no n\'edvel do nodo raiz. Em cada n\'edvel da \'e1rvore, os nodos s\'e3o visitados da esquerda para a direita. Outros exerc\'edcios de \'e1rvores bin\'e1rias incluem permitir que uma \'e1rvore de pesquisa bin\'e1ria contenha valores duplicados, inserir valores de strings em uma \'e1rvore bin\'e1ria e determinar quantos n\'edveis est\'e3o contidos em uma \'e1rvore bin\'e1ria. \line Resumo \line\bullet  Classes auto-referentes cont\'eam membros chamados de links que apontam para objetos do mesmo tipo da classe. \line\bullet  Classes auto-referentes possibilitam que muitos objetos da classe sejam encadeados em pilhas, filas, listas e \'e1rvores. \line\bullet  A aloca\'e7\'e3o din\'e2mica de mem\'f3ria reserva um bloco de bytes na mem\'f3ria para armazenar um objeto durante a execu\'e7\'e3o do programa. \line\bullet  Uma lista encadeada \'e9 uma cole\'e7\'e3o linear de objetos de uma classe auto-referente. \line\bullet  Uma lista encadeada \'e9 uma estrutura de dados din\'e2mica - o comprimento da lista pode aumentar ou diminuir conforme necess\'e1rio. \line\bullet  As listas encadeadas podem continuar a crescer at\'e9 a mem\'f3ria se esgotar. \line\bullet  As listas encadeadas fornecem um mecanismo para inser\'e7\'e3o e exclus\'e3o de dados atrav\'e9s da manipula\'e7\'e3o de ponteiros. \line\bullet  Uma lista simplesmente encadeada come\'e7a com um ponteiro para o primeiro nodo e cada nodo cont\'e9m um ponteiro para o pr\'f3ximo nodo \ldblquote na seqti\'eancia\rdblquote . Esta lista termina com um nodo cujo membro ponteiro \'e9 0. Uma lista simplesmente encadeada pode ser percorrida somente em uma dire\'e7\'e3o. \line\bullet  Uma lista circular simplesmente encadeada come\'e7a com um ponteiro para o primeiro nodo e cada nodo cont\'e9m um ponteiro para o pr\'f3ximo nodo. O ponteiro no \'faltimo nodo aponta para o primeiro nodo, fechando deste modo o c\'edrculo. \line\bullet  Uma lista duplamente encadeada permite percursos tanto para a frente como para tr\'e1s. Cada nodo tem um \ldblquote ponteiro para a frente\rdblquote  para o pr\'f3ximo nodo na lista na dire\'e7\'e3o para a frente e um \ldblquote ponteiro para tr\'e1s\rdblquote  para o pr\'f3ximo nodo da lista na dire\'e7\'e3o para tr\'e1s. \par
788 C++ COMO PROGRAMAR \line Em uma lista circular duplamente encadeada, o \ldblquote ponteiro para a frente\rdblquote  do \'faltimo nodo aponta para o primeiro nodo e o \ldblquote ponteiro para tr\'e1s\rdblquote  do primeiro nodo aponta para o \'faltimo nodo, fechando deste modo o \ldblquote cfrculo\rdblquote . \line\bullet  As pilhas e filas s\'e3o vers\'f5es de listas encadeadas com restri\'e7\'f5es. \line\bullet  Novos nodos de uma pilha s\'e3o inseridos e retirados da mesma pilha somente no topo da pilha. Por essa raz\'e3o, uma pilha \'e9 chamada de uma estrutura de dados \'faltimo a entrar, primeiro a sair (LIFO, last in, firsr our). \line\bullet  O membro link no \'faltimo nodo da pilha \'e9 inicializado com nulo (zero) para indicar a base da pilha. \line\bullet  As duas opera\'e7\'f5es prim\'e1rias usadas para manipular uma pilha s\'e3o push e pop. A opera\'e7\'e3o push cria um novo nodo e o coloca sobre o topo da pilha. A opera\'e7\'e3o pop remove um nodo do topo da pilha, libera a mem\'f3ria que foi alocada para aquele nodo e retorna o valor retirado. \line\bullet  Em uma estrutura de dados de fila, nodos s\'e3o removidos do in\'edcio e inseridos no fim. Por essa raz\'e3o, uma fila \'e9 chamada de uma estrutura de dados primeiro a entrar, primeiro a sair (FIFO, first in, first out ). As opera\'e7\'f5es de inser\'e7\'e3o e retirada s\'e3o conhecidas como enqueue e dequeue. \line\bullet  As \'e1rvores s\'e3o estruturas de dados de duas dimens\'f5es exigindo dois ou mais links por nodo. \line\bullet  As \'e1rvores bin\'e1rias cont\'eam dois links por nodo. \line\bullet  O nodo raiz \'e9 o primeiro nodo da \'e1rvore. \line\bullet  Cada um dos ponteiros no nodo raiz se refere a um filho. O filho esquerdo \'e9 o primeiro nodo na sub\'e1rvore esquerda e o filho direito \'e9 o primeiro nodo na sub\'e1rvore direita. Os filhos de um mesmo nodo s\'e3o chamados de irm\'e3os. Qualquer nodo da \'e1rvore que n\'e3o tem nenhum filho \'e9 chamado de nodo folha. \line\bullet  Uma \'e1rvore de pesquisa bin\'e1ria tem a caracter\'edstica que o valor no filho esquerdo de um nodo \'e9 menor que o valor em seu nodo pai, e o valor no filho direito de um nodo \'e9 maior do que ou igual ao valor em seu nodo pai. Se n\'e3o existirem valores de dados duplicados, o valor no filho direito \'e9 simplesmente maior que o valor em seu nodo pai. \line\bullet  Um percurso em ordem de uma \'e1rvore bin\'e1ria percorre a sub\'e1rvore esquerda em ordem, processa o valor no nodo raiz e, ent\'e3o, percorre a sub\'e1rvore direita em ordem. O valor em um nodo n\'e3o \'e9 processado at\'e9 que os valores em sua sub\'e1rvore esquerda sejam processados. \line\bullet  Um percurso em pr\'e9-ordem processa o valor no nodo raiz, percorre a sub\'e1rvore esquerda em pr\'e9-ordem e, ent\'e3o, percorre a sub\'e1rvore direita em pr\'e9-ordem. O valor em cada nodo \'e9 processado \'e0 medida que o nodo \'e9 encontrado. \line\bullet  Um percurso em p\'f3s-ordem percorre a sub\'e1rvore esquerda em p\'f3s-ordem, percorre a sub\'e1rvore direita em p\'f3s-ordem e, ent\'e3o, processa o valor no nodo raiz. O valor em cada nodo n\'e3o \'e9 processado at\'e9 que os valores nas duas sub\'e1rvores sejam processados. \line Terminologia \line aloca\'e7\'e3o din\'e2mica de mem\'f3ria fim de uma fila \line\'e1rvore fun\'e7\'e3o predicado \line\'e1rvore bin\'e1ria indire\'e7\'e3o dupla \line\'e1rvore de pesquisa bin\'e1ria in\'edcio de uma fila \line classifica\'e7\'e3o de \'e1rvore bin\'e1ria inserindo um nodo \line deletar um nodo irm\'e3os \line dequeue LIFO (\'faltimo a entrar, primeiro a sair) \line elimina\'e7\'e3o de duplicatas lista circular duplamente encadeada \line enqueue lista circular simplesmente encadeada \line estrutura auto-referente lista duplamente encadeada \line estrutura de dados linear lista encadeada \line estrutura de dados n\'e3o-linear lista simplesmente encadeada \line estruturas de dados din\'e2micas nodo \line FIFO (primeiro a entrar, primeiro a sair) nodo filho \line fila nodo folha \line filho direito nodo pai \line filho esquerdo nodo raiz \line filhos percurso \par
CAP\'cdTULO 15 - ESTRUTURAS DE DADOS 789 \line percurso de uma \'e1rvore bin\'e1ria em ordem push \line percurso de uma \'e1rvore bin\'e1ria em p\'f3s-ordem sizeof \line percurso de uma \'e1rvore bin\'e1ria em pr\'e9-ordem sub\'e1rvore \line percurso em ordem de n\'edvel de uma \'e1rvore bin\'e1ria sub\'e1rvore direita \line pilha sub\'e1rvore esquerda \line ponteiro nulo topo \line ponteiro para um ponteiro visitar um nodo \line poP \line Erros comuns de programa\'e7\'e3o \line 15.1 N\'e3o inicializar o link no \'faltimo nodo de uma lista com nulo (O). \line 15.2 Assumir que o tamanho de um objeto de uma classe \'e9 simplesmente a soma dos tamanhos de seus membros de dados. \line 15.3 N\'e3o liberar a mem\'f3ria alocada dinamicamente quando ela n\'e3o \'e9 mais necess\'e1ria pode fazer com que o sistema fique prematuramente sem mem\'f3ria. Isto \'e9 \'e0s vezes chamado de \ldblquote perda de mem\'f3ria.\rdblquote  \line 15.4 Apagar com delete mem\'f3ria que n\'e3o foi alocada dinamicamente com new. \line 15.5 Referenciar mem\'f3ria que foi deletada. \line 15.6 Tentar deletar mem\'f3ria que j\'e1 foi deletada pode levar a resultados imposs\'edveis de predizer, durante a execu\'e7\'e3o. \line 15.7 N\'e3o inicializar o link no nodo da parte inferior de uma pilha como nulo (zero). \line 15.8 N\'e3o inicializar o link no \'faltimo do \'faltimo nodo de uma fila com nulo (zero). \line 15.9 N\'e3o inicializar com nulo (zero) os links dos nodos folha de uma \'e1rvore. \line Boas pr\'e1ticas de programa\'e7\'e3o \line 15.1 Quando a mem\'f3ria que foi alocada dinamicamente com new n\'e3o \'e9 mais necess\'e1ria, use delete para liberar a mem\'f3ria imediatamente para o sistema. \line 15.2 Atribua nulo (zero) ao membro de encadeamento (link) de um novo nodo. Os ponteiros devem ser inicializados antes de serem usados. \line Dicas de desempenho \line 15.1 Um array pode ser declarado para conter mais elementos que o n\'famero de itens esperados, mas isto pode desperdi\'e7ar mem\'f3ria. As listas encadeadas podem fornecer uma utiliza\'e7\'e3o de mem\'f3ria melhor nestas situa\'e7\'f5es. As listas encadeadas \line permitem ao programa se adaptar durante a execu\'e7\'e3o. \line 15.2 A inser\'e7\'e3o e exclus\'e3o em um array ordenado pode consumir tempo - todos os elementos em seguida ao elemento insendo ou exclu\'eddo devem ser movidos de forma apropriada. \line 15.3 Os elementos de um array s\'e3o armazenados contiguamente na mem\'f3ria. Isto permite o acesso imediato a qualquer elemento do array porque o endere\'e7o de qualquer elemento pode ser calculado diretamente com base na posi\'e7\'e3o de in\'edcio \line do array. As listas encadeadas n\'e3o disp\'f5em de tal \ldblquote acesso direto\rdblquote  imediato a seus elementos. \line 15.4 Usar aloca\'e7\'e3o de mem\'f3ria din\'e2mica (em vez de arrays) para estruturas de dados que crescem e encolhem durante a execu\'e7\'e3o pode economizar mem\'f3ria. Tenha em mente, por\'e9m. que ponteiros ocupam espa\'e7o e que a aloca\'e7\'e3o de mem\'f3ria din\'e2mica incorre no overhead das chamadas de fun\'e7\'f5es. \line Dica de portabilidade \line 15.1 O tamanho de um objeto de uma classe n\'e3o \'e9 necessariamente a soma dos tamanhos de seus membros de dados. Isto ocorre por causa de v\'e1rios requisitos de alinhamento delimites de endere\'e7os dependentes de m\'e1quina (ver o Cap\'edtulo 16) \line e por outras raz\'f5es. Use o operador sizeof para determinar o tamanho de um objeto. \line Exerc\'edcios de auto-revis\'e3o \line 15.1 Preencha os espa\'e7os em branco em cada um dos seguintes itens: \line a) Uma classe auto- _______________ \'e9 usada para formar estruturas de dados din\'e2mica que podem crescer e encolher durante a execu\'e7\'e3o. \line b) O operador \'e9 usado para alocar mem\'f3ria dinamicamente e construir um objeto; este operador retorna \line um ponteiro para a mem\'f3ria alocada. \par
790 C++ COMO PROGRAMAR \line c) Uma ______________ \'e9 uma vers\'e3o com restri\'e7\'f5es de uma lista encadeada, na qual os nodos podem ser inseridos e apagados somente no in\'edcio da lista, e os valores dos nodos s\'e3o retirados na ordem \'faltimo a entrar, primeiro a sair. \line d) Uma fun\'e7\'e3o que n\'e3o altera uma lista encadeada, mas simplesmente examina a lista para determinar se ela est\'e1 vazia \'e9 chamada de uma fun\'e7\'e3o \line e) Uma fila \'e9 chamada de uma estrutura de dados porque os primeiros nodos inseridos s\'e3o os primeiros \line nodos removidos. \line f) O ponteiro para o pr\'f3ximo nodo em uma lista encadeada \'e9 chamado de _____________ \line g) O operador \'e9 usado para destruir um objeto e recuperar mem\'f3ria alocada dinamicamente. \line h) A ______________ \'e9 uma vers\'e3o com restri\'e7\'f5es de uma lista encadeada na qual os nodos podem ser inseridos somente no fim da lista e retirados somente do in\'edcio da lista. \line i) A ______________ \'e9 uma estrutura de dados n\'e3o-linear, de duas dimens\'f5es, que cont\'e9m nodos com dois ou mais links. \line j) Uma pilha \'e9 chamada de uma estrutura de dados porque o \'faltimo nodo inserido \'e9 o primeiro nodo retirado. \line k) Os nodos de uma \'e1rvore _____________ cont\'e9m dois membros de link. \line 1) O primeiro nodo de uma \'e1rvore \'e9 o nodo_____________ \line m) Cada Iink em um nodo de uma \'e1rvore aponta para um _____________ou daquele nodo. \line n) Um nodo de \'e1rvore que n\'e3o tem nenhum filho \'e9 chamado de um nodo _____________ \line o) Os quatro algoritmos de percurso dos nodos que mencionamos no texto para \'e1rvores de pesquisa bin\'e1ria s\'e3o \line ________ ________ ________ e ________ \line 15.2 Quais s\'e3o as diferen\'e7as entre uma lista encadeada e uma pilha? \line 15.3 Quais s\'e3o as diferen\'e7as entre uma pilha e uma fila\rquote ? \line 15.4 Talvez um t\'edtulo mais apropriado para este cap\'edtulo teria sido \ldblquote Estruturas de dados reutiliz\'e1veis\rdblquote . Comente sobre como cada uma das entidades ou conceitos seguintes contribui para a reutiliza\'e7\'e3o de estruturas de dados: \line a) classes \line b) classes gabarito \line e) heran\'e7a \line d) heran\'e7a privada \line e) composi\'e7\'e3o. \line 15.5 Forne\'e7a manualmente os percursos em ordem, na pr\'e9-ordem e na p\'f3s-ordem da \'e1rvore de pesquisa bin\'e1ria da Fig. 15.19. \line Respostas aos exerc\'edcios de auto-revis\'e3o \line 15.1 a) referente. b) new. c) pilha. d) fun\'e7\'f5es predicado. e) primeiro a entrar, primeiro a sair (FIFO). 1) link. g) delete. h) fila. i) \'e1rvore. j) \'faltimo a entrar, primeiro a sair (LIFO). k) bin\'e1ria. 1) raiz. m) filho ou sub\'e1rvore. n) folha. o) em ordem, \line na pr\'e9-ordem e na p\'f3s-ordem. \line 15.2 \'c9 poss\'edvel se inserir um nodo em qualquer lugar em uma lista encadeada e remover um nodo de qualquer lugar em uma lista encadeada. Os nodos em uma pilha somente podem ser inseridos no topo da pilha e removidos do topo da pilha. \line 15.3 Uma fila tem ponteiros tanto para seu in\'edcio como para seu fim, de forma que podemos inserir no fim e retirar do in\'edcio. Uma pilha tem um ponteiro \'fanico para o topo da pilha, onde tanto a inser\'e7\'e3o como a retirada de nodos s\'e3o executadas. \line 15.4 a) Classes nos permitem instanciar tantos objetos de estrutura de dados de um certo tipo (i.e., classe) conforme desejemos. \line b) Gabaritos de classes nos possibilitam instanciar classes relacionadas - cada uma baseada em um par\'e2metro de tipo diferente - podemos ent\'e3o gerar tantos objetos de cada classe gabarito quantos quisermos. \line e) A heran\'e7a nos possibilita reutilizar o c\'f3digo de uma classe base em uma classe derivada, de forma que a estrutura de dados da classe derivada tamb\'e9m \'e9 uma estrutura de dados da classe base (com heran\'e7a p\'fablica, \'e9 claro). \line d) A heran\'e7a privada nos possibilita reutilizar partes do c\'f3digo de uma classe base para formar uma estrutura de dados da classe derivada; como a heran\'e7a \'e9 private. todas as fun\'e7\'f5es membro private da classe base tornam-se private na classe derivada. Isto nos possibilita evitar que clientes da estrutura de dados da classe derivada acessem fun\'e7\'f5es membro da classe base que n\'e3o se aplicam \'e0 classe derivada. \line e) A composi\'e7\'e3o nos possibilita reutilizar c\'f3digo tomando a estrutura de dados de um objeto de classe um membro de uma classe composta; se tornarmos o objeto de classe um membro private da classe composta, ent\'e3o as fun\'e7\'f5es \line membro public do objeto de classe n\'e3o estar\'e3o dispon\'edveis atrav\'e9s da interface do objeto composto. \par
CAP\'cdTULO 15 - ESTRUTURAS DE DADOS 791 \line los e 15.5 O percurso em ordem \'e9: \line air. 11 18 19 28 32 40 44 49 69 71 72 83 92 97 99 \line vazia \line O percurso na pr\'e9-ordem \'e9: \line tiros \line 49 28 18 11 19 40 32 44 83 71 69 72 97 92 99 \line O percurso na p\'f3s-ordem \'e9: \line ente 11 19 18 32 44 40 28 69 72 71 92 99 97 83 49 \line O percurso na pr\'e9-ordem \'e9: \line mais \line 49 28 18 11 19 40 32 44 83 71 69 72 97 92 99 \line\lquote odo O percurso na p\'f3s-ordem \'e9: \line 11 19 18 32 44 40 28 69 72 71 92 99 97 83 49 \line s\'e3o \line orno 119 32 44 62 929 \line Fig. 15.19 Uma \'e1rvore de pesquisa bin\'e1ria de 15 nodos. \line 5.19. Exerc\'edcios \line 15.6 Escreva um programa que concatena dois objetos de listas encadeadas de caracteres. O programa deve incluir a fun\'e7\'e3o concatenate. a qual recebe refer\'eancias para ambos os objetos da lista como argumentos e concatena a segunda lista com a primeira lista. \line ei 15.7 Escreva um programa que intercala (merge) dois objetos lista de inteiros ordenados em um \'fanico objeto lista de inteiros ordenada. A fun\'e7\'e3o merge deve receber refer\'eancias para cada um dos objetos lista a serem intercalados e deve retornar uma refer\'eancia para o objeto lista intercalada. \line uma . . . . \line 15.8 Escreva um programa que insere 25 inteiros aleatorios de O ate 100 em ordem em um objeto lista encadeada. O programa deve calcular a soma dos elementos e a m\'e9dia dos elementos em ponto flutuante. \line rdo 15.9 Escreva um programa que cria um objeto lista encadeada de 10 caracteres e, ent\'e3o, cria um segundo objeto lista contendo uma c\'f3pia da primeira lista, mas em ordem inversa. \line [flOS 15.10 Escreva um programa que recebe como entrada uma linha de texto e usa um objeto pilha para imprimir a linha invertida. \line 15.11 Escreva um programa que usa um objeto pilha para determinar se um string \'e9 um pal\'edndromo (i.e., um string que \'e9 a de soletrado da mesma maneira da frente para tr\'e1s e de tr\'e1s para diante). O programa deve ignorar espa\'e7os e pontua\'e7\'e3o. \line ados 15.12 Pilhas s\'e3o usadas por compiladores para ajudar no processo de analisar express\'f5es e gerar c\'f3digo em linguagem de m\'e1quina. Neste e no pr\'f3ximo exerc\'edcio, investigaremos como compiladores analisam express\'f5es aritm\'e9ticas consistindo somen se te em cons\'d8tes, operadores e par\'eanteses. \line Seres humanos geralmente escrevem express\'f5es como 3 + 4 e 7 / 9 em que o operador (aqui + ou i \'e9 escrito entre \line o_de seus operandos - isto \'e9 chamado de nota\'e7\'e3o infixa. Os computadores \ldblquote preferem\rdblquote  a nota\'e7\'e3o p\'f3s-fixa, na qual o operador \'e9 escrito \'e7oes \'e0 direita de seus dois operandos. As express\'f5es infixas precedentes apareceriam em nota\'e7\'e3o p\'f3s-fixa como 3 4 e 7 9 1, \line respectivamente. \par
792 C++ COMO PROGRAMAR \line Para calcular uma express\'e3o infixa complexa, um compilador primeiro converteria a express\'e3o para a nota\'e7\'e3o p\'f3s-fixa e, ent\'e3o, analisaria e calcularia a vers\'e3o p\'f3s-fixa da express\'e3o. Cada um destes algoritmos exige somente uma \'fanica passagem pela express\'e3o, da esquerda para a direita. Cada algoritmo usa um objeto pilha para suportar sua opera\'e7\'e3o e, em cada passagem do algoritmo, a pilha \'e9 usada para um fim diferente. \line Neste exerc\'edcio, voc\'ea escrever\'e1 uma vers\'e3o em C++ do algoritmo de convers\'e3o de nota\'e7\'e3o infixa para p\'f3s-fixa. No pr\'f3ximo exerc\'edcio, voc\'ea escrever\'e1 uma vers\'e3o em C++ do algoritmo de an\'e1lise da express\'e3o p\'f3s-fixa. Mais \'e0 frente no cap\'edtulo, voc\'ea descobrir\'e1 que o c\'f3digo que voc\'ea escreveu para este exerc\'edcio pode o ajudar a implementar um compilador completo que funciona. \line Escreva um programa que converte uma express\'e3o aritm\'e9tica infixa comum (suponha que uma express\'e3o v\'e1lida \'e9 fornecida \line como entrada) com inteiros de um \'fanico d\'edgito, tal como \line (6 + 2) * 5 - 8 / 4 \line para uma express\'e3o p\'f3s-fixa. A vers\'e3o p\'f3s-fixa da express\'e3o infixa precedente \'e9 \line 62+5 * 84 / - \line O programa deveria ler a express\'e3o para o array de caracteres infix e usar vers\'f5es modificadas das fun\'e7\'f5es de pilha implementadas neste cap\'edtulo para ajudar a criar a express\'e3o p\'f3s-fixa em um array de caracteres postfix. O algoritmo para criar uma express\'e3o p\'f3s-fixa \'e9 o seguinte: \line 1) Insira um par\'eantese \'e0 esquerda \lquote  ( no topo da pilha. \line 2) Acrescente um par\'eantese \'e0 direita \lquote ) ao fim de infix. \line 3) Enquanto a pilha n\'e3o estiver vazia, leia irif ix da esquerda para a direita e fa\'e7a o seguinte: \line Se o caractere atual em infix \'e9 um d\'edgito, copie-o para o pr\'f3ximo elemento de postfix. Se o caractere atual em infix \'e9 um par\'eantese \'e0 esquerda, insira-o no topo da pilha. \line Se o caractere atual em infix \'e9 um operador, \line Remova operadores (se existirem) do topo da pilha enquanto tiverem preced\'eancia igual ou mais alta que o \line operador atual e insira os operadores removidos em pos tf ix. \line Insira o caractere atual em inf ix no topo da pilha. \line Se o caractere atual em inf ix \'e9 um par\'eantese \'e0 direita \line Remova operadores do topo da pilha e insira-os em postfix at\'e9 um par\'eantese a esquerda estar ou topo da \line pilha. \line Remova (e descarte) da pilha o par\'eantese \'e0 esquerda. \line As seguintes opera\'e7\'f5es aritm\'e9ticas s\'e3o permitidas em uma express\'e3o: \line + adi\'e7\'e3o \line - subtra\'e7\'e3o \line * multiplica\'e7\'e3o \line / divis\'e3o \line exponencia\'e7\'e3o \line % m\'f3dulo \line A pilha deve ser mantida com nodos de pilha, cada um contendo um membro de dados e um ponteiro para o pr\'f3ximo nodo da pilha. \line Alguns dos recursos funcionais que voc\'ea pode querer fornecer s\'e3o: \line a) Fun\'e7\'e3o convertTopostfix, que converte a express\'e3o infixa para a nota\'e7\'e3o p\'f3s-fixa. \line b) Fun\'e7\'e3o isOperator. que determina se c \'e9 uni operador. \line c) Fun\'e7\'e3o precedence. que determina se a preced\'eancia do operatori \'e9 menor que, igual a ou maior que a preced\'eancia do operator2, A fun\'e7\'e3o retorna -1,0 e 1, respectivamente. \line d) Fun\'e7\'e3o push. que insere um valor na pilha. \line e) Fun\'e7\'e3o pop, que retira um valor da pilha. \line O Fun\'e7\'e3o stackTop, que retoma o valor do topo da pilha sem retir\'e1-lo da pilha. \line g) Fun\'e7\'e3o isEmpty, que determina se a pilha est\'e1 vazia. \line h) Fun\'e7\'e3o imprime Stack, que imprime a pilha. \line 15.13 Escreva um programa que analisa uma express\'e3o p\'f3s-fixa (suponha que ela \'e9 v\'e1lida), tal como \line 62+5 * 84 / - \line O programa deve ler uma express\'e3o p\'f3s-fixa que consiste em d\'edgitos e operadores para um array de caracteres. Usando vers\'f5es modificadas das fun\'e7\'f5es de pilha inementadas anteriormente neste cap\'edtulo, o programa deve percorrer a express\'e3o e calcul\'e1la . O algoritmo \'e9 o seguinte: \par
CAP\'cdTULO 15 - ESTRUTURAS DE DADOS 793 \line 1) Acrescente o caractere nulo (\lquote  \\O\rquote ) ao fim da express\'e3o p\'f3s-fixa. Quando o caractere nulo for encontrado, nenhum processamento adicional ser\'e1 mais necess\'e1rio. \line 2) Enquanto \\O\rquote  n\'e3o for encontrado, leia a express\'e3o, da esquerda para a direita. \line Se o caractere atual \'e9 um d\'edgito, \line Insira seu valor inteiro no topo da pilha (o valor inteiro de um caractere que \'e9 um d\'edgito \'e9 seu valor no conjunto \line de caracteres do computador menos o valor de O\rquote  no conjunto de caracteres do computador). \line Caso contr\'e1rio, se o caractere atual \'e9 um operador; \line Remova os dois elementos do topo da pilha para as vari\'e1veis x e y. \line Calcule y operador x. \line Insira o resultado do c\'e1lculo no topo da pilha. \line 3) Quando o caractere nulo for encontrado na express\'e3o, remova o valor do topo da pilha. Este \'e9 o resultado da express\'e3o p\'f3s-fixa. \line Nota: na etapa 2) acima, se o operador \'e9 / \lquote , o topo da pilha \'e9 2 e o pr\'f3ximo elemento na pilha \'e9 8, ent\'e3o remova 2 da pilha e o atribua a x. remova 8 para y, calcule 8/2 e insira o resultado, 4, de volta no topo da pilha. Esta nota tamb\'e9m se aplica ao operador \lquote -\lquote . As opera\'e7\'f5es aritm\'e9ticas permitidas em uma express\'e3o s\'e3o: \line + adi\'e7\'e3o \line - subtra\'e7\'e3o \line * multiplica\'e7\'e3o \line / divis\'e3o \line A exponencia\'e7\'e3o \line m\'f3dulo \line A pilha deve ser mantida com nodos de pilha que cont\'eam um membro de dados inteiro e um ponteiro para o pr\'f3ximo nodo da pilha. Voc\'ea pode querer fornecer os seguintes recursos funcionais: \line a) Fun\'e7\'e3o evaluatePostfixExpression. que analisa e calcula a express\'e3o p\'f3s-fixa. \line b) Fun\'e7\'e3o calculate. que calcula a express\'e3o opi operador op2. \line c) Fun\'e7\'e3o push, que insere um valor na pilha. \line d) Fun\'e7\'e3o pop. que retira um valor da pilha. \line e) Fun\'e7\'e3o isEmpty, que determina se a pilha est\'e1 vazia. \line f) Fun\'e7\'e3o printStack. que imprime a pilha. \line 15.14 Modifique o programa de an\'e1lise e c\'e1lculo de express\'f5es p\'f3s-fixas do Exerc\'edcio 15.13 de forma que ele possa processar operandos inteiros maiores do que 9. \line 15.15 (Simula\'e7\'e3o de supermercado) Escreva um programa que simula uma fila de caixa em um supermercado. A fila \'e9 um objeto fila. Os clientes (i.e., objetos clientes) chegam em intervalos inteiros aleat\'f3rios de 1 a 4 minutos. Al\'e9m disso, cada cliente \'e9 atendido em intervalos inteiros aleat\'f3rios de 1 a 4 minutos. Obviamente, as taxas precisam ser equilibradas. Se a taxa de chegada m\'e9dia \'e9 maior que a taxa de atendimento m\'e9dio, a fila crescer\'e1 infinitamente. At\'e9 com taxas \ldblquote equilibradas\rdblquote , a aleatoriedade ainda pode causar longas filas. Execute a simula\'e7\'e3o do supermercado para um dia de 12 horas (720 minutos), usando o seguinte algoritmo: \line 1) Escolha um inteiro aleat\'f3rio entre 1 e 4 para determinar o minuto no qual o primeiro cliente chega. \line 2) No momento de chegada do primeiro cliente: \line Determine o tempo de atendimento do cliente (um inteiro aleat\'f3rio de 1 a 4); \line Comece a atender o cliente; \line Programe o tempo de chegada do pr\'f3ximo cliente (um inteiro aleat\'f3rio de 1 a 4 somado \'e0 hora atual). 3) Para cada minuto do dia: \line Se o pr\'f3ximo cliente chega, \line Fa\'e7a o seguinte: \line Insira o cliente no objeto fila; \line Programe o tempo de chegada do pr\'f3ximo cliente; \line Se foi completado o atendimento para o \'faltimo cliente, \line Fa\'e7a o seguinte: \line Retire da fila o pr\'f3ximo cliente a ser atendido; \line Determine o tempo de conclus\'e3o do atendimento ao cliente \line (um inteiro aleat\'f3rio de 1 at\'e9 4 somado ao tempo atual). \line Agora execute sua simula\'e7\'e3o para 720 minutos e responda a cada uma das seguintes perguntas: \line a) Qual \'e9 o n\'famero m\'e1ximo de clientes na fila, em qualquer momento? \line b) Qual \'e9 a espera mais longa que um cliente teve? \line c) O que acontece se o intervalo de chegada \'e9 mudado de 1 a 4 minutos para 1 a 3 minutos? \par
15.23 (Pesquisa em \'e1rvore bin\'e1ria) Escreva a fun\'e7\'e3o membro binaryTreeSearch. a qual tenta localizar um valor especificado em um objeto \'e1rvore de pesquisa bin\'e1ria. A fun\'e7\'e3o deve aceitar como argumentos um ponteiro para o nodo raiz da \'e1rvore bin\'e1ria e uma chave de pesquisa para ser localizada. Se o nodo contendo a chave de pesquisa \'e9 encontrado, a fun\'e7\'e3o deve retornar um ponteiro para aquele nodo; caso contr\'e1rio, a fun\'e7\'e3o deve retornar um ponteiro nulo. \par
15.24 (Percurso de \'e1rvore bin\'e1ria em ordem de n\'edvel) O programa da Fig. 15.16 ilustrou tr\'eas m\'e9todos recursivos de percorrer uma \'e1rvore bin\'e1ria - percursos em ordem, na pr\'e9-ordem e na p\'f3s-ordem. Este exerc\'edcio apresenta o percurso na ordem de n\'edvel de uma \'e1rvore bin\'e1ria, no qual os valores dos nodos s\'e3o impressos n\'edvel por n\'edvel, come\'e7ando no n\'edvel do nodo raiz. Os nodos em cada n\'edvel s\'e3o impressos da esquerda para a direita. O percurso em ordem de n\'edvel n\'e3o \'e9 um algoritmo recursivo. Ele usa um objeto fila para controlar a impress\'e3o dos nodos. O algoritmo \'e9 o seguinte: \line 1) Insira o nodo raiz na fila \line 2) Enquanto existirem nodos na fila, \line Obtenha o pr\'f3ximo nodo na fila \line Imprima o valor do nodo \line Se o ponteiro para o filho esquerdo do nodo n\'e3o \'e9 nulo \line Insira o nodo filho esquerdo na fila \line Se o ponteiro para o filho direito do nodo n\'e3o \'e9 nulo \line Insira o nodo filho direito na fila. \par
Escreva a fun\'e7\'e3o membro levelOrder para executar um percurso em ordem de n\'edvel de um objeto \'e1rvore bin\'e1ria. Modifique o programa da Fig 15. 16 para usar esta fun\'e7\'e3o. (Nota: voc\'ea tamb\'e9m necessitar\'e1 modificar e incorporar as fun\'e7\'f5es de processamento de fila da Fig. 15.12 neste programa.) \par
15.25 (imprimindo \'e1rvores) Escreva uma fun\'e7\'e3o membro recursiva outputTree para exibir um objeto \'e1rvore bin\'e1ria na tela. \line A fun\'e7\'e3o deve exibir a \'e1rvore linha por linha, com o topo da \'e1rvore \'e0 esquerda da tela e a parte inferior da \'e1rvore em dire\'e7\'e3o ao \line lado direito da tela. Cada linha \'e9 exibida verticalmente. Por exemplo, a \'e1rvore bin\'e1ria ilustrada na Fig. 15.19 \'e9 exibida como \par
segue: \par
Note que o nodo folha mais \'e0 direita aparece no topo da sa\'edda na coluna mais \'e0 direita e o nodo raiz aparece na esquerda da sa\'edda. Cada coluna de sa\'edda come\'e7a cinco espa\'e7os \'e0 direita da coluna anterior. A fun\'e7\'e3o outputTree deve receber um par\'e2metro totaiSpaces representando o n\'famero dos espa\'e7os antes do valor a ser exibido (esta vari\'e1vel deve come\'e7ar em zero, de modo que o nodo raiz seja exibido \'e0 esquerda da tela). A fun\'e7\'e3o usa um percurso em ordem modificado, para exibir a \'e1rvore - ela come\'e7a no nodo mais \'e0 direita na \'e1rvore e trabalha retrocedendo para a esquerda. O algoritmo \'e9 o seguinte: \line Enquanto o ponteiro para o nodo atual n\'e3o for nulo \line Recursivamente chama outputTree com a sub\'e1rvore direita do nodo atual e \line totaiSpaces + 5 \line Usa uma estrutura for para contar de 1 at\'e9 totaiSpaces e imprimir espa\'e7os \line Exibe o valor no nodo atual \line Inicializa o ponteiro para o nodo atual para apontar para a sub\'e1rvore esquerda do nodo atual \line Incrementa totaiSpaces em 5. \par
CAP\'cdTULO 15 - ESTRUTURAS DE DADOS 795 \par
99 \par
97 \par
83 \par
92 \par
72 \par
71 \par
49 \par
69 \par
40 \par
44 \line 32 \par
28 \par
19 \par
18 \par
11 \par
796 C++ COMO PROGRAMAR \par
Se\'e7\'e3o especial: construindo seu pr\'f3prio compilador \line Nos Exerc\'edcios 5.18 e 5.19, introduzimos a Simpletron Machine Language (SML) e voc\'ea implementou um simulador do computador Simpletron para executar programas escritos em SML. Nesta se\'e7\'e3o, constru\'edmos um compilador que converte programas escritos em uma linguagem de programa\'e7\'e3o de alto n\'edvel para a SML. Esta se\'e7\'e3o \ldblquote unifica\rdblquote  todo o processo de programa\'e7\'e3o. Voc\'ea escrever\'e1 programas nesta nova linguagem de alto n\'edvel, compilar\'e1 os programas com o compilador que voc\'ea construir\'e1 e executar\'e1 os programas no simulador que voc\'ea construiu no Exerc\'edcio 7.19. Voc\'ea deve fazer todo esfor\'e7o para implementar seu compilador de uma maneira orientada a objetos. \line 15.26 (A linguagem Simple) Antes de come\'e7armos a construir o compilador, discutiremos uma linguagem simples, mas ainda assim poderosa, de alto n\'edvel e semelhante \'e0s primeiras vers\'f5es da popular linguagem BASIC. Chamamos esta linguagem de Simple. Todo comando em Simple consiste em um n\'famero de linha e uma instru\'e7\'e3o de Simple. Os n\'fameros de linha devem aparecerem ordem ascendente. Cada instru\'e7\'e3o come\'e7a com um dos seguintes comandos de Simple: rem. input. let. print. goto, if/goto ou end (ver Fig. 15.20). Todos os comandos, exceto end, podem ser usados repetidamente. Simple avalia somente express\'f5es inteiras usando os operadores +, -\lquote  *. e 1. Estes operadores t\'eam a mesma preced\'eancia que em C. Par\'eanteses podem ser usados para mudar a ordem de avalia\'e7\'e3o de uma express\'e3o. \line Nosso compilador de Simple reconhece somente letras m\'ednusculas. Todos os caracteres em um arquivo de Simple devem ser min\'fasculas (letras mai\'fasculas resultam em um erro de sintaxe, a menos que apare\'e7am em um comando rem. caso em que s\'e3o ignoradas). Um nome de vari\'e1vel \'e9 uma \'fanica letra. Simple n\'e3o permite nomes de vari\'e1veis descritivos, assim as vari\'e1veis deveriam ser explicadas em observa\'e7\'f5es, para indicar seu uso em um programa. Simple usa somente vari\'e1veis do tipo inteiro. Simple n\'e3o tem declara\'e7\'f5es de vari\'e1veis simplesmente mencionar um nome de vari\'e1vel em um programa faz com que a vari\'e1vel seja declarada e automaticamente inicializada com zero. A sintaxe de Simple n\'e3o permite a manipula\'e7\'e3o de strings (ler um string, escrever um string, comparar srrings, etc.). Se um string \'e9 encontrado em um programa de Simple (ap\'f3s um outro comando que n\'e3o rem), o compilador gera um erro de sintaxe. A primeira vers\'e3o de nosso compilador assumir\'e1 que os programas em Simple s\'e3o escritos e digitados corretamente. O Exerc\'edcio 15.29 pede ao estudante para modificar o compilador para executar a verifica\'e7\'e3o de erros de sintaxe. \line Simple usa o comando condicional if/goto e o comando incondicional goto para alterara fluxo de controle durante a execu\'e7\'e3o do programa. Se a condi\'e7\'e3o no comando if/goto for verdadeira, o controle \'e9 transferido para uma linha espec\'edfica do programa. Os seguintes operadores relacionais e de igualdade s\'e3o v\'e1lidos em um comando if/goto: <,>,<. >. == ou \line A preced\'eancia destes operadores \'e9 a mesma que em C++. \line Iremos agora considerar v\'e1rios programas que demonstram as caracter\'edsticas de Simple. O primeiro programa (Fig. 15.21) l\'ea dois inteiros do teclado, armazena os valores nas vari\'e1veis a e b e calcula e imprime sua soma (armazenada na vari\'e1vel c). \par
II \line :4 \par
Fig. 15.20 Comandos de Simple. \par
\pard\par
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx942\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1392\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx3257\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx8946\pard\intbl Comando \cell Ex \cell emplo de comando \cell Descri\'e7\'e3o \cell\row
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx942\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1392\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2067\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx3257\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx8946\pard\intbl rem \cell 50 \cell rem isto \cell\'e9 um coment\'e1rio \cell Texto que segue o comando rem se destina a documenta\'e7\'e3o e \'e9 ignorado pelo compilador. \cell\row
\intbl input \cell 30 \cell input x \cell\cell Exibe um ponto de interrogando solicitando uma entrada do usu\'e1rio para entrar um inteiro. L\'ea aquele inteiro do teclado e armazena o inteiro em x. \cell\row
\intbl let \cell 80 \cell let u = 4 \cell * (j - 56) \cell Atribui au o valor de 4 * - 56). Note que uma express\'e3o arbitrariamente complexa pode aparecer \'e0 direita do sinal de igual. \cell\row
\intbl print \cell 10 \cell print w \cell\cell Exibeovalordew. \cell\row
\intbl goto \cell 70 \cell goto 45 \cell\cell Transfere o controle do programa para a linha 45. \cell\row
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx942\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1392\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx3257\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx8946\pard\intbl if/goto \cell 35 \cell if i == z goto 80 \cell Compara i e z quanto \'e0 igualdade e transfere o controle para a linha 80 se a condi\'e7\'e3o \'e9 verdadeira; caso contr\'e1rio, continua a execu\'e7\'e3o com o pr\'f3ximo comando. \cell\row
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx942\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1392\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2067\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx3257\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx8946\pard\intbl end \cell 99 \cell end \cell\cell Termina a execu\'e7\'e3o do programa. \cell\row
\pard\par
\pard\sb100\sa240 CAP\'cdTULO 15 - ESTRUTURAS DE DADOS 797 \par
Fig. 15.21 Programa em Simple que determina a soma de dois inteiros. \par
O programa da Fig. 15.22 determina e imprime o maior de dois inteiros. Os inteiros s\'e3o fornecidos pelo teclado e armazenados \line em s e t. O comando if/goto testa a condi\'e7\'e3o s >= t. Se a condi\'e7\'e3o \'e9 verdadeira, o controle \'e9 transferido para linha 90 e s \line\'e9 impresso; caso contr\'e1rio, t \'e9 impresso e o controle \'e9 transferido para o comando end na linha 99, onde o programa termina. \line Simple n\'e3o oferece uma estrutura de repeti\'e7\'e3o (tal como for, while ou do/while de C++). Por\'e9m, Simple pode simular cada uma das estruturas de repeti\'e7\'e3o de C++ usando os comandos if/goto e goto. A Fig.15.23 usa um la\'e7o controlado por sentinela para calcular os quadrados de v\'e1rios inteiros. Cada inteiro \'e9 fornecido pelo teclado e armazenado na vari\'e1vel j. Se o valor lido \'e9 a sentinela -9999, o controle \'e9 transferido para a linha 99. onde o programa termina. Caso contr\'e1rio, o quadrado de j \'e9 atribu\'eddo a k, k \'e9 exibido na tela e o controle \'e9 passado para a linha 20, onde o pr\'f3ximo inteiro \'e9 lido. \par
npuimas Voc\'ea ir\'e1 e seu \par
inda \'ef de vem Lnt, valia Leses \par
vem \line sao \line\'edveis \line eiro. \par
ue a (ler )utro )grapara \par
ante \par
\'edfica \par
ou \par
(Pig. \line Ia na \par
irada \line o do \par
Fig. 15.22 Programa em Simple que encontra o maior de dois inteiros. \par
Fig. 15.23 Calcula o quadrado de v\'e1rios inteiros. \par
\pard\par
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx301\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx710\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx3135\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4394\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx6401\pard\intbl 1 \cell 10 \cell rem determina e imprime \cell a soma \cell de dois inteiros \cell\row
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx301\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx710\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx3135\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4394\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx5080\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx5828\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx6401\pard\intbl 2 \cell 15 \cell rem \cell\cell\cell\cell\cell\row
\intbl 3 \cell 20 \cell rem l\'ea os dois inteiros \cell\cell\cell\cell\cell\row
\intbl 4 \cell 30 \cell input a \cell\cell\cell\cell\cell\row
\intbl 5 \cell 40 \cell input b \cell\cell\cell\cell\cell\row
\intbl 6 \cell 45 \cell rem \cell\cell\cell\cell\cell\row
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx301\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx710\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx3135\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx5080\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx5828\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx6401\pard\intbl 7 \cell 50 \cell rem soma os inteiros e \cell guarda o resultado \cell em \cell e \cell\row
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx301\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx710\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx3135\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4394\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx5080\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx5828\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx6401\pard\intbl 8 \cell 60 \cell letc=a+b \cell\cell\cell\cell\cell\row
\intbl 9 \cell 65 \cell rem \cell\cell\cell\cell\cell\row
\intbl 10 \cell 70 \cell rem imprime o resultado \cell\cell\cell\cell\cell\row
\intbl 11 \cell 80 \cell print c \cell\cell\cell\cell\cell\row
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx301\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx710\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx3135\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx5080\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx5828\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx6401\pard\intbl 12 \cell 90 \cell rem termina a execu\'e7\'e3o \cell do programa \cell\cell\cell\row
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx301\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx710\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx3135\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4394\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx5080\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx5828\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx6401\pard\intbl 13 \cell 99 \cell end \cell\cell\cell\cell\cell\row
\pard\sa240\par
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx301\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx710\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1407\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2488\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx3530\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx3939\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx6197\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx7086\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx7399\pard\intbl 1 \cell 10 \cell rem \cell determina \cell o maior \cell de \cell dois inteiros \cell\cell\cell\row
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx301\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx710\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1407\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2488\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx3054\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx3530\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx3939\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4924\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx6197\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx7086\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx7399\pard\intbl 2 \cell 20 \cell input \cell s \cell\cell\cell\cell\cell\cell\cell\cell\row
\intbl 3 \cell 30 \cell input \cell t \cell\cell\cell\cell\cell\cell\cell\cell\row
\intbl 4 \cell 32 \cell rem \cell\cell\cell\cell\cell\cell\cell\cell\cell\row
\intbl 5 \cell 35 \cell rem \cell testa se \cell s >= \cell t \cell\cell\cell\cell\cell\cell\row
\intbl 6 \cell 40 \cell if s \cell >= tgoto \cell 90 \cell\cell\cell\cell\cell\cell\cell\row
\intbl 7 \cell 45 \cell rem \cell\cell\cell\cell\cell\cell\cell\cell\cell\row
\intbl 8 \cell 50 \cell rem \cell t \'e9 maior \cell do \cell que \cell s, \cell portanto \cell imprime t \cell\cell\cell\row
\intbl 9 \cell 60 \cell print \cell t \cell\cell\cell\cell\cell\cell\cell\cell\row
\intbl 10 \cell 70 \cell goto \cell 99 \cell\cell\cell\cell\cell\cell\cell\cell\row
\intbl li \cell 75 \cell rem \cell\cell\cell\cell\cell\cell\cell\cell\cell\row
\intbl 12 \cell 80 \cell rem \cell s \'e9 maior \cell do \cell que \cell ou \cell igual a \cell t, portanto \cell imprime \cell s \cell\row
\intbl 13 \cell 90 \cell print \cell s \cell\cell\cell\cell\cell\cell\cell\cell\row
\intbl 14 \cell 99 \cell end \cell\cell\cell\cell\cell\cell\cell\cell\cell\row
\pard\sa240\par
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx301\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx710\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1407\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2296\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx6093\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx6374\pard\intbl 1 \cell 10 \cell rem \cell calcula \cell o quadrado de diversos inteiros \cell\cell\row
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx301\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx710\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1407\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2296\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4546\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx5805\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx6093\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx6374\pard\intbl 2 \cell 20 \cell input \cell j \cell\cell\cell\cell\cell\row
\intbl 3 \cell 23 \cell rem \cell\cell\cell\cell\cell\cell\row
\intbl 4 \cell 25 \cell rem \cell testa o \cell valor sentinela \cell\cell\cell\cell\row
\intbl 5 \cell 30 \cell if j \cell = -9999 \cell goto 99 \cell\cell\cell\cell\row
\intbl 6 \cell 33 \cell rem \cell\cell\cell\cell\cell\cell\row
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx301\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx710\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1407\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2296\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx6374\pard\intbl 7 \cell 35 \cell rem \cell calcula \cell o quadrado de j e atribui o resultado a k \cell\row
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx301\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx710\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1407\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2296\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4546\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx5805\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx6093\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx6374\pard\intbl 8 \cell 40 \cell letk \cell =j * j \cell\cell\cell\cell\cell\row
\intbl 9 \cell 50 \cell print \cell k \cell\cell\cell\cell\cell\row
\intbl 10 \cell 53 \cell rem \cell\cell\cell\cell\cell\cell\row
\intbl 11 \cell 55 \cell rem \cell repete \cell o la\'e7o para obter \cell pr\'f3ximo j \cell\cell\cell\row
\intbl 12 \cell 60 \cell goto \cell 20 \cell\cell\cell\cell\cell\row
\intbl 13 \cell 99 \cell end \cell\cell\cell\cell\cell\cell\row
\pard\par
\pard\sb100\sa240 798 C++ COMO PROGRAMAR \line Usando os programas de exemplo da Fig. 15.21, Fig. 15.22 e Fig. 15.23 como orienta\'e7\'e3o, escreva um programa em Simple para executar cada um dos seguintes itens: \line a) Receba como entrada tr\'eas inteiros, determine sua m\'e9dia e imprima o resultado. \line b) Use um la\'e7o controlado por sentinela para receber como entrada 10 inteiros e calcule e imprima sua soma. \line c) Use um la\'e7o controlado por contador para receber como entrada 7 inteiros, algum positivos e alguns negativos, e calcule e imprima sua m\'e9dia. \line d) Receba como entrada uma s\'e9rie de inteiros e determine e imprima o maior. O primeiro inteiro lido indica quantos n\'fameros devem ser processados. \line e) Receba como entrada lO inteiros e imprima o menor. \line f) Calcule e imprima a soma dos inteiros pares de 2 at\'e9 30. \line g) Calcule e imprima o produto dos inteiros \'edmpares de 1 a 9. \line 15.27 (Construindo um compilador; pr\'e9-requisito: complete os Exerc\'edcios 5.18, 5.19, 15.12, 15.13 e 15.26) Agora que a linguagem Simple foi apresentada (Exerc\'edcio 15.26), discutiremos como construir um compilador de Simple. Primeiro, consideramos o processo para que um programa em Simple seja convertido em SML e executado pelo simulador do Simpletron (veja Fig. 15.24). Um arquivo contendo um programa em Simple \'e9 lido pelo compilador e convertido em c\'f3digo em SML. O c\'f3digo em SML \'e9 colocado em um arquivo em disco, no qual as instru\'e7\'f5es de SML aparecem uma por linha. O arquivo em SML \'e9 ent\'e3o carregado para o simulador do Simpletron e os resultados s\'e3o enviados para um arquivo em disco e para a tela. Note que o programa em Simpletron desenvolvido no Exerc\'edcio 5.19 recebe sua entrada pelo teclado. Ele deve ser modificado para ler um arquivo, de forma que ele possa executar os programas produzidos pelo nosso compilador. \line sa\'edda para \line saida para ateia \line o disco \line Fig. 15.24 Escrevendo, compilando e executando um programa na linguagem Simple. \line O compilador de Simple executa duas passa gens pelo programa em Simple para convert\'ea-lo para SML. A primeira passagem constr\'f3i uma tabela de s\'edmbolos (objeto) em que todo n\'famero de linha (objeto), nome de vari\'e1vel (objeto) e constante (objeto) do programa em Simple \'e9 armazenado com seu tipo e localiza\'e7\'e3o correspondente no c\'f3digo SML final (a tabela de s\'edmbolos \'e9 discutida em detalhes abaixo). A primeira passagem tamb\'e9m produz o(s) objeto(s) instru\'e7\'e3o(\'f5es) correspondente(s) de SML para cada um dos comandos em Simple (objeto, etc.). Como veremos, se o programa em Simple cont\'e9m comandos que transferem o controle para uma linha mais \'e0 frente no programa, a primeira passagem resulta em um programa de SML contendo algumas instru\'e7\'f5es \ldblquote inacabadas\rdblquote . A segunda passagem do compilador localiza e completa as instru\'e7\'f5es inacabadas e grava o programa SML em um arquivo. \line Primeiro passo \line O compilador come\'e7a lendo um comando do programa em Simple para a mem\'f3ria. A linha deve ser separada em suas \ldblquote unidades l\'e9xicas\rdblquote  (tokens) individuais (i.e., \ldblquote peda\'e7os\rdblquote  de um comando) para processamento e compila\'e7\'e3o (a fun\'e7\'e3o strtok da biblioteca padr\'e3o pode er usada para facilitar esta tarefa). Lembre que toda instru\'e7\'e3o come\'e7a com um n\'famero de linha seguido por um comando. A medida que o compilador quebra um comando em \ldblquote unidades l\'e9xicas\rdblquote , se a \ldblquote unidade l\'e9xica\rdblquote  \'e9 um n\'famero de linha, uma vari\'e1vel ou uma constante, ela \'e9 colocada na tabela de s\'edmbolos. Um n\'famero de linha \'e9 colocado na tabela de s\'edmbolos somente se ele \'e9 a primeira \ldblquote unidade l\'e9xica\rdblquote  em uma instru\'e7\'e3o. O objeto symbolTable \'e9 um array de objetos tableEntry, cada um representando um s\'edmbolo no programa. N\'e3o existe nenhuma restri\'e7\'e3o quanto ao n\'famero de s\'edmbolos que podem aparecer no programa. Ent\'e3o, a symbolTable para um programa particular pode ser grande. Por ora, use para a syinbolTable um array de 100 elementos. Voc\'ea pode aumentar ou diminuir seu tamanho depois que o programa estiver funcionando. \par
CAP\'cdTULO 15 - ESTRUTURAS DE DADOS 799 \par
Cada objeto tableEntry cont\'e9m tr\'eas membros. O membro symbol \'e9 um inteiro contendo a representa\'e7\'e3o em ASCII de uma vari\'e1vel (lembre-se que nomes de vari\'e1veis s\'e3o caracteres simples), um n\'famero de linha ou uma constante. O membro type \'e9 um dos seguintes caracteres, que indicam o tipo do s\'edmbolo: \lquote C\rquote  para constante, \lquote L\rquote  para n\'famero de linha, ou \lquote V\rquote  para vari\'e1vel. O membro location cont\'e9m a posi\'e7\'e3o de mem\'f3ria no Simpletron (00 a 99) \'e0 qual o s\'edmbolo se refere. A mem\'f3ria do Simpletron \'e9 um array de 100 inteiros no qual as instru\'e7\'f5es de SML e dados s\'e3o armazenados. Para um n\'famero de linha, a localiza\'e7\'e3o \'e9 o elemento no array de mem\'f3ria do Simpletron no qual as instru\'e7\'f5es de SML para o comando de Simple come\'e7am. Para uma vari\'e1vel ou constante, a localiza\'e7\'e3o \'e9 o elemento no array de mem\'f3ria do Simpletron em que a vari\'e1vel ou constante \'e9 armazenada. Vari\'e1veis e constantes s\'e3o alocadas do fim da mem\'f3ria do Simpletron para o in\'edcio. A primeira vari\'e1vel ou constante \'e9 armazenada na localiza\'e7\'e3o 99, a pr\'f3xima na localiza\'e7\'e3o 98, etc. \line A tabela de s\'edmbolos desempenha um papel importante na convers\'e3o de programas em Simple para SML. Aprendemos no Cap\'edtulo 5 que uma instru\'e7\'e3o de SML \'e9 um inteiro de quatro d\'edgitos composto de duas partes - o c\'f3digo de opera\'e7\'e3o e o operando. O c\'f3digo de opera\'e7\'e3o \'e9 determinado pelos comandos em Simple. Por exemplo, ao comando Simple input corresponde o c\'f3digo de opera\'e7\'e3o de SML 10 (ler) e ao comando em Simple print corresponde o c\'f3digo de opera\'e7\'e3o de SML 11 (escrever). O operando \'e9 uma posi\'e7\'e3o de mem\'f3ria contendo os dados sobre os quais o c\'f3digo de opera\'e7\'e3o executa sua tarefa (por exemplo, o c\'f3digo de opera\'e7\'e3o 10 l\'ea um valor do teclado e armazena-o na posi\'e7\'e3o de mem\'f3ria especificada pelo operando). O compilador pesquisa symbolTable para determinar a posi\'e7\'e3o de mem\'f3ria do Simpletron para cada s\'edmbolo e, assim, a localiza\'e7\'e3o correspondente pode ser usada para completar as instru\'e7\'f5es de SML. \line A compila\'e7\'e3o de cada comando de Simple \'e9 baseada em seu comando. Por exemplo, depois que o n\'famero de linha em um \par
comando rem \'e9 inserido na tabela de s\'edmbolos, o restante do comando \'e9 ignorado pelo compilador porque um coment\'e1rio serve somente para fins de documenta\'e7\'e3o. Os comandos input, print, goto e end correspondem \'e0s instru\'e7\'f5es de SML ler escrever desviar (para uma posi\'e7\'e3o espec\'edfica) e parar. Os comandos contendo esses comandos de Simple s\'e3o diretamente convertidos para SML (note que um comando goto pode conter uma refer\'eancia n\'e3o-resolvida se o n\'famero de linha especificado se refere a um comando mais \'e0 frente no arquivo do programa em Simple; isto \'e9 \'e0s vezes chamado de refer\'eancia antecipada). \line Quando um comando goto \'e9 compilado com uma refer\'eancia n\'e3o-resolvida, a instru\'e7\'e3o de SML deve ser marcada, para indicar que na segunda passagem o compilador deve completar a instru\'e7\'e3o. As marcas s\'e3o armazenadas em um array flags de 100 elementos do tipo int, no qual cada elemento \'e9 inicializado com -1. Se a posi\'e7\'e3o de mem\'f3ria a que um n\'famero de linha no programa em Simple se refere ainda n\'e3o \'e9 conhecida (i.e., n\'e3o est\'e1 na tabela de s\'edmbolos), o n\'famero da linha \'e9 armazenada no array flags. no elemento com o mesmo \'edndice que a instru\'e7\'e3o incompleta. O operando da instru\'e7\'e3o incompleta \'e9 temporariamente inicializado com 00. Por exemplo, uma instru\'e7\'e3o de desvio incondicional (que est\'e1 fazendo uma refer\'eancia antecipada) \'e9 deixada como +4 000 at\'e9 a segunda passagem do compilador. A segunda passagem do compilador ser\'e1 descrita em breve. \line ) A compila\'e7\'e3o de comandos if/goto e let \'e9 mais complicada que a de outros comandos - eles s\'e3o os \'fanicos comandos que produzem mais de uma instru\'e7\'e3o de SML. Para um if/goto. o compilador produz c\'f3digo para testar a condi\'e7\'e3o e para desviar para outra linha, se necess\'e1rio. O resultado do desvio pode ser uma refer\'eancia n\'e3o-resolvida. Cada um dos operadores relacionais e de igualdade podem ser simulados usando-se as instru\'e7\'f5es desvie quando zero e desvie quando negativo de SML (ou, possivelmente, uma combina\'e7\'e3o de ambas). \line Para um comando let, o compilador produz c\'f3digo para avaliar uma express\'e3o aritm\'e9tica arbitrariamente complexa consistindo em vari\'e1veis inteiras e/ou constantes. As express\'f5es devem separar cada operando e operador com espa\'e7os. Os Exerc\'edcios 15.12 e 15.13 apresentaram o algoritmo de convers\'e3o infixa para p\'f3s-fixa e o algoritmo de avalia\'e7\'e3o p\'f3s-fixa usado por compiladores para avaliar express\'f5es. Antes de continuar seu compilador, voc\'ea deve completar cada um destes exerc\'edcios. Quando um compilador encontra uma express\'e3o, ele converte a express\'e3o da nota\'e7\'e3o infixa para a nota\'e7\'e3o p\'f3s-fixa e, ent\'e3o, avalia a express\'e3o p\'f3s-fixa. \line Como o compilador produz a linguagem de m\'e1quina para avaliar uma express\'e3o que cont\'e9m vari\'e1veis\rquote ? O algoritmo de avalia\'e7\'e3o p\'f3s-fixa cont\'e9m um \ldblquote gancho onde o compilador pode gerar instru\'e7\'f5es de SML em vez de avaliar realmente a express\'e3o. Para posssibilitar este \ldblquote gancho\rdblquote  no compilador, o algoritmo de avalia\'e7\'e3o p\'f3s-fixa deve ser modificado para pesquisar a tabela de simbolos para cada s\'edmbolo que ele encontra (e possivelmente inseri-lo), determinar a posi\'e7\'e3o de mem\'f3ria correspondente ao s\'edmbolo e inserir a posi\'e7\'e3o de mem\'f3ria no topo da pilha (em vez do s\'edmbolo). Quando um operador \'e9 encontrado na express\'e3o p\'f3s-fixa, as duas posi\'e7\'f5es de mem\'f3ria no topo da pilha s\'e3o recuperadas e \'e9 produzida a linguagem de m\'e1quina para executar a opera\'e7\'e3o usando as posi\'e7\'f5es de mem\'f3ria como operandos. O resultado de cada subexpress\'e3o \'e9 armazenado em uma posi\'e7\'e3o tempor\'e1ria na mem\'f3ria e empurrado de volta para o topo da pilha, de modo que a avalia\'e7\'e3o da express\'e3o p\'f3s-fixa possa continuar. Quando a avalia\'e7\'e3o p\'f3s-fixa est\'e1 completa, a posi\'e7\'e3o de mem\'f3ria contendo o resultado \'e9 a \'fanica posi\'e7\'e3o deixada no topo da pilha. Esta \'e9 retirada da pilha e instru\'e7\'f5es de SML s\'e3o geradas para atribuir o resultado \'e0 vari\'e1vel \'e0 esquerda no comando \par
let. \par
Segundo passo \par
O segundo passo do compilador executa duas tarefas: soluciona quaisquer refer\'eancias n\'e3o-resolvidas e grava o c\'f3digo de SML em um arquivo. A resolu\'e7\'e3o de refer\'eancias acontece como segue: \line a) Percorre o array flags procurando uma refer\'eancia n\'e3o-resolvida (i.e., um elemento com um valor diferente de -1). \line b) Localiza o objeto no array symbolTable que cont\'e9m o s\'edmbolo armazenado no array flags (assegure-se de que o tipo do s\'edmbolo \'e9 L\rquote  para um n\'famero de linha). . - \par
80() C++ COMO PROGRAMAR \line c) Insira a posi\'e7\'e3o de mem\'f3ria do membro location na instru\'e7\'e3o com a refer\'eancia n\'e3o-resolvida (lembre que uma instru\'e7\'e3o que cont\'e9m uma refer\'eancia n\'e3o-resolvida tem operando 00). \line d) Repita os passos 1, 2 e 3 at\'e9 atingir o fim do array flags. \line Depois do processo de resolu\'e7\'e3o estar completo, o array inteiro que cont\'e9m o c\'f3digo SML \'e9 gravado em um arquivo em disco, com uma instru\'e7\'e3o de SML por linha. Este arquivo pode ser lido pelo Simpletron para execu\'e7\'e3o (depois de o simulador ser modificado para ler sua entrada de um arquivo). Compilar seu primeiro programa em Simple, grav\'e1-lo em um arquivo de SML e ent\'e3o executar esse arquivo, deve lhe dar uma verdadeira sensa\'e7\'e3o de realiza\'e7\'e3o pessoal. \line Um exemplo completo \line O exemplo seguinte ilustra uma convers\'e3o completa de um programa em Simple para SML, tal como eia ser\'e1 executada pelo \line compilador de Simple. Considere um programa em Simple que recebe como entrada um inteiro e soma os valores de 1 at\'e9 aquele \line inteiro, O programa e as instru\'e7\'f5es de SML produzidos pelo primeiro passo do compilador Simple s\'e3o ilustrados na Fig. 15.25. \line A tabela de s\'edmbolos constru\'edda pelo primeiro passo \'e9 mostrada na Fig. 15.26. \par
Fig. 15.26 Tabela de s\'edmbolos para o programa da Fig. 15.25 (parte 1 de 2). \par
\pard\par
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx6258\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx6494\pard\intbl Localiza\'e7\'e3o e  Programa em Simple instru\'e7\'e3o SML Descri\'e7\'e3o \cell\cell\row
\intbl 5 rem soma 1 a x nenhuma coment\'e1rio ignorado \cell\cell\row
\intbl 10 input x 09 +2095 l\'eaxparaaposi\'e7\'e3o 99 \cell\cell\row
\intbl 15 rem testa se y == x nenhuma coment\'e1rio ignorado \cell\cell\row
\intbl 20 if y == x goto 60 01 +2098 carregay (98> no acumulador \cell\cell\row
\intbl 02 +3199 subtraix (99) do acumulador \cell\cell\row
\intbl 03 +4200 desvia se zero para endere\'e7o n\'e3o-calculado \cell\cell\row
\intbl 25 rem incrementa y nenhuma coment\'e1rio ignorado \cell\cell\row
\intbl 30 let y = y + 1 04 +2098 carrega y no acumulador \cell\cell\row
\intbl 05 +3097 somai (97) ao acumulador \cell\cell\row
\intbl 06 +2196 armazena na posi\'e7\'e3o tempor\'e1ria 96 \cell\cell\row
\intbl 07 +2096 carrega da posi\'e7\'e3o tempor\'e1ria 96 \cell\cell\row
\intbl 08 +2 198 armazena o acumulador em y \cell\cell\row
\intbl 35 rem soma y a total nenhuma coment\'e1rio ignorado \cell\cell\row
\intbl 40 let t = t + y 09 +2095 carrega t (95) no acumulador \cell\cell\row
\intbl 10 +30 98 soma y ao acumulador \cell\cell\row
\intbl ii +2194 armazena na posi\'e7\'e3o tempor\'e1ria 94 \cell\cell\row
\intbl 12 +20 94 carrega da posi\'e7\'e3o tempor\'e1ria 94 \cell\cell\row
\intbl 13 +2 195 armazena o acumulador em t \cell\cell\row
\intbl 45 rem repete y nenhuma coment\'e1rio ignorado \cell\cell\row
\intbl 50 goto 20 14 +4001 desvia para o endere\'e7o 01 \cell\cell\row
\intbl 55 rem escreve resultado nenhuma coment\'e1rio ignorado \cell\cell\row
\intbl 60 print t 15 +1195 enviatparaatela \cell\cell\row
\intbl 99 end 16 +4300 termina execu\'e7\'e3o \cell\cell\row
\intbl Fig. 15.25 Instru\'e7\'f5es SML produzidas ap\'f3s o primeiro passo do compilador. \cell\cell\row
\intbl S\'edmbolo Tipo Endere\'e7o \cell\cell\row
\pard\par
\par
\pard\sb100\sa240 CAP\'cdTULO 15 - ESTRUTURAS DE DADOS 801 \line 30 L 04 \line 1 C 97 \line 35 L 09 \line 40 L 09 \line\lquote t\rquote  V 95 \line 45 L 14 \line 50 L 14 \line 55 L 15 \line 60 L 15 \line 99 L 16 \line Fig. 15.26 Tabela de simbolos para o programa da Fig. 15.25 (parte 2 de 2). \line A maioria dos comandos de Simple s\'e3o convertidos diretamente em uma \'fanica instru\'e7\'e3o de SML. As exce\'e7\'f5es neste programa s\'e3o os coment\'e1rios (rem). o comando if/goto na linha 20 e os comandos let. As observa\'e7\'f5es n\'e3o se traduzem para linguagem de m\'e1quina. Por\'e9m, o n\'famero da linha de um coment\'e1rio \'e9 colocado na tabela de s\'edmbolos no caso do n\'famero da linha ser referenciado em um comando goto ou um comando if/goto. A linha 20 do programa especifica que, se a condi\'e7\'e3o y == x \line\lquote  \'e9 verdadeira, o controle do programa \'e9 transferido para a linha 60. Como a linha 60 aparece mais \'e0 frente no programa, a primeira passagem do compilador ainda n\'e3o colocou 60 na tabela de s\'edmbolos (os n\'fameros de linha dos comandos s\'e3o colocados na tabela de s\'edmbolos somente quando aparecem como a primeira \ldblquote unidade l\'e9xica\rdblquote  em um comando). Ent\'e3o, n\'e3o \'e9 poss\'edvel neste momento se determinar o operando da instru\'e7\'e3o de SML desvia se zero na posi\'e7\'e3o 03 no array de instru\'e7\'f5es de SML. O compilador coloca 60 na localiza\'e7\'e3o 03 do array flags para indicar que a segunda passagem completar\'e1 esta instru\'e7\'e3o. \line Devemos manter o controle da pr\'f3xima posi\'e7\'e3o de instru\'e7\'e3o no array de SML porque n\'e3o existe uma correspond\'eancia um para um entre comandos de Simple e instru\'e7\'f5es de SML. Por exemplo, o comando if/goto da linha 20 \'e9 compilado para tr\'eas instru\'e7\'f5es de SML. Toda vez que uma instru\'e7\'e3o \'e9 produzida, devemos incrementar o contador de instru\'e7\'f5es para a pr\'f3xima localiza\'e7\'e3o no array de SML. Note que o tamanho da mem\'f3ria do Simpletron poderia ser um problema para programas de Simple com muitos comandos, vari\'e1veis e constantes. E poss\'edvel que o compilador fique sem mem\'f3ria. Para testar este caso, seu programa deveria conter um contador de dados para manter a localiza\'e7\'e3o em que a pr\'f3xima vari\'e1vel ou constante ser\'e1 armazenada no array de SML. Se o valor do contador de instru\'e7\'f5es for maior que o valor do contador de dados, o array de SML est\'e1 cheio. Neste caso, o processo de compila\'e7\'e3o deveria terminar e o compilador deveria imprimir uma mensagem de erro indicando que ele ficou sem mem\'f3ria durante a compila\'e7\'e3o. Isto serve para enfatizar que, embora o programador esteja liberado dos problemas de administrar a mem\'f3ria pelo compilador, o pr\'f3prio compilador deve determinar cuidadosamente a coloca\'e7\'e3o de instru\'e7\'f5es e dados na mem\'f3ria e deve testar a ocorr\'eancia de erros tais como o esgotamento da mem\'f3ria durante o processo de compila\'e7\'e3o. \line Uma vis\'e3o passo a passo do processo de compila\'e7\'e3o \line Iremos agora fazer um walkthrough do processo de compila\'e7\'e3o para o programa em Simple na Fig. 15.25. O compilador l\'ea a primeira linha do programa \line 5 rem soma 1 a x \line para a mem\'f3ria. A primeira \ldblquote unidade l\'e9xica\rdblquote  no comando (o n\'famero de linha) \'e9 determinada usando-se strtok (veja Cap\'edtulos 5 e 16 para uma discuss\'e3o das fun\'e7\'f5es de manipula\'e7\'e3o de strings de C++). A \ldblquote unidade l\'e9xica\rdblquote  retomada por strtok \'e9 convertida em um inteiro usando atoi, de modo que o s\'edmbolo 5 possa ser localizado na tabela de s\'edmbolos. Se o s\'edmbolo n\'e3o \'e9 encontrado, \'e9 inserido na tabela de s\'edmbolos. Uma vez que estamos no come\'e7o do programa e esta \'e9 a primeira linha, nenhum s\'edmbolo ainda est\'e1 na tabela. Assim, 5 \'e9 inserido na tabela de s\'edmbolos como tipo L (n\'famero de linha) e atribu\'eddo \'e0 primeira posi\'e7\'e3o no array de SML (00). Embora esta linha seja um coment\'e1rio, um espa\'e7o na tabela de s\'edmbolos \'e9 ainda alocado para o n\'famero de linha (no caso de ele ser referenciado por um goto ou um if/goto). Nenhuma instru\'e7\'e3o de SML \'e9 gerada para um comando rem, assim o contador de instru\'e7\'f5es n\'e3o \'e9 incrementado. \line O comando \line 10 input x \line\'e9 o pr\'f3ximo a ser separado em \ldblquote unidades l\'e9xicas\rdblquote . O n\'famero de linha 10 \'e9 colocado na tabela de s\'edmbolos como tipo L e atribu\'eddo \'e0 primeira posi\'e7\'e3o no array de SML (00, porque um coment\'e1rio come\'e7ou o programa e assim o contador de instru\'e7\'f5es \'e9 atualmente 00). O comando input indica que a pr\'f3xima \ldblquote unidade l\'e9xica\rdblquote  \'e9 uma vari\'e1vel (somente uma vari\'e1vel pode aparecer em um comando input). Como input corresponde diretamente a um c\'f3digo de opera\'e7\'e3o de SML, o compilador tem que determinar a posi\'e7\'e3o dcx no array de SML. O s\'edmbolo x n\'e3o \'e9 encontrado na tabela de s\'edmbolos. Assim, ele \'e9 inserido na tabela de s\'edmbolos como a representa\'e7\'e3o em ASCII de x, tipo de dados V, e atribu\'eddo \'e0 posi\'e7\'e3o 99 no array de SML (a mem\'f3ria de dados come\'e7a em 99 e \'e9 alocada para tr\'e1s). O c\'f3digo de SML pode agora ser gerado para este comando. O c\'f3digo de opera\'e7\'e3o 10 (o c\'f3digo da opera\'e7\'e3o SML read) \'e9 multiplicado por 100 e a localiza\'e7\'e3o de x (conforme determinada na tabela de s\'edmbolos) \par
CAP\'cdTULO 15 - ESTRUTURAS DE DADOS 803 \line\'e9 separado em \ldblquote unidades l\'e9xicas\rdblquote , o n\'famero de linha 35 \'e9 inserido na tabela de s\'edmbolos como tipo L e atribu\'eddo \'e0 posi\'e7\'e3o 09. O comando \line 40 let t = t + y \line\'e9 semelhante \'e0 linha 30. A vari\'e1vel t \'e9 inserida na tabela de s\'edmbolos como tipo V e atribu\'edda \'e0 posi\'e7\'e3o de SML 95. As \line instru\'e7\'f5es seguem a mesma l\'f3gica e formato que a linha 30 e as instru\'e7\'f5es 09+2095, 10+3098. 11+2194. 12+2094 e \line 13+2 195 s\'e3o geradas. Note que o resultado de t + y \'e9 atribu\'eddo \'e0 posi\'e7\'e3o tempor\'e1ria 94 antes de ser atribu\'eddo a t (95). Uma \line vez mais, o leitor notar\'e1 que as instru\'e7\'f5es nas posi\'e7\'f5es de mem\'f3ria 11 e 12 parecem ser redundantes. Repetindo, discutiremos \line isto em breve. \line O comando \line 45 rein repete y \line\'e9 um coment\'e1rio; assim, a linha 45 \'e9 acrescentada \'e0 tabela de s\'edmbolos como tipo L e atribu\'edda \'e0 posi\'e7\'e3o de SML 14. \line O comando \line 50 goto 20 \line transfere o controle para a linha 20. O n\'famero da linha 50 \'e9 inserido na tabela de s\'edmbolos como tipo L e atribu\'eddo \'e0 posi\'e7\'e3o de \line SML 14. O equivalente do goto em SML \'e9 a instru\'e7\'e3o desvio incondicional (40) que transfere o controle para uma posi\'e7\'e3o de \line SML espec\'edfica. O compilador procura na tabela de s\'edmbolos a linha 20 e descobre que ela corresponde \'e0 posi\'e7\'e3o de SML 01. \line O c\'f3digo de opera\'e7\'e3o (40) \'e9 multiplicado por 100 e a posi\'e7\'e3o 01 \'e9 somada a ele para produzir a instru\'e7\'e3o 14 +4001. \line O comando \line 55 rexu exibe resultado \line e um coment\'e1rio; assim, a linha 55 e inserida na tabela de s\'edmbolos como tipo L e atribu\'edda \'e0 posi\'e7\'e3o de SML 15. \line O comando \line 60 print t \line\'e9 um comando de sa\'edda. O n\'famero de linha 60 \'e9 inserido na tabela de s\'edmbolos como tipo L e atribu\'eddo \'e0 posi\'e7\'e3o de SML 15. O \line equivalente de print em SML \'e9 o c\'f3digo de opera\'e7\'e3o 11 (write). A posi\'e7\'e3o de t \'e9 obtida da tabela de s\'edmbolos e somada ao \line resultado do c\'f3digo de opera\'e7\'e3o multiplicado por 100. \line O comando \line 99 end \line\'e9 a linha final do programa. O n\'famero de linha 99 \'e9 armazenado na tabela de s\'edmbolos como tipo L e atribu\'eddo \'e0 posi\'e7\'e3o de SML \line 16. O comando end produz a instru\'e7\'e3o de SML +4300 (43 \'e9 halt em SML) que \'e9 armazenada como a instru\'e7\'e3o final no array \line de mem\'f3ria de SML. \line Isso completa a primeira passagem do compilador. Agora, consideraremos a segunda passagem. O array flags \'e9 percorrido, procurando valores diferentes de -1. A posi\'e7\'e3o 03 cont\'e9m 60; assim, o compilador sabe que a instru\'e7\'e3o 03 est\'e1 incompleta. O compilador completa a instru\'e7\'e3o procurando 60 na tabela de s\'edmbolos, determinando sua posi\'e7\'e3o na mem\'f3ria e somando a posi\'e7\'e3o \'e0 instru\'e7\'e3o incompleta. Neste caso, a busca determina que a linha 60 corresponde \'e0 posi\'e7\'e3o de SML 15; assim, a instru\'e7\'e3o completa 03 +4215 \'e9 produzida, substituindo 03 +4200. O programa em Simple agora foi compilado com sucesso. \line Para construir o compilador, voc\'ea ter\'e1 que executar cada uma das tarefas seguintes: \line a) Modifique o programa simulador do Simpletron que voc\'ea escreveu no Exerc\'edcio 5.19, para aceitar como entrada um arquivo especificado pelo usu\'e1rio (veja Cap\'edtulo 14). O simulador deve gravar seus resultados em um arquivo em disco, no mesmo formato que o da tela de sa\'edda. Converta o simulador para ser um programa orientado a objetos. Em particular, tome cada parte do hardware um objeto. Organize os tipos de instru\'e7\'e3o em uma hierarquia de classes usando heran\'e7a. Ent\'e3o, execute o programa polimorficamente, simplesmente dizendo a cada instru\'e7\'e3o para executar a si pr\'f3pria com uma mensagem executelnstruction. \line b) Modifique o algoritmo de convers\'e3o de nota\'e7\'e3o infjxa para p\'f3s-fixa do Exerc\'edcio 15.12, para processar operandos inteiros de v\'e1rios d\'edgitos e nomes de vari\'e1vejs de uma \'fanica letra. Sugest\'e3o: a fun\'e7\'e3o strtok da biblioteca padr\'e3o pode ser usada para localizar cada constante e vari\'e1vel em uma express\'e3o e as constantes podem ser convertidas de strings para inteiros usando a fun\'e7\'e3o atoi da biblioteca padr\'e3o. (Nota: a representa\'e7\'e3o de dados da express\'e3o p\'f3sfixa deve ser alterada para suportar nomes de vari\'e1veis e constantes inteiras). \line c) Modifique o algoritmo de avalia\'e7\'e3o de express\'f5es p\'f3s-fixas para processar operandos inteiros de v\'e1rios d\'edgitos e nomes de vari\'e1veis. Tamb\'e9m agora, o algoritmo deve implementar o \ldblquote gancho\rdblquote  discutido acima de forma que instru\'e7\'f5es de SML sejam produzidas em lugar de avaliar diretamente a express\'e3o. Sugest\'e3o: a fun\'e7\'e3o da biblioteca padr\'e3o strtok pode ser usada para localizar cada constante e vari\'e1vel em uma express\'e3o, e constantes podem ser conver \par
\pard\par
\pard\sb100\sa240 804 C++ COMO PROGRAMAR \line tidas de strings para inteiros usando a fun\'e7\'e3o da biblioteca padr\'e3o atoi. (Nota: a representa\'e7\'e3o de dados da express\'e3o p\'f3s-fixa deve ser alterada para suportar constantes inteiras e nomes de vari\'e1veis.) \line d) Construa o compilador. Incorpore as partes (b) e (c) para avaliar express\'f5es em comandos let. Seu programa deve conter uma fun\'e7\'e3o que executa a primeira passagem do compilador e uma fun\'e7\'e3o que executa a segunda passagem do compilador. Ambas as fun\'e7\'f5es podem chamar outras fun\'e7\'f5es para realizar suas tarefas. Torne seu compilador t\'e3o orientado a objetos quanto poss\'edvel. \line 15.28 (Otimizando o compilador de Simple) Quando um programa \'e9 compilado e convertido para SML, \'e9 gerado um conjunto de instru\'e7\'f5es. Freq\'fcentemente, certas combina\'e7\'f5es de instru\'e7\'f5es repetem a si mesmas, normalmente em triplas chamadas de produ\'e7\'f5es. Uma produ\'e7\'e3o consiste normalmente em tr\'eas instru\'e7\'f5es tais como carregar somar e armazenar Por exemplo, a Fig. 15.27 ilustra cinco das instru\'e7\'f5es de SML que foram produzidas na compila\'e7\'e3o do programa da Fig. 15.25 As tr\'eas primeiras instru\'e7\'f5es comp\'f5e a produ\'e7\'e3o que somai a y. Note que as instru\'e7\'f5es 06 e 07 armazenam o valor do acumulador na localiza\'e7\'e3o tempor\'e1ria 96 e, ent\'e3o, carregam o valor de volta para o acumulador, de modo que a instru\'e7\'e3o 08 possa armazenar o valor na localiza\'e7\'e3o 98. Freq\'fcentemente, uma produ\'e7\'e3o \'e9 seguida por uma instru\'e7\'e3o de carga para a mesma localiza\'e7\'e3o que acabou de ser armazenada. Este c\'f3digo pode ser otimizado eliminando-se a instru\'e7\'e3o armazenar e a instru\'e7\'e3o de carga subseq\'fcente, que opera sobre a mesma localiza\'e7\'e3o de mem\'f3ria, possibilitando deste modo ao Simpletron executar o programa mais rapidamente. A Fig 15.28 ilustra a SML otimizada para o programa da Fig. 15.25. Note que existem quatro instru\'e7\'f5es a menos no c\'f3digo otimizado - uma economia de espa\'e7o e mem\'f3ria de 25%. \line Modifique o compilador para fornecer uma op\'e7\'e3o para otimizar o c\'f3digo em Simpletron Machine Language que ele \line produz. Compare manualmente o c\'f3digo n\'e3o-otimizado com o c\'f3digo otimizado e calcule a redu\'e7\'e3o percentual. \par
Fig. 15.28 C\'f3digo otimizado para o programa da Fig. 15.25. \line 15.29 (Modfica\'e7\'f5es do compilador de Simple) Execute as seguintes modifica\'e7\'f5es no compilador de Simple. Algumas dessas modifica\'e7\'f5es podem tamb\'e9m exigir modifica\'e7\'f5es no programa simulador do Simpletron escrito no Exerc\'edcio 5.19. \par
\pard\par
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx5002\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx7547\pard\intbl 1 04 +2098 (load) \cell\cell\row
\intbl 2 05 +3097 (add) \cell\cell\row
\intbl 3 06 +2196 (store) \cell\cell\row
\intbl 4 07 +2096 (load) \cell\cell\row
\intbl 5 08 +2198 (store) \cell\cell\row
\intbl Fig. 15.27 C\'f3digo n\'e3o-otimizado do programa da Fig. 15.25. \cell\cell\row
\intbl Localiza\'e7\'e3o e \cell\cell\row
\intbl Programa em Simple Instru\'e7\'e3o SML \cell Descri\'e7\'e3o \cell\row
\intbl 5 rem soma 1 a x nenhuma \cell coment\'e1rio ignorado \cell\row
\intbl 10 input x 00 +1099 \cell l\'eaxparaaposi\'e7\'e3o99 \cell\row
\intbl 15 rem testa se y == x nenhuma \cell coment\'e1rio ignorado \cell\row
\intbl 20 if y == x goto 60 01 +2098 \cell carregay (98) no acumulador \cell\row
\intbl 02 +3199 \cell subtraix (99) do acumulador \cell\row
\intbl 03 +4211 \cell desvia para o endere\'e7o 11 se zero \cell\row
\intbl 25 rem incrementa y nenhuma \cell coment\'e1rio ignorado \cell\row
\intbl 30 let y = y + 1 04 +2098 \cell carregayno acumulador \cell\row
\intbl 05 +3097 \cell somai (97) ao acumulador \cell\row
\intbl 06 +2198 \cell armazena acumulador em y (98) \cell\row
\intbl 35 rem soma y a total nenhuma \cell coment\'e1rio ignorado \cell\row
\intbl 40 let t = t + y 07 +2096 \cell carrega tdo endere\'e7o (96) \cell\row
\intbl 08 +3098 \cell soma y (98) ao acumulador \cell\row
\intbl 09 +2196 \cell armazena acumulador em t (96) \cell\row
\intbl 45 rem repete y nenhuma \cell coment\'e1rio ignorado \cell\row
\intbl 50 goto 20 10 +4001 \cell desvia para o endere\'e7o 01 \cell\row
\intbl 55 rem exibe resultado nenhuma \cell coment\'e1rio ignorado \cell\row
\intbl 60 print t 11 +1196 \cell envia (96) paraatela \cell\row
\intbl 99 end 12 +4300 \cell termina execu\'e7\'e3o \cell\row
\pard\par
\pard\sb100\sa240 CAP\'cdTULO 15 - ESTRUTURAS DE DADOS 805 \line a) Permita que o operador m\'f3dulo (%) seja usado em comandos let. A Simpletron Machine Language deve ser modificada para incluir uma instru\'e7\'e3o m\'f3dulo. \line b) Possibilite a exponencia\'e7\'e3o em um comando let usando A como o operador de exponencia\'e7\'e3o. A Simpletron Machine Language deve ser modificada para incluir uma instru\'e7\'e3o de exponencia\'e7\'e3o. \line c) Possibilite que o compilador reconhe\'e7a letras mai\'fasculas e min\'fasculas em comandos de Simple (por exemplo, \lquote A\rquote  \'e9 equivalente a \lquote a\rquote ). Nenhuma modifica\'e7\'e3o do simulador \'e9 necess\'e1ria. \line d) Possibilite que comandos input leiam valores para diversas vari\'e1veis, tal como input x , y. N\'e3o s\'e3o necess\'e1rias modifica\'e7\'f5es no simulador do Simpletron. \line e) Possibilite que o compilador exiba diversos valores em um \'fanico comando de impress\'e3o, tal como print a ,b , c. N\'e3o s\'e3o necess\'e1rias modifica\'e7\'f5es no simulador do Simpletron. \line O Acrescente recursos de verifica\'e7\'e3o de sintaxe ao compilador, de forma que sejam exibidas mensagens de erro quando forem encontrados erros de sintaxe em um programa em Simple. Nenhuma modifica\'e7\'e3o no simulador do Simpletron \line\'e9 necess\'e1ria. \line g) Possibilite arrays de inteiros. Nenhuma modifica\'e7\'e3o no simulador do Simpletron \'e9 necess\'e1ria. \line h) Possibilite sub-rotinas especificadas pelos comandos de Simple gosub e return. O comando gosub passa o controle do programa para uma sub-rotina e o comando return devolve o controle para o comando depois do gosub. Isto \'e9 semelhante a uma chamada de fun\'e7\'e3o em C++. A mesma sub-rotina pode ser chamada por muitos comandos gosub distribu\'eddos ao longo de um programa. Nenhuma modifica\'e7\'e3o no simulador do Simpletron \'e9 necess\'e1ria. \line i) Permita estruturas de repeti\'e7\'e3o da forma \line for x = 2 to 10 step 2 \line comandos simples \line next \line Este comando for itera de 2 at\'e9 10. com um incremento de 2. A linha next marca o fim do corpo da linha for. \line Nenhuma modifica\'e7\'e3o no simulador do Simpletron \'e9 necess\'e1ria. \line j) Permita estruturas de repeti\'e7\'e3o da forma \line for x = 2 to 10 \line comandos simples \line next \line Este comando for itera de 2 at\'e9 10 com um incremento default de 1. Nenhuma modifica\'e7\'e3o no simulador do \line Simpletron \'e9 necess\'e1ria. \line k) Permita ao compilador processar a entrada e sa\'edda de strings. Isto exige que o simulador do Simpletron seja modificado para processar e armazenar valores de .strings. (Dica: cada palavra do Simpletron pode ser dividida em dois grupos, cada um guardando um inteiro de dois d\'edgitos. Cada inteiro de dois d\'edgitos representa o equivalente decimal em ASCII de um caractere. Acrescente uma instru\'e7\'e3o de linguagem de m\'e1quina que imprimir\'e1 um string come\'e7ando em uma determinada posi\'e7\'e3o de mem\'f3ria do Simpletron. A primeira metade da palavra naquela posi\'e7\'e3o \'e9 o n\'famero de caracteres no ,string (i.e., o comprimento do string). Cada meia palavra subseq\'fcente cont\'e9m um caractere em ASCII expresso como dois d\'edgitos decimais. A instru\'e7\'e3o de linguagem de m\'e1quina confere o comprimento e imprime o string traduzindo cada n\'famero de dois d\'edgitos para o seu caractere equivalente). \line 1) Permita que o compilador processe valores de ponto flutuante al\'e9m de inteiros. O simulador do Simpletron deve tamb\'e9m ser modificado para processar valores de ponto flutuante. \line 15.30 (Um interpretador de Simple) Um interpretador \'e9 um programa que l\'ea um comando de um programa em uma linguagem de alto n\'edvel, determina a opera\'e7\'e3o a ser executada pelo comando e executa a opera\'e7\'e3o imediatamente, O programa em linguagem de alto n\'edvel n\'e3o \'e9 convertido primeiro para linguagem de m\'e1quina. Os interpretadores executam lentamente, porque cada comando encontrado no programa deve primeiro ser decifrado. Se os comandos est\'e3o contidos em um la\'e7o, os comandos s\'e3o decifrados toda vez em que s\'e3o encontrados no la\'e7o. As primeiras vers\'f5es da linguagem de programa\'e7\'e3o BASIC foram implementadas com interpretadores. \line Escreva um interpretador para a linguagem Simple discutida no Exerc\'edcio 15.26. O programa deve usar o conversor de nota\'e7\'e3o infixa para p\'f3s-fixa desenvolvido no Exerc\'edcio 15.12 e o avaliador de express\'f5es em nota\'e7\'e3o p\'f3s-fixa desenvolvido no Exerc\'edcio 15.13 para avaliar express\'f5es em um comando let. As mesmas restri\'e7\'f5es impostas \'e0 linguagem Simple no Exerc\'edcio 15.26 deveriam ser obedecidas neste programa. Teste o interpretador com os programas em Simple escritos no Exerc\'edcio 15.26. Compare os resultados da execu\'e7\'e3o desses programas pelo interpretador com os resultados de programas em Simple compilados, executando-os no simulador do Simpletron constru\'eddo no Exerc\'edcio 5.19. \line 15.31 (inser\'e7\'e3o/exclus\'e3o em qualquer lugar de uma lista encadeada) Nosso gabarito de classe para listas encadeadas permitia inser\'e7\'f5es e exclus\'f5es somente no in\'edcio e no fim da lista encadeada. Esses recursos nos foram convenientes quando usamos \par
806 C++ COMO PROGRAMAR \par
heran\'e7a privada e composi\'e7\'e3o para produzir um gabarito de classe pilha e um gabarito de classe fila com uma quantidade m\'ednima de c\'f3digo, reutilizando o gabarito da classe lista. Na realidade, as listas encadeadas s\'e3o mais gerais que aquelas que fornecemos. Modifique o gabarito da classe lista encadeada que desenvolvemos neste cap\'edtulo para tratar inser\'e7\'f5es e exclus\'f5es em qualquer lugar da lista. \line 15.32 (Lista efilas sem ponteiros de fim) Nossa implementa\'e7\'e3o de uma lista encadeada (Fig. 15.3) usou tanto um firstPtr como um lastPtr. O lastPtr era \'fatil para as fun\'e7\'f5es membro insertAtBack e removeFromBack da classe List. A fun\'e7\'e3o insertAtBack corresponde \'e0 fun\'e7\'e3o membro enqueue da classe Queue. Rescreva a classe List de forma que ela n\'e3o use um lastPtr. Deste modo, quaisquer opera\'e7\'f5es sobre o fim de uma lista devem come\'e7ar a pesquisar a lista pela frente (in\'edcio da lista). Isso afeta nossa implementa\'e7\'e3o da classe Queue (Fig. 15.12)? \line 15.33 Use a vers\'e3o de composi\'e7\'e3o do programa de pilha (Fig. 15.11) para formar um programa completo de pilha que funcione. Modifique esse programa para tomar mime as fun\'e7\'f5es membro. Compare as duas abordagens. Resuma as vantagens e desvantagens de colocar em linha as fun\'e7\'f5es membro. \line 15.34 (Desempenho da classifica\'e7\'e3o e pesquisa em \'e1rvores bin\'e1rias) Um problema com a classifica\'e7\'e3o de \'e1rvores bin\'e1rias \'e9 que a ordem em que os dados s\'e3o inseridos afeta a forma da \'e1rvore - para a mesma cole\'e7\'e3o de dados, diferentes ordens podem produzir \'e1rvores bin\'e1rias de formas drasticamente diferentes. O desempenho de classifica\'e7\'e3o da \'e1rvore bin\'e1ria e dos algoritmos de busca \'e9 sens\'edvel \'e0 forma da \'e1rvore bin\'e1ria. Qual forma teria uma \'e1rvore bin\'e1ria se seus dados fossem inseridos em ordem crescente? E em ordem decrescente? Qual forma a \'e1rvore deveria ter para atingir o m\'e1ximo desempenho de pesquisa? \line 15.35 (Listas indexadas) Conforme apresentado no texto, listas encadeadas devem ser pesquisadas seq\'fcencialmente. Para listas grandes, isso pode resultar em um desempenho fraco. Uma t\'e9cnica comum para melhorar o desempenho da busca em listas \'e9 criar e manter um \'edndice para alista. Um \'edndice \'e9 um conjunto de ponteiros para v\'e1rios lugares-chave na lista. Por exemplo, uma aplica\'e7\'e3o que pesquisa uma lista grande de nomes poderia melhorar seu desempenho criando um \'edndice com 26 entradas - uma para cada letra do alfabeto. Uma opera\'e7\'e3o de busca de um sobrenome come\'e7ando com \lquote Y\rquote  iria ent\'e3o primeiro pesquisar o \'edndice para determinar onde come\'e7am as entradas com \lquote Y\rquote  e, ent\'e3o, \ldblquote saltaria\rdblquote  para a lista naquele ponto, pesquisando seq\'fcencialmente a partir da\'ed at\'e9 encontrar o nome desejado. Isso seria muito mais r\'e1pido do que pesquisar a lista encadeada desde o in\'edcio. Use a classe List da Fig. 15.3 como a base para uma classe indexedList. Escreva um programa que demonstre o funcionamento de listas indexadas. N\'e3o deixe de incluir as fun\'e7\'f5es membro insertlnlndexedList, searchlndexedList e deieteFromlndexedList. \par
\pard\lang1033\f1\fs20\par
}
 