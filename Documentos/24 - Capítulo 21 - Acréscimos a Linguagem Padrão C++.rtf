{\rtf1\ansi\ansicpg1252\deff0\deflang1033{\fonttbl{\f0\fswiss\fprq2\fcharset0 Arial;}{\f1\froman\fcharset0 Times New Roman;}}
\viewkind4\uc1\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx7341\pard\intbl\lang2070\f0\fs24 Acr\'e9scimos \'e0 linguagem \cell\row
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx4519\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx5937\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx7341\pard\intbl padr\'e3o \cell C++\cell  \cell\row
\pard\par
\par
\pard\sb100\sa240 Objetivos \par
\line\bullet  Compreender e usar o tipo de dados bool. \line\bullet  Ser capaz de usar operadores de coer\'e7\'e3o: staticcast, \line uma const_cast e reinterpretcast. \line\bullet  Compreender o conceito de ambientes de nomes. \line\bullet  Compreender e usar informa\'e7\'f5es sobre tipos durante a execu\'e7\'e3o (RTFT)e os operadores typeide dynainiccast. \line\bullet  Compreender as palavras-chave operadores. \line\bullet  Compreender construtores explicit. \line\bullet  Usar membros mutable em objetos corist. \line\bullet  Compreender e usar os operadores ponteiros para membros de classes *e_>* \line\bullet  Compreender o papel das classes base virtual na heran\'e7a m\'faltipla. \line O que h\'e1 em um nome? O que chamamos de rosa sob qualquer outro nome soaria t\'e3o doce. \line William Shakespeare, Romeu e Julieta \line Oh, diamante!, diamante! mal tendes conhecimento do dano causado. \line Sir Tsaac Newton \line s\'ea verdadeiro contigo mesmo \line William Shakespeare, Hamlet \par
A sorte est\'e1 lan\'e7ada. \line J\'falio C\'e9sar \par
\pard\par
\pard\sb100\sa240 1004 C++ COMO PROGRAMAR \line\ul Vis\'e3o Geral \ulnone\line 21.1 Introdu\'e7\'e3o \line 21.2 O tipo de dados bool \line 21.3 O operador static_cast \line 21.4 O operador const_cast \line 21.5 O operador reinterpret_cast \line 21.6 Ambientes de nomes \line 21.7 Informa\'e7\'e3o sobre tipo durante a execu\'e7\'e3o - RTTI \line 21.8 Palavras-chave operadores \line 21.9 Construtores explicit \line 21.10 Membros de classe mutable \line 21.11 Ponteiros para membros de classe (.* e _>*) \line 21.12 Heran\'e7a m\'faltipla e classes base virtual \line 21.13 Observa\'e7\'f5es finais \line Resumo\bullet  Terminologia Erros comuns de programa\'e7\'e3o Boas pr\'e1ticas de programa\'e7\'e3o Dica de desempenho . Dicas de portabilidade Observa\'e7\'e3o de engenharia de software Dicas de teste e depura \'e7\'e3o Exerc\'edcios de auto-revis\'e3o Respostas aos exerc\'edcios de auto-revis\'e3o \bullet  Exerc\'edcios \line 21.1 Introdu\'e7\'e3o \line Agora examinaremos alguns recursos de C++ padr\'e3o, incluindo o tipo de dados bool, operadores de coer\'e7\'e3o, ambientes de nomes (namespace) informa\'e7\'f5es sobre tipos durante a execu\'e7\'e3o (RTTI) e palavras-chave operadores. Tamb\'e9m discutiremos operadores ponteiros para membros de classes e classes base virtual. \line 21.2 O tipo de dados bool \line C++ padr\'e3o fornece o tipo de dados bool, cujos valores podem ser false ou true, como alternativa preferencial ao estilo antigo de uso de O para indicar falso e um valor diferente de zero para indicar verdadeiro, O programa da Fig.21.l demonstra o tipo de dados bool. \line 1 II Fig. 21.1: fig2lOl.cpp \line 2 II Demonstrando o tipo de dado bool. \line 3 #include <iostream> \line 4 \line 5 using std::cout; \line 6 using std: :eridl; \line 7 using std::cin; \line 8 using std: :boolalpha; \line 9 \line 10 int main() \line 11 \line 12 bool boolean = false; \line 13 intx=O; \line 14 \line Fig. 21.1 Demonstrando o tipo de dados primitivo bool (parte 1 de 2). \par
CAP\'cdTULO 21 - AcR\'c9sciMos \'c0 LINGUAGEM PADR\'c3O C ++ 1005 \line 15 cout \'ab \ldblquote boolean \'e9 \ldblquote  \'ab boolean \line 16 \'ab \ldblquote\\nDigite um inteiro: \ldblquote ; \line 17 cm \'bb x; \line 18 \line 19 cout \'ab \ldblquote o inteiro \ldblquote  \'ab x \'ab \ldblquote  \'e9\rdblquote  \line 20 \'ab ( x ? \ldblquote  diferente de zero \ldblquote  : \ldblquote  zero \line 21 \'ab \ldblquote e interpretado como \ldblquote ; \line 22 \line 23 if(x) \line 24 cout \'ab \ldblquote true\\n\rdblquote ; \line 25 else \line 26 cout \'ab \ldblquote false\\n\rquote ; \line 27 \line 28 boolean = true; \line 29 cout \'ab \ldblquote boolean \'e9 \ldblquote  \'ab boolean; \line 30 cout \'ab \ldblquote\\nboolean exibido com o manipulador boolalpha \'e9 \line 31 \'ab boolalpha \'ab boolean \'ab endl; \line 32 \line 33 return 0; \line 34 \line boolean \'e9 O \line Digite um inteiro: 22 \line o inteiro 22 \'e9 diferente de zero e interpretado como true \line boolean \'e9 1 \line boolean exibido com o manipulador boolalpha \'e9 true \line Fig. 21.1 Demonstrando o tipo de dados primitivo bool (parte 2 de 2). \line t\'e3o, A linha 12 \line dobool \line boolean = false; \line declara a vari\'e1vel boolean como do tipo bool e inicializa boolean como false. A vari\'e1vel x \'e9 declarada e inicilizada com 0. A linha 15 \line cout \'ab \ldblquote boolean \'e9 \ldblquote  \'ab boolean \line exibe o valor de boolean. O valor o \'e9 exibido em lugar da palavra-chave false. O default para display de valores bool \'e9 o valor num\'e9rico correspondente. \line O valor dcx (lido na linha 17) \'e9 usado como a condi\'e7\'e3o de um if/else na linha 23. Se x \'e9 0, a condi\'e7\'e3o \'e9 false. Caso contr\'e1rio, a condi\'e7\'e3o \'e9 true. Note que valores negativos s\'e3o diferentes de zero e, portanto, true. \line A linha 28 atribui true para boolean. O valor de boolean (1) \'e9 exibido na linha 29. Uma vari\'e1vel bool \line\'e9 exibida como O ou 1 por default. O operador de inser\'e7\'e3o em stream, \'ab, foi sobrecarregado para exibir bools como inteiros. \line As linhas 30 e 31 \line cout \'ab \ldblquote\\nboolean exibido com o manipulador boolalpha \'e9 \line\'ab boolalpha \'ab boolean \'ab endl; \line usam \ldblquote o\rdblquote  manipulador de stream boolalpha para preparar o stream de sa\'edda para exibir valores bool como os strings \ldblquote true\rdblquote  e \ldblquote false\rdblquote . O manipulador boolalpha tamb\'e9m pode ser usado para entrada. \line Ponteiros, ints, doubles, etc. tamb\'e9m podem ser convertidos implicitamente para bools. Valores zero s\'e3o \line convertidos para false e valores diferentes de zero s\'e3o convertidos para true. Por exemplo, a express\'e3o \line bool dc = false + x * 2 - b && true; \line atribuiria true a dc assumindo-se que x \'e9 3 e b \'e9 true. Note que a avalia\'e7\'e3o do lado direito da express\'e3o de atribui\'e7\'e3o d\'e1 o valor 5, mas este valor \'e9 implicitamente convertido para true. \par
1006 C++ COMO PROGRAMAR \line Boa pr\'e1tica de programa\'e7\'e3o 21.1 \line Quando criar vari\'e1veis de estado para indicar verdade ou falsidade, d\'ea prefer\'eancia ao uso de bools em \line vez de ints. \line Boa pr\'e1tica de programa\'e7\'e3o 21.2 \line Usar true e false em lugar de valores zero e diferentes de zero torna os programas mais claros. \line 21.3 O operador static_cast \line C++ padr\'e3o cont\'e9m quatro operadores de coer\'e7\'e3o para serem usados de prefer\'eancia ao \ldblquote velho estilo\rdblquote  de coer\'e7\'e3o que tem sido usado em C e C++. Os novos operadores de coer\'e7\'e3o s\'e3o menos poderosos e mais espec\'edficos do que o estilo antigo de coer\'e7\'e3o, o que d\'e1 ao programador um controle mais preciso. A coer\'e7\'e3o \'e9 perigosa, podendo freq\'fcentemente ser uma fonte de erros; assim, os operadores de coer\'e7\'e3o no novo estilo s\'e3o tamb\'e9m mais f\'e1ceis de detectar e pesquisar usando-se ferramentas automatizadas. Uma outra vantagem das coer\'e7\'f5es no novo estilo \'e9 que os quatro operadores t\'eam finalidades completamente diversas, enquanto que com o velho estilo de coer\'e7\'e3o a filosofia era \ldblquote um operador de coer\'e7\'e3o para tudo\rdblquote . \line C++ fornece o operador static cast para convers\'e3o entre tipos. A verifica\'e7\'e3o de tipos \'e9 feita durante a \line compila\'e7\'e3o. O operador static cast executa convers\'f5es padr\'e3o (por exemplo, void * para char , int para float, etc.) e suas inversas. A Fig. 21.2 demonstra o operador staticcast. \line Erro comum de programa\'e7\'e3o 21.1 \line Executar uma coer\'e7\'e3o ilegal com o operador static cast \'e9 um erro de sintaxe. Coer\'e7\'f5es ilegais incluem fazer uma convers\'e3o de tipos const para tipos n\'e3o-const, fazer coer\'e7\'e3o de ponteiros e refer\'eancias entre tipos que n\'e3o s\'e3o relacionados por heran\'e7a public e fazer coer\'e7\'e3o para um tipo para o qual n\'e3o h\'e1 um construtor ou operador de convers\'e3o apropriado para executar a convers\'e3o. \line O programa declara as classes BaseClass e DerivedClass. Cada classe define uma fun\'e7\'e3o membro f. As linhas 23 e 24 \line double d = 8.22; \line int x = static cast< int >( d ); \line declaram e inicializam tanto d como x. O operador static_cast converte d de double para int. O operador static_cast pode ser usado para a maioria das convers\'f5es entre tipos de dados primitivos, tais como int, float, double, etc. \line 1 // Fig. 21.2: fig2lO2.cpp \line 2 II Demonstrando o operador static_cast. \line 3 #include <iostreain> \line 4 \line 5 using std: :cout; \line 6 using std::endl; \line 7 \line 8 class BaseClass \{ \line 9 public: \line 10 void f( void ) const \{ cout \'ab \ldblquote BASE\\n\rdblquote ; \} \line 11 \}; \line 12 \line 13 class DerivedClass : public BaseClass \{ \line Fig. 21.2 Demonstrando o operador static cast (parte 1 de 2). \par
- \par
CAP\'cdTULO 21 - ACR\'c9SCIMOS \'c0 LINGUAGEM PADR\'c3O C ++ 1007 \line 14 public: \line 15 void f( void ) const \{ cout \'ab \ldblquote DERIVADA\\n; \line 16 \line 17 \line 18 void test( BaseClass * \line 19 \line 20 int main() \line 21 ( \line 22 II usa static_cast para uma convers\'e3o \line 23 double d = 8.22; \line 24 int x = staticcast< int >( d ); \line 25 \line 26 cout \'ab \lquote d \'e9 \'ab d \'ab \\nx \'e9 \'ab x \'ab endi; \line 27 \line 28 BaseClass * basePtr = new DerivedClass; \line 29 test( basePtr ); // chama test \line 30 delete basePtr; \line 31 \line 32 return 0; \line 33 ) \line 34 \line 35 void test( BaseClass * basePtr \line 36 \line 37 DerivedClass *derjvedptr; \line 38 \line 39 // faz coer\'e7\'e3o de ponteiro p/classe base em ponteiro p/classe derivada \line 40 derivedPtr = static_cast< DerivedClass * >( basePtr ); \line 41 derivedPtr->f O); // invoca a fun\'e7\'e3o f de DerivedClass \line 42 \par
Fig. 21.2 Demonstrando o operador static_cast (parte 2 de 2). \line Observa\'e7\'e3o de engenharia de software 21.1 \line ______ Com os acr\'e9scimos dos novos operadores de coer\'e7\'e3o (p.ex., static cast) ao C++ padr\'e3o, os opera- dores de coer\'e7\'e3o no estilo antigo (estilo de C) s\'e3o considerados obsoletos. \line Boa pr\'e1tica de programa\'e7\'e3o 21.3 \line Use o operador static cast, mais seguro e confi\'e1vel, em prefer\'eancia ao operador de coer\'e7\'e3o no \line estilo de C. \line Na linha 28, um novo objeto DerivedClass \'e9 atribu\'eddo ao ponteiro para BaseClass basePtr e passado para a fun\'e7\'e3o test na linha 29. O endere\'e7o passado para test \'e9 recebido pelo ponteiro basePtr. O ponteiro derivedPtr de DerivedClass \'e9 declarado na linha 37. A linha 40 \line derivedPtr = static cast< DerivedClass * >( basePtr ); \line usa static_cast para tazer um downcasting de BaseClass * para DerivedClass . Embora (como vimos no Cap\'edtulo 9) fazer um downcasting de um ponteiro de uma classe base para um ponteiro de uma classe derivada seja uma opera\'e7\'e3o potencialmente perigosa, static_cast permite essa coer\'e7\'e3o. A fun\'e7\'e3o f \'e9 invocada usando-se derivedPtr (linha 41). \par
\pard\par
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx878\pard\intbl d \'e9 8.22 \cell\row
\intbl x\'e9 8 \cell\row
\intbl DERIVADA \cell\row
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx385\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx878\pard\intbl\cell\cell\row
\pard\par
\pard\sb100\sa240 1008 C++ COMO PROGRAMAR \line 21.4 O operador const_cast \line C++ fornece o operador const_cast para eliminar os atributos de const e volatile. O programa da Fig. 21.3 demonstra o uso de const_cast. \line 1 // Fig. 21.3: fig2l_03.cpp \line 2 II Demonstrando o operador const_cast. \line 3 #include <iostream> \line 4 \line 5 using std::cout; \line 6 using std::endl; \line 7 \line 8 class ConstCastTest \line 9 public: \line 10 void setNumber( int ); \line 11 int getNumber() const; \line 12 void printNumber() const; \line 13 private: \line 14 int number; \line 15 \}; \line 16 \line 17 void ConstCastTest::setNuinber( int num ) \{ number num; \line 18 \line 19 int ConstCastTest::getNumber() const \{ return number; \line 20 \line 21 void ConstCastTest::printNumber() const \line 22 \line 23 cout \'ab \ldblquote\\nNumber ap\'f3s modifica\'e7\'e3o: \ldblquote ; \line 24 \line 25 // a express\'e3o number-- geraria um erro de compila\'e7\'e3o \line 26 // elimina atributo de const para permitir a modifica\'e7\'e3o \line 27 const_cast< ConstCastTest * >( this )->number--; \line 28 \line 29 cout \'ab nunber \'ab endl; \line 30 \line 31 \line 32 int main() \line 33 \{ \line 34 ConstCastTest x; \line 35 x.setNuxnber( 8 ); // atribui 8 ao dado private number \line 36 \line 37 cout \'ab \ldblquote Valor inicial de number: \'ab x.getNumberO; \line 38 \line 39 x.printNuniberO; \line 40 return 0; \line 41 \} \line Valor inicial de number: 8 \line Nurnber ap\'f3s modifica\'e7\'e3o: 7 \line Fig. 21.3 Demonstrando o operador const_cast. \line As linhas 8 a 15 declaram a classe ConstCastTest que cont\'e9m tr\'eas fun\'e7\'f5es membro e a vari\'e1vel private nuniber. Duas das fun\'e7\'f5es membro s\'e3o declaradas const. A fun\'e7\'e3o setNuniber define o valor de number. A \line fun\'e7\'e3o getNumber retorna o valor de nuznber. \line L \par
CAP\'cdTULO 21 - ACRESCIMOS \'c0 LINGUAGEM PADR\'c3O C ++ 1009 \line A fun\'e7\'e3o membro const printNumber modifica o valor de number na linha 27 \line daFig. constcast< ConstCastTest * >( this )->nuinber--; \line Na fun\'e7\'e3o membro const printNumber. o tipo de dados do ponteiro this \'e9 const ConstCastTest*. \line O comando anterior retira o atributo const do ponteiro this com o operador const_cast. Agora, o tipo do ponteiro this para o restante do comando \'e9 ConstCastNumber . Isto permite que number seja modificado, O operador const cast n\'e3o pode ser usado para retirar diretamente o atributo const de uma vari\'e1vel constante. \line 21.5 O operador reinterpret_cast \line C++ fornece o operador reinterpret cast para coer\'e7\'f5es n\'e3o-padr\'e3o (por exemplo, coer\'e7\'e3o de um tipo de ponteiro para outro tipo de ponteiro, etc.). O operador reinterpret cast tamb\'e9m pode ser usado para coer\'e7\'f5es padr\'e3o (i. e., double para int, etc.). A Fig. 21.4 demonstra o uso do operador reinterpret_cast. \line 1 II Fig. 21.4: fig2104.cpp \line 2 II Demonstrando o operador reinterpret_cast. \line 3 #include <iostreain> \line 4 \line 5 using std::cout; \line 6 using std::endl; \line 7 \line 8 int main() \line 9\{ \line 10 int x = 120, *ptr = \line 11 \line 12 cout \'ab *remnterpretcast<char *>( ptr ) \'ab endi; \line 13 \line 14 return 0; \line 15 \} \line x \line Fig. 21.4 Demonstrando o operador reinterpretcast. \line O programa declara um inteiro e um ponteiro. O ponteiro ptr \'e9 inicializado como endere\'e7o de x. A linha 12 cout \'ab *reinterpretcast<char *>( ptr ) \'ab endl; \line usa o operador reinterpret cast para fazer a coer\'e7\'e3o de ptr (do tipo int *) para char . O endere\'e7o \line retornado \'e9 derreferenciado. \line\'ae \ul Dica de teste e depura \'e7\'e3o 21.1 \ulnone\line\'c9 f\'e1cil usar reinterpret cast para executar manipula\'e7\'f5es perigosas que podem levar a s\'e9rios \line erros durante a execu\'e7\'e3o. \line\ul Dica de portabilidade 21.1 \ulnone\line ivate \line nber. A Usar reinterpret cast pode fazer com que os programas se comportem de modo diferente em diferentes plataformas. \par
1010 C++ COMO PROGRAMAR \line 21.6 Ambientes de nomes \line 4 Um programa inclui muitos identificadores definidos em diferentes escopos. \'c0s vezes, o escopo de uma vari\'e1vel se \ldblquote sobrep\'f5e ao\rdblquote  (i.e., colide com o) escopo de uma vari\'e1vel com o mesmo nome em um escopo diferente, criando um problema potencial. Tais sobreposi\'e7\'f5es podem ocorrer em muitos n\'edveis. A sobreposi\'e7\'e3o de identificadores ocorre com freq\'fc\'eancia com bibliotecas fornecidas por terceiros que usam os mesmos nomes para identificadores globais (tais como fun\'e7\'f5es). Quando isto ocorre, geralmente s\'e3o gerados erros de compila\'e7\'e3o. \line Boa pr\'e1tica de programa\'e7\'e3o 21.4 \line Evite come\'e7ar identificadores com o caractere sublinhado, o que pode levar a erros de liga\'e7\'e3o. \line C++ padr\'e3o tenta resolver este problema com ambientes de nomes (namespaces). Cada namespace define um escopo onde identificadores e vari\'e1veis s\'e3o colocados. Para usar um membro de um namespace. o nome do membro deve ser qualificado com o nome do naxnespace e o operador bin\'e1rio de resolu\'e7\'e3o de escopo (: :) como segue: \line namespace_nome: : membro \line ou um comando using deve aparecer antes de o nome ser usado; comandos using s\'e3o tipicamente colocados no come\'e7o do arquivo no qual membros do namespace s\'e3o usados. Por exemplo, o comando \line us ing namespace nome_do_namespace \line no come\'e7o de um arquivo-fonte especifica que os membros do nainespace nome_do_namespace podem ser usados no arquivo sem preceder cada membro com o nome_do_namespace e o operador de resolu\'e7\'e3o de escopo (: :). \line Boa pr\'e1tica de programa\'e7\'e3o 21.5 \line Preceda um membro pelo nome do seu namespace e o operador de resolu\'e7\'e3o de escopo (: :) se existe possibilidade de um conflito de escopo. \line Nem todos os namespaces s\'e3o garantidamente \'fanicos. Dois fornecedores independentes podem inadvertidamente usar o mesmo namespace. A Fig. 21.5 demonstra o uso de namespaces. \line A linha 4 \line using namespace std; II usa o ambiente de nomes std \line informa ao compilador que o namespace std est\'e1 sendo usado. Os conte\'fados do arquivo de cabe\'e7alho <iostream> s\'e3o todos definidos como sendo parte do namespace std. [Nota: a maioria dos programadores de C++ considera uma pr\'e1tica de programa\'e7\'e3o sobre escrever um comando using como o da linha 4, porque todo o conte\'fado do ambiente de nomes \'e9 inclu\'eddo. 1 \line 1 II Fig. 21.5: fig2lO5.cpp \line 2 // Demonstrando ambientes de nomes. \line 3 #include <iostream> \line 4 using namespace std; II usa o ambiente de nomes std \line 5 \line 6 int mylnt = 98; II vari\'e1vel global \line 7 \line 8 namespace Example \{ \line 9 const double P1 = 3.14159; \line 10 const double E = 2.71828; \line 11 int mylnt = 8; \line 12 void printValuesO; \line 13 \line 14 namespace Inner \{ II ambiente de nomes aninhado \line 15 enum Years \{ FISCAL1 = 1990, FISC\'c3L2, FISCAL3 \}; \line Fig. 21.5 Demonstrando o uso de namespaces (parte 1 de 2). \par
CAP\'cdTULO 21 - AcR\'c9sciMos \'c0 LINGUAGEM PADR\'c3O C ++ 1011 \line 16 \} \line 17 ) \line 18 \line 19 naxnespace \{ II ambiente de nomes sem nome \line 20 double d = 88.22; \line 21 \line 22 \line 23 int main() \line 24 \line 25 II exibe o valor de d do ambiente de nomes sem nome \line 26 cout \'ab \ldblquote d = \ldblquote  \'ab d; \line 27 \line 28 II exibe a vari\'e1vel global \line 29 cout \'ab \ldblquote\\n(global) mylnt = \'ab mylnt; \line 30 \line 31 II exibe os valores do ambiente de nomes Example \line 32 cout \'ab \\nPI = \lquote  \'ab Example::PI \'ab \\nE = \line 33 \'ab Exainple: :E \'ab \ldblquote\\nmylnt = \line 34 \'ab Example: :mylnt \'ab \ldblquote\\nFISCAL3 = \line 35 \'ab Example::Inner::FISCAI3 \'ab endl; \line 36 \line 37 Example::printValuesO; II invoca a fun\'e7\'e3o printValues \line 38 \line 39 return 0; \line 40 \line 41 \line 42 void Example::printValues() \line 43 \{ \line 44 cout \'ab \\nEm printValues:\\n\rdblquote  \'ab \ldblquote mylnt = \line 45 \'ab mylnt \'ab \\nPI = \'ab P1 \'ab \\nE = \line 46 \'ab E \'ab \ldblquote\\nd = \'ab d \'ab \ldblquote\\n(global) mylnt \line 47 \'ab : :mylnt \'ab \lquote\\nFISCAL3 = \line 48 \'ab Inner::FISCAL3 \'ab endl; \line 49 \} \line d = 88.22 \line (global) mylnt = 98 \line P1 = 3.14159 \line E = 2.71828 \line mylnt = 8 \line FISCAL3 = 1992 \line Em printValues: \line mylnt = 8 \line P1 = 3.14159 \line E = 2.71828 \line d = 88.22 \line (global) mylnt = 98 \line FISCAL3 = 1992 \line Fig. 21.5 Demonstrando o uso de nomespaces (parte 2 de 2). \line O comando using namespace especifica que os membros de um namespace ser\'e3o usados freq\'fcentemente ao longo de um programa. Isto permite ao programador acessar todos os membros do namespace e escrever comandos mais concisos, tais como \line cout \'ab d =\ldblquote  \'ab d; \par
1012 C++ COMO PROGRAMAR \line em vez de \line std::cout \'ab \ldblquote d = \'ab d; \line Sem a linha 4, cada cout e endi na Fig. 21.5 teria que ser qualificado com std: : . O comando using namespace pode ser usado para namespaces predefinidos (por exemplo, std) ou namespaces definidos pelo programador. \line As linhas 8 a 17 \line nainespace Example \{ \line const double P1 = 3.14159; \line const double E = 2.71828; \line int mylnt = 8; \line void printValues \line namespace Inner \{ II ambiente de nomes aninhado \line enum Years \{ FISCAL1 = 1990, FISCAL2, FISCAL3 \}; \line usam a palavra-chave narnespace para definir o nainespace Example. O corpo de um namespace \'e9 delimitado por chaves (\{ \}). Diversamente dos corpos de classes, os corpos de namespaces n\'e3o terminam em ponto-e- v\'edrgula. Os membros de Exainple consistem em duas constantes (P1 e E), um int (mylnt), uma fun\'e7\'e3o (printValues) e um namespace aninhado (Inner). Note que o membro mylnt tem o mesmo nome que a vari\'e1vel global ntylnt. Vari\'e1veis que t\'eam o mesmo nome devem ter escopos diferentes - caso contr\'e1rio, ocorrer\'e3o erros de sintaxe. Um namespace pode conter constantes, dados, classes, namespaces aninhados, fun\'e7\'f5es, etc. As defini\'e7\'f5es de namespaces devem ocupar o escopo global ou estar aninhadas dentro de outros namespaces. \line As linhas 19 a 21 \line namespace \{ II ambiente de nomes sem nome \line double d = 88.22; \line criam um namespace n\'e3o-nomeado contendo o membro d. Os membros de namespaces n\'e3o-nomeados ocupam o namespace global, s\'e3o acess\'e1veis diretamente e n\'e3o t\'eam que ser qualificados com o nome de um names- pace. Vari\'e1veis globais tamb\'e9m s\'e3o parte do namespace global e s\'e3o acess\'e1veis em todos os escopos que seguem a sua declara\'e7\'e3o em um arquivo. \line Observa\'e7\'e3o de engenharia de software 21.2 \line Cada unidade de compila\'e7\'e3o separada tem seu pr\'f3prio e \'fanico namespace n\'e3o-nomeado, ou seja, o \line namespace n\'e3o-nomeado substitui o especficador de liga\'e7\'e3o static. \line A linha 26 exibe o valor de dO membro d \'e9 diretamente acess\'e1vel como parte do namespace n\'e3o-nomeado. A linha 29 exibe o valor da vari\'e1vel global mylnt.As linhas 32 a 35 \line cout \'ab \ldblquote\\nPI = \ldblquote  \'ab Example::PI \'ab \ldblquote\\nE = \line\'ab Example: :E \'ab \ldblquote\\nmylnt = \line\'ab Example::mylnt \'ab \ldblquote\\nFISCAL3 = \line\'ab Example::Inner::FISCAL3 \'ab endi; \line exibem os valores de P1. E. mylnt e FISCAL3. P1. E e mylnt s\'e3o membros de Example e, portanto, s\'e3o qualificados com Exanple: :. O membro mylnt deve ser qualificado porque existe uma vari\'e1vel global com o mesmo nome. Caso contr\'e1rio, \'e9 exibida a vari\'e1vel global. FISCAL3 \'e9 um membro do namespace aninhado Inner e \'e9 qualificado com Example: : Inner::. \line A fun\'e7\'e3o printValues \'e9 um membro de Example e pode acessar diretamente outros membros do mesmo namespace sem usar um qualificador de namespace. O cout na linha 44 exibe mylnt, P1, E, d, a vari\'e1vel global mylnt e FISCAL3. Repare que P1 e E n\'e3o s\'e3o qualificados com Example, d ainda est\'e1 acess\'e1vel, a vers\'e3o global de mylnt foi qualificada com o operador de resolu\'e7\'e3o de escopo (: :) e FISCAI3 foi qualificado com \par
CAP\'cdTULO 21 - ACR\'c9SCIMOS \'c0 LINGUAGEM PADR\'c3O C ++ 1013 \par
Inner: :. Quando acessar membros de um namespace aninhado, os membros devem ser qualificados com o nome do namespace (a menos que voc\'ea esteja dentro do namespace aninhado). \line A palavra-chave using tamb\'e9m pode ser usada para permitir que um membro individual de um namespa- ce seja usado. Por exemplo, a linha \line using Example::PI; \line permitiria que P1 fosse usado sem a qualifica\'e7\'e3o de nainespace. Isto \'e9 feito tipicamente quando somente um membro de um naxnespace \'e9 usado com freq\'fc\'eancia. namespaces podem ter nomes alternativos (aliases). Por exemplo, o comando \line namespace CPPHTP3E = CPlusPlusHowToProgram3E; \line cria o alias CPPHTP3E para CPlusPlusHowToPrograin3E. \line Erro comum de programa\'e7\'e3o 21.2 \line Colocar main em um namespace \'e9 um erro de sintaxe. \line Observa\'e7\'e3o de engenharia de software 21.3 \line ______ Em programas grandes, idealmente cada entidade deve ser declarada em uma classe, fun\'e7\'e3o, bloco ou \line eI namespace. Isto ajuda a deixar claro o papel de cada entidade. \line 21.7 Informa\'e7\'e3o sobre tipo durante a execu\'e7\'e3o - RTTI \line A informa\'e7\'e3o sobre tipo durante a execu\'e7\'e3o (RTTI, run-time tvpe information) fornece um meio de determinar o tipo de um objeto durante a execu\'e7\'e3o. Nesta se\'e7\'e3o, s\'e3o discutidos dois importantes operadores de RTTI: typeid e dynamiccast. O programa da Fig. 21.6 demonstra typeid e o programa da Fig. 21.7 demonstra dynamic_cas t. \line\'ae Dica de teste e depura \'e7\'e3o 21.2 \line De modo a poder usar R777, alguns compiladores requerem que os recursos de RTI\rquote i sejam habilitados. \line Verifique a documenta\'e7\'e3o do seu compilador sobre o uso de RTI\rquote I. \line 1 II Fig. 21.6: fig2l_06.cpp \line 2 // Demonstrando o recurso typeid de RTTI. \line 3 #include <iostreani> \line 4 \line 5 using std::cout; \line 6 using std::endl; \line 7 \line 8 #include <typeinfo> \line 9 \line 10 template < typenaxne T > \line 11 T maximum( T valuel, T value2, T value3 \line 12 \line 13 T max = valuel; \line 14 \line 15 if ( value2 > max \line O 16 max = value2; \line 17 \line 18 if ( value3 > max \line 19 max = value3; \line 20 \par
Fig. 21.6 Demonstrando typeid (parte 1 de 2). \par
1014 C++ COMO PROGRAMAR \line 21 // obt\'e9m o nome do tipo (i.e., int ou double) \line 22 const char *dataType = typeid( T ).nameO; \line 23 \line 24 cout \'ab dataType \'ab \ldblquote s foram comparados.\\nO maior \line 25 \'ab dataType \'ab \'e9 \line 26 \line 27 return max; \line 28 \line 29 \line 30 int main() \line 31 \{ \line 32 inta=8,b=88, c=22; \line 33 double d = 95.96, e = 78.59, f = 83.89; \line 34 \line 35 cout \'ab maximum( a, b, c ) \'ab \ldblquote\\n\rdblquote ; \line 36 cout \'ab maximum( d, e, f ) \'ab endl; \line 37 \line 38 return 0; \line 39 \par
Fig. 21.6 Demonstrando typeid (parte 2 de 2). \line A linha 8 inclui o arquivo de cabe\'e7alho <typeinfo>. Quando se usa o resultado de typeid, <typeinfo> \'e9 obrigat\'f3rio, O programa define um gabarito de fun\'e7\'e3o maximum que recebe tr\'eas par\'e2metros do tipo de dado T especificado e determina e retorna o maior dos tr\'eas. A palavra-chave typename \'e9 usada no lugar da palavra-chave class. Nesta situa\'e7\'e3o, typename se comporta de maneira id\'eantica a class. \line A linha 22 \line const char *dataType = typeid( T ).nameO; \line usa a fun\'e7\'e3o name para retornar um string no estilo de C, definido pela implementa\'e7\'e3o, representando o tipo de dados de T. O operador typeid retorna uma refer\'eancia para um objeto type info. Um objeto type info \'e9 um objeto mantido pelo sistema que representa um tipo. Note que o string retornado por name \'e9 mantido pelo sistema e n\'e3o deve ser deletado pelo programador. \line Boa pr\'e1tica de programa\'e7\'e3o 21.6 \line Usar typeid em testes do tipo switch \'e9 um mau uso de RTrI. Em vez disso, use fun\'e7\'f5es virtual. \line O operador dynamic cast assegura que as convers\'f5es adequadas sejam feitas durante a execu\'e7\'e3o (ou seja, o compilador n\'e3o pode verificar se \'e9 ou n\'e3o uma convers\'e3o adequada). O operador dynamic_cast \'e9 freq\'fcentemente usado para fazer downcasting (coer\'e7\'e3o) de um ponteiro de uma classe base para um ponteiro de uma classe derivada. O programa da Fig. 21.7 demonstra dynamiccast. \line 1 II Fig. 21.7: fig2lO7.cpp \line 2 // Demonstrando dynamic_cast. \line 3 #include <iostream> \line 4 \line 5 using std::cout; \line 6 using std::endl; \line Fig. 21.7 Demonstrando dynamic cast (parte 1 de 3). \par
\pard\par
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2847\pard\intbl ints foram comparados. \cell\row
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx781\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1574\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2847\pard\intbl O maior \cell int \'e9 \cell 88 \cell\row
\intbl doubles \cell foram \cell comparados. \cell\row
\intbl O maior \cell double \cell\'e9 95.96 \cell\row
\pard\par
\pard\sb100\sa240 CAP\'cdTULO 21 - ACR\'c9SCIMOS \'c0 LINGUAGEM PADR\'c3O C ++ 1015 \line 7 \line 8 const double P1 = 3.14159; \line 9 \line 10 class Shape \line 11 public: \line 12 virtual double area() const \{ return 0.0; \line 13 \line 14 \line 15 class Circle : public Shape \line 16 public: \line 17 Circle( int r = 1 ) \{ radius = r; \line 18 \line 19 virtual double area() const \line 20 \line 21 return P1 * radius * radius; \line 22 \line 23 protected: \line 24 int radius; \line 25 \line 26 \line 27 class Cylinder : public Circle \line 28 public: \line 29 Cylinder( int h = 1 ) \{ height = h; \line 30 \line 31 virtual double area() const \line 32 \line 33 return 2 * * radius * height + \line 34 2 * Circle::areaO; \line O>\'e9 35 \} \line doT 36 private: \line have 37 int height; \line 38 \line 39 \line 40 void outputShapeArea( const Shape * ); // prot\'f3tipo \line 41 \line 42 int niain() \line Iode 43 \{ \line foe 44 Circle circle; \line pelo 45 Cylinder cylinder; \line 46 Shape *ptr = 0; \line 47 \line 48 outputShapeArea( &circle ); II exibe a \'e1rea do c\'edrculo \line 49 outputShapeArea( &cylinder ); II exibe a \'e1rea do cilindro \line 50 outputShapeArea( ptr ); II tenta exibir a \'e1rea \line 51 return 0; \line ja,o 52 \line asse 54 void outputShapeArea( const Shape *shapePtr ) \line 55 \line 56 const Circle *circleptr; \line 57 const Cylinder *cylinderPtr; \line 58 \line 59 // faz coer\'e7\'e3o de Shape * para um Cylinder * \line 60 cylinderPtr dynamic_cast< const Cylinder * >( shapePtr ); \line 61 \line 62 if ( cylinderPtr != O ) II setrue, invoca area() \line 63 cout \'ab \'c1rea do cilindro: \'ab shapePtr->areaO; \line Fig. 21.7 Demonstrando dynamic cast (parte 2 de 3). \par
1016 C++ COMO PROGRAMAR \line 64 else \{ II shapePtr n\'e3o aponta para um cilindro \line 65 \line 66 II faz coer\'e7\'e3o de shapePtr para uni Circie * \line 67 circlePtr = dynaxnic_cast< const Circle * >( shapePtr ); \line 68 \line 69 if ( circlePtr != O ) // se true, invoca area() \line 70 cout \'ab \ldblquote\'c1rea do c\'edrculo: \ldblquote  \'ab circlePtr->area \line 71 else \line 72 cout \'ab \ldblquote Nem um c\'edrculo nem um cilindro.\rdblquote ; \line 73 \} \line 74 \line 75 cout \'ab endl; \line 76 \line\'c1rea do c\'edrculo: 3.14159 \line\'c1rea do cilindro: 12.5664 \line Nem um c\'edrculo nem um cilindro. \line Fig. 21.7 Demonstrando dynamic cast (parte 3 de 3). \line O programa define a classe base Shape (linha 10) que cont\'e9m a fun\'e7\'e3o virtual area, uma classe derivada Circle (linha 15) que herda publicamente de Shape e uma classe derivada Cylinder (linha 27) que herda publicamente de Circle. Tanto Circle como Cylinder sobrescrevem a fun\'e7\'e3o area. \line Na fun\'e7\'e3o main, nas linhas 44 a 46, s\'e3o instanciados um objeto da classe Circie chamado circie, um objeto da classe Cylinder chamado cylinder, e um ponteiro para um Shape chamado ptr \'e9 declarado e inicializado com zero. As linhas 48 a 50 chamam a fun\'e7\'e3o outputShapeArea (definida na linha 54) tr\'eas vezes. Cada chamada a outputShapeArea exibir\'e1 um de tr\'eas resultados - a \'e1rea de um Circle, a \'e1rea de um Cylinder ou a indica\'e7\'e3o de que o objeto Shape n\'e3o \'e9 nem um Circle nem um Cylinder. A fun\'e7\'e3o outputShapeArea recebe como argumento um ponteiro para um Shape - a primeira chamada recebe o endere\'e7o de circle, a segunda chamada recebe o endere\'e7o de cylinder e a terceira chamada recebe um ponteiro para a classe base Shape chamado ptr. \line A linha 60 \line cylinderPtr = dynamic cast< const Cylinder * >( shapePtr ); \line efetua dinamicamente a convers\'e3o de shapePtr (um const Shape *) para um const Cylinder * usando o \line operador de coer\'e7\'e3o dynamic cast. Como resultado, ou o endere\'e7o do objeto cylinder ou O \'e9 atribu\'eddo a \line cylinderPtr, para indicar que o Shape n\'e3o \'e9 um Cylinder. Se o resultado da coer\'e7\'e3o n\'e3o \'e9 o, \'e9 exibida a \line\'e1rea do Cylinder. \line A linha 67 \line circlePtr = dynamic_cast< const Circle * >( shapePtr ); \line faz a convers\'e3o din\'e2mica de shapePtr para um const Circle * (downcast) usando o operador de coer\'e7\'e3o dynamiccast. Como resultado, ou o endere\'e7o do objeto circie ou O \'e9 atribu\'eddo a circlePtr, para indicar que o Shape n\'e3o \'e9 um Circle. Se o resultado da coer\'e7\'e3o n\'e3o \'e9 o, \'e9 exibida a \'e1rea do Circle. \line Erro comum de programa\'e7\'e3o 21.3 \line Tentar usar dynamic cast sobre um ponteiro do tipo void * \'e9 um erro de sintaxe. \line Observa\'e7\'e3o de engenharia de software 21.4 \line ______ Riu foi concebido para ser usado com hierarquias de heran\'e7a polim\'f3mficas (com fun\'e7\'f5es virtual). \par
CAP\'cdTULO 21 - AcR\'c9sciMos \'c0 LINGUAGEM PADR\'c3O C ++ 1017 \line 21.8 Palavras-chave operado res \line C++ padr\'e3o fornece palavras-chave operadores (Fig. 21.8) que podem ser usadas no lugar de v\'e1rios operadores C++. Palavras-chave operadores podem ser \'fateis para teclados de programadores que n\'e3o suportam certos caracteres, tais como!, &. \lquote , 1 etc. \line O programa na Fig. 21.9 demonstra o uso de palavras-chave operadores. Este programa foi compilado com o Microsoft Visual C++, que requer o arquivo de cabe\'e7alho <iso646 h> para usar palavras-chave operadores. Outros compiladores podem diferir do acima; assim, verifique a documenta\'e7\'e3o do seu compilador para determinar qual arquivo de cabe\'e7alho deve ser inclu\'eddo (eventualmente, o compilador pode n\'e3o necessitar da inclus\'e3o de qualquer arquivo de cabe\'e7alho para usar estas palavras-chave). \line O programa declara e inicializa dois inteiros, a e b. Opera\'e7\'f5es l\'f3gicas e sobre bits s\'e3o executadas com a e b usando as v\'e1rias palavras-chave operadores. O resultado de cada opera\'e7\'e3o \'e9 exibido. \par
Fig. 21.9 Demonstrando as palavras-chave operadores (parte 1 de 2). \par
\pard\par
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx6204\pard\intbl Operador Palavra-chave operador Descri\'e7\'e3o \cell\row
\intbl Operadores l\'f3gicos \cell\row
\intbl && and E l\'f3gico \cell\row
\intbl 1 or OU l\'f3gico \cell\row
\intbl not nega\'e7\'e3o l\'f3gica \cell\row
\intbl Operadores de desigualdade \cell\row
\intbl = noteq desigualdade \cell\row
\intbl Operado res sobre bits \cell\row
\intbl & bitand E sobre bits \cell\row
\intbl bitor OU inclusivo sobre bits \cell\row
\intbl xor OU exclusivo sobre bits \cell\row
\intbl - compi complemento de bits \cell\row
\intbl Operadores de atribui\'e7\'e3o sobre bits \cell\row
\intbl &= and_eq atribui\'e7\'e3o E sobre bits \cell\row
\intbl = oreq atribui\'e7\'e3o OU inclusivo sobre bits \cell\row
\intbl xoreq atribui\'e7\'e3o OU exclusivo sobre bits \cell\row
\intbl Fig. 21.8 Palavras-chave operadores como alternativa para s\'edmbolos de operadores. \cell\row
\intbl 1 II Fig. 21.9: fig2lO9.cpp \cell\row
\intbl 2 // Demonstrando as palavras-chave operadores. \cell\row
\intbl 3 #include <iostreani> \cell\row
\intbl 4 \cell\row
\intbl 5 using std::cout; \cell\row
\intbl 6 using std::endl; \cell\row
\intbl 7 using std: :boolalpha; \cell\row
\intbl 8 \cell\row
\intbl 9 #include <iso646.h> \cell\row
\intbl 10 \cell\row
\intbl 11 int main() \cell\row
\intbl 12 \cell\row
\intbl 13 inta=8, b=22; \cell\row
\intbl 14 \cell\row
\intbl 15 cout \'ab boolalpha \cell\row
\intbl 16 \'ab a and b: \'ab ( a and b \cell\row
\intbl 17 \'ab \\n a or b: \'ab ( a or b \cell\row
\intbl 18 \'ab \\n not a: \'ab ( not a \cell\row
\intbl 19 \'ab \ldblquote\\na not_eq b: \'ab ( a not_eq b \cell\row
\pard\par
\pard\sb100\sa240 1018 C++ COMO PROGRAMAR \par
Fig. 21.9 Demonstrando as palavras-chave operadores (parte 2 de 2). \par
21.9 Construtores explicit \par
No Cap\'edtulo 8, \ldblquote Sobrecarga de operadores\rdblquote , discutimos que qualquer construtor que \'e9 chamado com um argumento pode ser usado pelo compilador para executar uma convers\'e3o impl\'edcita, na qual o tipo recebido pelo construtor \'e9 convertido em um objeto da classe na qual o construtor est\'e1 definido. A convers\'e3o \'e9 autom\'e1tica e o programador n\'e3o precisa usar um operador de coer\'e7\'e3o. Em algumas situa\'e7\'f5es, convers\'f5es impl\'edcitas s\'e3o indesej\'e1veis ou sujeitas a erros. Por exemplo, nossa classe Array na Fig. 8.4 define um construtor que aceita um \'fanico argumento int. O objetivo deste construtor \'e9 criar um objeto Array contendo o n\'famero de elementos especificado pelo argumento int. Contudo, este construtor pode ser mal-utilizado pelo compilador para executar uma convers\'e3o impl\'edcita. O programa da Fig. 21.10 usa uma vers\'e3o simplificada da classe Array do Cap\'edtulo 8 para demonstrar uma convers\'e3o impl\'edcita impr\'f3pria. \par
II Fig 21.10: array2.h \line 1/ Uma classe Array simples (para inteiros) #ifndef ARRAY2H \line #define ARP.AY2H \par
6 #include <iostream> \par
7 \par
8 using std: :ostream; \par
9 \par
10 class Array \line 11 friend ostream &operator\'ab( ostream &, const Array & ); \line 12 public: \line 13 Array( int = 10 ); II construtor default/de convers\'e3o \line 14 -ArrayO; II destruidor \par
20 \line 21 \line 22 \line 23 \line 24 \line 25 \line 26 \line 27 \line 28 \line 29 \par
\'ab \lquote\\na bitand b: \line\'ab \ldblquote\\na bit_or b: \line\'ab \ldblquote\\n a xor b: \line\'ab \ldblquote\\n compl a: \line\'ab \ldblquote\\na and_eq b: \line\'ab \ldblquote\\n a or_eq b: \line\'ab \ldblquote\\na xor eq b: \line return 0; \par
\'ab ( a bitand b \line\'ab ( a bitor b \line\'ab ( a xor b \line\'ab ( compl a \line\'ab ( a and_eq b \line\'ab ( a or_eq b \line\'ab ( a xor eq b ) \'ab endl; \par
\} \par
a and b: true \line a or b: true not a: false \line a not_eq b: false \line a bitand b: 22 \line a bit or b: 22 a xor b: O \line compl a: -23 a andeq b: 22 a or_eq b: 30 a xor_eq b: 30 \par
1 \line 2 \line 3 \line 4 \line 5 \par
Fig. 21.10 Construtores de um \'fanico argumento e convers\'f5es impl\'edcitas - array2 .h (parte 1 de 2). \par
CAP\'cdTULO 21 - ACR\'c9SCIMOS \'c0 LINGUAGEM PADR\'c3O C ++ 1019 \line 15 private: \line 16 int size; II tamanho do array \line 17 int *ptr; II ponteiro para o primeiro elemento do array \line 18 \line 19 \line 20 #endif \line Fig. 21.10 Construtores de um \'fanico argumento e convers\'f5es impl\'edcitas - array2 .h (parte 2 de 2). \line 21 II Fig 21.10: array2.cpp \line 22 II Defini\'e7\'f5es de fun\'e7\'f5es membro para a classe Array \line 23 #include <iostream> \line 24 \line 25 using std::cout; \line 26 using std::ostream; \line 27 \line 28 #include <cassert> \line 29 #include \ldblquote array2.h\rquote  \line 30 \line 31 II Construtor default para a classe Array (tamanho default 10) \line 32 Array: :Array( int arraySize \line 33 \line 34 size = ( arraySize > O ? arraySize : 10 ); \line 35 cout \'ab Construtor de Array chamado para \line 36 \'ab size \'ab elementos\\n\rdblquote ; \line 37 \line 38 ptr = new int[ size ]; II cria espa\'e7o para array \line 39 assert( ptr != O ); II termina se mem\'f3ria n\'e3o foi alocada \line umeiliu 40 \line strutor\'e9 41 for ( int i = 0; i < size; i++ ) \line 42 ptr[ i ] = 0; // inicializa array \line dornao 43 \} \line ujeitas a 44 \line int.O 45 II Destruidor para a classe Array \line wmento 46 Array: :Array() \{ delete [] ptr; \} \line 47 \line icita., 48 II Operador de sa\'edda sobrecarregado para a classe Array \line nversao 49 ostream &operator\'ab( ostream &output, const Array &a \line 50 \{ \line 51 int i; \line 52 \line 53 for ( i = 0; i < a.size; i++ \line 54 output \'ab a.ptr[ i ) \'ab \line 55 \line 56 return output; II permite usar cout \'ab x \'ab y; \line 57 \} \line Fig. 21.10 Construtores de um \'fanico argumento e convers\'f5es impl\'edcitas - array2 .cpp. \par
Fig. 21.10 Construtores de um \'fanico argumento e convers\'f5es impl\'edcitas - fig2l 10 cpp (parte 1 de 2). \par
\pard\par
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx301\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx5151\pard\intbl 58 \cell // Fig 21.10: fig2l_l0.cpp \cell\row
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx301\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2342\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx5151\pard\intbl 59 \cell II Programa de teste \cell para a classe Array simples \cell\row
\intbl 60 \cell #include <iostream> \cell\cell\row
\intbl 61 \cell\cell\cell\row
\intbl 62 \cell using std::cout; \cell\cell\row
\intbl 63 \cell\cell\cell\row
\pard\par
\pard\sb100\sa240 1020 C++ COMO PROGRAMAR \line 64 #include \ldblquote array2.h\rdblquote  \line 65 \line 66 void outputArray( const Array & ); \line 67 \line 68 int main() \line 69 \line 70 Array integersi ( 7 ); \line 71 \line 72 outputArray( integersi ); II envia Array integersi para a sa\'edda \line 73 \line 74 outputArray( 15 ); II converte 15 para um Array e envia para a sa\'edda \line 75 \line 76 return 0; \line 77 \} \line 78 \line 79 void outputArray( const Array &arrayToOutput \line 80 \line 81 cout \'ab \ldblquote O array recebido cont\'e9m:\\n\rdblquote  \line 82 \'ab arrayToOutput \'ab \ldblquote\\n\\n\rdblquote ; \line 83 \line Construtor de Array chamado para 7 elementos \line O array recebido cont\'e9m: \line 0000000 \line Construtor de Array chamado para 15 elementos \line O array recebido cont\'e9m: \line 000000000000000 \line Fig. 21.10 Construtores de um unico argumento e conversoes imphcitas - fig2l 10. cpp (parte 2 de 2). \line A linha 70 em main \line Array integersi ( 7 ); \line define o objeto integersi do tipo Array e chama o construtor de par\'e2metro \'fanico com o valor int 7 para especificar o n\'famero de elementos no Array. Modificamos o construtor de Array de modo que exiba uma linha de texto indicando que o construtor de Array foi chamado e o n\'famero de elementos que foram alocados ao Array. A linha 72 \line outputArray( integersl ); II envia Array integersi para a sa\'edda \line chama a fun\'e7\'e3o outputArray (definida na linha 79) para exibir o conte\'fado do Array. A fun\'e7\'e3o outputArray recebe como seu argumento um const Array& para o Array e, ent\'e3o, exibe o Array usando o operador de inser\'e7\'e3o em stream \'ab . A linha 74 \line outputArray( 15 ); II converte 15 para um Array e envia para a sa\'edda \line chama a fun\'e7\'e3o outputArray com o valor int 15 como argumento. N\'e3o existe fun\'e7\'e3o outputArray que aceite um int como argumento; assim, o compilador testa a classe Array para verificar se existe um construtor de convers\'e3o que pode converter um int em um Array. Como a classe Array fornece um construtor de convers\'e3o, o compilador usa esse construtor para ciar um objeto Array tempor\'e1rio contendo 15 elementos e passa o objeto Array tempor\'e1rio para a fun\'e7\'e3o outputArray para exibir o Array. A sa\'edda mostra que construtor de convers\'e3o de Array foi chamado para um Array de 15 elementos, bem como o conte\'fado do Array. \line C++ fornece a palavra-chave explicit para suprimir convers\'f5es impl\'edcitas atrav\'e9s de construtores de \line convers\'e3o. Um construtor que \'e9 declarado explicit n\'e3o pode ser usado em convers\'e3o impl\'edcita. O programa da Fig. 21.11 demonstra um contrutor explicit. \par
CAP\'cdTULO 21 - ACR\'c9SCIMOS \'c0 LINGUAGEM PADR\'c3O C ++ 1021 \line 1 II Fig. 21.11: array3.h \line 2 /1 Classe Array simples (para inteiros) \line 3 #ifndef ARRAY3H \line 4 #define ARRAY3H \line 5 \line 6 #include <iostream> \line 7 \line 8 using std::ostream; \line 9 \line sa\'edda 10 class Array \line 11 friend ostream &operator\'ab( ostream &, const Array & ); \line 12 public: \line 13 explicit Array( int = 10 ); // construtor default \line 14 -ArrayO; II destruidor \line 15 private: \line 16 int size; // tamanho do array \line 17 int *ptr; II ponteiro para o primeiro elemento do array \line 18 \line 19 \line 20 #endif \line Fig. 21.11 Demonstrando um construtor explicit - array3 .h. \line 21 II Fig. 21.11: array3.cpp \line 22 II Defini\'e7\'f5es de fun\'e7\'f5es membro para a classe Array \line 23 #include <iostreani> \line 24 \line 25 using std::cout; \line 26 using std::ostream; \line 27 \line 28 #include <cassert> \line 29 #include \ldblquote array3.h\rdblquote  \line 30 \line 31 II Construtor default para a classe Array (tamanho default 10) \line para 32 Array: :Array( int arraySize \line alinha 33 \line ray. 34 size = ( arraySize > O ? arraySize : 10 ); \line 35 cout \'ab Construtor de Array chamado para \line 36 \'ab size \'ab elementos\\n\rdblquote ; \line 37 \line rra 38 ptr = new int[ size ]; II cria espa\'e7o para o array \line dorde 39 assert( ptr = O ); // termina se mem\'f3ria n\'e3o alocada \line 40 \line 41 for ( int i = 0; i < size; i++ \line 42 ptr[ i ] = 0; // inicializa array \line 43 \} \line yque \line itorde 45 // Destruidor para a classe Array \line\lquote ers\'e3o 46 Array: :.-Array() \{ delete [] ptr; \line b \line O O 48 // Operador de sa\'edda sobrecarregado para a classe Array \line versao 49 ostream &operator\'ab( ostream &output, const Array &a \line 50 \{ \line resde 51 int i; \line grama 52 \line Fig. 21.11 Demonstrando um construtor explicit - array3 . cpp (parte 1 de 2). \par
1022 C++ COMO PROGRAMAR \line 53 for ( i O; i < a.size; i++ \line 54 output \'ab a.ptr[ i ] \'ab \line 55 \line 56 return output; II permite usar cout \'ab x \'ab y; \line 57 \} \line Fig. 21.11 Demonstrando um construtor explicit - array3 . cpp (parte 2 de 2). \line 58 II Fig. 21.11: fig2l_1l.cpp \line 59 II Programa de teste para a classe Array simples \line 60 #include <iostream> \line 61 \line 62 using std: :cout; \line 63 \line 64 #include \ldblquote array3.h\rdblquote  \line 65 \line 66 void outputArray( const Array & ); \line 67 \line 68 int main() \line 69 \line 70 Array integersi ( 7 ); \line 71 \line 72 outputArray( mntegersi ); II envia o Array mntegersi para a sa\'edda \line 73 \line 74 II ERRO: constru\'e7\'e3o n\'e3o permitida \line 75 outputArray( 15 ); II converte 15 para um Array e envia para a sa\'edda \line 76 \line 77 outputArray( Array( 15 ) ); II realmente quer fazer isto! \line 78 \line 79 return 0; \line 80 \line 81 \line 82 void outputArray( const Array &arrayToOutput \line 83 \line 84 cout \'ab O array recebido cont\'e9m:\\n\rdblquote  \line 85 \'ab arrayToOutput \'ab \ldblquote\\n\\n\rquote ; \line 86 \line Mensagem de erro do compilador Borland C++ de linha de comando \line Fig2 1_li. cpp: \line Error E2064 Fig2l l1.cpp 18: Cannot initialize \lquote const Array &\lquote  \line wjth \lquote int\rquote  in function main() \line Error E2340 Fig2l l1.cpp 18: Type mismatch in parameter 1 (wanted \line const Array &\lquote , got \lquote int\rquote ) in function main() \line 2 errors in Compile *** \line Mensagem de erro do compilador Microsofi Visual C+ + \line Compiling... \line Fig2lll . cpp \line Fig2l_11.cpp(18) : error C2664: \lquote outputArray\rquote  : cannot convert \line parameter 1 from \lquote const int\rquote  to \lquote const class Array & \line Reason: cannot convert from const int to \lquote const class Array\rquote  No construtor could take the source type, or construtor overload resolution was ambiguous \line Fig. 21.11 Demonstrando um construtor explicit - fig2l 11 . cpp. \par
CAP\'cdTULO 21 - ACR\'c9SCIMOS \'c0 LINGUAGEM PADR\'c3O C ++ 1023 \line A \'fanica modifica\'e7\'e3o em rela\'e7\'e3o ao programa da Fig. 21.10 foi a adi\'e7\'e3o da palavra-chave explicit na declara\'e7\'e3o do construtor de par\'e2metro \'fanico na linha 13. Quando o programa \'e9 compilado, o compilador produz uma mensagem de erro indicando que o valor inteiro passado para outputArray na linha 75 n\'e3o pode ser convertido para um const Array&. A mensagem de erro do compilador \'e9 mostrada na janela de sa\'edda. A linha 77 ilustra como criar um Array de 15 elementos e pass\'e1-lo para outputArray usando o construtor explicit. \line Erro com um de programa\'e7\'e3o 21.4 \line Tentar invocar um construtor explicit para uma convers\'e3o impl\'edcita \'e9 um erro de sintaxe. \line IErro comum de programa\'e7\'e3o 21.5 \line Usar a palavra-chave explicit em membros de dados ou fun\'e7\'f5es membro outras que n\'e3o um construtor de par\'e2metro \'fanico \'e9 m erro de sinta.e. \line Observa\'e7\'e3o de engenharia de soflware 21.5 \line ______ Use a palavra-chave explicit em construtores que n\'e3o deveriam ser usados pelo compilador para efetuar convers\'f5es impl\'edcitas. \line 21.10 Membros de classe mutable \line\'edda \line Na Se\'e7\'e3o 21.4, introduzimos o operador const_cast que permitiu retirar o atributo const. C++ fornece o \line la\'edda especificador de classe de armazenamento mutable como alternativa a const cast. Um membro de dados mutable \'e9 sempre modific\'e1vel, mesmo em uma fun\'e7\'e3o membro const ou em um objeto const. Isso reduz a necessidade de retirar o atributo const. \line Dica de portabilidade 21.2 \line ______ O efeito de tentar modificar um objeto que foi definido como constante, independente do fato de aquela modifica\'e7\'e3o ter sido possibilitada por um const cast ou por uma coer\'e7\'e3o no estilo de C, varia de \line compilador para compiladoic \line Tanto mutable como const cast permitem que um membro de dados seja modificado; cada um \'e9 usado em um contexto diferente. Para um objeto const sem membros de dados mutable, o operador const_cast deve ser usado toda vez que um membro de dados deve ser modificado. Isto reduz enormemente a possibilidade de que um membro de dados seja modificado acidentalmente, porque o membro de dados n\'e3o \'e9 modific\'e1vel permanente- mente. Opera\'e7\'f5es envolvendo const cast s\'e3o tipicamente ocultadas na implementa\'e7\'e3o de uma fun\'e7\'e3o membro. O usu\'e1rio de uma classe pode n\'e3o estar ciente de que um membro est\'e1 sendo modificado. \line\ul Observa\'e7\'e3o de engenharia de software 21.6 \ulnone\line ______ Membros mutable s\'e3o \'fateis em classes que t\'eam detalhes de implementa\'e7\'e3o \ldblquote secretos\rdblquote  que n\'e3o contribuem para o valor l\'f3gico de um objeto. \line O programa da Fig. 21.12 demonstra o uso de um objeto mutable. O programa define a classe TestNutable (linha 8) que cont\'e9m um construtor, duas fun\'e7\'f5es e o membro de dados value que \'e9 private mutable. A linha 11 \line void modifyValue() const \{ value++; \} \line define a fun\'e7\'e3o modifyValue como uma fun\'e7\'e3o const que incrementa o membro de dados mutable. va- lue. Normalmente, uma fun\'e7\'e3o membro const n\'e3o pode modificar membros de dados, a menos que o objeto sobre o qual a fun\'e7\'e3o opera - aquele para o qual this aponta - seja convertido (usando const_cast) para um \par
1024 C++ COMO PROGRAMAR \line tipo n\'e3o cons t. Como value \'e9 mutable, esta fun\'e7\'e3o cons t \'e9 capaz de modificar os dados. A fun\'e7\'e3o getValue (linha 12) \'e9 uma fun\'e7\'e3o const que retorna value. Note que getValue poderia mudar value, porque value \'e9mutable. \line 1 II Fig. 21.12: fig2l_12.cpp \line 2 // Demonstrando o especificador de classe de armazenamento mutable. \line 3 #include <iostream> \line 4 \line 5 using std::cout; \line 6 using std: :endl; \line 7 \line 8 class TestMutable \{ \line 9 public: \line 10 TestMutable( int v = O ) \{ value = v; ) \line 11 void modifyValue() const \{ value++; \} \line 12 int getValue() const \{ return value; \line 13 private: \line 14 mutable int value; \line 15 \line 16 \line 17 int main() \line 18 \line 19 const TestMutable t( 99 ); \line 20 \line 21 cout \'ab \ldblquote Valor inicial: \ldblquote  \'ab t.getValueO; \line 22 \line 23 t.modifyValueQ; II modifica o membro mutable \line 24 cout \'ab \ldblquote\\nValor modificado: \ldblquote  \'ab t.getValue() \'ab endl; \line 25 \line 26 return 0; \line 27 \} \line Valor inicial: 99 \line Valor modificado: 100 \line Fig. 21.12 Demonstrando um membro de dados mutable. \line A linha 19 declara o objeto t como const TestMutable e o inicializa com 99. A linha 21 exibe o conte\'fado de \line value. A linha 23 chama a fun\'e7\'e3o membro const modifyValue para adicionar um a value. Note que, tanto \line t como modifyValue, s\'e3o const. A linha 24 exibe o conte\'fado de value (100) para provar que o membro \line mutable foi de fato modificado. \line 21.11 Ponteiros para membros de classe (.* e _>*) \line C++ fornece os operadores . * e _>* para acessar membros de classes. Ponteiros para membros de classe n\'e3o s\'e3o \line o mesmo tipo de ponteiros que discutimos anteriormente. Tentar usar o operador -> ou o operador * com um \line ponteiro para membro gera erros de sintaxe. O programa da Fig. 2 1.12 demonstra os operadores ponteiros para \line membros de classe. \line Erro comum de programa\'e7\'e3o 21.6 \line Tentar usar o operador -> ou o operador * com um ponteiro para membro de classe \'e9 erro de sintaxe. \par
CAP\'cdTULO 21 - ACR\'c9SCIMOS \'c0 LINGUAGEM PADR\'c3O C ++ 1025 \line e 1 II Fig. 21.13 fig2ll3.cpp \line e 2 // Demonstrando os operadores . e -> \line 3 #i-nclude <iostream> \line 4 \line 5 using std::cout; \line 6 using std: :endl; \line 7 \line 8 class Test \{ \line 9 public: \line 10 void function() \{ cout \'ab \ldblquote fun\'e7\'e3o\\n; \line 11 int value; \line 12 \line 13 \line 14 void arrowStar( Test * \line 15 void dotStar( Test * ); \line 16 \line 17 int main() \line 18 \line 19 Test t; \line 20 \line 21 t.value = 8; \line 22 arrowStar( &t ); \line 23 dotStar( &t ); \line 24 return 0; \line 25 \} \line 26 \line 27 void arrowStar( Test *tptr \line 28 \line 29 void ( Test: :*memPtr ) O = &Test: :function; \line 30 ( tptr_>*memPtr ) Q; // invoca a fun\'e7\'e3o indiretamente \line 31 \} \line 32 \line 33 void dotStar( Test *tptr \line 34 \line 35 int Test: :*vPtr = &Test: :value; \line 36 cout \'ab ( ) .*vptr \'ab endl; II accessa o valor \line 37 \} \par
fun\'e7\'e3o \line 8 \par
e Fig. 21.13 Demonstrando os operadores . * e _>*. \line O programa declara a classe Test que fornece a fun\'e7\'e3o membro public function e o membro de dados \line p\'fablico value. A fun\'e7\'e3o function exibe a palavra \ldblquote function\rdblquote . As linhas 14 e 15 apresentam os prot\'f3tipos \line das fun\'e7\'f5es arrowS tar e dotS tar. Nas linhas 19 a 21,0 objeto t \'e9 instanciado e o membro de dados value de \line t \'e9 definido como 8. As linhas 22 e 23 chamam as fun\'e7\'f5es arrowStar e dotStar; cada chamada passa o \line endere\'e7o de t. \line A linha 29 \line void ( Test: :*memptr ) () = &Test: :function; \line na fun\'e7\'e3o arrowS tar declara e inicializa memPtr como um ponteiro para um membro da classe Tes t que \'e9 uma fun\'e7\'e3o com uni resultado void e sem par\'e2metros. Come\'e7amos examinando o lado esquerdo da atribui\'e7\'e3o. Primeiro, void \'e9 o tipo de retorno da fun\'e7\'e3o membro. Os par\'eanteses vazios indicam que esta fun\'e7\'e3o membro n\'e3o recebe argumentos. Os par\'eanteses do meio especificam um ponteiro memPtr que aponta para um membro da classe Test. Os par\'eanteses em torno de Test: : memPtr s\'e3o necess\'e1rios. Note que, se Test: : n\'e3o for especificado, memPtr \'e9 um ponteiro para fun\'e7\'e3o padr\'e3o. Em seguida, examinaremos o lado direito da atribui\'e7\'e3o. \par
1026 C++ COMO PROGRAMAR \line Erro comum de programa\'e7\'e3o 21.7 \line Declarar um ponteiro de fun\'e7\'e3o membro sem colocar o nome do ponteiro entre par\'eanteses \'e9 um erro de sintaxe. \line Erro comum de programa\'e7\'e3o 21.8 \line Declarar um ponteiro de fun\'e7\'e3o membro sem preceder o nome do ponteiro por um nome de classe seguido pelo operador de resolu\'e7\'e3o de escopo (: :) \'e9 um erro de sintaxe. \line O lado direito da atribui\'e7\'e3o usa o operador endere\'e7o (&) para obter o deslocamento dentro da classe para a fun\'e7\'e3o membro function (que deve retomar void e n\'e3o aceita argumentos). O ponteiro memPtr \'e9 inicializado com este deslocamento. Note que tanto o lado esquerdo como o lado direito da atribui\'e7\'e3o na linha 29 n\'e3o se referem a nenhum objeto espec\'edfico. Somente o nome da classe \'e9 usado com o operador bin\'e1rio de resolu\'e7\'e3o de escopo (: :). Sem &Test: :, o lado direito da atribui\'e7\'e3o na linha 29 \'e9 um ponteiro de fun\'e7\'e3o padr\'e3o. A linha 30 \line tPtr_>*memPtr ) o; // invoca a fun\'e7\'e3o indiretamente \line invoca o nome da fun\'e7\'e3o membro armazenado em memPtr (i.e., function) usando o operador ->. A linha 35 int Test: :*vPtr = &Test: :value; \line declara e inicializa vPtr como um ponteiro para um membro de dados int da classe Test. O lado esquerdo da atribui\'e7\'e3o especifica o nome do membro de dados value. Note que sem Test: :. Ptr se torna um ponteiro int \line * para o endere\'e7o de int va].ue. \line A pr\'f3xima linha \line cout \'ab ( *jp ) .*vPtr \'ab endl; // accessa o valor \line usa o operador . * para acessar o membro cujo nome est\'e1 em vPtr. Note que em um c\'f3digo cliente podemos usar somente operadores ponteiros para membro nos membros que sejam acess\'e1veis naquele escopo. Neste exemplo, tanto \line value como function s\'e3o public. Em uma fun\'e7\'e3o membro da classe, todos os membros da classe s\'e3o acess\'e1veis. \line Erro comum de programa\'e7\'e3o 21.9 \line Colocar espa\'e7o(s) entre os caracteres de . * ou >* \'e9 um erro de sintaxe. \line Erro comum de programa\'e7\'e3o 21.10 \line Inverter a ordem dos s\'edmbolos em . * ou -> \'e9 um erro de sintaxe. \line 21.12 Heran\'e7a m\'faltipla e classes base virtual \line No Cap\'edtulo 9, discutimos a heran\'e7a m\'faltipla, o processo pelo qual uma classe herda de duas ou mais classes. A heran\'e7a m\'faltipla \'e9 usada, por exemplo, na biblioteca padr\'e3o de C++ para formar a classe iostream (Fig. 2 1.14). \line A classe ios \'e9 a classe base tanto de ostream como de istream. cada uma das quais \'e9 formada por heran\'e7a simples. A classe iostream herda tanto de ostream como istream. Isto possibilita a objetos de iostream oferecer tanto a funcionalidade de istream como a de ostream. Em hierarquias de heran\'e7a m\'faltipla, a situa\'e7\'e3o descrita na Fig. 2 1.14 \'e9 chamada de heran\'e7a losango (diamond). \line jos \line istream ostream \line iostream \line Fig. 21.14 Heran\'e7a m\'faltipla para formar a classe iostream. \par
CAP\'cdTULO 21 - ACR\'c9SCIMOS \'c0 LINGUAGEM PADR\'c3O C ++ 1027 \line Como as classes ostream e istream herdam de ios, existe um problema potencial para iostreain. A classe \line - iostream poderia conter objetos da superclasse duplicados (por exemplo, ios \'e9 herdado tanto por ostream v de como por istreain). Poderia acontecer um problema quando um ponteiro de iostream \'e9 convertido para um \line ponteiro de ios. Poderiam existir dois objetos ios. Qual, ent\'e3o, seria usado? Tal situa\'e7\'e3o seria amb\'edgua e resultaria em um erro de sintaxe. A Fig. 2 1.15 demonstra este tipo de ambig\'fcidade, mas atrav\'e9s de convers\'e3o impl\'edcita e \line - n\'e3o de convers\'e3o do ponteiro para a classe de cima; naturalmente, na realidade iostreaxn n\'e3o sofre do problema uido que mencionamos. Nesta se\'e7\'e3o, explicaremos como o uso de classes base virtual resolve o problema de sub- \line objetos duplicados. \line n\'e7\'e3o \ul Dica de desempenho 21.1 \ulnone\line com -k . \line Subobjetos duplicados consomem memo ria. \line em a \line 1 // Fig. 21.15: fig2ll5.cpp \line 2 II Tentando chamar polimorficamente uma fun\'e7\'e3o \line 3 II herdada de duas classes base por heran\'e7a m\'faltipla. \line a35 4 #include <iostream> \line 5 \line 6 using std: :cout; \line 7 using std::endl; \line joda 8 \line int 9 class Base \line 10 public: \line 11 virtual void print() const = 0; II virtual pura \line 12 \line 13 \line US 14 class DerivedOne : public Base \line 15 public: \line 16 1/ sobrescreve a fun\'e7\'e3o de impress\'e3o \line aveis. 17 void print() const \{ cout \'ab \lquote DerivedOne\\n\rquote ; \} \line 18 \line 19 \line 20 class DerivedTwo : public Base \line 21 public: \line 22 // sobrescreve a fun\'e7\'e3o de impress\'e3o \line 23 void print() const \{ cout \'ab \ldblquote DerivedTwo\\n\rdblquote ; \line 24 \}; \line 25 \line 26 class Multiple : public DerivedOne, public DerivedTwo \line 27 public: \line 28 II qualifica qual a vers\'e3o da fun\'e7\'e3o de impress\'e3o \line ,es.A 29 void print() const \{ DerivedTwo::print \line 1.14). \line a por 32 int main() \line osde 33 \{ \line iiulti- 34 Multiple both; II instancia objeto Multiple \line 35 DerivedOne one; 1/ instancia objeto DerivedOne \line 36 DerivedTwo two; II instancia objeto DerivedTwo \line 37 \line 38 Base *array[ 3 ]; \line 39 array[ O ) = &both; // ERRO - amb\'edguo \line 40 array[ 1 ) = &one; \line 41 array[ 2 ) = &two; \line 42 \line Fig. 21.15 Tentando chamar polimorficamente uma fun\'e7\'e3o herdada de multiplica\'e7\'e3o (parte 1 de 2). \par
1028 C++ COMO PROGRAMAR \line 43 // invoca fun\'e7\'e3o de impress\'e3o polimorficamente \line 44 for ( int k = 0; k < 3; k++ \line 45 array[ k 3 -> printO; \line 46 \line 47 return 0; \line 48 \line Mensagem de erro do compilador Borland C++ com linha de comando \line Borland C++ 5.5 for Win32 Copyright (c) 1993, 2000 Borland \line Fig2l_15 . cpp: \line Error E2034 Fig2l_15.cpp 39: Cannot convert \lquote Multiple *\lquote  to Base *\lquote  in function main() \line 1 errors in Compile *** \line Mensagem de erro do compilador Microsofi Visual C+ + \line Compiling... \line Fig2l_15 . cpp \line Fig2l_15.cpp(39) : error C2594: \lquote =\lquote  : anbiguous conversions from \line\lquote class Multiple *\lquote  to \lquote class Base *\lquote  \line Fig. 21.15 Tentando chamar polimorticamente uma fun\'e7\'e3o herdada de multiplica\'e7\'e3o (parte 2 de 2). \line O programa define a classe Base que cont\'e9m a fun\'e7\'e3o virtual print. As classes DerivedOne e Derive- dTwo herdam publicamente de Base e sobrescrevem print. A classe DerivedOne e a classe DerivedTwo cont\'e9m cada uma um subobjeto Base. \line A classe Multiple herda de DerivedOne e DerivedTwo. A fun\'e7\'e3o print \'e9 sobrescrita para chamar a print de DerivedTwo. Note a qualifica\'e7\'e3o para especificar a vers\'e3o correspondente a qual sub objeto chamar. \line Em main. \'e9 criado um objeto de cada classe da hierarquia. Um array de ponteiros Base * tamb\'e9m \'e9 declarado. Cada elemento do array \'e9 inicializado com o endere\'e7o de um objeto. Ocorre um erro quando o endere\'e7o de both (que \'e9 do tipo herdado multiplamente Multiple) \'e9 implicitamente convertido para Base . O objeto both cont\'e9m subobjetos herdados multiplamente de Base e isto, naturalmente, torna as chamadas a print amb\'edguas. Um la\'e7o for \'e9 escrito para chamar polimorficamente print para cada um dos objetos apontados por array. \line O problema dos objetos duplicados \'e9 resolvido com a heran\'e7a virtual. Quando uma classe base \'e9 herda- da como virtual, somente um subobjeto aparecer\'e1 na classe derivada - um processo chamado de heran\'e7a de uma classe base virtual. O programa na Fig. 21.16 revisa o programa da Fig. 21.15 para usar uma classe base virtual. \line A classe Base \'e9 definida e cont\'e9m a fun\'e7\'e3o virtual pura print. A classe DerivedOne herda de Base 41 com a linha \line class DerivedOne : virtual public Base \line e a classe DerivedTwo herda de Base com a linha \line class DerivedTwo : virtual public Base \line 1 II Fig. 21.16: fig2l_16.cpp \line 2 // Usando classes base virtuais. \line 3 #include <iostream> \line 4 \line 5 using std::cout; \line 6 using std: :endl; \line Fig. 21.16 Usando classes base virtual (parte 1 de 2). \par
CAP\'cdTULO 21 - ACR\'c9SCIMOS \'c0 LINGUAGEM PADR\'c3O C ++ 1029 \line 7 \line 8 class Base \line 9 public: \line 10 II construtor default impl\'edcito \line 11 \line 12 virtual void print() const = 0; II virtual pura \line 13 \}; \line 14 \line 15 class DerivedOne : virtual public Base \line 16 public: \line 17 II construtor default impl\'edcito \line 18 // chama o construtor default base \line 19 \line 20 // sobrescreve a fun\'e7\'e3o de impress\'e3o \line 21 void print() const \{ cout \'ab DerivedOne\\n\rdblquote ; \line 22 \line 23 \line 24 class DerivedTwo virtual public Base \line 25 public: \line 26 II construtor default impl\'edcito \line 27 // chama o construtor default base \line 28 \line 29 // sobrescreve a fun\'e7\'e3o de impress\'e3o \line 30 void print() const \{ cout \'ab \lquote DerivedTwo\\n; \line 31 \line 32 \line 33 class Multiple public DerivedOne, public DerivedTwo \line 34 public: \line 35 II construtor default impl\'edcito chama \line 36 // os construtores default de DerivedOne e DerivedTwo \line 37 \line 38 II qualifica qual a vers\'e3o da fun\'e7\'e3o de impress\'e3o \line 39 void print() const ( DerivedTwo: :printO; \line 40 \line 41 \line 42 int main() \line 43 \line 44 Multiple both; II instancia objeto Multiple \line 45 DerivedOne one; II instancia objeto DerivedOne \line 46 DerivedTwo two; II instancia objeto DerivedTwo \line 47 \line 48 Base *array[ 3 ]; \line 49 array[ O 1 = &both; \line 50 array[ 1 1 = &one; \line 51 array[ 2 1 = &two; \line 52 \line 53 II invoca a fun\'e7\'e3o de impress\'e3o polimorficamente \line 54 for ( int k 0; k < 3; k++ \line 55 array[ k 1 -> printi); \line 56 \line 57 return 0; \line 58 \} \line DerivedTwo \line DerivedOne \line DerivedTwo \line Fig. 21.16 Usando classes base virtual (parte 2 de 2). \par
1030 C++ COMO PROGRAMAR \line Ambas as classes herdam de Base - cada uma cont\'e9m um subobjeto de Base. A classe Multiple herda tanto DerivedOne como de DerivedTwo. Somente um subobjeto de Base \'e9 herdado pela classe Multiple. compilador agora permite que ocorra a convers\'e3o (Multiple * para Base *). Em main. um objeto \'e9 criado p cada classe na hierarquia. Tamb\'e9m \'e9 declarado um array de ponteiros para Base. Cada elemento do arra inicializado com o endere\'e7o de um objeto. Note que a convers\'e3o (upcast) do endere\'e7o de both para Base * ag \'e9 permitida. Um la\'e7o for percorre array e chama print polimorficamente para cada objeto. \line Projetar hierarquias com classes base virtual \'e9 simples se s\'e3o usados os construtores default para classes base. Os dois exemplos anteriores usam construtores default gerados pelo compilador. Se uma classe b virtual fornece um construtor, o projeto se torna mais complicado porque a classe mais derivada deve iniciali a classe base virtual. \line Em nossos dois exemplos, Base. DerivedOne, DerivedTwo e Multiple s\'e3o, cada uma, as clas mais derivadas. Se estivermos criando um objeto de Base, Base \'e9 a classe mais derivada. Se estivermos crian um objeto de DerivedOne (ou de DerivedTwo). DerivedOne (ou DerivedTwo) \'e9 a classe mais deriva Se estivermos criando um objeto de Multiple. Multiple \'e9 a classe mais derivada. N\'e3o importa qu\'e3o abaixo hierarquia uma classe esteja, ela \'e9, portanto, a classe mais derivada e a respons\'e1vel pela inicializa\'e7\'e3o da classe b virtual. No Exerc\'edcio 21.17, solicitamos que leitor treine o conceito de classe mais derivada. \line Observa\'e7\'e3o de engenharia de software 21.7 \line ______ Fornecer um construtor default para classes bases virtual simplifica o projeto da hierarquia. \line 21.13 Observa\'e7\'f5es finais \line Sinceramente, esperamos que voc\'ea tenha apreciado apreender C++ e programa\'e7\'e3o orientada a objetos neste cur O futuro parece claro. Desejamos-lhe sucesso para alcan\'e7\'e1-lo. \line Apreciar\'edamos muito seus coment\'e1rios, cr\'edticas, corre\'e7\'f5es e sugest\'f5es para melhorar o texto. Por favor, dir \line toda sua correspond\'eancia para nosso e-mau: \line deitel@deitel . com \line Boa sorte! \line Resumo \line\bullet  C++ padr\'e3o fornece o tipo de dados bool (com valores false ou true) como uma alternativa preferida ao velho estilo usar 0 para indicar falso e um valor diferente de zero para indicar verdadeiro. \line\bullet  O \ldblquote manipulador de stn\rquote am boolalpha prepara o arcam de sa\'edda para exibir valores bool como os strings \ldblquote true false. \line\bullet  C++ padr\'e3o introduz quatro novos operadores de coer\'e7\'e3o para serem usados preferencialmente em vez do velho estilo coer\'e7\'e3o de C e C++. \line\bullet  C++ fornece o operador static cast para convers\'e3o entre tipos. A verifica\'e7\'e3o de tipo \'e9 efetuada durante a compila\'e7 \line\bullet  O operador const_cast retira o atributo const dos objetos. \line\bullet  O operador reiriterpret cast \'e9 fornecido para coer\'e7\'f5es n\'e3o-padr\'e3o entre tipos n\'e3o-relacionados. \line\bullet  Cada namespace define um escopo onde s\'e3o colocados identificadores e vari\'e1veis. Para usar um membro de um name pace. o nome do membro deve ser qualificado com o nome do namespace e o operador bin\'e1rio de resolu\'e7\'e3o de esco \line (: :) ou um comando using deve ocorrer antes de o nome ser usado. \line\bullet  Um nainespace pode conter constantes, dados, classes, namespaces aninhados, fun\'e7\'f5es, etc. As defini\'e7\'f5es de name paces devem ocupar o escopo global ou estar aninhadas dentro de outros nainespaces. \line\bullet  Membros de um naxnespace n\'e3o-nomeado ocupam o nainespace global. \par
CAP\'cdTULO 21 - ACR\'c9SCIMOS \'c0 LINGUAGEM PADR\'c3O C ++ 1031 \line\bullet  A informa\'e7\'e3o sobre tipos durante a execu\'e7\'e3o (RTTI) fornece um meio de determinar o tipo de um objeto durante a execu\'e7\'e3o. \line\bullet  O operador typeid \'e9 usado durante a compila\'e7\'e3o para retomar uma refer\'eancia para um objeto typeinfo. Um objeto typeinfo \'e9 um objeto mantido pelo sistema que representa um tipo. \line\bullet  O operador dynamic cast assegura que as convers\'f5es apropriadas ocorram durante a execu\'e7\'e3o. O resultado de um dynamiccast para opera\'e7\'f5es de coer\'e7\'e3o inv\'e1lidas \'e9 O. \line\bullet  C++ padr\'e3o fornece palavras-chave operadores que podem ser usadas no lugar de v\'e1rios operadores de C++. \line\bullet  C++ fornece a palavra-chave explicit para suprimir convers\'f5es impl\'edcitas feitas atrav\'e9s de construtores de convers\'e3o. Um construtor que \'e9 declarado explicit n\'e3o pode ser usado em uma convers\'e3o impl\'edcita. \line\bullet  Um membro de dados mutable \'e9 sempre modific\'e1vel, mesmo em uma fun\'e7\'e3o membro const ou um objeto const. \line\bullet  C++ fornece os operadores * e -> para acessar membros de classes atrav\'e9s de ponteiros para aqueles membros. \line\bullet  A heran\'e7a m\'faltipla pode criar sub objetos duplicados que podem ser resolvidos com heran\'e7a virtual. Quando uma clase base \'e9 herdada como virtual, somente um subobjeto aparecer\'e1 na classe derivada-um processo chamado de heran\'e7a de classe base virtual. \line Terminologia \line * nainespace aninhado \line <typeinfo> namespace an\'f4nimo \line _>* namespace global \line and not \line and_eq not_eq \line bitand operador ponteiro para membro de classe \line bitor or \line bool oreq \line boolalpha palavras-chave operadores \line classe base virtual ponteiro para fun\'e7\'e3o membro \line classe mais derivada ponteiro para membro de dados \line compl reinterpretcast \line constcast RTTI (run-time lype information) \line convers\'e3o expl\'edcita staticcast \line convers\'e3o impl\'edcita sub objeto \line downcast (convers\'e3o para tipo inferior na hierarquia) true \line dynamic_cast typeinfo \line explicit typeinfo . h \line false typeid \line heran\'e7a losango USing \line informa\'e7\'e3o sobre o tipo vari\'e1veis globais \line mutable virtual \line name xor \line namespace xoreq \line Erros comuns de programa\'e7\'e3o \line 21.1 Executar uma coer\'e7\'e3o ilegal como operador static cast \'e9 um erro de sintaxe. Coer\'e7\'f5es ilegais incluem fazer uma convers\'e3o de tipos const para tipos n\'e3o-const. fazer coer\'e7\'e3o de ponteiros e refer\'eancias entre tipos que n\'e3o s\'e3o relacionados por heran\'e7a public e fazer coer\'e7\'e3o para um tipo para o qual n\'e3o h\'e1 um construtor ou operador de convers\'e3o apropriado para executar a convers\'e3o. \line 21.2 Colocar main em um namespace \'e9 um erro de sintaxe. \line 21.3 Tentar usar dynamic cast sobre um ponteiro do tipo void * \'e9 um erro de sintaxe. \line 21.4 Tentar invocar um construtor explicit para uma convers\'e3o impl\'edcita \'e9 um erro de sintaxe. \line 21.5 Usar a palavra-chave explicit em membros de dados ou fun\'e7\'f5es membro outras que n\'e3o um construtor de par\'e2metro \'fanico \'e9 um erro de sintaxe. \line 21.6 Tentar usar o operador -> ou o operador * com um ponteiro para membro de classe \'e9 erro de sintaxe. \line 21.7 Declarar um ponteiro de fun\'e7\'e3o membro sem colocar o nome do ponteiro entre par\'eanteses \'e9 um erro de sintaxe. \par
1032 C++ COMO PROGRAMAR \line 21.8 Declarar um ponteiro de fun\'e7\'e3o membro sem preceder o nome do ponteiro por um nome de classe seguido pelo operador de resolu\'e7\'e3o de escopo (: :) \'e9 um erro de sintaxe. \line 21.9 Colocar espa\'e7o(s) entre os caracteres de . * ou >\lquote  \'e9 um erro de sintaxe. \line 21.10 Inverter a ordem dos s\'edmbolos em * ou ->\lquote  \'e9 um erro de sintaxe. \line Boas pr\'e1ticas de programa\'e7\'e3o \line 21.1 Quando criar vari\'e1veis de estado para indicar verdade ou falsidade, d\'ea prefer\'eancia ao uso de bools em vez de ints. \line 21.2 Usar true e false em lugar de valores zero e diferentes de zero toma os programas mais claros. \line 21.3 Use o operador static cast, mais seguro e confi\'e1vel, em prefer\'eancia ao operador de coer\'e7\'e3o no estilo de C. \line 21.4 Evite come\'e7ar identificadores com o caractere sublinhado, o que pode levar a erros de liga\'e7\'e3o. \line 21.5 Preceda um membro pelo nome do seu namespace eu operador de resolu\'e7\'e3o de escopo (: :) se existe possibilidade de um conflito de escopo. \line 21.6 Usar typeid em testes do tipo switch \'e9 um mau uso de RTTI. Em vez disso, use fun\'e7\'f5es virtual. \line Dica de desempenho \line 21.1 Subobjetos duplicados consumem mem\'f3ria. \line Dicas de portabilidade \line 21.1 Usar reinterpret_cast pode fazer com que os programas se comportem de modo diferente em diferentes plataformas. \line 21.2 O efeito de tentar modificar um objeto que foi definido como constante, independente do fato de aquela modifica\'e7\'e3o ter sido possibilitada por um const_cast ou por uma coer\'e7\'e3o no estilo de C, varia de compilador para compilador. \line Observa\'e7\'f5es de engenharia de software \line 21.1 Com os acr\'e9scimos dos novos operadores de coer\'e7\'e3o (p.ex.. static cast) ao C++ padr\'e3o, os operadores de coer\'e7\'e3o no estilo antigo (estilo de C) s\'e3o considerados obsoletos. \line 21.2 Cada unidade de compila\'e7\'e3o separada tem seu pr\'f3prio e \'fanico namespace n\'e3o-nomeado, ou seja, o namespace n\'e3o- nomeado substitui o especificador de liga\'e7\'e3o static. \line 21.3 Em programas grandes, idealmente cada entidade deve ser declarada em uma classe, fun\'e7\'e3o, bloco ou namespace. Isto ajuda a deixar claro o papel de cada entidade. \line 21.4 RTII foi concebido para ser usado com hierarquias de heran\'e7a polim\'f3rficas (com fun\'e7\'f5es virtual). \line 21.5 Use a palavra-chave explicit em construtores que n\'e3o deveriam ser usados pelo compilador para efetuar convers\'f5es impl\'edcitas. \line 21.6 Membros mutable s\'e3o \'fateis em classes que t\'eam detalhes de implementa\'e7\'e3o \ldblquote secretos\rdblquote  que n\'e3o contribuem para o valor l\'f3gico de um objeto. \line 21.7 Fornecer um construtor default para classes bases virtual simplifica o projeto da hierarquia. \line Dicas de teste e depura \'e7\'e3o \line 21.1 \'c9 f\'e1cil usar reinterpret cast para executar manipula\'e7\'f5es perigosas que podem levar a s\'e9rios erros durante a execu\'e7\'e3o. \line 21.2 De modo a poder usar RTTI. alguns compiladores requerem que os recursos de RTTI sejam habilitados. Verifique a documenta\'e7\'e3o do seu compilador sobre o uso de RTTI. \line Exerc\'edcios de auto-revis\'e3o \line 21.1 Preencha os espa\'e7os em branco de cada um dos seguintes: \line a) O operador qualifica um membro com seu namespace. \par
CAP\'cdTULO 21 - ACR\'c9SCIMOS \'c0 LINGUAGEM PADR\'c3O C ++ 1033 \line operador b) O operador permite que o atributo const de um objeto seja retirado. \line c) O operador permite a convers\'e3o entre tipos. \line 21.2 Diga qual das seguintes frases \'e9 verdadeira ou falsa. Se uma afirma\'e7\'e3o \'e9falsa, explique por qu\'ea. \line a) namespaces s\'e3o garantidos como sendo \'fanicos. \line h) namespaces n\'e3o podem ter namespaces como membros. \line c) O tipo de dados bool \'e9 um tipo de dados primitivo. \line e ints. Respostas aos exerc\'edcios de auto-revis\'e3o \line 21.1 a) resolu\'e7\'e3o de escopo bin\'e1rio (: :). \line ilidade de b) constcast. \line c) estilo de C. dynamic cast, static cast ou reinterpretcast. \line 21.2 a) Falsa. Um programador pode inadvertidamente escolher o mesmo namespace como um outro. \line b) Falsa. namespaces podem ser aninhados. \line c) Verdadeira. \line Exerc\'edcios \line 21.3 Preencha os espa\'e7os em branco em cada um dos seguintes itens. \line a) O operador _______________ \'e9 usado para determinar o tipo de um objeto em tempo de execu\'e7\'e3o. \line b) A palavra-chave especifica que um namespace ou um membro de um namespace est\'e1 sendo \line splatafor- usado. \line c) O operador _______________ \'e9 a palavra-chave operador para OU l\'f3gico. \line ica\'e7\'e3o ter d) O especificador de armazemamento _____________ permite que um membro de um objeto const seja modificado. ador. \line 21.4 Diga qual das seguintes frases s\'e3o verdadeiras e quais s\'e3o falsas. Se uma afirma\'e7\'e3o \'e9falsa, explique por qu\'ea. \line a) A validade de uma opera\'e7\'e3o static_cast \'e9 verificada durante a compila\'e7\'e3o. \line b) A validade de uma opera\'e7\'e3o dynamic cast \'e9 verificada durante a execu\'e7\'e3o. \line e) O nome typeid \'e9 uma palavra-chave. \line le coer\'e7\'e3o d) A palavra-chave explicit pode ser aplicada a construtores, fun\'e7\'f5es membro e membros de dados. \line - 21.5 Qual o valor de cada express\'e3o? (Nota: algumas express\'f5es podem gerar erros; se esse for caso, diga qual \'e9 a causa do erro). \line iacenao- a) cout \'ab false; \line b) cout \'ab ( bool b 8 ); \line >ace. Isto e) cout \'ab ( a = true ); // a \'e9 do tipo int \line d) cout \'ab ( *ptr + true && p ); II *ptr \'e9 10 e p \'e9 8.88 \line - e) // *ptr \'e9 O e m \'e9 false \line onversoes boolk (*ptr*2 1 (true+24) ); \line f) bool s = true + false; \line iraovalor g) cout \'ab boolalpha \'ab false \'ab setw(3) \'ab true; \line 21.6 Escreva um namespace Moeda que defina os membros constantes Um, Dois, Cinco, Dez, Vinte, Cinquenta e Cem. Escreva dois pequenos programas que usam Moeda. Um programa deve tornar todas as constantes dispon\'edveis e o outro programa deve tornar somente Cinco dispon\'edvel. \line 21.7 Escreva um programa que usa o operador reinterpret_cast para fazer a coer\'e7\'e3o de diferentes tipos de ponteiros para int. Alguma das convers\'f5es resulta em erro de sintaxe? \line durante a \line 21.8 Escreva um programa que usa o operador static cast para fazer a coer\'e7\'e3o de alguns tipos de dados primitivos para \line\lquote erifique a int. O compilador permite as coer\'e7\'f5es para int? \line 21.9 Escreva um programa que demonstra a \ldblquote convers\'e3o para cima\rdblquote  (upcasting) de uma classe derivada para uma classe base. Use o operador static_cast para executar a convers\'e3o. \line 21.10 Escreva um programa que cria um construtor explicit que aceita dois argumentos. O compilador permite isto? Remova explicit e tente uma convers\'e3o impl\'edcita. O compilador permite isto? \line 21.11 Qual \'e9 o benef\'edcio de um construtor explicit? \par
1034 C++ COMO PROGRAMAR \line 2 1.12 Escreva uma programa que cria uma classe contendo dois construtores. Um construtor deve aceitar um \'fanico argumento int. O segundo construtor deve aceitar um argumento char . Escreva um programa de teste que constr\'f3i diversos objetos diferentes, com cada objeto tendo um tipo diferente passado para o construtor. N\'e3o use explicit. O que acontece? Agora use explicit somente para o construtor que aceita um int. O que acontece? \line 21.13 Dados os seguintes namespaces. responda se cada afirma\'e7\'e3o \'e9 verdadeira ou falsa. Justifique as respostasfalsas. \line 1 #include <string> \line 2 namespace Misc \{ \line 3 using namespace std; \line 4 enuin Countries \{ POLONIA, SUlCA, ALEMANHA, \line 5 AUSTRIA, REPUBLICATCHECA \}; \line 6 int kilometers; \line 7 string s; \line 8 \line 9 namespace Temp \{ \line 10 short y = 77; \line 11 Car car; II assume que a defini\'e7\'e3o existe \line 12 \line 13 \line 14 \line 15 namespace ABC \line 16 using namespace Misc: :Temp; \line 17 void *function( void \lquote , int ); \line 18 ) \line a) A vari\'e1vel y \'e9 acess\'e1vel dentro do namespace ABC. \line b) O objeto s \'e9 acess\'e1vel dentro do namespace Temp. \line c) A constante POLONIA n\'e3o \'e9 acess\'e1vel dentro do namespace Temp. \line d) A constante ALEMANHA \'e9 acess\'e1vel dentro do namespace ABC. \line e) A fun\'e7\'e3o function \'e9 acess\'e1vel no namespace Temp. \line f) O namespace ABC \'e9 acess\'e1vel para Misc. \line g) O objeto carro \'e9 acess\'e1vel para Misc. \line 21.14 Compare e contraste muta1e e const cast. D\'ea ao menos um exemplo de quando um \'e9 prefer\'edvel em rela\'e7\'e3o ao outro. Nota: este exerc\'edcio n\'e3o requer que seja escrito c\'f3digo de programa\'e7\'e3o. \line 21.15 Escreva um programa que usa const_cast para modificar uma vari\'e1vel const. (Sugest\'e3o: use um ponteiro em sua solu\'e7\'e3o para apontar para o identificador const. \line 2 1.16 Que problema resolvem as classes base virtual? \line 21.17 Escreva um programa que usa classes bases virtual. A classe no topo da hierarquia deve fornecer um construtor que aceite pelo menos um argumento (ou seja, n\'e3o fornece um construtor default). Que desafios isto apresenta para a hierarquia de heran\'e7a? \line 21.18 Encontre o(s) erro(s) em cada um dos seguintes itens. Quando poss\'edvel, explique como corrigir cada erro. \line a) manespace Name \{ \line int x, y; \line mutable int z; \line b) int integer = const_cast< int >( double ); \line c) namespace PCM(l1l, \ldblquote al\'f4\rdblquote ); // constr\'f3i o namespace \line d) explicit int x = 99; \par
\pard\lang1033\f1\fs20\par
}
 