{\rtf1\ansi\ansicpg1252\deff0\deflang1033{\fonttbl{\f0\fswiss\fprq2\fcharset0 Arial;}{\f1\froman\fcharset0 Times New Roman;}}
\viewkind4\uc1\pard\sb100\sa240\lang2070\f0\fs24\par
Fun\'e7\'f5es virtuais e polimorfismo \line Um Rei para govern\'e1-los. Um Rei para encontr\'e1-los. \line Um Rei para traz\'ea-los e na escurid\'e3o gui\'e1-los. \line John Ronald Reuel Tolkien, The Fellowship ofthe Ring \line O sil\'eancio de pura inoc\'eancia persuade quando a fala falha. William Shakespeare, The Winter\rquote s Tale \line Proposi\'e7\'f5es gerais n\'e3o decidem casos concretos. \line Oliver Wendell Holmes \par
eCe Fa\'e7a \par
uillento \ldblquote um 1 1 c \line esse \par
/ \par
lS\'f5es - e, Class \line rarquja \line formas \par
/ \par
1 \line / \par
\par
Objetivos \par
\par
\bullet  Entender a no\'e7\'e3o de polimorfismo. \line\bullet  Entender como declarar e usar fun\'e7\'f5es virtual e aplicar o polimorfismo. \line\bullet  Entender a diferen\'e7a entre classes abstratas e classes concretas. \line\bullet  Aprender como declarar fun\'e7\'f5es virtual puras e criar classes abstratas. \line\bullet  Apreciar como o polimorfismo torna os sistemas extens\'edveis e mais f\'e1ceis de manter. \line\bullet  Entender como fun\'e7\'f5es virtual e a vincula\'e7\'e3o din\'e2mica s\'e3o implementadas em C++ \ldblquote por baixo dos panos\rdblquote . \par
Um fil\'f3sofo de valor incontest\'e1vel n\'e3o pensa no v\'e1cuo. Mesmo suas id\'e9ias mais abstratas s\'e3o, at\'e9 certo ponto, condicionadas pelo que \'e9 ou n\'e3o \'e9 conhecido na \'e9poca e\'edn que ele vive. \line Alfred North Whitehead \par
608 C++ COMO PROGRAMAR \line\ul Vis\'e3o geral \ulnone ____________ \line 10.1 Introdu\'e7\'e3o \line 10.2 Campos de tipo e comandos switch \line 10.3 Fun\'e7\'f5es virtual \line 10.4 Classes base abstratas e classes concretas \line 10.5 Polimorfismo \line 10.6 Estudo de caso: um sistema de folha de pagamento usando polimorfismo \line 10.7 Novas classes e vincula\'e7\'e3o din\'e2mica \line 10.8 Destruidores virtual \line 10.9 Estudo de caso: herdando a interface e herdando a implementa\'e7\'e3o \line 10.10 Polimorfismo, fun\'e7\'f5es virtual e vincula\'e7\'e3o din\'e2mica \ldblquote vistos por dentro\rdblquote  \line Resumo . 7\rquote rminologia . Erros comuns de programa\'e7\'e3o Boas pr\'e1ticas de programa\'e7\'e3o Dicas de desempenho Observa\'e7\'f5es de engenharia de software Exerc\'edcio de auto-revis\'e3o Respostas ao exerc\'edcio de auto-revis\'e3o \bullet  Exerc\'edcios \line 10.1 Introdu\'e7\'e3o \line Com fun\'e7\'f5es virtuais e polimorfismo \'e9 poss\'edvel se projetar e implementar sistemas que s\'e3o mais facilmente extens\'edveis. Os programas podem ser escritos para processar genericamente - como objetos de classes base - objetos de todas as classes existentes em uma hierarquia. Classes que n\'e3o existem durante o desenvolvimento do programa podem ser acrescentadas, com poucas ou nenhuma modifica\'e7\'e3o, \'e0 parte gen\'e9rica do programa - desde que aquelas classes sejam parte da hierarquia que est\'e1 sendo processada genericamente. As \'e1nicas partes de um programa que necessitar\'e3o de modifica\'e7\'f5es s\'e3o aquelas partes que exigem conhecimento direto da classe particular que est\'e1 sendo acrescentada \'e0 hierarquia. \line 10.2 Campos de tipo e comandos switch \line Um meio de lidar com objetos de tipos diferentes \'e9 usar um comando switch para executar a a\'e7\'e3o apropriada sobre cada objeto, com base no tipo do objeto. Por exemplo, em uma hierarquia de formas, em que cada forma especifica seu tipo como um membro de dados, uma estrutura switch poderia determinar qual fun\'e7\'e3o de impress\'e3o chamar baseando-se no tipo do objeto particular. \line Existem muitos problemas com o uso de l\'f3gica de programa\'e7\'e3o que emprega switchs. O programador pode se esquecer de fazer um teste de tipo quando necess\'e1rio. O programador pode esquecer de testar todos os casos poss\'edveis em um switch. Se um sistema baseado em switchs for modificado pelo acr\'e9scimo de novos tipos, o programador pode se esquecer de inserir os novos casos em todos os comandos switch existentes. Todas as adi\'e7\'f5es ou exclus\'f5es a uma classe para tratar novos tipos exige que todo comando switch no sistema seja modificado; localizar todos eles pode consumir tempo e \'e9 uma atividade sujeita a erros. \line Como veremos, fun\'e7\'f5es virtual e a programa\'e7\'e3o polim\'f3rfica podem eliminar a necessidade do uso de l\'f3gica de programa\'e7\'e3o que emprega switchs. O programador pode usar o mecanismo de fun\'e7\'e3o virtual para executar automaticamente a l\'f3gica equivalente, evitando deste modo os tipos de erros tipicamente associados com o uso de l\'f3gica de programa\'e7\'e3o que emprega switchs. \line Observa\'e7\'e3o de engenharia de software 10.1 \line ______ Uma conseq\'fc\'eancia interessante do uso de fun\'e7\'f5es virtual e polimorfismo \'e9 que os programas adquirem uma apar\'eancia mais simples. Eles cont\'eam menos ramifica\'e7\'f5es l\'f3gicas, favorecendo o emprego de c\'f3digo seq\'fcencial mais simples. Isso facilita o teste, a depura \'e7\'e3o e a manuten\'e7\'e3o de programas e evita erros. \par
CAP\'cdTULO 10 - FUN\'c7\'d5ES VIRTUAIS E POLIM0RFISM0 609 \par
Suponha que um conjunto de classes de formas, tais como Circle, Triangle. Rectangle. Square, etc. sejam todas derivadas da classe base Shape. Na programa\'e7\'e3o orientada a objetos, cada uma dessas classes poderia ser dotada da habilidade de desenhar a si pr\'f3pria. Embora cada classe tenha sua pr\'f3pria fun\'e7\'e3o draw. a fun\'e7\'e3o draw para cada forma \'e9 bastante diferente. Quando desenharmos uma forma, qualquer que seja a forma, seria interessante sermos capazes de tratar todas essas formas genericamente, como objetos da classe b\'e1sica Shape. Ent\'e3o, para desenhar qualquer forma, poder\'edamos simplesmente chamar a fun\'e7\'e3o draw da classe base Shape e deixar o programa determinar dinamicamente (i.e., durante a execu\'e7\'e3o) qual a fun\'e7\'e3o draw de uma classe derivada que deve ser usada. \line Para possibilitar este tipo de comportamento, declaramos draw na classe b\'e1sica como uma fun\'e7\'e3o virtual e sobrescrevemos draw em cada uma das classes derivadas para desenhar a forma apropriada. Uma fun\'e7\'e3o virtual \'e9 declarada precedendo-se o prot\'f3tipo da fun\'e7\'e3o pela palavra-chave virtual na classe b\'e1sica. Por exemplo, \line virtual void draw() const; \line pode aparecer na classe base Shape. O prot\'f3tipo precedente declara que a fun\'e7\'e3o draw \'e9 uma fun\'e7\'e3o constante, que n\'e3o aceita nenhum argumento, n\'e3o retorna nada e \'e9 uma fun\'e7\'e3o virtual. \line Observa\'e7\'e3o de engenharia de software 10.2 \line ______ Uma vez que uma fun\'e7\'e3o seja declarada virtual, ela permanece virtual por toda a hierarquia de heran\'e7a, daquele ponto para baixo, mesmo se n\'e3o \'e9 declarada virtual quando uma classe a sobrescreve. \line Boa pr\'e1tica de programa\'e7\'e3o 10.1 \line Embora certas fun\'e7\'f5es sejam implicitamente virtual, por causa de uma declara\'e7\'e3o feita mais acima na hierarquia de classes, declarar explicitamente estas fun\'e7\'f5es como virtual em cada n\'edvel da hierarquia melhora a clareza do programa. \line Observa\'e7\'e3o de engenharia de software 10.3 \line Quando uma classe derivada escolhe n\'e3o definir uma fun\'e7\'e3o como virtual, a classe derivada simplesmente herda a defini\'e7\'e3o da fun\'e7\'e3o virtual da sua classe b\'e1sica imediata. \line Se a fun\'e7\'e3o draw na classe b\'e1sica foi declarada virtual, e se ent\'e3o usamos um ponteiro ou refer\'eancia da classe b\'e1sica para apontar para o objeto da classe derivada e invocar a fun\'e7\'e3o draw usando este ponteiro ou refer\'eancia (por exemplo, shapePtr->draw () ), o programa escolher\'e1 dinamicamente a fun\'e7\'e3o draw correta para a classe derivada (i.e., durante a execu\'e7\'e3o) com base no tipo do objeto - n\'e3o no tipo do ponteiro ou da refer\'eancia. Tal vincula \'e7\'e3o din\'e2mica ser\'e1 ilustrada nos estudos de caso nas Se\'e7\'f5es 10.6 e 10.9. \line Quando uma fun\'e7\'e3o virtual \'e9 chamada referenciando um objeto espec\'edfico por nome e usando o operador \line de sele\'e7\'e3o de membro ponto (.) (por exemplo, squareObject. draw ), a refer\'eancia \'e9 resolvida durante a \line compila\'e7\'e3o (isto \'e9 chamado de vincula \'e7\'e3o est\'e1tica), e a fun\'e7\'e3o virtual que \'e9 chamada \'e9 aquela definida para a \line (ou herdada pela) classe daquele objeto particular. \line 10.4 Classes base abstratas e classes concretas \line Quando pensamos em uma classe como um tipo, assumimos que os objetos daquele tipo ser\'e3o instanciados. Contudo, existem casos em que \'e9 \'fatil se definir classes para as quais o programador nunca pretende instanciar nenhum objeto. Tais classes s\'e3o chamadas de classes abstratas. Como elas s\'e3o usadas como classes base em situa\'e7\'f5es de heran\'e7a, normalmente nos referiremos a elas como classes b\'e1sicas abstratas. Nenhum objeto de uma classe b\'e1sica abstrata pode ser instanciado. \line O \'fanico objetivo de uma classe abstrata \'e9 fornecer uma classe b\'e1sica apropriada da qual outras classes podem herdar a interface e/ou a implementa\'e7\'e3o. As classes das quais podem ser instanciados objetos s\'e3o chamadas de classes concretas. \line Poder\'edamos ter uma classe b\'e1sica abstrata TwoDimensionalShape e classes concretas derivadas tais como Square, Circle. Triangle. etc. Poder\'edamos tamb\'e9m ter uma classe b\'e1sica abstrata \par
10.3 Fun\'e7\'f5es virtual \par
610 C++ COMO PROGRAMAR \line ThreeDimensionalShape e classes concretas derivadas tais como Cube, Sphere, Cylinder. etc. Classes base abstratas s\'e3o muito gen\'e9ricas para definirmos objetos reais; precisamos ser mais espec\'edficos antes de podermos pensar em instanciar objetos. Isso \'e9 o que as classes concretas fazem; elas fornecem os aspectos espec\'edficos que tornam razo\'e1vel instanciarmos objetos. \line Uma classe \'e9 tornada abstrata declarando-se uma ou mais de suas fun\'e7\'f5es virtual como sendo \ldblquote pura\rdblquote . Uma \line fun\'e7\'e3o virtual pura \'e9 uma fun\'e7\'e3o que tem um inicializador = O em sua declara\'e7\'e3o, como em \line virtual double earnings() const = O; II virtual pura \line Observa\'e7\'e3o de engenharia de software 10.4 \line ______ Se uma classe \'e9 derivada de uma classe com uma Jun\'e7\'e3o virtual pura e se nenhuma defini\'e7\'e3o for fornecida para aquela fun\'e7\'e3o virtual pura na classe derivada, ent\'e3o aquela fun\'e7\'e3o virtual permanece pura na classe derivada. Conseq\'fcentemente, a classe derivada tamb\'e9m \'e9 uma classe abstrata. \line Erro comum de programa\'e7\'e3o 10. 1 \line Tentar instanciar um objeto de uma classe abstrata (i.e., uma classe que cont\'e9m uma ou mais fun\'e7\'f5es \line virtual puras) \'e9 um erro de sintaxe. \line Uma hierarquia n\'e3o necessita conter quaisquer classes abstratas, mas, como veremos, muitos sistemas bons orientados a objetos t\'eam hierarquias de classe com uma classe b\'e1sica abstrata no topo. Em alguns casos, as classes abstratas formam os n\'edveis mais altos da hierarquia. Um bom exemplo disso \'e9 uma hierarquia de formas. A hierarquia poderia ser encabe\'e7ada pela classe b\'e1sica abstrata Shape. No pr\'f3ximo n\'edvel abaixo, podemos ter mais duas classes b\'e1sicas abstratas, isto \'e9 TwoDimensionalShape e ThreeDimensionalShape. O pr\'f3ximo n\'edvel abaixo come\'e7aria a definir classes concretas para formas bidimensionais, tais como cfrculos e quadrados, e classes concretas para formas tridimensionais, tais como esferas e cubos. \line 10.5 Polimorfismo \line C++ possibilita o polimoifismo - a habilidade de objetos de classes diferentes relacionadas por heran\'e7a responderem diferentemente \'e0 mesma mensagem (i.e., uma chamada a uma fun\'e7\'e3o membro). A mesma mensagem enviada para muitos tipos diferentes de objetos assume \ldblquote muitas formas\rdblquote  - da\'ed o termo polimorfismo. Se, por exemplo, a classe \line Rectangle \'e9 derivada da classe Quadrilateral, ent\'e3o um objeto Rectangle \'e9 uma vers\'e3o mais espec\'edfica de \ldblquote 7 um objeto Quadrilateral. Uma opera\'e7\'e3o (tal como calcular o per\'edmetro ou a \'e1rea) que pode ser executada sobre \line um objeto do tipo Quadrilateral tamb\'e9m pode ser executada sobre um objeto do tipo Rectangle. \line O polimorfismo \'e9 implementado por meio de fun\'e7\'f5es virtuais. Quando \'e9 feito um pedido atrav\'e9s de um ponteiro (ou refer\'eancia) de uma classe b\'e1sica para usar uma fun\'e7\'e3o virtual, C++ escolhe a fun\'e7\'e3o sobrecarregada correta na classe derivada apropriada associada com o objeto. \line As vezes, uma fun\'e7\'e3o membro n\'e3o-virtual \'e9 definida em uma classe b\'e1sica e sobrescrita em uma classe derivada. Se uma fun\'e7\'e3o membro como esta \'e9 chamada, por meio de um ponteiro da classe b\'e1sica para o objeto da classe derivada, a vers\'e3o da classe b\'e1sica \'e9 usada. Se a fun\'e7\'e3o membro \'e9 chamada por meio de um ponteiro da classe derivada, a vers\'e3o da classe derivada \'e9 usada. Isto \'e9 comportamento n\'e3o-polim\'f3rfico. \line Considere o exemplo seguinte, que usa a classe base Ernployee e a classe derivada HourlyWorker da Fig. \line 9.5: \line Employee e, *eptr = \line HourlyWorker h, *hptr = \line ePtr->printO; II chama a fun\'e7\'e3o print da classe base \line hPtr->printQ; // chama a fun\'e7\'e3o print da classe derivada \line ePtr = &h; // convers\'e3o impl\'edcita permiss\'edvel \line ePtr->print II ainda chama print da classe base \line Nossa classe base Employee e nossa classe derivada HourlyWorker tiveram ambas suas pr\'f3prias fun\'e7\'f5es de 1 impress\'e3o definidas. Como as fun\'e7\'f5es n\'e3o foram declaradas como virtual e t\'eam a mesma assinatura, chamar a \par
CAP\'cdTULO 10- FUN\'c7\'d5ES VIRTUAIS E POLIMORFISMO 611 \par
fun\'e7\'e3o print atrav\'e9s de um ponteiro de Employee resulta em chamar Employee: : print O (n\'e3o importando se o ponteiro de Employee est\'e1 apontando para um objeto da classe base Employee ou para um objeto da classe derivada HourlyWorker) e chamar a fun\'e7\'e3o de impress\'e3o atrav\'e9s de um ponteiro de HourJ.yWorker resulta em chamar Hourj.yWorker: print . A fun\'e7\'e3o print da classe base tamb\'e9m est\'e1 dispon\'edvel para a classe derivada, mas para chamar print da classe base para um objeto da classe derivada atrav\'e9s de um ponteiro para um objeto da classe derivada, por exemplo, a fun\'e7\'e3o deve ser explicitamente chamada como segue: \par
hPtr->Employee: :printO; II chama fun\'e7\'e3o print da classe base \par
Isto especifica que print da classe b\'e1sica deve ser chamada explicitamente. \line Atrav\'e9s do uso de fun\'e7\'f5es virtuais e polimorfismo, uma chamada de fun\'e7\'e3o membro pode causar a execu\'e7\'e3o de a\'e7\'f5es diferentes, dependendo do tipo do objeto que est\'e1 recebendo a chamada (veremos que \'e9 necess\'e1ria uma pequena quantidade de overhead durante a execu\'e7\'e3o). Isto d\'e1 ao programador uma tremenda capacidade de express\'e3o. Veremos v\'e1rios exemplos do poder do polimorfismo e das fun\'e7\'f5es virtuais nas pr\'f3ximas se\'e7\'f5es. \par
Observa\'e7\'e3o de engenharia de software 10.5 \par
Com fun\'e7\'f5es virtual e polimoifismo, o programador pode tratar com generalidades e deixar para o ambiente de execu\'e7\'e3o a preocupa\'e7\'e3o com os aspectos espec\'edficos. O programador pode fazer com que uma grande variedade de objetos se comporte de modos apropriados para aqueles objetos, sem sequer conhecer os tipos dos mesmos. \par
Observa\'e7\'e3o de engenharia de software 10.6 \par
O polimorfismo promove a extensibilidade: o software escrito para invocar o comportamento polim\'f3tfico \line\'e9 escrito independentemente dos tipos dos objetos para os quais as mensagens s\'e3o enviadas. Deste modo, \line novos tipos de objetos que podem responder a mensagens existentes podem ser acrescentados a um sistema como esse, sem modificar o sistema b\'e1sico. Com a exce\'e7\'e3o do c\'f3digo cliente que instancia novos \line objetos, os programas n\'e3o necessitam ser recompilados. \par
Observa\'e7\'e3o de engenhariti de software 10. 7 \par
Uma classe abstrata define uma interface para os v\'e1rios membros de uma hierarquia de classes. A classe abstrata cont\'e9m fun\'e7\'f5es virtuais puras que ser\'e3o definidas nas classes derivadas. Todas as fun\'e7\'f5es na hierarquia podem usar essa mesma interface, atrav\'e9s do polimorfismo. \par
Embora n\'e3o possamos instanciar objetos de classes base abstratas, podemos declarar ponteiros e refer\'eancias para classes base abstratas. Tais ponteiros e refer\'eancias podem, ent\'e3o, ser usados para possibilitar manipula\'e7\'f5es polim\'f3rficas de objetos de classes derivadas quando tais objetos forem instanciados a partir de classes concretas. \line Vamos agora considerar as aplica\'e7\'f5es do polimorfismo e fun\'e7\'f5es virtual. Um gerenciador de tela necessita exibir muitos objetos de classes diferentes, inclusive novos tipos de objetos que ser\'e3o incorporados ao sistema at\'e9 mesmo depois de o gerenciador de tela ser escrito, O sistema pode necessitar exibir v\'e1rias formas (i.e., a classe base \'e9 Shape) tais como quadrados, c\'edrculos, tri\'e2ngulos, ret\'e2ngulos, pontos, linhas, etc. (cada uma dessas classes de formas \'e9 derivada da classe base Shape). O gerenciador de tela usa ponteiros da classe base ou refer\'eancias (para Shape) para administrar todos os objetos a serem exibidos. Para desenhar qualquer objeto (n\'e3o importando o n\'edvel em que o objeto aparece na hierarquia de heran\'e7a), o gerenciador de tela usa um ponteiro da classe base (ou refer\'eancia) para o objeto e simplesmente envia a mensagem draw para o objeto. A fun\'e7\'e3o draw foi declarada como virtual pura na classe base Shape e foi redefinida em cada uma das classes derivadas. Cada objeto do tipo Shape sabe como desenhar a si mesmo adequadamente. O gerenciador de tela n\'e3o tem que se preocupar com de que tipo cada objeto \'e9 ou se o objeto \'e9 de um tipo que o gerenciador de tela j\'e1 viu antes - o gerenciador de tela simplesmente diz a cada objeto para se desenhar adequadamente. \line O polimorfismo \'e9 particularmente efetivo para implementar sistemas de software em camadas. Em sistemas operacionais, por exemplo, cada tipo de dispositivo f\'edsico pode operar de modo diferente dos outros. Independemente disso, os comandos para ler ou escrever dados de e para dispositivos podem ter uma certa uniformidade. A mensagem escrever enviada para um objeto acionador de dispositivo precisa ser especificamente interpretada no contexto daqsuele acionador de dispositivo e como aquele acionador de dispositivo manipula dispositivos de um tipo espec\'edfico. Por\'e9m, a chamada escrever, em si, n\'e3o \'e9 realmente diferente da escrever para qualquer outro dispositivo no \par
612 C++ COMO PROGRAMAR \line sistema - ela simplesmente transfere um certo n\'famero de bytes da mem\'f3ria para aquele dispositivo. Um sistema operacional orientado a objetos poderia usar uma classe base abstrata para fornecer uma interface apropriada para todos os acionadores de dispositivos. Ent\'e3o, por heran\'e7a daquela classe base abstrata, classes derivadas s\'e3o formadas, todas operando de modo semelhante. Os recursos (i.e., a interface public) oferecidos pelos acionadores de dispositivos s\'e3o fornecidos como fun\'e7\'f5es virtual puras na classe base. As implementa\'e7\'f5es destas fun\'e7\'f5es virtual s\'e3o fornecidas nas classes derivadas que correspondem aos tipos espec\'edficos de acionadores de dispositivos. \line Com programa\'e7\'e3o polim\'f3rfica, um programa poderia caminhar atrav\'e9s de um cont\'eainer, tal como um array de ponteiros para objetos de v\'e1rios n\'edveis de uma hierarquia de classes. Os ponteiros em tal array seriam todos ponteiros da classe base para objetos de classes derivadas. Por exemplo, um array de objetos da classe TwoDimensionalShape poderia conter ponteiros TwoDimensionalShape * para objetos das classes derivadas Square. Circle, Triangle. Rectangle. Line, etc. Enviar uma mensagem para desenhar cada objeto do array iria, usando polimorfismo, desenhar a imagem correta na tela. \line 10.6 Estudo de caso: um sistema de folha de pagamento usando polimorfismo \line Iremos usar fun\'e7\'f5es virtual e polimorfismo para executar os c\'e1lculos de uma folha de pagamento, com base no tipo de um empregado (Fig. 10.1). Usaremos uma classe base Employee. As classes derivadas de Employee s\'e3o Boss, ao qual \'e9 pago um sal\'e1rio semanal fixo n\'e3o importando o n\'famero de horas trabalhadas, ComissionWorker. que recebe um sal\'e1rio b\'e1sico fixo mais uma porcentagem sobre as vendas, PieceWorker. o qual recebe pelo n\'famero de itens produzidos, e HourlyWorker, que \'e9 pago por hora (normal) e hora extra. \line Uma chamada \'e0 fun\'e7\'e3o earnings certamente se aplica genericamente a todos os empregados. Mas o modo como o sal\'e1rio de cada pessoa \'e9 calculado depende da classe do empregado, e tais classes s\'e3o todas derivadas da classe base Eniployee. Assim. earnings \'e9 declarada virtual pura na classe base Employee. e implementa\'e7\'f5es apropriadas de earnings s\'e3o fornecidas para cada uma das classes derivadas. Ent\'e3o, para calcular o sal\'e1rio de qualquer empregado, o programa simplesmente usa um ponteiro (ou refer\'eancia) da classe base para o objeto daquele Employee e invoca a fun\'e7\'e3o earnings. Em um sistema de folha de pagamento real, os diversos objetos do tipo empregado poderiam ser apontados por elementos individuais em um array (ou lista) de ponteiros do tipo Employee \line *. O programa simplesmente percorreria o array, um elemento de cada vez, usando os ponteiros Employee * para invocar a fun\'e7\'e3o earnings de cada objeto. \line 1 II Fig. 10.1: employ2.h \line 2 // Classe base abstrata Employee \line 3 #ifndef EMPLOY2H \line 4 #define EMPLOY2H \line 5 \line 6 class Employee \line 7 public: \line 8 Employee( const char , const char * \line 9 -Emp1oyeeQ; // destruidor recupera mem\'f3ria \line 10 const char *getFirstwalne() const; \line 11 const char *getLastNe() const; \line 12 \line 13 II Fun\'e7\'e3o virtual pura torna Employee urna classe base abstrata \line 14 virtual double earnings() const = 0; // virtual pura \line 15 virtual void print() const; II virtual \line 16 private: \line 17 char *fjrstNe; \line 18 char *lastNe; \line 19 \line 20 \line 21 #endif \line Fig. 10.1 Demonstrando o polimorfismo com a hierarquia de classes Employee - employ2 .h. \par
CAP\'cdTULO 10- FUN\'c7\'d5ES VIRTUAIS E POLIMORFISMO 613 \line 22 II Fig. 10.1: employ2.cpp \line 23 II Defini\'e7\'f5es de fun\'e7\'f5es membro para \line 24 II a classe base abstrata Employee. \line 25 II Nota: nenhuma defini\'e7\'e3o dada para fun\'e7\'f5es virtuais puras. \line 26 #include <iostream> \line 27 \line 28 using std: :cout; \line 29 \line 30 #include <cstring> \line 31 #include <cassert> \line 32 #include \ldblquote employ2.h\rdblquote  \line 33 \line 34 II Construtor aloca dinamicamente espa\'e7o para \line 35 II primeiro e \'faltimo nomes e usa strcpy para \line 36 II copiar o primeiro e \'faltimos nomes para o objeto. \line 37 Employee::Employee( const char *fjrst, const char *last \line 38 \line 39 firstName = new char[ strlen( first ) + 1 1; \line 40 assert( firstName != O ) // testa se new funcionou \line 41 strcpy( firstName, first ); \line 42 \line 43 lastName = new char[ strlen( last ) + 1 1; \line 44 assert( lastName != O ) II testa se new funcionou \line 45 strcpy( lastName, last ); \line 46 \line 47 \line 48 II Destruidor desaloca mem\'f3ria alocada dinamicamente \line 49 Employee: :-Employee() \line 50 \{ \line 51 delete [] firstwame; \line 52 delete [] lastName; \line 53 1 \line 54 \line 55 // Retorna um ponteiro para o primeiro nome \line 56 II Tipo de retorno const impede chamador de modificar dados privados. \line 57 II Chamador deve copiar o string retornado antes que o destruidor \line 58 II delete a mem\'f3ria din\'e2mica, para evitar um ponteiro indefinido. \line 59 const char *Employee: :getFirstName() const \line 60 \line 61 return firstName; // chamador deve deletar mem\'f3ria \line 62 \line 63 \line 64 II Retorna um ponteiro para o \'faltimo nome \line 65 // Tipo de retorno const impede chamador de modificar dados privados. \line 66 II Chamador deve copiar o string retornado antes que o destruidor \line 67 II delete a mem\'f3ria din\'e2mica, para evitar um ponteiro indefinido. \line 68 const char *Employee: :getLastName() const \line 69 \line 70 return lastName; 1/ chamador deve deletar mem\'f3ria \line 71 \line 72 \line 73 II Imprime o nome do empregado \line 74 void Employee: :print() const \line 75 \{ cout \'ab firstName \'ab \'ab lastwame; \line Fig. 10.1 Demonstrando o polimorfismo com a hierarquia de classes Employee - employ2 .cpp. \par
614 C++ COMO PROGRAMAR \line 76 II Fig. 10.1: bossl.h \line 77 II Classe Boss derivada a partir de Employee \line 78 #ifndef BOSS1H \line 79 #define BOSS1H \line 80 #include \ldblquote employ2.h\rdblquote  \line 81 \line 82 class Boss : public Employee \line 83 public: \line 84 Boss( const char , const char , double = 0.0 ); \line 85 void setWeeklySalary( double ); \line 86 virtual double earnings() const; \line 87 virtual void print() const; \line 88 private: \line 89 double weeklySalary; \line 90 \line 91 \line 92 #endif \line Fig. 10.1 Demonstrando o polimorfismo com a hierarquia de classes Employee - bossl . h. \line 93 II Fig. 10.1: bossl.cpp \line 94 // Defini\'e7\'f5es de fun\'e7\'f5es membro para a classe Boss \line 95 #include <iostream> \line 96 \line 97 using std::cout; \line 98 \line 99 #include \ldblquote bossl.h\rdblquote  \line 100 \line 101 II Fun\'e7\'e3o construtor para a classe Boss \line 102 Boss: :Boss( const char *first, const char *last, double s \line 103 : Employee( first, last ) II chama construtor da classe base \line 104 \{ setWeeklySalary( s ); \} \line 105 \line 106 // Incializa o sal\'e1rio de Boss \line 107 void Boss::setWeeklySalary( double s \line 108 \{ weeklySalary = s > O ? s : 0; \} \line 109 \line 110 II Obt\'e9m o pagamento de Boss \line 111 double Boss: :earnings() const \{ return weeklySalary; ) \line 112 \line 113 II Imprime o nome do Boss \line 114 void Boss::print() const \line 115 \{ \line 116 cout \'ab \ldblquote\\n Chefe: \line 117 Employee: :printO; \line 118\} \line Fig. 10.1 Demonstrando o polimorfismo com a hierarquia de classes Employee - bossi .cpp. \line 119 II Fig. 10.1: commisl.h \line 120 // Classe CommissionWorker derivada de Employee \line 121 #ifndef COMMIS1H \line 122 #define COMMIS1H \line 123 #include \ldblquote employ2.h\rdblquote  \line 124 \line Fig. 10.1 Demonstrando o polimorfismo com a hierarquia de classes Employee - commisl .h. \par
CAP\'cdTULO 10- FUN\'c7\'d5ES VIRTUAIS E POLIMORFISMO 615 \par
125 class CommissionWorker : public Employee \line 126 public: \line 127 CommissionWorker( const char , const char , \line 128 double = 0.0, double = 0.0, \line 129 int0); \line 130 void setSalary( double ); \line 131 void setCommission( double ); \line 132 void setQuantity( int ); \line 133 virtual double earnings() const; \line 134 virtual void print() const; \line 135 private: \line 136 double salary; \line 137 double cornmission; \line 138 int quantity; \line 139 \}; \line 140 \line 141 #endif \line Fig. 10.1 Demonstrando o polimortismo com a hierarquia de classes Employee - commisl . h (parte 2 de 2). \line Consideremos a classe Employee (linhas 1 a 75). As fun\'e7\'f5es membro public incluem um construtor que aceita o primeiro e \'faltimo nome como par\'e2metros; um destruidor que recupera a mem\'f3ria alocada dinamicamente; uma fun\'e7\'e3o get que retorna o primeiro nome; uma fun\'e7\'e3o get que retoma o \'faltimo nome; uma fun\'e7\'e3o virtual pura carnings e uma fun\'e7\'e3o virtual print. Por que earnings \'e9 virtual pura? A resposta \'e9 que n\'e3o faz sentido fornecer uma implementa\'e7\'e3o desta fun\'e7\'e3o na classe Employee. N\'e3o podemos calcular o sal\'e1rio para um empregado gen\'e9rico - primeiro devemos saber que tipo de empregado ele \'e9. Tornando esta fun\'e7\'e3o virtual pura, estamos indicando que forneceremos uma implementa\'e7\'e3o desta fun\'e7\'e3o em cada classe derivada, mas n\'e3o na pr\'f3pria classe base. O programador nunca pretende chamar esta fun\'e7\'e3o virtual pura na classe base abstrata Employee; todas as classes derivadas redefinir\'e3o earnings com implementa\'e7\'f5es apropriadas para aquelas classes. \line A classe Boss (linhas 76 a 118) \'e9 derivada de Employee por heran\'e7a p\'fablica. As fun\'e7\'f5es membro public incluem um construtor que aceita um primeiro nome, um \'faltimo nome e um sal\'e1rio semanal como par\'e2metros e passa o primeiro nome e o \'faltimo nome para o construtor de Employee para inicializar os membros firstName e las tName da parte da classe base do objeto da classe derivada; uma fun\'e7\'e3o set para atribuir um novo valor ao membro privado de dados weeklySalary; uma fun\'e7\'e3o virtual earnings definindo como calcular o sal\'e1rio de um Boss; e uma fun\'e7\'e3o virtual print que imprime o tipo do empregado e ent\'e3o chama Employee: : print O para imprimir o nome do empregado. \line 142 // Fig. 10.1: commisl.cpp \line 143 // Defini\'e7\'f5es de fun\'e7\'f5es membro para a classe CommissionWorker \line 144 #include <iostream> \line 145 \line 146 using std::cout; \line 147 \line 148 #include \ldblquote commisl.h\rdblquote  \line II Construtor para a classe CommissionWorker \line CoxnmissionWorker: :CommissionWorker( const char *first, \line const char *last, double s, double c, int q \line Employee( first, last ) II chama construtor da classe base \line setSalary( s ); \line setCommission( c ); \line setQuantity( q ); \par
// sal\'e1rio base semanal \line II valor por item vendido \line // total de itens vendidos na semana \par
149 \line 150 \line 151 \line 152 \line 153 \line 154 \{ \line 155 \line 156 \line 157 \par
Fig. 10.1 Demonstrando o polimorfismo com a hierarquia de classes Employee - commisl . cpp (parte \line 1 de 2). \par
616 C++ COMO PROGRAMAR \line 158 \} \line 159 \line 160 // Inicializa o sal\'e1rio base semanal do CommissionWorker \line 161 void CommissionWorker::setSalary( double s \line 162 \{ salary = s > O ? s : O; \} \line 163 \line 164 // Inicializa a comiss\'e3o do CommissionWorker \line 165 void Commissionworker: :setCommission( double e \line 166 \{ commission = c > O ? c : O; \line 167 \line 168 // Inicializa a quantidade vendida do CommissionWorker \line 169 void CommissionWorker::setQuantity( int q \line 170 \{ quantity = q > O ? q : 0; \} \line 171 \line 172 // Determina os rendimentos do CommissionWorker \line 173 double CommissionWorker: : earnings () const \line 174 \{ return salary + commission * quantity; \} \line 175 \line 176 // Imprime o nome do CommissionWorker \line 177 void CommissionWorker: :print() const \line 178 \{ \line 179 cout \'ab \ldblquote\\nComissionado: \ldblquote ; \line 180 Employee: :printO; \line 181 \} \line Fig. 10.1 Demonstrando o polimorfismo com a hierarquia de classes Employee - commisl . cpp (parte 2 de 2). \line A classe Comissionworker (linhas 119 a 181) \'e9 derivada de Employee por heran\'e7a public. As fun\'e7\'f5es membro public incluem um construtor que aceita um primeiro nome, um \'faltimo nome, um sal\'e1rio, uma comiss\'e3o e uma quantidade de itens vendidos como par\'e2metros e passa o primeiro nome e o \'faltimo nome para o construtor de Employee: fun\'e7\'f5es set para atribuir novos valores aos membros de dados private sal\'e1rio, comiss\'e3o e quantidade; uma fun\'e7\'e3o virtual earnings definindo como calcular o sal\'e1rio de um ComissionWorker; e uma fun\'e7\'e3o virtual de impress\'e3o (print), que imprime o tipo do empregado e ent\'e3o chama Employee: : print para imprimir o nome do empregado. \line 182 II Fig. 10.1: piecel.h \line 183 // Classe PieceWorker derivada de Employee \line 184 #ifndef PIECE1H \line 185 #define PIECE1H \line 186 #include employ2.h\rquote  \line 187 \line 188 class PieceWorker : public Employee \{ \line 189 public: \line 190 Pieceworker( const char , const char , \line 191 double = 0.0, int = 0); \line 192 void setWage( double ); \line 193 void setQuantity( int ); \line 194 virtual double earnings() const; \line 195 virtual void print() const; \line 196 private: \line 197 double wagePerPiece; // remunera\'e7\'e3o por cada pe\'e7a produzida \line 198 int quantity; II produ\'e7\'e3o da semana \line 199 ); \line 200 \line 201 #endif \line Fig. 10.1 Demonstrando o polimorfismo com a hierarquia de classes Employee - piecel .h. \par
CAP\'cdTULO 10- FUN\'c7\'d5ES VIRTUAIS E POLIMORFISMO 617 \line 202 II Fig. 10.1: piecel.cpp \line 203 // Defini\'e7\'f5es de fun\'e7\'f5es membro para a classe PieceWorker \line 204 #include <iostream> \line 205 \line 206 using std: :cout; \line 207 \line 208 #include \lquote piecel.h\rdblquote  \line 209 \line 210 // Construtor para a classe PieceWorker \line 211 PieceWorker: :PieceWorker( const char *first, const char *last, \line 212 double w, int q \line 213 : Employee( first, last ) // chama construtor da classe base \line 214 \{ \line 215 setWage( w ); \line 216 setQuantity( q ); \line 217 \} \line 218 \line 219 II Inicializa a remunera\'e7\'e3o \line 220 void PieceWorker::setWage( double w \line 221 \{ wagePerPiece = w > O ? w : 0; \} \line 222 \line 223 II Inicializa o numero de itens produzidos \line 224 void PieceWorker::setQuantity( int q \line 225 \{ quantity = q > O ? q : 0; \} \line 226 \line 227 II Determina os rendimentos do PieceWorker \line 228 double PieceWorker: :earnings() const \line 229 \{ return quantity * wagePerPiece; \} \line 230 \line 231 II Imprime o nome do PieceWorker \line 232 void PieceWorker::print() const \line 233 \{ \line 234 cout \'ab \ldblquote\\n PieceWorker: \ldblquote ; \line 235 Employee: :printO; \line 236 ) \line Fig. 10.1 Demonstrando o polimorfismo com a hierarquia de classes Employee - piecel cpp. \line 237 II Fig. 10.1: hourlyl.h \line 238 II Defini\'e7\'e3o da classe HourlyWorker \line 239 #ifndef HOURLY1H \line 240 #define HOURLY1H \line 241 #include \ldblquote employ2.h\rdblquote  \line 242 \line 243 class HourlyWorker : public Employee \{ \line 244 public: \line 245 HourlyWorker( const char , const char , \line 246 double = 0.0, double = 0.0); \line 247 void setWage( double ); \line 248 void setHours( double ); \line 249 virtual double earnings() const; \line 250 virtual void print() const; \line 251 private: \line 252 double wage; II sal\'e1rio-hora \line 253 double hours; // horas trabalhadas na semana \line 254 \}; \line 255 \line 256 #endif \line Fig. 10.1 Demonstrando o polimorfismo com a hierarquia de classes Employee - hourlyl .h. \par
618 C++ COMO PROGRAMAR \par
A classe PieceWorker (linhas 182 a 236) \'e9 derivada de Employee por heran\'e7a public. As fun\'e7\'f5es membro public incluem um construtor que aceita um primeiro nome, um \'faltimo nome, uma remunera\'e7\'e3o por pe\'e7a e uma quantidade de itens produzidos como par\'e2metros e passa o primeiro e \'faltimo nomes para o construtor de Employee: \line fun\'e7\'f5es set para atribuir novos valores aos membros de dados private wagePerPiece e quantity: uma fun\'e7\'e3o virtual earnings definindo como calcular o sal\'e1rio de um PieceWorker: e uma fun\'e7\'e3o de impress\'e3o virtual que imprime o tipo do empregado e ent\'e3o chama Employee: : print () para imprimir o nome do empregado. \line A classe HourlyWorker (linhas 237 a 297) \'e9 derivada de Employee por heran\'e7a public. As fun\'e7\'f5es membro public incluem um construtor que aceita um primeiro nome, um \'faltimo nome, uma remunera\'e7\'e3o e o n\'famero de horas trabalhadas como par\'e2metros e passa o primeiro nome e \'faltimo nome para o construtor de Employee para inicializar os membros firstName e las tNaxne da parte da classe base do objeto da classe derivada fun\'e7\'f5es de inicializa\'e7\'e3o para atribuir novos valores aos membros de dados privados wage e hours: uma fun\'e7\'e3o virtual earnings definindo como calcular o sal\'e1rio de um HourlyWorker; e uma fun\'e7\'e3o de impress\'e3o virtual que imprime o tipo do empregado e ent\'e3o chama Employee: : print () para imprimir o nome do empregado. \line O programa de teste \'e9 mostrado nas linhas 298 a 367. Cada um dos quatro segmentos de c\'f3digo em main \'e9 semelhante, de modo que discutiremos somente o primeiro segmento, que lida com um objeto do tipo Boss. \par
257 \line 258 \line 259 \line 260 \line 261 \line 262 \line 1 263 \line 264 \line 1 265 \line 4 266 \line 267 \line 268 \line 269 \line 270 \{ \line 271 \line 272 \line 273 ) \line 274 \line 275 \line 276 \line 277 \line 278 \line 279 \line 280 \line 281 \line 282 \line 283 \line 284 \line 285 \line 286 \line 287 \line 288 \line 289 \line 290 \} \line 291 \line 292 \line 293 \line 294 \line 295 \line 296 \line 297 \par
setWage( w ); setHours ( h ); \par
cout \'ab \ldblquote\\n \line Employee: :printO; \par
A \par
II Fig. 10.1: hourlyl.cpp \line // Defini\'e7\'f5es de fun\'e7\'f5es membro para a classe HourlyWorker #include <iostream> \line using std::cout; \line #include \ldblquote hourlyl .h\rdblquote  \line II Construtor para a classe HourlyWorker \line HourlyWorker: :HourlyWorker( const char *first, \line const char *last, \line double w, double h \line Employee( first, last ) // chama construtor da classe base \line 1/ Inicializa a remunera\'e7\'e3o \line void HourlyWorker: :setWage( double w \line wage = w > O ? w : 0; \line // Inicializa horas trabalhadas \line void HourlyWorker::setHours( double h \line hours h > O && h < 168 ? h : 0; \line // Obt\'e9m o pagamento do HourlyWorker \line double HourlyWorker: :earnings() const \line if ( hours <= 40 ) // sem horas extras \line return wage * hours; \line else // hora extra \'e9 paga com remunera\'e7\'e3o * 1.5 return 40 * wage + ( hours - 40 ) * wage * 1.5; \line // Imprime o nome do HourlyWorker \line void HourlyWorker: :print() const \line HourlyWorker: \par
1 \line 1 \par
Fig. 10.1 Demonstrando o polimorfismo com a hierarquia de classes Employee - hourlyl . cpp. \par
CAP\'cdTULO 10-FUN\'c7\'d5ES VIRTUAIS E POLIMORFIsMO 619 \line II Fig. 10.1: figlOOl.cpp \line II Programa de teste para a hierarquia Employee \line #include <iostream> \line using std: :cout; \line using std::endl; \line 305 #include <iomanip> \line 306 \line 307 using std::ios; \line using std: :setiosflags; \line using std: :setprecision; \line #include \ldblquote employ2 .h\rdblquote  \line #include \ldblquote bossi .h\rdblquote  \line #include \ldblquote commisl h\rdblquote  \line #include \ldblquote piecel .h\rdblquote  \line #include \ldblquote hourlyl.h\rdblquote  \line II define formata\'e7\'e3o da sa\'edda \line cout \'ab setiosflags ( ios: : fixed 1 ios: : showpoint \line\'ab setprecision( 2 ); \line CommissionWorker c( Simone\rdblquote , \ldblquote Bianchi\rdblquote , 200.0, 3.0, 150 ); \line c.printO; II vincula\'e7\'e3o est\'e1tica \line cout \'ab \ldblquote  recebeu $\ldblquote  \'ab c.earnings II vincula\'e7\'e3o est\'e1tica \line virtualViaPointer( &c ); // usa vincula\'e7\'e3o din\'e2mica \line virtualViaReference( c ); // usa vincula\'e7\'e3o din\'e2mica \line PieceWorker p( \ldblquote Roberto\rquote , \ldblquote Santos\rquote , 2.5, 200 ); \line p.printO; // vincula\'e7\'e3o est\'e1tica \line cout \'ab \ldblquote  recebeu $\ldblquote  \'ab p.earningsO; // vincula\'e7\'e3o est\'e1tica \line virtualViaPointer( &p ); // usa vincula\'e7\'e3o din\'e2mica \line virtualViaReference( p ); II usa vincula\'e7\'e3o din\'e2mica \line HourlyWorker h( \ldblquote Carmem\rdblquote , \lquote Pereira\rquote , 13.75, 40 ); \line h.printO; II \line cout \'ab \ldblquote  recebeu $\ldblquote  \'ab h.earnings // \line virtualViaPointer( &h ); II \line virtualViaReference( h ); II \line cout \'ab endl; \line return 0; \par
298 \line 299 \line 300 \line 301 \line 302 \line 303 \line 304 \par
308 \line 309 \line 310 \line 311 \line 312 \line 313 \line 314 \line 315 \line 316 \par
void virtualViaPointer( const Employee * void virtualViaReference ( const Employee & ); \par
317 \line 318 \line 319 \line 320 int main() \line 321 \line 322 \line 323 \line 324 \line 325 \par
Boss b( \ldblquote Jos\'e9\rdblquote , \ldblquote Silva, 800.00 ); b.printO; \line cout \'ab \ldblquote  recebeu $\ldblquote  \'ab b.earningsO); virtualViaPointer( &b ); \line virtualViaReference ( b ); \par
II vincula\'e7\'e3o est\'e1tica \line II vincula\'e7\'e3o est\'e1tica \line // usa vincula\'e7\'e3o din\'e2mica \line // usa vincula\'e7\'e3o din\'e2mica \par
326 \line 327 \line 328 \line 329 \line 330 \line 331 \line 332 \line 333 \line 334 \line 335 \line 336 \line 337 \line 338 \line 339 \line 340 \line 341 \line 342 \line 343 \line 344 \line 345 \line 346 \line 347 \line 348 \line 349 \line 350 \line 351 \line 352 \line 353 \par
vincula\'e7\'e3o est\'e1tica vincula\'e7\'e3o est\'e1tica usa vincula\'e7\'e3o din\'e2mica usa vincula\'e7\'e3o din\'e2mica \par
II Faz chamadas virtuais com um ponteiro de \par
Fig. 10.1 Demonstrando o polimorfismo com a hierarquia de classes Employee - figlO_Ol . cpp (parte 1 de 2). \par
620 C++ COMO PROGRAMAR \line 354 // classe base usando vincula\'e7\'e3o din\'e2mica. \line 355 void virtualViaPointer( const Employee *baseclassptr \line 356 \line 357 baseClassPtr->print \line 358 cout \'ab \ldblquote  recebeu $\ldblquote  \'ab baseClassPtr->earnings \line 359 \} \line 360 \line 361 II Faz chamadas virtuais com urna refer\'eancia para \line 362 II classe base usando vincula\'e7\'e3o din\'e2mica. \line 363 void virtualViaReference( const Employee &baseClassRef \line 364 \line 365 baseClassRef.printO; \line 366 cout \'ab \ldblquote  recebeu $\ldblquote  \'ab baseClassRef.earnings \line 367 \} \line Boss: Jos\'e9 Silva recebeu $800.00 \line Boss: Jos\'e9 Silva recebeu $800.00 \line Boss: Jos\'e9 Silva recebeu $800.00 \line Comissionado: Simone Bianchi recebeu $650.00 \line Comissionado: Simone Bianchi recebeu $650.00 \line Comissionado: Simone Bianchi recebeu $650.00 \line PieceWorker: Roberto Santos recebeu $500.00 \line PieceWorker: Roberto Santos recebeu $500.00 \line PieceWorker: Roberto Santos recebeu $500.00 \line HourlyWorker: Carmem Pereira recebeu $550.00 \line HourlyWorker: Carmem Pereira recebeu $550.00 \line HourlyWorker: Carmem Pereira recebeu $550.00 \line Fig. 10.1 Demonstrando o polimorfismo com a hierarquia de classes Employee - figlO 01 . cpp (parte 2 de 2). \line A linha 326 \line Boss b( \ldblquote Jos\'e9, \ldblquote Silva\rquote , 800.00 \line instancia objeto b da classe derivada Boss e fornece os par\'e2metros ao construtor, inclusive o primeiro nome, o \'faltimo nome e o sal\'e1rio semanal fixo. \line A linha 327 \line b.print // vincula\'e7\'e3o est\'e1tica \line invoca explicitamente a vers\'e3o de Boss da fun\'e7\'e3o membro print, usando o operador de sele\'e7\'e3o de membro ponto (.)para o objeto do tipo Boss espec\'edfico b. Este \'e9 um exemplo de vincula\'e7\'e3o est\'e1tica, porque o tipo do objeto para o qual a fun\'e7\'e3o est\'e1 sendo chamada \'e9 conhecido durante a compila\'e7\'e3o. Esta chamada \'e9 inclu\'edda para fins de compara\'e7\'e3o, para ilustrar que a fun\'e7\'e3o print correta \'e9 invocada usando-se vincula\'e7\'e3o din\'e2mica. \line A linha 328 \line cout \'ab \ldblquote  recebeu $\ldblquote  \'ab b.earningsQ; II vincula\'e7\'e3o est\'e1tica \line invoca explicitamente a vers\'e3o de Boss da fun\'e7\'e3o membro earnings, usando o operador de sele\'e7\'e3o de membro ponto ( . ) para o objeto do tipo Boss espec\'edfico b. Este tamb\'e9m \'e9 um exemplo de vincula\'e7\'e3o est\'e1tica. Esta chamada tamb\'e9m \'e9 inclu\'edda para fins de compara\'e7\'e3o, desta vez para ilustrar que a fun\'e7\'e3o earnings correta \'e9 invocada usando-se liga\'e7\'e3o din\'e2mica. \line A linha 329 \line virtualViaPointer( &b ); // usa vincula\'e7\'e3o din\'e2mica \par
CAP\'cdTULO lO - FUN\'c7\'d5ES VIRTUAIS E POLIM0RFISMO 621 \line invoca a fun\'e7\'e3o virtualViaPointer (linha 335) com o endere\'e7o do objeto de classe derivada b. A fun\'e7\'e3o recebe esse endere\'e7o em seu par\'e2metro baseClassPtr, que \'e9 declarado como um const Employee . Isto \'e9 precisamente como realizar o comportamento polim\'f3rfico. \line A linha 357 \line baseClassPtr->print \line invoca a fun\'e7\'e3o membro de impress\'e3o do objeto apontado por baseClassPtr. Como print \'e9 declarada virtual na classe base, o sistema invoca a fun\'e7\'e3o de impress\'e3o do objeto da classe derivada - o que \'e9 precisamente chamado de comportamento polim\'f3rfico. Esta chamada de fun\'e7\'e3o \'e9 um exemplo de vincula\'e7\'e3o din\'e2mica - a fun\'e7\'e3o virtual \'e9 invocada atrav\'e9s de um ponteiro da classe base, de modo que a decis\'e3o sobre que fun\'e7\'e3o invocar \'e9 adiada at\'e9 o momento da execu\'e7\'e3o. \line A linha 358 \line cout \'ab \lquote  recebeu $\ldblquote  \'ab baseClassPtr->earnings() \line invoca a fun\'e7\'e3o membro earnings do objeto apontado por baseClassPtr. Como earnings e declarada uma fun\'e7\'e3o virtual na classe base, o sistema invoca a fun\'e7\'e3o earnings do objeto da classe derivada. Isso tamb\'e9m \'e9 vincula\'e7\'e3o din\'e2mica. \line A linha 330 \line virtualViaReferencia (b); /1 usa vincula\'e7\'e3o din\'e2mica \line invoca a fun\'e7\'e3o virtualViaReferencia (linha 363) para demonstrar que o polimorfismo tamb\'e9m pode ser realizado com fun\'e7\'f5es virtual chamadas com refer\'eancias para a classe base. A fun\'e7\'e3o recebe o objeto b no par\'e2metro baseClassRef que \'e9 declarado como um const Ernployee &. Esta \'e9 precisamente a maneira de realizar comportamento polim\'f3rfico com refer\'eancias. \line A linha 365 \line baseClassRef print O; \line invoca a fun\'e7\'e3o membro print do objeto referenciado por baseClassRef. Como print \'e9 declarada uma fun\'e7\'e3o virtual na classe base, o sistema invoca a fun\'e7\'e3o de impress\'e3o do objeto da classe derivada. Esta chamada de fun\'e7\'e3o \'e9 tamb\'e9m um exemplo de vincula\'e7\'e3o din\'e2mica - a fun\'e7\'e3o \'e9 invocada atrav\'e9s de uma refer\'eancia para a classe base, de modo que a decis\'e3o sobre qual fun\'e7\'e3o invocar \'e9 adiada at\'e9 o tempo de execu\'e7\'e3o. \line A linha 366 \line cout \'ab \ldblquote  recebeu $\lquote  \'ab baseClassRef.earnings() \line invoca a fun\'e7\'e3o membro earnings do objeto referenciado por baseClassRef. Como earnings \'e9 declarada uma fun\'e7\'e3o virtual na classe base, o sistema invoca a fun\'e7\'e3o earnings do objeto da classe derivada. Isso tamb\'e9m \'e9 liga\'e7\'e3o din\'e2mica. \line 10.7 Novas classes e vincula\'e7\'e3o din\'e2mica \line O polimorfismo e fun\'e7\'f5es virtuais funcionam bem quando todas as classes poss\'edveis n\'e3o s\'e3o conhecidas com anteced\'eancia. Mas eles tamb\'e9m funcionam quando novos tipos de classes s\'e3o acrescentados aos sistemas. Novas classes s\'e3o acomodadas pela vincula\'e7\'e3o din\'e2mica (tamb\'e9m chamada de vincula \'e7\'e3o tardia). O tipo de um objeto n\'e3o precisa ser conhecido durante a compila\'e7\'e3o para que uma chamada de fun\'e7\'e3o virtual seja compilada. Durante a execu\'e7\'e3o, a chamada da fun\'e7\'e3o virtual \'e9 associada com a fun\'e7\'e3o membro apropriada do objeto chamado. \line Um programa gerenciador de tela pode agora exibir novos tipos de objetos, \'e0 medida que s\'e3o acrescentados ao sistema, sem o gerenciador de tela necessitar ser recompilado. A chamada \'e0 fun\'e7\'e3o draw permanece a mesma. Os \par
CAP\'cdTULO 10 - FUN\'c7\'d5ES VIRTUAIS E POLIMORFISMO 623 \line Observa\'e7\'e3o de engenharia de software 10.8 \line _______ Uma classe pode herdar a inteiface e/ou a implementa\'e7\'e3o de uma classe base. As hierarquias projetadas para heran\'e7a de implementa\'e7\'e3o tendem a ter sua funcionalidade colocada no alto da hierarquia - cada nova classe derivada herda uma ou mais fun\'e7\'f5es membro que foram definidas em uma classe base, e a nova classe derivada usa as defini\'e7\'f5es da classe base. As hierarquias projetadas para heran\'e7a de interface tendem a ter sua funcionalidade colocada mais abaixo na hierarquia - uma classe base especifica uma ou mais fun\'e7\'f5es que deveriam ser definidas para cada classe na hierarquia (i.e., elas t\'eam a mesma assinatura), mas as classes derivadas individuais fornecem suas pr\'f3prias implementa\'e7\'f5es da(s)fun\'e7\'e3o(\'f5es). \line 1 II Fig. 10.2: shape.h \line 2 // Defini\'e7\'e3o da classe base abstrata Shape \line 3 #ifndef SHAPEH \line 4 #define SHAPEH \line 5 \line 6 class Shape \line 7 public: \line 8 virtual double area() const \{ return 0.0; \line 9 virtual double volume() const \{ return 0.0; \line 10 \line 11 II fun\'e7\'f5es virtuais puras sobrescritas nas classes derivadas \line 12 virtual void printShapeName() const 0; \line 13 virtual void print() const = 0; \line 14 \line 15 \line 16 #endif \line Fig. 10.2 Demonstrando a heran\'e7a de interface com a hierarquia de classes Shape - shape . h. \line 17 II Fig. 10.2: pointl.h \line 18 /1 Defini\'e7\'e3o da classe Point \line 19 #ifndef POINT1H \line 20 #define POINT1H \line 21 \line 22 #include <iostreaxn> \line 23 \line 24 using std::cout; \line 25 \line 26 #include shape.h\rdblquote  \line 27 \line 28 class Point : public Shape \line 29 public: \line 30 Point( int = 0, int = O ); II construtor default \line 31 void setpoint( int, int ); \line 32 int getX() const \{ return x; \} \line 33 int getY() const \{ return y; \} \line 34 virtual void printShapeName() const \{ cout \'ab \ldblquote Point: \line 35 virtual void print() const; \line 36 private: \line 37 int x, y; II coordenadas x e y de Point \line 38 \line 39 \line 40 #endif \line Fig. 10.2 Demonstrando a heran\'e7a de intertace com a hierarquia de classes Shape -pointi .h. \par
624 C++ COMO PROGRAMAR \par
41 // Fig. 10.2: pointl.cpp \line 42 1/ Defini\'e7\'f5es de fun\'e7\'f5es membro para a classe Point \line 43 #include \ldblquote pointl.h\rdblquote  \line 44 \line 45 Point::Point( int a, int b ) \{ setPoint( a, b ); \line 46 \line 47 void Point::setpoint( int a, int b \line 48 \line 49 xa; \line 50 y=b; \line 51 \line 52 \line 53 void Point::print() const \line 54 \{ cout \'ab \lquote [\lquote  \'ab x \'ab \lquote , \'ab y \'ab \lquote ] \par
A classe base Shape (linhas 1 a 16) consiste em quatro fun\'e7\'f5es virtual public e n\'e3o cont\'e9m quaisquer dados. As fun\'e7\'f5es printShapeName e print s\'e3o virtual puras, assim elas s\'e3o redefinidas em cada uma das classes derivadas. As fun\'e7\'f5es area e volume s\'e3o definidas para retornar O. O. Essas fun\'e7\'f5es s\'e3o redefinidas nas classe derivadas quando for apropriado para aquelas classes terem um c\'e1lculo de \'e1rea diferente e/ou um c\'e1lculo de volume diferente. Note que Shape \'e9 uma classe abstrata e cont\'e9m algumas fun\'e7\'f5es virtual \ldblquote impuras\rdblquote  (area e volume). Classes abstratas tamb\'e9m podem incluir fun\'e7\'f5es e dados n\'e3o-virtuais, que ser\'e3o herdados por classes derivadas. \par
56 \line 57 \line 58 \line 59 \line 60 \line 61 \line 62 \line 63 \line 64 \line 65 \line 66 \line 67 \line 68 \line 69 \line 70 \line 71 \line 72 \line 73 \line 74 \par
II Fig. 10.2: circlel.h \line II Defini\'e7\'e3o da classe Circle \line #ifndef CIRCLE1H \line #define CIRCLE1H \line #include \ldblquote pointi . \line class Circle : public Point \{ \line public: \line // construtor default \line Circle( double r = 0.0, int x = 0, int y = u ); \line void setRadius ( double ); \line double getRadius() const; \line virtual double area() const; \line virtual void printShapeName() const \{ cout virtual void print() const; \line private: \line double radius; // raio do c\'edrculo \par
\'ab \ldblquote Circle: \ldblquote ; \par
75 #endif \line Fig. 10.2 Demonstrando a heran\'e7a de inter\'edace com a hierarquia de classes Shape - circlel .h. \par
Fig. 10.2 Demonstrando a heran\'e7a de inter\'edace com a hierarquia de classes Shape - circlel . cpp (partel de 2). \par
80 \line 81 \line 82 \line 83 \line 84 \line 85 \line 86 \line 87 \line 88 \line 89 \line 90 \line 91 \line 92 \line 93 \line 94 \par
95 \line Fig. 10.2 Demonstrando a heran\'e7a de interface com a hierarquia de classes Shape - pointi . cpp. 96 \line 97 \par
98 \line 99 \line Fig. \line (par \par
Ad \par
volu \line simf \line de fi \par
fun\'e7 \line obje \line e fui \par
0.0 \par
ame \line clas \line com \par
fun\'e7 \line uma \par
\'e1rea \line cIas \line com \line fun\'e7 \par
altui \par
100 \line 101 \line 102 \line 103 \par
104 \line 1OE \line 1OE \line 101 \par
Fig. \line (pai \par
\pard\par
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx301\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx672\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1286\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1983\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx5848\pard\intbl 76 \cell II \cell Fig. \cell 10.2: \cell circlel.cpp \cell\row
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx301\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx672\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1983\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx5848\pard\intbl 77 \cell // \cell Defini\'e7\'f5es \cell de fun\'e7\'f5es membro para a classe Circie \cell\row
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx301\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1286\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx5848\pard\intbl 78 \cell #include \cell <iostream> \cell\row
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx301\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx672\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1286\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx1983\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx5848\pard\intbl 79 \cell\cell\cell\cell\cell\row
\pard\par
\pard\sb100\sa240 CAP\'cdTULO 10 - FUN\'c7\'d5ES VIRTUAIS E P0LIM0RFIsM0 625 \line 80 using std::cout; \line 81 \line 82 #include \ldblquote circlel.h\rdblquote  \line 83 \line 84 Circle::Circle( double r, int a, int b \line 85 : Point( a, b ) II chama construtor da classe base \line 86 \{ setRadius( r ); \} \line 87 \line 88 void Circle::setRadius( double r ) \{ radius = r > O ? r : 0; \} \line 89 \line 90 double Circle::getRadius() const \{ return radius; \} \line 91 \line 92 double Circle::area() const \line 93 \{ return 3.14159 * radius * radius; \line 94 \line 95 void Circle::print() const \line 96 \line 97 Point: :printO; \line 98 cout \'ab \ldblquote ; Raio = \ldblquote  \'ab radius; \line 99 1 \line Fig. 10.2 Demonstrando a heran\'e7a de interface com a hierarquia de classes Shape - circiel . cpp (parte 2 de 2). \line A classe Point (linhas 17 a 54) \'e9 derivada de Shape por heran\'e7a public. Um Point tem uma \'e1rea O . O e um volume 0. 0, assim as fun\'e7\'f5es membros da classe base area e volume n\'e3o s\'e3o sobrescritas aqui - elas s\'e3o simplesmente herdadas como definidas em Shape. As fun\'e7\'f5es printShapeName e print s\'e3o implementa\'e7\'f5es de fun\'e7\'f5es virtual que foram definidas como virtual puras na classe base - se n\'e3o sobrescrev\'eassemos essas fun\'e7\'f5es na classe Point, ent\'e3o Point tamb\'e9m ser\'edamos uma classe abstrata e n\'e3o ser\'edamos capazes de instanciar objetos Point. Outras fun\'e7\'f5es membro incluem uma fun\'e7\'e3o set para atribuir novas coordenadas x e y a um Point e fun\'e7\'e3o get para retornar as coordenadas x e y de um Point. \line A classe Circle (linhas 55 a 99) \'e9 derivada de Point por heran\'e7a public. Um c\'edrculo tem um volume O . O, assim a fun\'e7\'e3o membro volume da classe base n\'e3o \'e9 sobrescrita aqui - ela \'e9 herdada de Point, que previamente herdou volume de Shape. Um c\'edrculo tem \'e1rea n\'e3o-nula, de modo que a fun\'e7\'e3o area \'e9 sobrescrita nesta classe. As fun\'e7\'f5es printShapeName e print s\'e3o implementa\'e7\'f5es de fun\'e7\'f5es virtual que foram definidas como virtual puras na classe Shape. Se estas fun\'e7\'f5es n\'e3o s\'e3o sobrescritas aqui, as vers\'f5es de Point destas fun\'e7\'f5es ser\'e3o herdadas. Outras fun\'e7\'f5es membro incluem uma fun\'e7\'e3o set para atribuir um novo raio a um c\'edrculo e uma fun\'e7\'e3o get para retornar o raio de um Circle. \line A classe Cylinder (linhas 100 a 154) \'e9 derivada de Circle por heran\'e7a public. Um Cylinder tem \'e1rea e volume diferentes daqueles de um Circle, assim as fun\'e7\'f5es area e volume s\'e3o ambas sobrescritas nesta classe. As fun\'e7\'f5es printShapeName e print s\'e3o implementa\'e7\'f5es de fun\'e7\'f5es virtual que foram definidas como virtual puras na classe Shape. Se estas fun\'e7\'f5es n\'e3o s\'e3o sobrescritas aqui, as vers\'f5es de Circle destas fun\'e7\'f5es ser\'e3o herdadas. Outras fun\'e7\'f5es membro incluem fun\'e7\'f5es set e get para atribuir uma nova altura e retornar a altura de um Cylinder, respectivamente. \par
Fig. 10.2 Demonstrando a heran\'e7a de interface com a hierarquia de classes Shape - cylindrl.h \line (parte 1 de 2). \par
\pard\par
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx397\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx3484\pard\intbl 100 \cell II Fig. 10.2: cylindrl.h \cell\row
\intbl 101 \cell // Defini\'e7\'e3o da classe Cylinder \cell\row
\trowd\trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx397\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx2696\clbrdrt\brdrw15\brdrs\clbrdrl\brdrw15\brdrs\clbrdrb\brdrw15\brdrs\clbrdrr\brdrw15\brdrs \cellx3484\pard\intbl 102 \cell #ifndef CYLINDR1H \cell\cell\row
\intbl 103 \cell #define CYLINDR1H \cell\cell\row
\intbl 104 \cell #include \ldblquote circlel.h\rdblquote  \cell\cell\row
\intbl 105 \cell\cell\cell\row
\intbl 106 \cell class Cylinder : public \cell Circle \{ \cell\row
\intbl 107 \cell public: \cell\cell\row
\pard\par
\pard\sb100\sa240 626 C++ CoMo PROGRAMAR \line 108 // construtor default 157 #in \line 109 Cylinder( double h = 0.0, double r = 0.0, 158 \line 110 int x 0, int y = O ); 159 usi \line 111 160 usi \line 112 void setHeight( double ); 161 \line 113 double getHeightO; 162 #ifl \line 114 virtual double area() const; 163 \line 115 virtual double volume() const; 164 uSii \line 116 virtual void printShapeName() const \{ cout \'ab \ldblquote Cylinder: \ldblquote ; \} 165 usii \line 117 virtual void print() const; 166 usi \line 118 private: 167 \line 119 double height; II altura do cilindro 168 #ifl \line 120 \}; 169 #in \line 121 170 #in \line 122 #endif 171 #in \line 172 \line Fig. 10.2 Demonstrando a heran\'e7a de inter-face com a hierarquia de classes Shape - cylindrl.h 173 voi \line (parte 2 de 2). 174 voi \line 175 \line 176 int \line 123 II Fig. 10.2: cylindrl.cpp 177 \line 124 // Defini\'e7\'f5es de fun\'e7\'f5es membro e friend para a classe Cylinder 178 \line 125 #include <iostream> 179 \line 126 180 \line 127 using std: :cout; 181 \line 128 182 \line 129 #include \lquote cylindrl.h\rdblquote  183 \line 130 184 \line 131 Cylinder::Cylinder( double h, double r, int x, int y ) 185 \line 132 : Circle( r, x, y ) // chama construtor da classe base 186 \line 133 \{ setHeight( h ) \} 187 \line 134 188 \line 135 void Cylinder: :setHeight( double h ) 189 \line 136 \{ height = h > O ? h : 0; \} 190 \line 137 191 \line 138 double Cylinder: :getHeight() \{ return height; \} 192 \line 139 193 \line 140 double Cylinder::area() const 194 \line 141 \{ 195 \line 142 // \'e1rea da superf\'edcie do cilindro 196 \line 143 return 2 * Circle::area() \'f7 197 \line 144 2 * 3.14159 * getRadius() * height; 198 \line 145 \} 199 \line 146 200 \line 147 double Cylinder::volume() const 201 \line 148 \{ return Circle::area() * height; \} 202 \line 149 203 \line 150 void Cylinder: :print() const 204 \line 151 205 \line 152 Circle::printQ; 206 \line 153 cout \'ab Altura = \'ab height; 207 \line 154 \} 208 \line Fig. 10.2 Demonstrando a heran\'e7a de interface com a hierarquia de classes Shape - cylindrl - cpp. 209 \line 211 \line 155 // Fig. 10.2: figlOO2.cpp 212 \line 156 // Programa de teste para a hierarquia forma, ponto, c\'edrculo, cilindro \line Fig. 10.2 Demonstrando a heran\'e7a de interface com a hierarquia de classes Shape - figlO 02. cpp Fig. 10.2 \line (parte 1 de 3). (parte 2 c \par
\pard\par
\pard\sb100\sa240 CAP\'cdTULO 10- FUN\'c7\'d5ES VIRTUAIS E POLIMORFISMO 627 \line 157 #include <iostreain> \line 158 \line 159 using std: :cout; \line 160 using std: :endl; \line 161 \line 162 #include <iomanip> \line 163 \line 164 using std::ios; \line 165 using std: :setiosflags; \line 166 using std::setprecision; \line 167 \line 168 #include \lquote shape.h\rdblquote  \line 169 #include \ldblquote pointl.h\rdblquote  \line 170 #include \ldblquote circlel.h\rdblquote  \line 171 #iriclude \ldblquote cylindrl.h\rdblquote  \line 172 \line 173 void virtualViaPointer( const Shape * \line 174 void virtualViaReference( const Shape & ); \line 175 \line 176 int main() \line 177 \{ \line 178 cout \'ab setiosflags( ios::fixed ios::showpoint \line 179 \'ab setprecision( 2 ); \line 180 \line 181 Point point( 7, 11 ); II cria um Point \line 182 Circie circle( 3.5, 22, 8 ); // cria um Circie \line 183 Cylinder cylinder( 10, 3.3, 10, 10 ); II cria uni Cylmnder \line 184 \line 185 point.printShapeNameO; II vincula\'e7\'e3o est\'e1tica \line 186 point.printO; II vincula\'e7\'e3o est\'e1tica \line 187 cout \'ab \lquote\\n\rquote ; \line 188 \line 189 circle.printShapeNameO; // vincula\'e7\'e3o est\'e1tica \line 190 circle.printO; II vincula\'e7\'e3o est\'e1tica \line 191 cout \'ab \lquote\\n\rquote ; \line 192 \line 193 cy1inder.printShapet\rquote Iaxne 1/ vincula\'e7\'e3o est\'e1tica \line 194 cylinder.printO; li vincula\'e7\'e3o est\'e1tica \line 195 cout \'ab \ldblquote\\n\\n\rdblquote ; \line 196 \line 197 Shape *arrayofshapes[ 3 ]; II array de ponteiros para classe base \line 198 \line 199 li aponta arrayOfShapes[03 para objeto Point da classe derivada \line 200 arrayOfShapes[ O J = &point; \line 201 \line 202 // aponta arrayOfShapes[1) para objeto Circle da classe derivada \line 203 arrayOfShapes[ 1 ) = &circle; \line 204 \line 205 // aponta arrayOfShapes[2J para objeto Cylinder da classe derivada \line 206 arrayOfShapes[ 2 ] = &cylinder; \line 207 \line 208 // Itera ao longo de arrayOfShapes e chama virtualViaPointer \line 209 II para imprimir nome, atributos, \'e1rea e volume da forma \line 210 // de cada objeto usando vincula\'e7\'e3o din\'e2mica. \line 211 cout \'ab \ldblquote Chamadas de fun\'e7\'e3o virtuais feitas com \line 212 \'ab \lquote ponteiros para a classe base\\n\rdblquote ; \line 213 \line 214 for ( int i = 0; i < 3; i++ \line Fig. 10.2 Demonstrando a heran\'e7a de intertace com a hierarquia de coasses Shape - figl0_02 . cpp (parte 2 de 3). \par
\pard\par
\pard\sb100\sa100 628 C++ COMO PROGRAMAR \line 215 virtualViaPointer( arrayOfShapes( i 1 \line 216 \line 217 // Itera ao longo de arrayOfShapes e chama virtualViaReference \line 218 II para imprimir nome, atributos, \'e1rea e volume da forma \line 219 // de cada objeto usando vincula\'e7\'e3o din\'e2mica. \line 220 cout \'ab \lquote Chamadas de fun\'e7\'e3o virtuais feitas com \line 221 \'ab \ldblquote refer\'eancias para a classe base\\n\rquote ; \line 222 \line 223 for ( int j 0; j < 3; j++ \line 224 virtualViaReference( *arrayofShapes[ j ] ); \line 225 \line 226 return O; \line 227 \line 228 \line 229 /1 Faz chamadas de fun\'e7\'e3o virtuais com um ponteiro \line 230 // para a classe base usando vincula\'e7\'e3o din\'e2mica. \line 231 void virtualViaPointer( const Shape *baseClassptr \line 232 \{ \line 233 baseClassPtr->printShapeNameO; \line 234 baseClassPtr->print \line 235 cout \'ab \ldblquote\\n\'c1rea = \ldblquote  \'ab baseClassPtr->area() \line 236 \'ab \ldblquote\\nVolume \ldblquote  \'ab baseClassPtr->volume() \'ab \ldblquote\\n\\n\rdblquote ; \line 237 \line 238 \line 239 II Faz chamadas de fun\'e7\'e3o virtuais com uma refer\'eancia \line 240 II para a classe base usando vincula\'e7\'e3o din\'e2mica. \line 241 void virtualViaReference( const Shape &baseClassRef \line 242 \{ \line 243 baseClassRef.printShapeNameO; \line 244 baseClassRef.print \line 245 cout \'ab \lquote\\n\'c1rea = \ldblquote  \'ab baseClassRef.area() \line 246 \'ab \ldblquote\\nVolume = \ldblquote  \'ab baseClassRef.volume() \'ab \ldblquote\\n\\n\rdblquote ; \line 247 \} \par
\pard\sb100\sa240 Point: [7, 11) \line Circle: [22, 8]; Raio = 3.50 \line Cylinder: [10, 10); Raio = 3.30; Altura = 10.00 \line Chamadas de fun\'e7\'e3o virtuais feitas com ponteiros para a classe base \line Point: (7, 11] \line\'c1rea = 0.00 \line Volume = 0.00 \line Circle: [22, 8]; Raio 3.50 \line\'c1rea = 38.48 \line Volume = 0.00 \line Cylinder: [10, 10]; Raio = 3.30; Altura 10.00 \line\'c1rea = 275.77 \line Volume = 342.12 \line Chamadas de fun\'e7\'e3o virtuais feitas com refer\'eancias para a classe base \line Point: (7, 11] \line\'c1rea = 0.00 \line Volume = 0.00 \line C\'edrcle: [22, 8]; Raio = 3.50 \line\'c1rea = 38.48 \line Volume 0.00 \line Cylinder: (10, 10]; Raio = 3.30; Altura = 10.00 \line\'c1rea = 275.77 \line Volume = 342.12 \par
Fig. 10.2 Demonstrando a heran\'e7a de interface com a hierarquia de classes Shape - figl0_02 . cpp (parte 3 de 3). \par
CAP\'cdTULO lO - FUN\'c7\'d5ES VIRTUAIS E POLIMORFISMO 629 \line O programa de teste (linhas 155 a 247) come\'e7a instanciando o objeto point do tipo Point, o objeto circie do tipo Circle e o objeto cylinder do tipo Cylinder. As fun\'e7\'f5es printShapeName e print s\'e3o invocadas para cada um dos objetos, para imprimir o nome do objeto e para ilustrar que os objetos s\'e3o corretamente inicializados. Cada chamada printShapeName e print, nas linhas 185 a 194, usa vincula\'e7\'e3o est\'e1tica \line - o compilador sabe durante a compila\'e7\'e3o o tipo de cada objeto para o qual printShapeName e print s\'e3o chamadas. \line A seguir, o array arrayofShapes, no qual cada elemento \'e9 do tipo Shape , \'e9 declarado. Este array de ponteiros da classe base \'e9 usado para apontar para cada um dos objetos das classes derivadas. O endere\'e7o do objeto point \'e9 atribu\'eddo a arrayOfShapes [ O 1 (linha 200), o endere\'e7o do objeto circle \'e9 atribu\'eddo a arrayOfShapes [ 1 1 (linha 203) e o endere\'e7o do objeto cylinder \'e9 atribu\'eddo a arrayOfShapes [ 2 1 (linha 206). \line Em seguida, uma estrutura for (linha 214) percorre o array arrayOfShapes e invoca a fun\'e7\'e3o \line virtualViaPointer (linha 215) \line virtualViaPointer ( arrayOfShapes [ i ] ); \line para cada elemento do array. A fun\'e7\'e3o virtualViaPointer recebe no par\'e2metro baseClassPtr (do tipo const Shape *) o endere\'e7o armazenado em um elemento do arrayOfShapes. Toda vez que virtualViaPointer \'e9 executada, as quatro chamadas de fun\'e7\'e3o virtual seguintes s\'e3o feitas \line baseClassPtr->printShapeName O \line baseClassPtr->print() \line baseClassPtr->area () \line baseClassPtr->volume O \line Cada uma destas chamadas invoca uma fun\'e7\'e3o virtual sobre o objeto que baseClassPtr aponta durante a execu\'e7\'e3o - um objeto cujo tipo n\'e3o pode ser determinado durante a compila\'e7\'e3o. A sa\'edda ilustra que as fun\'e7\'f5es apropriadas para cada uma das classes s\'e3o invocadas. Primeiro, o string \ldblquote Point: \ldblquote  e as coordenadas do objeto point s\'e3o mostradas; a \'e1rea e o volume s\'e3o ambos 0.00. Em seguida, o string \ldblquote Circle:\rdblquote , as coordenadas do centro do objeto circle e o raio do objeto circle s\'e3o mostrados; a \'e1rea de circle \'e9 calculada e o volume \'e9 retornado como O . 00. Finalmente, o string \ldblquote Cylinder: as coordenadas do centro da base do objeto cylirider, o raio do objeto cylinder e a altura do objeto cylinder s\'e3o mostrados; a \'e1rea e o volume do cilindro s\'e3o calculados. Todas as chamadas das fun\'e7\'f5es virtuais printShapeName, print, area e volume s\'e3o resolvidas durante a execu\'e7\'e3o com vincula\'e7\'e3o din\'e2mica. \line Finalmente, uma estrutura for (linha 223) percorre o arrayOfShapes e invoca a fun\'e7\'e3o \line virtualViaReference (linha 224) \line virtualViaReference ( *arrayofshapes [ j 1 ); \line para cada um dos elementos do array. A fun\'e7\'e3o virtualViaReference recebe em seu par\'e2metro baseClassRef (do tipo const Shape &), uma refer\'eancia formada pela desreferencia\'e7\'e3o do endere\'e7o armazenado em um elemento do array. Durante cada chamada a virtualViaReference, s\'e3o feitas as seguintes chamadas a fun\'e7\'f5es virtuais \line baseClassRef .printShapeName O \line baseClassRef .print() \line baseCiassRef. area O \line baseClassRef .volume O \line Cada uma das chamadas precedentes invoca estas fun\'e7\'f5es sobre o objeto que baseClassRef referencia. A \line sa\'edda produzida usando refer\'eancias para a classe base \'e9 id\'eantica \'e0 sa\'edda produzida usando-se ponteiros para a \line classe base. \par
\pard\par
\pard\sb100\sa240 630 C++ COMO PROGRAMAR \line 10.10 Polimorfismo, fun\'e7\'f5es virtual e vincula\'e7\'e3o din\'e2mica \ldblquote vistos por dentro\rdblquote  \line C++ facilita a programa\'e7\'e3o do polimorfismo. Certamente, \'e9 poss\'edvel se programar com polimorfismo em linguagens n\'e3o-orientadas a objetos, tal como C, mas faz\'ea-lo exige manipula\'e7\'f5es de ponteiros complexas e potencialmente perigosas. Nessa se\'e7\'e3o, discutimos como C++ implementa o polimorfismo, fun\'e7\'f5es virtuais e a vincula\'e7\'e3o din\'e2mica internamente. Isso lhe dar\'e1 uma s\'f3lida compreens\'e3o de como realmente funcionam estes recursos. Mais importante ainda, ajudar\'e1 a aval\'edar o overhead provocado pelo polimortismo - em consumo de mem\'f3ria e tempo de processador adicionais. Isso ajudar\'e1 a decidir quando usar polimorfismo e quando evit\'e1-lo. Como voc\'ea ver\'e1 no Cap\'edtulo 20, \ldblquote A biblioteca padr\'e3o de gabaritos (STL)\rdblquote , os componentes da STL foram implementados sem usar polimorfismo e fun\'e7\'f5es virtuais - isto foi feito para evitar overhead durante a execu\'e7\'e3o e obter um desempenho \'f3timo para atender aos requisitos especiais da STL. \line Primeiro, explicaremos as estruturas de dados que o compilador C++ constr\'f3i durante a compila\'e7\'e3o para \line suportar o polimorfismo durante a execu\'e7\'e3o. Ent\'e3o, mostraremos como um programa em execu\'e7\'e3o usa estas estruturas de dados para executar fun\'e7\'f5es virtual e obter a vincula\'e7\'e3o din\'e2mica associada com o polimorfismo. \line Quando C++ compila uma classe que tem uma ou mais fun\'e7\'f5es virtual, o compilador constr\'f3i uma tabela de fun\'e7\'f5es virtuais (vtable) para aquela classe. A vtable \'e9 usada pelo programa em execu\'e7\'e3o para selecionar as implementa\'e7\'f5es apropriadas da fun\'e7\'e3o toda vez que uma fun\'e7\'e3o virtual daquela classe \'e9 executada. A Fig. 10.3 ilustra as tabelas de fun\'e7\'f5es virtual para as classes Shape. Point, Circle e Cylinder. \line Na vtable para a classe Shape, o primeiro ponteiro de fun\'e7\'e3o aponta para a implementa\'e7\'e3o da fun\'e7\'e3o area \line para aquela classe, isto \'e9, uma fun\'e7\'e3o que retorna uma \'e1rea de valor O . O. O segundo ponteiro de fun\'e7\'e3o aponta para \line a fun\'e7\'e3o volume, que tamb\'e9m retorna O . O. As fun\'e7\'f5es printShapeName e print s\'e3o ambas virtual puras \line - elas n\'e3o t\'eam implementa\'e7\'f5es, de modo que seus ponteiros de fun\'e7\'e3o s\'e3o ambos inicializados com O. Qualquer \line classe que tenha um ou mais ponteiros O em sua vtable \'e9 uma classe abstrata. Classes sem quaisquer ponteiros O na \line vtable (como Point, Circle e Cylinder) s\'e3o classes concretas. \line A classe Point herda as fun\'e7\'f5es area e volume da classe Shape. de modo que o compilador simplesmente deixa esses dois ponteiros na vtable para a classe Point como c\'f3pias dos ponteiros de area e volume da classe Shape. A classe Point redefine a fun\'e7\'e3o printShapeNaine para imprimir Point:\rdblquote . por isso o ponteiro de fun\'e7\'e3o aponta para a fun\'e7\'e3o printShapeNaxne da classe Point. Point tamb\'e9m sobrescreve print. de modo que o ponteiro de fun\'e7\'e3o correspondente aponta para a fun\'e7\'e3o da classe Point que imprime [x, y]. \line O ponteiro de fun\'e7\'e3o para area de Circle, na vtable para a classe Circle, aponta para a fun\'e7\'e3o area de Circie que retorna tr2. O ponteiro da fun\'e7\'e3o volume simplesmente \'e9 copiado da classe Point - aquele ponteiro foi previamente copiado de Shape para Point. O ponteiro da fun\'e7\'e3o printShapeName aponta para a vers\'e3o de Circle da fun\'e7\'e3o que imprime \ldblquote Circie: \ldblquote . O ponteiro da fun\'e7\'e3o print aponta para a fun\'e7\'e3o print de Circle que imprime [x, y] r. \line O ponteiro da fun\'e7\'e3o area de Cylinder, na vtable para a classe Cylinder. aponta para a fun\'e7\'e3o area de Cylinder que calcula a \'e1rea da superf\'edcie do Cylinder. isto \'e9 27tr2 + 2trh. O ponteiro da fun\'e7\'e3o volume de Cylinder aponta para uma fun\'e7\'e3o volume que retorna 2Ttr2h. O ponteiro da fun\'e7\'e3o printShapeNante de Cylinder aponta para uma fun\'e7\'e3o que imprime \ldblquote Cylinder:\rquote . O ponteiro da fun\'e7\'e3o print de Cylinder aponta para sua fun\'e7\'e3o que imprime [ x, y 1 r h. \line O polimorfismo \'e9 realizado atrav\'e9s de uma estrutura de dados complexa, que envolve tr\'eas n\'edveis de ponteiros. Discutimos s\'f3 um n\'edvel - os ponteiros de fun\'e7\'e3o na v\'edable. Estes ponteiros apontam para as fun\'e7\'f5es reais que devem ser executadas quando \'e9 invocada uma fun\'e7\'e3o virtual. \line Agora, consideraremos o segundo n\'edvel de ponteiros. Sempre que um objeto de uma classe com fun\'e7\'f5es \line virtual \'e9 instanciado, o compilador anexa \'e0 frente do objeto um ponteiro para a vtable daquela classe. [Nota: \line normalmente, este ponteiro est\'e1 na frente do objeto, mas n\'e3o \'e9 obrigat\'f3rio que seja implementado deste modo.j \line O terceiro n\'edvel de ponteiros \'e9 simplesmente o handle para o objeto que est\'e1 recebendo a chamada da fun\'e7\'e3o virtual (este handie tamb\'e9m pode ser uma refer\'eancia). \line Agora, vejamos como uma chamada de fun\'e7\'e3o virtual t\'edpica \'e9 executada. Considere a chamada \line baseClassPtr->printShapeName O \line na fun\'e7\'e3o virtualViaPointer. Suponha, para a discuss\'e3o seguinte, que baseClassPtr cont\'e9m o endere\'e7o que est\'e1 em arrayOfShapes [ 1 1 (i.e., o endere\'e7o do objeto circle). Quando o compilador compila este \par
CAP\'cdTULO 10 - FUN\'c7\'d5ES VIRTUAIS E POLIMORFISMO 631 \par
O fluxo de uma chamada de fun\'e7\'e3o virtual baseClassPtr->printShapeName O; \line\'e9 ilustrado pelas flechas em negrito acima. \par
passa &circle para baseClassPtr obt\'e9m o objeto Circle \line obt\'e9m a vtable de Circie \line obt\'e9m o ponteiro de printShapeName na vtable executa printShapeName para Circie \par
Fig. 10.3 Fluxo de controle de uma chamada de fun\'e7\'e3o virtual. \par
comando, ele determina que a chamada est\'e1 sendo de fato feita a partir de um ponteiro para a classe base e que printShapeName \'e9 uma fun\'e7\'e3o virtual. \line Em seguida, o compilador determina que printShapeName \'e9 a terceira entrada em cada uma das vtables. \line Para localizar esta entrada, o compilador nota que ele necessitar\'e1 saltar as primeiras duas entradas. Deste modo, o compilador compila um offset ou deslocamento de 8 bytes (4 bytes para cada ponteiro em m\'e1quinas de 32 bits, \par
vtable de Shape \par
height 10.00 \par
Legenda \line a fun\'e7\'e3oarea \line v = fun\'e7\'e3o volume \line psn fun\'e7\'e3o printShapeName \line pr = fun\'e7\'e3o print \line entrada com o significa fun\'e7\'e3o virtual pura \line r = raio: h = altura \par
\pard\par
\pard\sb100\sa240 632 C++ COMO PROGRAMAR \line populares hoje em dia) para o c\'f3digo objeto em linguagem de m\'e1quina que executar\'e1 a chamada da fun\'e7\'e3o virtual. \line Ent\'e3o, o compilador gera o c\'f3digo que ir\'e1 (Nota: os n\'fameros na lista abaixo correspondem aos n\'fameros nos \line c\'edrculos na Fig. 10.3): \line 1. Selecionar a i-\'e9sima entrada de arrayOfShapes (neste caso, o endere\'e7o do objeto circle) e pass\'e1lo para virtualViaPointer. Isso inicializa baseClassPtr para apontar para circle. \line 2. Derreferenciar aquele ponteiro para obter o objeto circle - que, como voc\'ea se lembra, come\'e7a com um ponteiro para a vtable de Circle. \line 3. Derreferenciar o ponteiro para a vtable de circie para chegar \'e0 vtable de Circle. \line 4. Saltar o deslocamento de 8 bytes para pegar o ponteiro da fun\'e7\'e3o printShapeName. \line 5. Derreferenciar o ponteiro da fun\'e7\'e3o printShapeNaine para formar o nome da verdadeira fun\'e7\'e3o a ser executada e usar o operador de chamada de fun\'e7\'e3o () para executar a fun\'e7\'e3o printShapeName apropriada e imprimir o string de caracteres \ldblquote Circle:\rdblquote . \line As estruturas de dados da Fig. 10.3 podem parecer complexas, mas a maior parte dessa complexidade \'e9 administrada pelo compilador e escondida do programador, simplificando a programa\'e7\'e3o polim\'f3rfica em C++. \line As opera\'e7\'f5es de derreferenciamento de ponteiros e acessos \'e0 mem\'f3ria que ocorrem em toda chamada de \line fun\'e7\'e3o virtual exigem algum tempo de execu\'e7\'e3o adicional. As vtables e os ponteiros de vtable acrescentados aos objetos exigem alguma mem\'f3ria adicional. \line Esperamos que voc\'ea, agora, tenha informa\'e7\'f5es suficientes sobre como operam as fun\'e7\'f5es virtual para \line determinar se o seu uso \'e9 apropriado para cada aplica\'e7\'e3o que voc\'ea estiver pensando em fazer. \line Dica de desempenho 10.1 \line f O polimoifismo implementado com fun\'e7\'f5es virtual e vincula \'e7\'e3o din\'e2mica \'e9 eficiente. Os pro gramadores podem usar estes recursos com pequeno impacto sobre o desempenho do sistema. \line Dica de desempenho 10.2 \line _____ As fun\'e7\'f5es virtuais e a vincula \'e7\'e3o din\'e2mica possibilitam a programa\'e7\'e3o polim\'f3ifica, substituindo a l\'f3gica de programa\'e7\'e3o com switchs. Os compiladores otimizadores de C++ normalmente geram c\'f3digo que executa pelo menos t\'e3o eficazmente quanto a l\'f3gica de programa\'e7\'e3o baseada em swi tchs codificada pelo programador De uma forma ou de outra, o overhead do polimoifismo \'e9 aceit\'e1vel para a maioria das aplica\'e7\'f5es. Mas, em algumas situa\'e7\'f5es - por exemplo, aplicativos de tempo real com requisitos de desempenho especiais - o overhead do polimorfismo pode ser muito elevado. \line Resumo \line Com fun\'e7\'f5es virtual e polimorfismo, torna-se poss\'edvel projetar e implementar sistemas que s\'e3o mais facilmente extens\'edveis, Os programas podem ser escritos para processar objetos de tipos que podem ainda n\'e3o existir quando o programa est\'e1 em desenvolvimento. \line\bullet  A programa\'e7\'e3o polim\'f3rfica com fun\'e7\'f5es virtual pode eliminar a necessidade de l\'f3gica de programa\'e7\'e3o que emprega switchs. O programador pode usar o mecanismo das fun\'e7\'f5es virtuais para executar uma l\'f3gica equivalente de forma autom\'e1tica, evitando deste modo os tipos de erros tipicamente associados com a l\'f3gica de programa\'e7\'e3o que emprega switchs. Um c\'f3digo cliente que toma decis\'f5es sobre tipos e representa\'e7\'f5es de objetos indica um mau projeto de classe. \line\bullet  Classes derivadas podem fornecer suas pr\'f3prias implementa\'e7\'f5es de uma fun\'e7\'e3o virtual de uma classe base se necess\'e1rio, mas, se elas n\'e3o o fizerem, \'e9 usada a implementa\'e7\'e3o da classe base. \line\bullet  Se uma fun\'e7\'e3o virtual for chamada referenciando-se um objeto espec\'edfico por nome e usando-se o operador de sele\'e7\'e3o de membro ponto, a refer\'eancia \'e9 resolvida durante a compila\'e7\'e3o (isto \'e9 chamado de vincula \'e7\'e3o est\'e1tica) e a fun\'e7\'e3o virtual que \'e9 chamada \'e9 aquela definida para a (ou herdada pela) classe daquele de objeto em particular. \par
CAP\'cdTULO 10 - FUN\'c7\'d5ES VIRTUAIS E POLIMORFISMO 633 \line Existem muitas situa\'e7\'f5es em que \'e9 \'fatil se definir classes das quais o programador nunca pretende instanciar quaisquer objetos. Tais classes s\'e3o chamadas de classes abstratas. Como s\'e3o usadas s\'f3 como classes base, referir-nos-emos a elas como \line classes base abstratas. Nenhum objeto do tipo de uma classe abstrata pode ser instanciado em um programa. \line )S nos \bullet  As classes das quais podemos instanciar objetos s\'e3o chamadas de classes concretas. \line\bullet  Uma classe \'e9 tornada abstrata declarando-se uma ou mais de suas fun\'e7\'f5es como virtual puras. Uma fun\'e7\'e3o virtual \line )ass\'e1- pura \'e9 uma fun\'e7\'e3o com um inicializador = O em sua declara\'e7\'e3o. \line\bullet  Se uma classe \'e9 derivada de uma classe com uma fun\'e7\'e3o virtual pura e n\'e3o se fornece uma defini\'e7\'e3o para aquela fun\'e7\'e3o \line rn um virtual pura na classe derivada, ent\'e3o aquela fun\'e7\'e3o virtual permanece pura na classe derivada. Conseq\'fcentemente, a \line classe derivada tamb\'e9m \'e9 uma classe abstrata. \line\bullet  C++ possibilita o polimorfismo - a capacidade de objetos de classes diferentes relacionadas por heran\'e7a responderem dife rentement \'e0 mesma chamada de fun\'e7\'e3o membro. \line\bullet  O polimorfismo \'e9 implementado atrav\'e9s de fun\'e7\'f5es virtual. \line a ser \bullet  Quando \'e9 feita uma solicita\'e7\'e3o para usar uma fun\'e7\'e3o virtual, atrav\'e9s de um ponteiro ou refer\'eancia da classe base, C++ \line apro- escolhe a fun\'e7\'e3o sobrescrita correta, na classe derivada apropriada associada com o objeto. \line\bullet  Atrav\'e9s do uso de fun\'e7\'f5es virtual e polimorfismo, uma chamada de fun\'e7\'e3o membro pode produzir a\'e7\'f5es diferentes, \line trada dependendo do tipo do objeto que est\'e1 recebendo a chamada. \line\bullet  Embora n\'e3o possamos instanciar objetos de classes base abstratas, podemos declarar ponteiros para classes base abstratas. \line la de Tais ponteiros podem ser usados para possibilitar manipula\'e7\'f5es polim\'f3rficas de objetos de classes derivadas quando tais \line s aos objetos forem instanciados de classes concretas. \line nara \bullet  Novos tipos de classes s\'e3o regularmente acrescentados a sistemas existentes. Novas classes s\'e3o acomodadas por vincula\'e7\'e3o din\'e2mica (tamb\'e9m chamada de vincula\'e7\'e3o tardia), O tipo de um objeto n\'e3o precisa ser conhecido durante a compila\'e7\'e3o para \line que uma chamada de fun\'e7\'e3o virtual seja compilada. Durante a execu\'e7\'e3o, a chamada da fun\'e7\'e3o virtual \'e9 associada com a fun\'e7\'e3o membro do objeto receptor. \line\bullet  A vincula\'e7\'e3o din\'e2mica possibilita aos vendedores de software independentes (lSVs) distribuir seu software sem revelar \line segredos de sua propriedade. As distribui\'e7\'f5es de software podem consistir somente de arquivos em cabe\'e7alho e arquivos de \line c\'f3digo-objeto. Nenhum c\'f3digo-fonte precisa ser revelado, Os desenvolvedores de software podem ent\'e3o usar a heran\'e7a para \line derivar novas classes daquelas fornecidas pelos ISVs. O software que trabalha com as classes fornecidas pelos ISVs continu ar a funcionar com as classes delas derivadas e usar\'e1 (atrav\'e9s da vincula\'e7\'e3o din\'e2mica) fun\'e7\'f5es virtual sobrescritas \line - fornecidas nestas classes. \line l\'f3gi dig \line\bullet  A vincula\'e7\'e3o din\'e2mica exige que, durante a execu\'e7\'e3o, a chamada de uma fun\'e7\'e3o membro virtual seja redirecionada para \line fica- a vers\'e3o da fun\'e7\'e3o virtual apropriada para a classe. Uma tabela de fun\'e7\'f5es virtual chamada vtable \'e9 implementada \line oria como um array contendo ponteiros para fun\'e7\'f5es. Cada classe que cont\'e9m fun\'e7\'f5es virtual tem uma vtable. Para cada \line fun\'e7\'e3o virtual na classe, a vtable tem uma entrada contendo um ponteiro de fun\'e7\'e3o para a vers\'e3o da fun\'e7\'e3o virtual a \line s L4e ser usada para um objeto daquela classe. A fun\'e7\'e3o virtual a ser usada para uma classe particular poderia ser a fun\'e7\'e3o \line definida naquela classe, ou ela poderia ser uma fun\'e7\'e3o herdada direta ou indiretamente de uma classe base mais alta na \line hierarquia. \line\bullet  Quando uma classe base fornece uma fun\'e7\'e3o membro virtual, as classes derivadas podem sobrescrever a fun\'e7\'e3o virtual. mas elas n\'e3o precisam, obrigatoriamente, sobrescrev\'ea-la. Desse modo, uma classe derivada pode usar a vers\'e3o de uma classe base de uma fun\'e7\'e3o membro virtual, e isto seria indicado na vtable. \line ensI est \line\bullet  Cada objeto de uma classe com fun\'e7\'f5es virtual cont\'e9m um ponteiro para a vtable daquela classe. O ponteiro da fun\'e7\'e3o apropriada na s\rquote table \'e9 obtido e derreferenciado para completar a chamada durante a execu\'e7\'e3o. Esta pesquisa na vtable e derreferenciamento do ponteiro causam um certo overhead durante a execu\'e7\'e3o, normalmente menor do que o melhor c\'f3digo \line rega cliente poss\'edvel. \line rma \line\bullet  Declare o destruidor da classe base como virtual se a classe cont\'e9m fun\'e7\'f5es virtuais. Isto torna virtual todos os \line destruidores das classes derivadas, embora n\'e3o tenham o mesmo nome que o destruidor da classe base. Se um objeto na \line hierarquia \'e9 explicitamente destru\'eddo aplicando-se o operador delete a um ponteiro da classe base para um objeto de uma \line classe derivada, \'e9 chamado o destruidor para a classe apropriada. \line Qualquer classe que tenha um ou mais ponteiros O em sua vtable \'e9 uma classe abstrata. Classes sem quaisquer ponteiros O na \line ode vtable (como Point, Circle e Cylinder) s\'e3o classes concretas. \line ual \par
634 C++ COMO PROGRAMAR \par
Terminologia \par
classe abstrata classe base abstrata \par
classe base direta \line classe base indireta \line classe concreta \line classe derivada \line construtor de classe derivada \line convers\'e3o expl\'edcita de ponteiro \line converter um ponteiro de classe derivada para ponteiro de classe base \line deslocamento na vtable \par
destruidor virtual eliminando comandos switch extensibilidade \line fun\'e7\'e3o virtual \line fun\'e7\'e3o virtual da classe base \par
fun\'e7\'e3o virtual pura (=0) heran\'e7a \line heran\'e7a de implementa\'e7\'e3o heran\'e7a de interface hierarquia de classes \par
l\'f3gica de switch \par
Erros comuns de programa\'e7\'e3o \par
offset na vtable \line polimorfismo \line ponteiro da vtable \line ponteiro para uma classe abstrata ponteiro para uma classe base ponteiro para uma classe derivada programa\'e7\'e3o \ldblquote espec\'edfica\rdblquote  programa\'e7\'e3o \ldblquote gen\'e9rica\rdblquote  refer\'eancia para uma classe abstrata refer\'eancia para uma classe base refer\'eancia para uma classe derivada reutiliza\'e7\'e3o de software sobrescrever uma fun\'e7\'e3o virtual sobrescrever uma fun\'e7\'e3o virtual pura tabela de fun\'e7\'f5es virtual vendedor de software independente (ISV) vincula\'e7\'e3o antecipada vincula\'e7\'e3o din\'e2mica vincula\'e7\'e3o est\'e1tica vincula\'e7\'e3o tardia \line vtable \par
10. 1 Tentar instanciar um objeto de uma classe abstrata (i.e., uma classe que cont\'e9m uma ou mais fun\'e7\'f5es virtual puras) \'e9 um erro de sintaxe. \line 10.2 Construtores n\'e3o podem ser virtual. Declarar um construtor como virtual \'e9 um erro de sintaxe. \par
Boas pr\'e1ticas de programa\'e7\'e3o \par
\pard\sb100\sa100 10.1 Embora certas fun\'e7\'f5es sejam implicitamente virtual, por causa de uma declara\'e7\'e3o feita mais acima na hierarquia de classes, declarar explicitamente estas fun\'e7\'f5es como virtual em cada n\'edvel da hierarquia melhora a clareza do progra ma. \par
\pard\sb100\sa240 10.2 Se uma classe tem fun\'e7\'f5es virtuais, forne\'e7a um destruidor virtual, ainda que n\'e3o seja necess\'e1rio um para a classe. As classes derivadas desta classe podem conter destruidores que devem ser chamados corretamente. \par
Dicas de desempenho \par
10.1 O polimorfismo implementado com fun\'e7\'f5es virtual e vincula\'e7\'e3o din\'e2mica \'e9 eficiente. Os programadores podem usar estes recursos com pequeno impacto sobre o desempenho do sistema. \line 10.2 As fun\'e7\'f5es virtuais e a vincula\'e7\'e3o din\'e2mica possibilitam a programa\'e7\'e3o polim\'f3rfica, substituindo a l\'f3gica de programa\'e7\'e3o com switchs. Os compiladores otimizadores de C++ normalmente geram c\'f3digo que executa pelo menos t\'e3o eficazmente quanto a l\'f3gica de programa\'e7\'e3o baseada em switchs codificada pelo programador. De uma forma ou de outra, o overhead do polimorfismo \'e9 aceit\'e1vel para a maioria das aplica\'e7\'f5es. Mas, em algumas situa\'e7\'f5es - por exemplo, aplicativos de tempo real com requisitos de desempenho especiais - o overhead do polimorfismo pode ser muito elevado. \par
Observa\'e7\'f5es de engenharia de software \par
10.1 Uma conseq\'fc\'eancia interessante do uso de fun\'e7\'f5es virtual e polimorfismo \'e9 que os programas adquirem uma apar\'eancia mais simples. Eles cont\'eam menos ramifica\'e7\'f5es l\'f3gicas, favorecendo o emprego de c\'f3digo seq\'fcencial mais simples. \line Isso facilita o teste, a depura\'e7\'e3o e a manuten\'e7\'e3o de programas e evita erros. \par
CAP\'cdTULO 10- FUN\'c7\'d5ES VIRTUAIS E P0LIM0RFISM0 635 \line 10.2 Uma vez que uma fun\'e7\'e3o seja declarada virtual, ela permanece virtual por toda a hierarquia de heran\'e7a, daquele ponto para baixo, mesmo se n\'e3o \'e9 declarada virtual quando uma classe a sobrescreve. \line 10.3 Quando uma classe derivada escolhe n\'e3o definir uma fun\'e7\'e3o como virtual, a classe derivada simplesmente herda a defini\'e7\'e3o da fun\'e7\'e3o virtual da sua classe b\'e1sica imediata. \line 10.4 Se uma classe \'e9 derivada de uma classe com uma fun\'e7\'e3o virtual pura e se nenhuma defini\'e7\'e3o for fornecida para aquela fun\'e7\'e3o virtual pura na classe derivada, ent\'e3o aquela fun\'e7\'e3o virtual permanece pura na classe derivada. \line Conseq\'fcentemente, a classe derivada tamb\'e9m \'e9 uma classe abstrata. \line 10.5 Com fun\'e7\'f5es virtual e polimorfismo, o programador pode tratar com generalidades e deixar para o ambiente de execu\'e7\'e3o a preocupa\'e7\'e3o com os aspectos espec\'edficos. O programador pode fazer com que uma grande variedade de \line objetos se comporte de modos apropriados para aqueles objetos, sem sequer conhecer os tipos dos mesmos. \line 10.6 O polimorfismo promove a extensibilidade: o software escrito para invocar o comportamento polim\'f3rfico \'e9 escrito independentemente dos tipos dos objetos para os quais as mensagens s\'e3o enviadas. Deste modo, novos tipos de objetos que podem responder a mensagens existentes podem ser acrescentados a um sistema como esse, sem modificar o sistema b\'e1sico. Com a exce\'e7\'e3o do c\'f3digo cliente que instancia novos objetos, os programas n\'e3o necessitam ser recompilados. \line 10.7 Uma classe abstrata define uma interface para os v\'e1rios membros de uma hierarquia de classes. A classe abstrata cont\'e9m fun\'e7\'f5es virtuais puras que ser\'e3o definidas nas classes derivadas. Todas as fun\'e7\'f5es na hierarquia podem usar essa mesma \line interface, atrav\'e9s do polimorfismo. \line 10.8 Uma classe pode herdar a interface e/ou a implementa\'e7\'e3o de uma classe base. As hierarquias projetadas para heran\'e7a de \line implementa\'e7\'e3o tendem a ter sua funcionalidade colocada no alto da hierarquia - cada nova classe derivada herda uma ou \line mais fun\'e7\'f5es membro que foram definidas em uma classe base, e a nova classe derivada usa as defini\'e7\'f5es da classe base. \line As hierarquias projetadas para heran\'e7a de interface tendem a ter sua funcionalidade colocada mais abaixo na hierarquia \line - uma classe base especifica uma ou mais fun\'e7\'f5es que deveriam ser definidas para cada classe na hierarquia (i.e., elas t\'eam \line a mesma assinatura), mas as classes derivadas individuais fornecem suas pr\'f3prias implementa\'e7\'f5es da(s) fun\'e7\'e3o(\'f5es). \line Exerc\'edcio de auto-revis\'e3o \line 10.1 Preencha os espa\'e7os em branco em cada um dos seguintes itens: \line a) Usar heran\'e7a e polimorfismo ajuda a eliminar a l\'f3gica de _______________ \line b) Uma fun\'e7\'e3o virtual pura \'e9 especificada colocando-se no fim de seu prot\'f3tipo, na defini\'e7\'e3o da classe. \line e) Se uma classe cont\'e9m uma ou mais fun\'e7\'f5es virtual puras, \'e9 uma ______________ \line d) Uma chamada de fun\'e7\'e3o resolvida durante a compila\'e7\'e3o \'e9 chamada de vincula\'e7\'e3o \line e) Uma chamada de fun\'e7\'e3o resolvida durante a execu\'e7\'e3o \'e9 chamada de vincula\'e7\'e3o \line Respostas ao exerc\'edcio de auto-revis\'e3o \line 10.1 a) switch. b) =0. c) classe base abstrata. d) est\'e1tica ou antecipada. e) din\'e2mica ou tardia. \line Exerc\'edcios \line 10.2 O que s\'e3o fun\'e7\'f5es virtual? Descreva uma circunst\'e2ncia em que fun\'e7\'f5es virtual seriam apropriadas. \line 10.3 Dado que construtores n\'e3o podem ser virtual, descreva um esquema com o qual voc\'ea pode obter um efeito semelhante. \line 10.4 Como \'e9 que o polimorfismo possibilita a voc\'ea programar \ldblquote no geral\rdblquote  ao inv\'e9s de \ldblquote no espec\'edfico\rdblquote . Discuta as vantagens chaves da programa\'e7\'e3o \ldblquote no geral\rdblquote . \line 10.5 Discuta os problemas de programa\'e7\'e3o com l\'f3gica que emprega switchs. Explique por que o polimorfismo \'e9 uma alternativa efetiva ao uso de l\'f3gica de programa\'e7\'e3o que emprega switchs. \line 10.6 Distinga entre vincula\'e7\'e3o est\'e1tica e vincula\'e7\'e3o din\'e2mica. Explique o uso de fun\'e7\'f5es virtual e da vtable na vincula\'e7\'e3o din\'e2mica. \line 10.7 Distinga entre herdar a interface e herdar a implementa\'e7\'e3o. Como hierarquias de heran\'e7a projetadas para herdar a interface diferem daquelas projetadas para herdar a implementa\'e7\'e3o? \line 10.8 Distinga entre fun\'e7\'f5es virtual e fun\'e7\'f5es virtual puras. \line 10.9 (Verdadeiro/Falso) Todas as fun\'e7\'f5es virtual em uma classe base abstrata devem ser declaradas como fun\'e7\'f5es virtual puras. \par
636 C++ COMO PROGRAMAR \line 10.10 Sugira um ou mais n\'edveis de classes base abstratas para a hierarquia de Shape discutida neste cap\'edtulo (o primeiro n\'edvel \'e9 Shape e o segundo n\'edvel consiste nas classes TwoDimerisionalShape e ThreeDimensionalShape). \line 10.11 Como o polimorfismo promove a extensibilidade? \line 10.12 Foi solicitado a voc\'ea desenvolver um simulador de v\'f4o que ter\'e1 sa\'eddas elaboradas. Explique por que a programa\'e7\'e3o polim\'f3rfica seria especialmente efetiva para um problema desta natureza. \line 10.13 Desenvolva um pacote b\'e1sico para gr\'e1ficos. Use a hierarquia de classes por heran\'e7a de Shape do Cap\'edtulo 9. Limite-se a formas de duas dimens\'f5es, tais como quadrados, ret\'e2ngulos, tri\'e2ngulos e c\'edrculos. Interaja com o usu\'e1rio. Deixe o usu\'e1rio especificar a posi\'e7\'e3o, o tamanho, a forma e os caracteres de preenchimento a serem usados para desenhar cada forma, O usu\'e1rio pode especificar muitos itens da mesma forma. A medida que voc\'ea cria cada forma, coloque um ponteiro Shape* para cada novo objeto do tipo Shape em um array. Cada classe tem sua pr\'f3pria fun\'e7\'e3o membro draw. Escreva um gerenciador de tela polim\'f3rfico que percorre o array (usando de prefer\'eancia um iterador) enviando mensagens draw para cada objeto do array para formar uma imagem de tela. Redesenhe a imagem na tela toda vez que o usu\'e1rio especifica uma forma adicional. \line 10.14 Modifique o sistema de folha de pagamento da Fig. 10.1 para acrescentar os membros de dados privados dataDeNasc\'edmento (um objeto do tipo Date) e codigoDeDeparta!nento (um int) \'e0 classe Employee. Assuma que essa folha de pagamento \'e9 processada uma vez por m\'eas. Ent\'e3o, \'e0 medida que seu programa calcula a folha de pagamento para cada Employee (polimorficamente), some uma gratifica\'e7\'e3o de $100.00 \'e0 quantia da folha de pagamento da pessoa se este for o m\'eas de anivers\'e1rio do Employee. \line 10.15 No Exerc\'edcio 9.14, voc\'ea desenvolveu uma hierarquia de classes Shape e definiu as classes na hierarquia. Modifique a hierarquia de forma que a classe Shape seja uma classe base abstrata contendo a interface da hierarquia. Derive TwoDimensionalShape e ThreeDimensionalShape a partir da classe Shape - estas classes deveriam tamb\'e9m ser abstratas. Use uma fun\'e7\'e3o virtual print para dar sa\'edda ao tipo e dimens\'e3o de cada classe. Tamb\'e9m inclua fun\'e7\'f5es virtual area e volume, de forma que estes c\'e1lculos possam seqr executados para objetos de cada classe concreta na hierarquia. Escreva um programa de teste que testa a hierarquia de classes de Shape. \par
\pard\lang1033\f1\fs20\par
}
 